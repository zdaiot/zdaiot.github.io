<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="常用指令从github中同步代码到本地，以github分支为master为例1git pull origin master 从本地同步代码到github，以同步所有代码，github分支为master为例：123git add .git commit -m &quot;init&quot;git push origin master 查看当前所有远程分支1git branch -r 查看当前所有本地分支1git br"><meta name="keywords" content="github"><meta property="og:type" content="article"><meta property="og:title" content="git常用指令与使用技巧"><meta property="og:url" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="常用指令从github中同步代码到本地，以github分支为master为例1git pull origin master 从本地同步代码到github，以同步所有代码，github分支为master为例：123git add .git commit -m &quot;init&quot;git push origin master 查看当前所有远程分支1git branch -r 查看当前所有本地分支1git br"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/v2-af3bf6fee935820d481853e452ed2d55_720w.jpg"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/webp.webp"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/webp-1685349549296-5.webp"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/webp-1685349914787-10.webp"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/67c657754829426bb226c1f0df7604f5.png"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/73f30b18ace74097875941a39576962d.png"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/15990318563766.jpg"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/15990320262625.jpg"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/20171214142540334.png"><meta property="og:updated_time" content="2020-02-20T02:24:54.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="git常用指令与使用技巧"><meta name="twitter:description" content="常用指令从github中同步代码到本地，以github分支为master为例1git pull origin master 从本地同步代码到github，以同步所有代码，github分支为master为例：123git add .git commit -m &quot;init&quot;git push origin master 查看当前所有远程分支1git branch -r 查看当前所有本地分支1git br"><meta name="twitter:image" content="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/v2-af3bf6fee935820d481853e452ed2d55_720w.jpg"><link rel="canonical" href="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>git常用指令与使用技巧 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> git常用指令与使用技巧<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/Tools/Git/git常用指令与使用技巧.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-13 20:56:27" itemprop="dateCreated datePublished" datetime="2019-07-13T20:56:27+08:00">2019-07-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-20 10:24:54" itemprop="dateModified" datetime="2020-02-20T10:24:54+08:00">2020-02-20</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Tools/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>39k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>36 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>从github中同步代码到本地，以github分支为<code>master</code>为例<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p></p><p>从本地同步代码到github，以同步所有代码，github分支为<code>master</code>为例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"init"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p></p><p>查看当前所有远程分支<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><p></p><p>查看当前所有本地分支<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p></p><p>查看所有分支（含当地和远程）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>新建分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch +名字</span><br></pre></td></tr></table></figure><p>切换分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout +名字</span><br></pre></td></tr></table></figure><p>删除本地的分支，以test分支为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>删除远程分支，以远程服务为origin，删除test分支为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>显示某个commit的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show commit_id</span><br></pre></td></tr></table></figure><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your_Username"</span></span><br><span class="line">git config --global user.email username@xxx.com</span><br></pre></td></tr></table></figure><p>查看配置结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config user.name	</span><br><span class="line">git config user.email</span><br><span class="line"></span><br><span class="line">cat ~/.gitconfig</span><br></pre></td></tr></table></figure><h3 id="status显示中文"><a href="#status显示中文" class="headerlink" title="status显示中文"></a>status显示中文</h3><p>status查看有改动但未提交的文件时总只显示数字串，显示不出中文文件名，非常不方便。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On branch hexo</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   <span class="string">"source/_posts/C/\350\257\255\346\263\225/\345\212\250\346\200\201\351\223\276\346\216\245\345\272\223\345\222\214\351\235\231\346\200\201\351\223\276\346\216\245\345\272\223.md"</span></span><br></pre></td></tr></table></figure><p>原因：在默认设置下，中文文件名在工作区状态输出，中文名不能正确显示，而是显示为八进制的字符编码。</p><p>解决办法：将git 配置文件 core.quotepath 项设置为false，quotepath表示引用路径，加上—global表示全局配置</p><p>git bash 终端输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><h3 id="切换到tag"><a href="#切换到tag" class="headerlink" title="切换到tag"></a>切换到tag</h3><p>git clone 整个仓库后使用，以下命令就可以取得该 tag 对应的代码了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout tag_name</span><br></pre></td></tr></table></figure><p>但是，这时候 git 可能会提示你当前处于一个“detached HEAD” 状态。因为 tag 相当于是一个快照，是不能更改它的代码的。如果要在 tag 代码的基础上做修改，你需要一个分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure><p>这样会从 tag 创建一个分支，然后就和普通的 git 操作一样了。</p><h3 id="查看tag"><a href="#查看tag" class="headerlink" title="查看tag"></a>查看tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 本地tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程tag</span></span><br><span class="line">git ls-remote --tags origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出符合模式匹配的 tag</span></span><br><span class="line">git tag -l <span class="string">'pattern'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不但要看tag名字，还想看当时附加的注解</span></span><br><span class="line"><span class="comment"># 下面这个是列出前100个tag名字和注解信息</span></span><br><span class="line">git tag -n100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 又要搞模式匹配，又要列出注解信息</span></span><br><span class="line">git tag -l -n100 <span class="string">'pattern'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出tag的commit</span></span><br><span class="line">git show-ref --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定tag的commit</span></span><br><span class="line">git rev-list -n 1 <span class="variable">$yourTagName</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag对应的commit，并且按照时间排序</span></span><br><span class="line"><span class="comment"># ref https://stackoverflow.com/a/5188364/15304315 https://stackoverflow.com/a/6270112/15304315</span></span><br><span class="line">git <span class="keyword">for</span>-each-ref --sort=creatordate --format <span class="string">'%(refname) %(creatordate) %(color:red)%(objectname)%(color:reset)'</span> refs/tags</span><br><span class="line"><span class="comment"># 如果想要打印的时候，将creatordate转换为unix时间戳。</span></span><br><span class="line">git <span class="keyword">for</span>-each-ref --sort=creatordate --format <span class="string">'%(refname) %(creatordate:unix) %(color:red)%(objectname)%(color:reset)'</span> refs/tags</span><br></pre></td></tr></table></figure><h3 id="创建tag"><a href="#创建tag" class="headerlink" title="创建tag"></a>创建tag</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为本地仓库当前提交创建tag</span></span><br><span class="line">git tag $yourTagName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为本地仓库指定commit创建tag</span></span><br><span class="line">git tag $yourTagName $yourCommitPrefix</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要给tag附带一下注解，用-a但没用-m的话，会进入一个输入框，要你输入message</span></span><br><span class="line">git tag -a $yourTagName -m "your annotation message"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 又要指定commit又要带注解</span></span><br><span class="line">git tag -a $yourTagName $yourCommitPrefix -m "your annotation message"</span><br></pre></td></tr></table></figure><h3 id="推送tag到远程服务器"><a href="#推送tag到远程服务器" class="headerlink" title="推送tag到远程服务器"></a>推送tag到远程服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送指定tag</span></span><br><span class="line">git push origin $yourTagName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送本地所有tag</span></span><br><span class="line">git push --tags origin</span><br></pre></td></tr></table></figure><h3 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line">git tag --delete $yourTagName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line">git tag --delete origin $yourTagName</span><br></pre></td></tr></table></figure><h3 id="tag与commit"><a href="#tag与commit" class="headerlink" title="tag与commit"></a>tag与commit</h3><p>查看某个commit是否有对应的tag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --exact-match &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>If what you want is the first tag containing the commit then:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">git describe --contains &lt;commit&gt;</span><br><span class="line"></span><br><span class="line">&lt;&lt;<span class="string">'COMMENT'</span></span><br><span class="line">例如 git describe --contains bf998bdf47c94d141cc501f5701328f130154709 结果为：</span><br><span class="line">11.0.211~7</span><br><span class="line"></span><br><span class="line">那么这个结果怎么看呢？从https://git-scm.com/docs/git-rev-parse<span class="comment">#Documentation/git-rev-parse.txt-emltrevgtltngtemegemHEADv1510em可以看~的含义：</span></span><br><span class="line">G   H   I   J</span><br><span class="line"> \ /     \ /</span><br><span class="line">  D   E   F</span><br><span class="line">   \  |  / \</span><br><span class="line">    \ | /   |</span><br><span class="line">     \|/    |</span><br><span class="line">      B     C</span><br><span class="line">       \   /</span><br><span class="line">        \ /</span><br><span class="line">         A</span><br><span class="line">A =      = A^0</span><br><span class="line">B = A^   = A^1     = A~1</span><br><span class="line">C =      = A^2</span><br><span class="line">D = A^^  = A^1^1   = A~2</span><br><span class="line">E = B^2  = A^^2</span><br><span class="line">F = B^3  = A^^3</span><br><span class="line">G = A^^^ = A^1^1^1 = A~3</span><br><span class="line">H = D^2  = B^^2    = A^^^2  = A~2^2</span><br><span class="line">I = F^   = B^3^    = A^^3^</span><br><span class="line">J = F^2  = B^3^2   = A^^3^2</span><br><span class="line"></span><br><span class="line">然后我们执行命令，看11.0.210与11.0.211之间的commit，发现11.0.211往前数（不包含自身）7个commit就是bf998bdf47c94d141cc501f5701328f130154709了。</span><br><span class="line">也就是说bf998bdf47c94d141cc501f5701328f130154709是11.0.211的第7个parent。</span><br><span class="line"></span><br><span class="line">(base) PS E:\CodeLibrary\v8&gt; git <span class="built_in">log</span> --pretty=format:<span class="string">"%h; author: %cn; date: %ci; subject:%s"</span> 11.0.210...11.0.211</span><br><span class="line">9dcc25911c; author: v8-ci-autoroll-builder; date: 2022-12-12 14:02:45 +0000; subject:Version 11.0.211</span><br><span class="line">d871c03e4a; author: V8 LUCI CQ; date: 2022-12-12 11:35:11 +0000; subject:[maglev][arm64] Port simple Load&lt;Type&gt; IRs</span><br><span class="line">1bf670ef20; author: V8 LUCI CQ; date: 2022-12-12 11:30:33 +0000; subject:[wasm-gc] ref.cast null: Always produces a null <span class="built_in">type</span> independent of input <span class="built_in">type</span></span><br><span class="line">d310532598; author: V8 LUCI CQ; date: 2022-12-12 11:20:09 +0000; subject:[maglev] Use CallApiCallback <span class="keyword">for</span> api getters</span><br><span class="line">db973bb462; author: V8 LUCI CQ; date: 2022-12-12 11:08:42 +0000; subject:[maglev] Support %OptimizeOsr</span><br><span class="line">bd7458cb7f; author: V8 LUCI CQ; date: 2022-12-12 10:44:23 +0000; subject:Reland <span class="string">"[static-roots] Allow creating isolates from exist. r/o snapshot"</span></span><br><span class="line">e039f6b1a4; author: V8 LUCI CQ; date: 2022-12-12 10:31:34 +0000; subject:[maglev] Fix saved <span class="built_in">return</span> register <span class="keyword">in</span> CheckMapsWithMigration</span><br><span class="line">bf998bdf47; author: V8 LUCI CQ; date: 2022-12-12 08:37:34 +0000; subject:[rab/gsab] Fix TA.p.slice even more</span><br><span class="line">c9ab4a47ce; author: V8 LUCI CQ; date: 2022-12-12 08:26:37 +0000; subject:Reland <span class="string">"[heap] Fix typo in pretenuring"</span></span><br><span class="line">2681ff45a4; author: v8-ci-autoroll-builder; date: 2022-12-10 15:01:42 +0000; subject:Version 11.0.210</span><br><span class="line">COMMENT</span><br></pre></td></tr></table></figure><p>gives you all of the tags that contain that commit.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag --contains &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>tag中间的commit, 推荐下面的方式1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h; author: %cn; date: %ci; subject:%s"</span> 11.0.211...11.0.212</span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline 11.0.211...11.0.212</span><br><span class="line">git <span class="built_in">log</span> 11.0.211...11.0.212 --date=format-local:<span class="string">'%Y-%m-%d %H:%M:%S'</span></span><br></pre></td></tr></table></figure><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p><code>git diff</code>默认使用<strong>myers</strong>算法，该算法的原理可以参考<a href="https://cjting.me/2017/05/13/how-git-generate-diff/" target="_blank" rel="noopener">Git 是怎样生成 diff 的：Myers 算法</a>。</p><p>若想要直接对比两个文件，可以添加参数<code>--no-index</code>，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git diff --no-index a b</span></span><br><span class="line"><span class="comment"># compares two non-git things (1) and (2).</span></span><br><span class="line">git diff --no-index ori.cpp add.cpp</span><br></pre></td></tr></table></figure><p>直接使用<code>git diff</code>比较的时候，通常会在首部和尾部添加未更改的三行，若想只得到没有更改过的行，可以使用<code>--unified</code>参数，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff --no-index ori.cpp add.cpp --unified=0</span><br><span class="line"><span class="comment"># 或者使用简写参数</span></span><br><span class="line">git diff --no-index ori.cpp add.cpp -U0</span><br></pre></td></tr></table></figure><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>若某个已经在git版本中的文件，移动之后，并不是识别为<code>R</code>，而是源文件<code>D</code>，新文件<code>A</code>。则可以采用<code>git mv</code>指令。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv ./utils/a.zip ./models/a.zip</span><br></pre></td></tr></table></figure><h2 id="fetch与pull"><a href="#fetch与pull" class="headerlink" title="fetch与pull"></a>fetch与pull</h2><p>这里需要重点关注于pull指令的不同。</p><p>pull 根据不同的配置，可等于 fetch + merge 或 fetch + rebase。</p><p><strong>git fetch</strong>：从远程获取最新版本到本地，但不会自动 merge，用于从远程跟踪分支下载和查看其他人完成的最新提交，但不将这些提交合并到本地存储库中。它从远程存储库中获取更改并将其存储在本地存储库中。</p><p><strong>git pull</strong>：从远程获取最新版本并 merge 到本地，它会自动将提交合并到您的本地存储库中，而无需查看提交。</p><p>具体了解可继续读下去。要理解它们的区别，首先我们需要明白的git的架构，它是分布式的版本管理系统。知乎有人画了张图，不仅仅涉及到git fetch和git pull，对整体理解也会很有帮助。如下：</p><p><img src="/Tools/Git/git常用指令与使用技巧/v2-af3bf6fee935820d481853e452ed2d55_720w.jpg" alt="img" style="zoom:80%"></p><p>上图展示了git的整体架构，以及和各部分相关的主要命令。先说明下其中涉及的各部分。</p><p><strong>工作区(working directory)，</strong>简言之就是你工作的区域。对于git而言，就是的本地工作目录。工作区的内容会包含提交到暂存区和版本库(当前提交点)的内容，同时也包含自己的修改内容。</p><p><strong>暂存区(stage area, 又称为索引区index)，</strong>是git中一个非常重要的概念。是我们把修改提交版本库前的一个过渡阶段。查看GIT自带帮助手册的时候，通常以index来表示暂存区。在工作目录下有一个.git的目录，里面有个index文件，存储着关于暂存区的内容。git add命令将工作区内容添加到暂存区。</p><p><strong>本地仓库(local repository)，</strong>版本控制系统的仓库，存在于本地。当执行git commit命令后，会将暂存区内容提交到仓库之中。在工作区下面有.git的目录，这个目录下的内容不属于工作区，里面便是仓库的数据信息，暂存区相关内容也在其中。这里也可以使用merge或rebase将<strong>远程仓库副本</strong>合并到本地仓库。图中的只有merge，注意这里也可以使用rebase。</p><p><strong>远程版本库(remote repository)，</strong>与本地仓库概念基本一致，不同之处在于一个存在远程，可用于远程协作，一个却是存在于本地。通过push/pull可实现本地与远程的交互。根据<a href="https://git-scm.com/docs/git-fetch" target="_blank" rel="noopener">官方文档</a>，它应该存储在<code>.git/FETCH_HEAD</code>文件中。</p><p><strong>远程仓库副本，</strong>可以理解为存在于本地的远程仓库缓存。如需更新，可通过git fetch/pull命令获取远程仓库内容。使用fech获取时，并未合并到本地仓库，此时可使用git merge实现远程仓库副本与本地仓库的合并。git pull 根据配置的不同，可为git fetch + git merge 或 git fetch + git rebase。</p><h2 id="rebase与merge"><a href="#rebase与merge" class="headerlink" title="rebase与merge"></a>rebase与merge</h2><p>git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作方式，以下面的一个工作场景说明其区别。</p><p>你在一个feature分支进行新特性的开发，与此同时，master 分支的也有新的提交。</p><p><img src="/Tools/Git/git常用指令与使用技巧/webp.webp" alt="img" style="zoom:50%"></p><p>为了将master 上新的提交合并到你的feature分支上，你有两种选择：<code>merging</code> or <code>rebasing</code></p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure><p>或者执行更简单的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge master feature</span><br></pre></td></tr></table></figure><p>那么此时在feature上git自动会产生一个新的commit(merge commit)。</p><p><img src="/Tools/Git/git常用指令与使用技巧/webp-1685349549296-5.webp" alt="img" style="zoom:50%"></p><p>marge 特点：自动创建一个新的commit。</p><p>Merge 好在它是一个安全的操作。现有的分支不会被更改，避免了 rebase 潜在的缺点（后面会说）。</p><p>另一方面，这同样意味着每次合并上游更改时 feature 分支都会引入一个外来的合并提交。如果 master 非常活跃的话，这或多或少会污染你的分支历史。虽然高级的 <code>git log</code> 选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>作为 merge 的替代选择，你可以像下面这样将 feature 分支并入 master 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>它会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase 为原feature分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。</p><p><img src="/Tools/Git/git常用指令与使用技巧/webp-1685349914787-10.webp" alt="img" style="zoom:50%"></p><p>rebase最大的好处是你的项目历史会非常整洁。首先，它不像 <code>git merge</code> 那样引入不必要的合并提交。其次，如上图所示，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 <code>git log</code>、<code>git bisect</code> 和 <code>gitk</code> 来查看项目历史。</p><p>不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改。如果合并出现代码问题不容易定位，因为re-write了history。</p><p>合并时如果出现冲突需要按照如下步骤解决：</p><ul><li>修改冲突部分</li><li>git add，不要在git add 之后习惯性的执行 git commit命令</li><li><code>git rebase --continue</code></li><li>（如果第三步无效可以执行 <code>git rebase --skip</code>）</li></ul><h3 id="交互式rebase"><a href="#交互式rebase" class="headerlink" title="交互式rebase"></a>交互式rebase</h3><p>交互式的 rebase 允许你更改并入新分支的提交。这比自动的 rebase 更加强大，因为它提供了对分支上提交历史完整的控制。一般来说，这被用于将 feature 分支并入 master 分支之前，清理混乱的历史。</p><p>把 <code>-i</code> 传入 <code>git rebase</code> 选项来开始一个交互式的rebase过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase -i master</span><br></pre></td></tr></table></figure><p>它会打开一个文本编辑器，显示所有将被移动的提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick 33d5b7a Message for commit #1</span><br><span class="line">pick 9480b3d Message for commit #2</span><br><span class="line">pick 5c67e61 Message for commit #3</span><br></pre></td></tr></table></figure><p>这个列表定义了 rebase 将被执行后分支会是什么样的。更改 <code>pick</code> 命令或者重新排序，这个分支的历史就能如你所愿了。比如说，如果第二个提交修复了第一个提交中的小问题，你可以用 <code>fixup</code> 命令把它们合到一个提交中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick 33d5b7a Message for commit #1</span><br><span class="line">fixup 9480b3d Message for commit #2</span><br><span class="line">pick 5c67e61 Message for commit #3</span><br></pre></td></tr></table></figure><p>保存后关闭文件，Git 会根据你的指令来执行 rebase，项目历史看上去会是这样：</p><p><img src="/Tools/Git/git常用指令与使用技巧/67c657754829426bb226c1f0df7604f5.png" alt="img" style="zoom:67%"></p><h3 id="Rebase-的黄金法则"><a href="#Rebase-的黄金法则" class="headerlink" title="Rebase 的黄金法则"></a>Rebase 的黄金法则</h3><p>当你理解 rebase 是什么的时候，最重要的就是什么时候 <em>不能</em> 用 rebase。<code>git rebase</code> 的黄金法则便是，绝不要在公共的分支上使用它。</p><p>比如说，如果你把 feature 分支 rebase 到你的master分支上会发生什么：</p><p><img src="/Tools/Git/git常用指令与使用技巧/73f30b18ace74097875941a39576962d.png" alt="img" style="zoom:67%"></p><p>这次 rebase 将 master 分支上的所有提交都移到了 feature 分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的 master 上工作。因为 rebase 引起了新的提交，Git 会认为你的 master 分支和其他人的 master 已经分叉了。</p><p>同步两个 master 分支的唯一办法是把它们 merge 到一起，导致一个额外的合并提交和两堆包含同样更改的提交。不用说，这会让人非常困惑。</p><p>所以，在你运行 <code>git rebase</code> 之前，一定要问问你自己「有没有别人正在这个分支上工作？」。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如 <code>git revert</code>）来提交你的更改。不然的话，你可以随心所欲地重写历史。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你使用 rebase 之前需要知道的知识点都在这了。如果你想要一个干净的、线性的提交历史，没有不必要的合并提交，你应该使用 <code>git rebase</code> 而不是 <code>git merge</code> 来并入其他分支上的更改。</p><p>另一方面，如果你想要保存项目完整的历史，并且避免重写公共分支上的 commit， 你可以使用 <code>git merge</code>。两种选项都很好用，但至少你现在多了 <code>git rebase</code> 这个选择。</p><h2 id="过滤git-log提交历史"><a href="#过滤git-log提交历史" class="headerlink" title="过滤git log提交历史"></a>过滤git log提交历史</h2><p>格式化提交输出只是 <code>git log</code> 其中的一个用途。另一半是理解如何浏览整个提交历史。接下来的文章会介绍如何用 <code>git log</code> 选择项目历史中的特定提交。所有的用法都可以和上面讨论过的格式化选项结合起来。</p><h3 id="按数量"><a href="#按数量" class="headerlink" title="按数量"></a>按数量</h3><p><code>git log</code> 最基础的过滤选项是限制显示的提交数量。当你只对最近几次提交感兴趣时，它可以节省你一页一页查看的时间。</p><p>你可以在后面加上 <code>-&lt;n&gt;</code> 选项。比如说，下面这个命令会显示最新的 3 次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -3</span><br></pre></td></tr></table></figure><p>此时的日期是比较难看的，不同时区的人也没有统一，想要format日期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--date=format:<span class="string">'%Y-%m-%d %H:%M:%S'</span>       <span class="comment"># committer's timezone</span></span><br><span class="line">--date=format-local:<span class="string">'%Y-%m-%d %H:%M:%S'</span> <span class="comment"># current user's timezone</span></span><br></pre></td></tr></table></figure><h3 id="按日期"><a href="#按日期" class="headerlink" title="按日期"></a>按日期</h3><p>如果你想要查看某一特定时间段内的提交，你可以使用 <code>--after</code> 或 <code>--before</code> 标记来按日期筛选。它们都接受好几种日期格式作为参数。比如说，下面的命令会显示 2014 年 7 月 1 日后（含）的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --after=<span class="string">"2014-7-1"</span></span><br></pre></td></tr></table></figure><p>你也可以传入相对的日期，比如一周前（<code>&quot;1 week ago&quot;</code>）或者昨天（<code>&quot;yesterday&quot;</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get <span class="built_in">log</span> --after=<span class="string">"yesterday"</span></span><br></pre></td></tr></table></figure><p>你可以同时提供<code>--before</code> 和 <code>--after</code> 来检索两个日期之间的提交。比如，为了显示 2014 年 7 月 1 日到 2014 年 7 月 4 日之间的提交，你可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --after=<span class="string">"2014-7-1"</span> --before=<span class="string">"2014-7-4"</span></span><br></pre></td></tr></table></figure><p>注意 <code>--since</code>、<code>--until</code> 标记和 <code>--after</code>、<code>--before</code> 标记分别是等价的。</p><h3 id="按作者"><a href="#按作者" class="headerlink" title="按作者"></a>按作者</h3><p>当你只想看某一特定作者的提交的时候，你可以使用 <code>--author</code> 标记。它接受正则表达式，返回所有作者名字满足这个规则的提交。如果你知道那个作者的确切名字你可以直接传入文本字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=<span class="string">"John"</span></span><br></pre></td></tr></table></figure><p>它会显示所有作者叫 John 的提交。作者名不一定是全匹配，只要包含那个子串就会匹配。</p><p>你也可以用正则表达式来创建更复杂的检索。比如，下面这个命令检索名叫 Mary 或 John 的作者的提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=<span class="string">"John\|Mary"</span></span><br></pre></td></tr></table></figure><p>注意作者的邮箱地址也算作是作者的名字，所以你也可以用这个选项来按邮箱检索。</p><p>如果你的工作流区分提交者和作者，<code>--committer</code> 也能以相同的方式使用。</p><h3 id="按提交信息"><a href="#按提交信息" class="headerlink" title="按提交信息"></a>按提交信息</h3><p>按提交信息来过滤提交，你可以使用 <code>--grep</code> 标记。它和上面的 <code>--author</code> 标记差不多，只不过它搜索的是提交信息而不是作者。</p><p>比如说，你的团队规范要求在提交信息中包括相关的issue编号，你可以用下面这个命令来显示这个 issue 相关的所有提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --grep=<span class="string">"JRA-224:"</span></span><br></pre></td></tr></table></figure><p>你也可以传入 <code>-i</code> 参数来忽略大小写匹配。</p><h3 id="按文件"><a href="#按文件" class="headerlink" title="按文件"></a>按文件</h3><p>很多时候，你只对某个特定文件的更改感兴趣。为了显示某个特定文件的历史，你只需要传入文件路径。比如说，下面这个命令返回所有和 <code>foo.py</code> 和 <code>bar.py</code> 文件相关的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -- foo.py bar.py</span><br></pre></td></tr></table></figure><p><code>--</code> 告诉 <code>git log</code> 接下来的参数是文件路径而不是分支名。如果分支名和文件名不可能冲突，你可以省略 <code>--</code>。</p><h3 id="按内容"><a href="#按内容" class="headerlink" title="按内容"></a>按内容</h3><p>我们还可以根据源代码中某一行的增加和删除来搜索提交。这被称为 pickaxe，它接受形如 <code>-S&quot;&lt;string&gt;&quot;</code> 的参数。比如说，当你想要知道 <code>Hello, World!</code> 字符串是什么时候加到项目中哪个文件中去的，你可以使用下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -S <span class="string">"Hello, World!"</span></span><br></pre></td></tr></table></figure><p>如果你想用正则表达式而不是字符串来搜索，你可以使用 <code>-G&quot;&lt;regex&gt;&quot;</code> 标记。</p><p>这是一个非常强大的调试工具，它能让你定位到所有影响代码中特定一行的提交。它甚至可以让你看到某一行是什么时候复制或者移动到另一个文件中去的。</p><h3 id="按范围"><a href="#按范围" class="headerlink" title="按范围"></a>按范围</h3><p>你可以传入范围来筛选提交。这个范围由下面这样的格式指定，其中 <code>&lt;since&gt;</code> 和 <code>&lt;until&gt;</code> 是提交的引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;since&gt;..&lt;until&gt;</span><br></pre></td></tr></table></figure><p>这个命令在你使用分支引用作为参数时特别有用。这是显示两个分支之间区别最简单的方式。看看下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> master..feature</span><br></pre></td></tr></table></figure><p>其中的 <code>master..feature</code> 范围包含了在 feature 分支而不在 master 分支中所有的提交。换句话说，这个命令可以看出从 master 分支 fork 到 feature 分支后发生了哪些变化。</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><h3 id="语法-pattern-format"><a href="#语法-pattern-format" class="headerlink" title="语法(pattern format)"></a>语法(pattern format)</h3><h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><ol><li>空行被忽略</li><li>以<code>#</code>开头的行视为注释，需要<code>#</code>的地方要进行转意</li><li>其余每行表示一个pattern</li><li><strong>行尾</strong> 的空格被忽略，需要行尾空格的地方要进行转意</li><li><code>!</code>意味着<code>取反</code>，即原本被匹配上的文件被忽略，加上<code>!</code>后，这些文件则被包含进来，需要<code>!</code>的地方要要进行转意。但是<strong>如果一个文件的parent directory被忽略，则该文件不会被包含进来</strong>。</li><li>以<code>/</code>结尾的pattern，<code>/</code>将会被移除，然后按照<strong>下面</strong>的规则进行匹配，但是<strong>只匹配目录</strong></li><li>如果pattern中没有<code>/</code>，则git把该pattern当作一个shell glob去匹配文件路径</li><li>如果pattern中包含<code>/</code>，则git把该pattern当作一个<strong>受限</strong>的shell glob去匹配文件路径：此时wildcards(<code>*</code>)<strong>不能</strong>匹配<code>/</code>符号</li><li>以<code>/</code>开头的pattern，<code>/</code>匹配文件路径的开始，如<code>/*.c</code>匹配<code>cat.c</code>而不匹配<code>mozilla/cat.c</code></li></ol><p>语法一大堆，但是真正值得注意的地方是：</p><ol><li><code>/</code>和<code>*</code>，即pattern中有<code>/</code>的时候<code>*</code>不匹配<code>/</code>，pattern中没有<code>/</code>的时候<code>*</code>可以匹配<code>/</code></li><li>以<code>/</code>结尾的pattern会去掉<code>/</code>进行匹配，但是只匹配目录，如<code>*/</code>会匹配所有的目录，这一点常常结合<code>!</code>不能把父目录被忽略的文件重新包含进来这条规则来用</li></ol><p>pattern format定义好了，而pattern要跟谁进行匹配呢，答案是跟文件路径，文件路径指的是从git repository开始的相对文件路径。git会遍历所有的文件，用这里定义的pattern来进行匹配，匹配的结果就是要么包含进版本库，要么忽略它。</p><h4 id="双星号语法规则"><a href="#双星号语法规则" class="headerlink" title="双星号语法规则"></a>双星号语法规则</h4><p><code>**</code>匹配完整路径，它不管什么斜杠不斜杠的，所有字符通吃。</p><ol><li>以<code>**/</code>开始的pattern匹配所有路径。如<code>**/foo</code>匹配所有路径下的<code>foo</code>文件或者文件夹，<br>等同于<code>foo</code> pattern</li><li>以<code>/**</code>结尾的pattern匹配everything inside。如<code>abc/**</code>匹配<code>abc</code>目录下的所有文件或文件夹</li><li>中间包含<code>/**/</code>的pattern匹配零个或任意多个目录。如<code>a/**/b</code>匹配<code>a/b</code>、<code>a/x/b</code>、<code>a/x/y/b</code>等等</li><li>上述三种pattern的组合pattern</li></ol><p>这里的<code>**</code>类似于正则表达式里的<code>*</code>。</p><h3 id="gitignore白名单"><a href="#gitignore白名单" class="headerlink" title=".gitignore白名单"></a>.gitignore白名单</h3><p>在<code>.gitignore</code>文件中如下配置，可以忽略除了<code>lapsvmp_v02/gui/*.mat</code>下的所有<code>.mat</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*.mat</span><br><span class="line">!*lapsvmp_v02/gui/*.mat</span><br></pre></td></tr></table></figure><p>更加详细的用法如下。</p><h4 id="忽略某个文件夹"><a href="#忽略某个文件夹" class="headerlink" title="忽略某个文件夹"></a>忽略某个文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略build目录</span></span><br><span class="line"><span class="comment"># 如何做到的呢？ 看第6条规则</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略build目录中的所有内容，但是不忽略build目录本身，</span></span><br><span class="line"><span class="comment"># 该条pattern中包含斜杠，所以wildcards不能匹配斜杠，</span></span><br><span class="line"><span class="comment"># 于是这个pattern的作用就是把build/里面的文件、文件夹</span></span><br><span class="line"><span class="comment"># 全都忽略了，但是由于"parent dir"被忽略的文件不能被</span></span><br><span class="line"><span class="comment"># 包含进来，所以build目录的子目录中的所有文件、文件夹</span></span><br><span class="line"><span class="comment"># 也都被一并忽略了</span></span><br><span class="line">build/*</span><br></pre></td></tr></table></figure><h4 id="忽略某类文件"><a href="#忽略某类文件" class="headerlink" title="忽略某类文件"></a>忽略某类文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略所有的.exe文件</span></span><br><span class="line"><span class="comment"># 由于pattern中没有斜杠(/)，所以这个pattern被当作shell glob</span></span><br><span class="line"><span class="comment"># 来进行匹配，它可以匹配斜杠(/)，所以诸如"build/outputs/aaa.exe"</span></span><br><span class="line"><span class="comment"># 这样的.exe文件均被忽略了，从而达到忽略所有.exe文件目的</span></span><br><span class="line">*.exe</span><br></pre></td></tr></table></figure><h4 id="忽略某个文件夹，但是保留某些特殊文件"><a href="#忽略某个文件夹，但是保留某些特殊文件" class="headerlink" title="忽略某个文件夹，但是保留某些特殊文件"></a>忽略某个文件夹，但是保留某些特殊文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略build目录，但是保留build/config.xml文件</span></span><br><span class="line"><span class="comment"># build/ 是不行的，为什么呢？找找上面的规则，与parent dir相关哦</span></span><br><span class="line">build/*</span><br><span class="line">!build/config.xml</span><br></pre></td></tr></table></figure><h4 id="建立白名单，只保留某些文件夹或者目录"><a href="#建立白名单，只保留某些文件夹或者目录" class="headerlink" title="建立白名单，只保留某些文件夹或者目录"></a>建立白名单，只保留某些文件夹或者目录</h4><p>所谓的白名单就是先忽略所有的文件、文件夹，然后把需要的再重新包含进来，但是注意：parent dir被忽略的文件是不能被重新包含进来的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略一切</span></span><br><span class="line">*</span><br><span class="line"><span class="comment"># 把所有的文件夹重新包含进来</span></span><br><span class="line"><span class="comment"># 这是怎么做到的呢？ 看第6条规则</span></span><br><span class="line">!*/</span><br><span class="line"><span class="comment"># 把想要的文件或文件夹重新包含进来</span></span><br><span class="line"><span class="comment"># 这里为啥不能用： !src/* 呢，因为有斜杠时星号不能匹配斜杠，</span></span><br><span class="line"><span class="comment"># 导致src/里的子目录被忽略了，只包含进src/下的文件了</span></span><br><span class="line"><span class="comment"># 这里为啥不能用： !src/ 呢，因为以斜杠(/)结尾只能匹配目录</span></span><br><span class="line">!src/**</span><br><span class="line">!AndroidManifest.xml</span><br><span class="line"><span class="comment"># 如果不把所有文件夹包含进来，则需要先把res/目录包含进来才行</span></span><br><span class="line">!res/drawable/**</span><br></pre></td></tr></table></figure><h3 id="gitignore规则无效"><a href="#gitignore规则无效" class="headerlink" title=".gitignore规则无效"></a>.gitignore规则无效</h3><p>据我所知导致.gitignore里的忽略规则失效只有两种情况，当然我对Git的使用和理解比较浅薄，也只能想到这两个方面：一种是忽略规则的语法错误，这种情形好处理，只要修正错误的语法就可以了。PS：本文不对语法错误的问题详细说明，毕竟每个人情况不同。排查语法问题这事我也不知道怎么举例，总之只要符合官方规范的就可以了，需要注意的好像也就一个路径问题吧？！</p><p>另一种则是本文要重点说明的情况：项目中的文件或目录已经被纳入到Git的版本管理里面/跟踪文件清单，此时你再往.gitignore里添加此文件/目录的忽略规则就会发现毫无作用，因为已经被Git跟踪(track)的文件/目录无法被.gitignore忽略掉！。</p><p>这里再对上面一段所说的进行详细说明，所谓“已经被纳入到Git的版本管理里面/跟踪文件清单”，大体上指的是下面的三种情况：</p><ul><li>已使用add命令开始跟踪项目文件或者将修改的文件放入暂存区/索引</li><li>已使用commit命令提交更新到本地仓库</li><li>已使用push命令将项目文件推送到了Git远程仓库了（例如GitHub）</li></ul><p>上述的三种操作只要进行了其中一项，再添加对应文件的忽略规则都是不生效的！PS：这三个命令在GUI客户端上一般都可以找到对应的按钮和操作。</p><h4 id="未进行提交操作的处理方式"><a href="#未进行提交操作的处理方式" class="headerlink" title="未进行提交操作的处理方式"></a>未进行提交操作的处理方式</h4><p>如果此时还未进行提交操作，赶紧使用如下命令可及时挽救：<code>git rm --cached &lt;file&gt;</code>，其中<code>&lt;file&gt;</code>表示要从暂存区移除出去的文件名或者目录路径，注意可以使用通配符。不过Git有自己的通配符规则，所以要注意下差异，例如官方文档有提到在<code>*</code>号前面是需要加反斜杠<code>\</code>的（我有测试过不加也没事但是最好按照规范来），结合上面的案例，因为我们要移除bin文件夹下的所有文件，所以完整的Git命令为（注意路径一定要正确）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached WebApplication1/WebApplication1/bin/\*</span><br></pre></td></tr></table></figure><p>这里要留意忽略规则的添加时机，在命令执行后会有不同的影响，假设<strong>忽略规则</strong>是在<code>git rm --cached &lt;file&gt;</code>命令执行前就设置了，那么当命令执行完成后马上就可以看到效果，bin文件夹及里面的所有文件会被Git直接忽略。如果在命令执行后还<strong>没有添加忽略规则</strong>，你会发现bin文件夹下的文件变成未被跟踪的状态，也就是最初的状态，此时你<strong>再添加忽略规则</strong>这些文件就会被忽略了。</p><h4 id="文件已经进行提交操作的处理方式"><a href="#文件已经进行提交操作的处理方式" class="headerlink" title="文件已经进行提交操作的处理方式"></a>文件已经进行提交操作的处理方式</h4><p>如果bin文件夹已经被Git跟踪并提交到了本地版本库甚至远程版本库（例如GitHub），解决方法和上一小节中的方法是一样的，依然是使用<code>git rm --cached &lt;file&gt;</code>这个命令。PS：在执行此命令前Git最好能保持干净的状态,也就是”nothing to commit, working tree clean”。</p><p><strong>注意！！！在命令执行后受影响的文件都会变成未跟踪状态，此时一定要马上使用git commit -m ‘备注信息’命令提交这部分修改，如果还未设置.gitignore文件则可以设置后一并提交此次更新到本地仓库。</strong>这里千万不要使用任何GUI客户端去操作！因为不同GUI客户端可能有不一样的执行结果（例如可能会将文件重新纳入跟踪，等于刚刚的操作白费了）。</p><h4 id="忽略更改的文件（临时）"><a href="#忽略更改的文件（临时）" class="headerlink" title="忽略更改的文件（临时）"></a>忽略更改的文件（临时）</h4><p>为了忽略将更改的文件列为已修改文件，您可以使用以下git命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;</span><br></pre></td></tr></table></figure><p>恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --no-assume-unchanged &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;</span><br></pre></td></tr></table></figure><h2 id="git放弃修改"><a href="#git放弃修改" class="headerlink" title="git放弃修改"></a>git放弃修改</h2><h3 id="本地修改了一些文件-并没有使用-git-add-到暂存区-，想放弃修改"><a href="#本地修改了一些文件-并没有使用-git-add-到暂存区-，想放弃修改" class="headerlink" title="本地修改了一些文件 (并没有使用 git add 到暂存区)，想放弃修改"></a>本地修改了一些文件 (并没有使用 git add 到暂存区)，想放弃修改</h3><p>单个文件/文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>所有文件/文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h3 id="本地新增了一些文件-并没有-git-add-到暂存区-，想放弃修改。"><a href="#本地新增了一些文件-并没有-git-add-到暂存区-，想放弃修改。" class="headerlink" title="本地新增了一些文件 (并没有 git add 到暂存区)，想放弃修改。"></a>本地新增了一些文件 (并没有 git add 到暂存区)，想放弃修改。</h3><p>单个文件/文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm  -rf filename</span><br></pre></td></tr></table></figure><p>所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -xdf</span><br></pre></td></tr></table></figure><blockquote><p>删除新增的文件，如果文件已经已经 git add 到暂存区，并不会删除！</p></blockquote><p>所有文件和文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -xdff</span><br></pre></td></tr></table></figure><blockquote><p>本命令删除新增的文件和文件夹，如果文件已经已经 git add 到暂存区，并不会删除！</p></blockquote><h3 id="本地修改-新增了一些文件，已经-git-add-到暂存区，想放弃修改"><a href="#本地修改-新增了一些文件，已经-git-add-到暂存区，想放弃修改" class="headerlink" title="本地修改 / 新增了一些文件，已经 git add 到暂存区，想放弃修改"></a>本地修改 / 新增了一些文件，已经 git add 到暂存区，想放弃修改</h3><p>单个文件 / 文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD filename</span><br></pre></td></tr></table></figure><p>所有文件 / 文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure><p>例如，当我们使用<code>git reset --hard</code>指令时会舍弃所有的文件更改，但是有的时候我们只想舍弃某一个文件的更改，以<code>record.xlsx</code>文件为例，应该使用如下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件的修改记录</span></span><br><span class="line">$ git <span class="built_in">log</span> record.xlsx</span><br><span class="line"></span><br><span class="line">commit 8ac3974e2cefe34b51e718a6dc03a3d02ec2c10f</span><br><span class="line">Author: zdaiot &lt;zdaiot@163.com&gt;</span><br><span class="line">Date:   Wed Nov 27 10:28:24 2019 +0800</span><br><span class="line"></span><br><span class="line">    add record.xlsx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复到指定的版本</span></span><br><span class="line">$ git reset 8ac3974e2cefe34b51e718a6dc03a3d02ec2c10f record.xlsx</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       config.py</span><br><span class="line">M       models/build_model.py</span><br><span class="line">M       online-service/model/customize_service.py</span><br><span class="line">M       record.xlsx</span><br><span class="line">M       train_classifier.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新到工作目录</span></span><br><span class="line">$ git checkout record.xlsx</span><br></pre></td></tr></table></figure><h3 id="本地通过-git-add-和-git-commit-后，想要撤销此次-commit"><a href="#本地通过-git-add-和-git-commit-后，想要撤销此次-commit" class="headerlink" title="本地通过 git add 和 git commit 后，想要撤销此次 commit"></a>本地通过 git add 和 git commit 后，想要撤销此次 commit</h3><p>撤销 commit, 同时保留该 commit 修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset commit_id</span><br></pre></td></tr></table></figure><p>这个 <code>commit_id</code> 是你想要回到的那个节点，可以通过 git log 查看，可以只选前 6 位。</p><blockquote><p>撤销之后，你所做的已经 commit 的修改还在工作区！</p></blockquote><p>撤销 commit, 同时本地删除该 commit 修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><p>这个<code>commit_id</code> 是你想要回到的那个节点，可以通过 git log 查看，可以只选前 6。</p><blockquote><p>[谨慎操作] 撤销之后，你所做的已经 commit 的修改将会清除，仍在工作区 / 暂存区的代码也将会清除！</p></blockquote><h2 id="建立与远程仓库的连接"><a href="#建立与远程仓库的连接" class="headerlink" title="建立与远程仓库的连接"></a>建立与远程仓库的连接</h2><p>假设我们要与远程仓库<code>git@github.com:zdaiot/few-shot-gnn</code>建立连接，远程名字为<code>origin</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:zdaiot/few-shot-gnn</span><br></pre></td></tr></table></figure><p>执行完毕之后，就使用<code>git remote -v</code>可以看到新建立的链接了。</p><p>如果报错，提示说<code>fatal: remote origin already exists.</code>，这是因为你本地仓库已经存在了<code>origin</code>远程链接。</p><p>解决方法1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>然后再建立连接。</p><p>解决方法2：直接修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin [url]</span><br></pre></td></tr></table></figure><h2 id="远程仓库强制覆盖本地仓库"><a href="#远程仓库强制覆盖本地仓库" class="headerlink" title="远程仓库强制覆盖本地仓库"></a>远程仓库强制覆盖本地仓库</h2><p>执行下面语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull</span><br></pre></td></tr></table></figure><h2 id="查看历史commit总数"><a href="#查看历史commit总数" class="headerlink" title="查看历史commit总数"></a>查看历史commit总数</h2><p>使用如下指令，值得注意的是，它包含了历史分支中所有commit，但是不含有不属于任何分支的commit。详看下面<code>commit不属于任何分支</code>中的分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --all --count</span><br></pre></td></tr></table></figure><p>另外，github网页上看到的commit总数是当前分支的commit总数。</p><h2 id="查看commit位于哪些分支"><a href="#查看commit位于哪些分支" class="headerlink" title="查看commit位于哪些分支"></a>查看commit位于哪些分支</h2><p>以<a href="https://github.com/chromium/chromium的`e84c0fabb85b23caa47b88afbe0c27984948c20a`为例，看那些远程分支包含了它。" target="_blank" rel="noopener">https://github.com/chromium/chromium的`e84c0fabb85b23caa47b88afbe0c27984948c20a`为例，看那些远程分支包含了它。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r --contains e84c0fabb85b23caa47b88afbe0c27984948c20a</span><br><span class="line">origin/HEAD -&gt; origin/main</span><br><span class="line">origin/dependabot/npm_and_yarn/tools/android/dependency_analysis/js/webpack-5.76.0</span><br><span class="line">origin/lkgr</span><br><span class="line">origin/lkgr-android-internal</span><br><span class="line">origin/main</span><br></pre></td></tr></table></figure><p>若想看本地分支是否包含了它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --contains e84c0fabb85b23caa47b88afbe0c27984948c20a</span><br><span class="line">* main</span><br></pre></td></tr></table></figure><h2 id="commit不属于任何分支"><a href="#commit不属于任何分支" class="headerlink" title="commit不属于任何分支"></a>commit不属于任何分支</h2><p>若当使用<code>git branch -r --contains + commitid</code>的时候，发现为空。并且当在github打开该commit的时候（例如<a href="https://github.com/chromium/chromium/commit/74faf035c07ba2387ecbe8ae29f30a3312c5544b" target="_blank" rel="noopener">这里</a>），提示如下：This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.</p><p>为什么出现这种情况呢？核心原因是该commit所在的分支被删除了，而它又不属于其它分支。做实验如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">首先在github中建立仓库 delete。</span><br><span class="line"></span><br><span class="line">mkdir git_delete_test</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .\git_delete_test\</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"# delete"</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:zdaiot/delete.git</span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="comment"># 空白提交</span></span><br><span class="line">git commit --allow-empty -m <span class="string">"Trigger Build"</span></span><br><span class="line">git push origin main</span><br><span class="line">git branch <span class="built_in">test</span></span><br><span class="line">git checkout <span class="built_in">test</span></span><br><span class="line">git commit --allow-empty -m <span class="string">"new test branch"</span>  <span class="comment"># 71bf9563c5ae66578bbe99b8f854b01bf9f68be8</span></span><br><span class="line">git push origin <span class="built_in">test</span></span><br><span class="line">git commit --allow-empty -m <span class="string">"again branch"</span>  <span class="comment"># 34531bc751798f9fea4699ee80ee65a3da297b10</span></span><br><span class="line">git push origin <span class="built_in">test</span></span><br><span class="line">git push origin --delete <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这个时候，打开github，<code>&quot;new test branch&quot;</code>和<code>&quot;again branch&quot;</code>对应的commit就会显示<code>This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.</code></p><p>此时，执行如下指令，查看commit所在的分支，可以发现该commit不存在于任何远程分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) PS E:\Working\git_delete_test&gt; git branch -r --contains 71bf9563c5ae66578bbe99b8f854b01bf9f68be8</span><br><span class="line">(base) PS E:\Working\git_delete_test&gt; git branch --contains 71bf9563c5ae66578bbe99b8f854b01bf9f68be8</span><br><span class="line">* <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>然后继续探索，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(base) PS E:\Working\git_delete_test&gt; git rev-list --all --count</span><br><span class="line">4</span><br><span class="line">(base) PS E:\Working\git_delete_test&gt; git checkout main</span><br><span class="line">Switched to branch <span class="string">'main'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/main'</span>.</span><br><span class="line"><span class="comment"># 包含了所有分支的提交</span></span><br><span class="line">(base) PS E:\Working\git_delete_test&gt; git rev-list --all --count</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="comment"># That is not an error, it is a warning. It means the branch you are about to delete contains commits that are not reachable from any of: its upstream branch, or HEAD (currently checked out revision). In other words, when you might lose commits</span></span><br><span class="line">(base) PS E:\Working\git_delete_test&gt; git branch -d <span class="built_in">test</span></span><br><span class="line">error: The branch <span class="string">'test'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D test'</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们强制删除该分支</span></span><br><span class="line">(base) PS E:\Working\git_delete_test&gt; git branch -D <span class="built_in">test</span></span><br><span class="line">Deleted branch <span class="built_in">test</span> (was 34531bc).</span><br><span class="line"><span class="comment"># 不包含不属于任何分支的commit</span></span><br><span class="line">(base) PS E:\Working\git_delete_test&gt; git rev-list --all --count</span><br><span class="line">2</span><br></pre></td></tr></table></figure><blockquote><p>更加详细的说明可以参考<a href="https://stackoverflow.com/questions/50010761/why-do-some-commits-belong-to-no-branch" target="_blank" rel="noopener">Why do some commits belong to no branch?</a>。</p></blockquote><h3 id="恢复被删除的分支"><a href="#恢复被删除的分支" class="headerlink" title="恢复被删除的分支"></a>恢复被删除的分支</h3><p><code>Git会自行负责分支的管理，所以当我们删除一个分支时，Git只是删除了指向相关提交的指针，但该提交对象依然会留在版本库</code>中。</p><p>因此，如果我们知道删除分支时的散列值，就可以将某个删除的分支恢复过来。在已知提交的散列值的情况下恢复某个分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch_name&gt; &lt;hash_val&gt;</span><br><span class="line">例如</span><br><span class="line">(base) PS E:\Working\git_delete_test&gt; git branch <span class="built_in">test</span> 34531bc751798f9fea4699ee80ee65a3da297b10</span><br><span class="line">(base) PS E:\Working\git_delete_test&gt; git rev-list --all --count</span><br><span class="line">4</span><br></pre></td></tr></table></figure><blockquote><p>如果我们不知道想要恢复的分支的散列值，可以用<code>git reflog</code>命令将它找出来。详细的就不展开了。</p></blockquote><h2 id="git分支重命名"><a href="#git分支重命名" class="headerlink" title="git分支重命名"></a>git分支重命名</h2><p>假设分支名称为oldName，想要修改为 newName</p><p><strong>1. 本地分支重命名(本地还没有推送到远程时)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><p><strong>2. 远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同)</strong><br> a. 重命名远程分支对应的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><p>b. 删除远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete origin oldName</span><br></pre></td></tr></table></figure><p>c. 上传新命名的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin newName</span><br></pre></td></tr></table></figure><p>d.把修改后的本地分支与远程分支关联</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to origin/newName</span><br></pre></td></tr></table></figure><h2 id="拉取所有分支"><a href="#拉取所有分支" class="headerlink" title="拉取所有分支"></a>拉取所有分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -r | grep -v <span class="string">'\-&gt;'</span> | sed <span class="string">"s,\x1B\[[0-9;]*[a-zA-Z],,g"</span> | <span class="keyword">while</span> <span class="built_in">read</span> remote; <span class="keyword">do</span> git branch --track <span class="string">"<span class="variable">$&#123;remote#origin/&#125;</span>"</span> <span class="string">"<span class="variable">$remote</span>"</span>; <span class="keyword">done</span></span><br><span class="line">git fetch --all</span><br><span class="line">git pull --all</span><br></pre></td></tr></table></figure><h2 id="本地、远程分支与tag名"><a href="#本地、远程分支与tag名" class="headerlink" title="本地、远程分支与tag名"></a>本地、远程分支与tag名</h2><p>上一小节我们介绍了如何拉取所有分支的内容，那么若我们不想拉取内容，只是想拿到名字呢？对此可以继续看。</p><p>当我们直接使用<code>git clone</code>指令clone仓库的时候，可能并没有拉取所有的分支名字到本地，但是目前测试的所有的tag名字都拉取到本地了。如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/v8/v8.git</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> v8</span><br><span class="line"><span class="comment">### 此时会发现.git有packed-refs文件，推测存放了所有的远程分支名、本地tag名</span></span><br><span class="line"></span><br><span class="line">$ tree .git/refs/</span><br><span class="line">.git/refs/</span><br><span class="line">├── heads</span><br><span class="line">│   └── main</span><br><span class="line">├── remotes</span><br><span class="line">│   └── origin</span><br><span class="line">│       └── HEAD</span><br><span class="line">└── tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地分支，从refs/heads/文件夹读取</span></span><br><span class="line">$ git branch</span><br><span class="line">* main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程分支，从packed-refs文件中获取，要求origin标签不能删除</span></span><br><span class="line">$ git branch -r</span><br><span class="line">  origin/10.0-lkgr</span><br><span class="line">  origin/10.1-lkgr</span><br><span class="line">  origin/10.2-lkgr</span><br><span class="line">  origin/10.3-lkgr</span><br><span class="line">  origin/10.4-lkgr</span><br><span class="line">  origin/10.5-lkgr</span><br><span class="line">  origin/10.6.1</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地分支，从refs/heads/文件夹读取</span></span><br><span class="line">$ git <span class="keyword">for</span>-each-ref refs/heads/</span><br><span class="line">c5677ca37541eb0d4672fe963cd237a0aec4f1fc commit refs/heads/main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程分支，从packed-refs文件中获取，要求origin标签不能删除</span></span><br><span class="line">$ git <span class="keyword">for</span>-each-ref refs/remotes/</span><br><span class="line">9a8cb2c0be476a447374746bc7eb95e47d9914c9 commit refs/remotes/origin/10.0-lkgr</span><br><span class="line">e5f13e0cd10e245d822f856d17b347c77ccc7593 commit refs/remotes/origin/10.1-lkgr</span><br><span class="line">fc08b999dfa1bfa1633f3bf1cc8c3f1dfc50ecb6 commit refs/remotes/origin/10.2-lkgr</span><br><span class="line">9abdc4cc595e0cd9fc16f68f32a5c53e50045d88 commit refs/remotes/origin/10.3-lkgr</span><br><span class="line">0bd243efded55c52060d25611b9df8f641a1b918 commit refs/remotes/origin/10.4-lkgr</span><br><span class="line">3ae6859800b0b41e70896d8b7e4886689933a7c4 commit refs/remotes/origin/10.5-lkgr</span><br><span class="line">b80e2601a9010e0aec738cfa55eae7af9f12aef2 commit refs/remotes/origin/10.6-lkgr</span><br><span class="line">e5f414868799abe9cf8f758a5c746698c814f827 commit refs/remotes/origin/10.6.1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地tag，从packed-refs文件中获取</span></span><br><span class="line">$ git tag</span><br><span class="line">0.1.5</span><br><span class="line">0.2.5</span><br><span class="line">0.3.9.5</span><br><span class="line">0.4.9.3</span><br><span class="line">1.0.3.6</span><br><span class="line">1.1.10.17</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地tag详细信息，从packed-refs文件中获取</span></span><br><span class="line">$ git <span class="keyword">for</span>-each-ref refs/tags</span><br><span class="line">3a1ab8c626dfee28a5cafb6632b28e284c4cffb3 commit refs/tags/0.1.5</span><br><span class="line">727e995b7bba3c57fb1e5c156d386ca11894f781 commit refs/tags/0.2.5</span><br><span class="line">554479e0453f3ff3dc814dba686d8c7fbdf472c3 commit refs/tags/0.3.9.5</span><br><span class="line">987f25d8dd6faa1e1ccd0bca3558ee982a788019 commit refs/tags/0.4.9.3</span><br><span class="line">59bd73731279fb7bb43244828eba2c54d8ec58a5 commit refs/tags/1.0.3.6</span><br><span class="line">260cbc6daff7d06b16af64676c5b0de0350d4828 commit refs/tags/1.1.10.17</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程tag，需要联网</span></span><br><span class="line">$ git ls-remote --tags origin</span><br><span class="line">3a1ab8c626dfee28a5cafb6632b28e284c4cffb3        refs/tags/0.1.5</span><br><span class="line">727e995b7bba3c57fb1e5c156d386ca11894f781        refs/tags/0.2.5</span><br><span class="line">554479e0453f3ff3dc814dba686d8c7fbdf472c3        refs/tags/0.3.9.5</span><br><span class="line">987f25d8dd6faa1e1ccd0bca3558ee982a788019        refs/tags/0.4.9.3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p><code>git branch</code>与<code>git for-each-ref refs/heads/</code>本质一样，都是查看本地分支，只是详细方式不同</p><p><code>git branch -r</code>与<code>git for-each-ref refs/remotes/</code>本质一样，都是查看远程分支，只是详细方式不同</p><p><code>git tag</code>与<code>git for-each-ref refs/tags</code>本质一样，都是查看本地tag，只是详细方式不同</p></blockquote><p>那么，这些查看远程分支名与tag名的指令是需要联网的么？我们做了如下实验。</p><p>首先，删除origin后的实验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 删除origin后的实验</span></span><br><span class="line">$ git remote rm origin</span><br><span class="line"><span class="comment"># 下面输出为空</span></span><br><span class="line">$ git branch -r</span><br><span class="line"><span class="comment"># 下面输出为空</span></span><br><span class="line">$ git <span class="keyword">for</span>-each-ref refs/remotes/</span><br><span class="line"><span class="comment"># 下面会报错</span></span><br><span class="line">$ git ls-remote --tags origin</span><br><span class="line"><span class="comment"># 所有查看本地分支与tag的指令输出与上述相同</span></span><br><span class="line"><span class="comment"># git branch与git for-each-ref refs/heads/与git tag输出不变</span></span><br></pre></td></tr></table></figure><p>其次，保留origin，删除packed-refs的实验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 保留origin, 删除packed-refs</span></span><br><span class="line">$ rm .git/packed-refs</span><br><span class="line"><span class="comment"># 下面输出报warning</span></span><br><span class="line">$ git branch -r</span><br><span class="line">warning: ignoring broken ref refs/remotes/origin/HEAD</span><br><span class="line">$ git <span class="keyword">for</span>-each-ref refs/remotes/</span><br><span class="line">warning: ignoring broken ref refs/remotes/origin/HEAD</span><br><span class="line"><span class="comment"># 下面输出为空</span></span><br><span class="line">$ git tag</span><br><span class="line"><span class="comment"># git branch与git for-each-ref refs/heads/与git ls-remote --tags origin输出不变</span></span><br></pre></td></tr></table></figure><p>最后，保留origin与packed-refs，禁用github网址，实验如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-remote --tags origin</span><br><span class="line">fatal: unable to access <span class="string">'https://github.com/v8/v8.git/'</span>: Failed to connect to github.com port 443 after 2060 ms: Connection refused</span><br><span class="line"><span class="comment"># 其余指令输出不变</span></span><br></pre></td></tr></table></figure><h3 id="获取远程分支名到本地"><a href="#获取远程分支名到本地" class="headerlink" title="获取远程分支名到本地"></a>获取远程分支名到本地</h3><p><strong><code>git clone</code>会将所有的远程分支都下载下来</strong>，但是就是把远程的<code>main</code>会变成本地的<code>main</code>分支。其他的远程分支，名字仍旧是远程分支，没有重新命名。此时可以采用<code>git checkout</code>的方式还原：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line"></span><br><span class="line">$ git checkout auto_test</span><br><span class="line">$ git branch</span><br><span class="line">* auto_test</span><br><span class="line">  master</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 此时若main分支更新了，在当前auto_test执行如下操作，并不会拉取main分支的更新</span></span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><h3 id="获取所有的分支名到本地：方法一"><a href="#获取所有的分支名到本地：方法一" class="headerlink" title="获取所有的分支名到本地：方法一"></a>获取所有的分支名到本地：方法一</h3><p>当然上述一个个checkout肯定不行，很慢，而且还需要已知分支名。因此可以采用如下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://stackoverflow.com/a/10312587/15304315</span></span><br><span class="line"><span class="comment"># 执行该指令发现`.git/refs/heads/`在不断与远程同步</span></span><br><span class="line"><span class="comment"># 若想要拉取所有的分支名字，存放在.git/refs/heads文件夹</span></span><br><span class="line">$ git branch -r | grep -v <span class="string">'\-&gt;'</span> | sed <span class="string">"s,\x1B\[[0-9;]*[a-zA-Z],,g"</span> | <span class="keyword">while</span> <span class="built_in">read</span> remote; <span class="keyword">do</span> git branch --track <span class="string">"<span class="variable">$&#123;remote#origin/&#125;</span>"</span> <span class="string">"<span class="variable">$remote</span>"</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行完，结果如下</span></span><br><span class="line">$ tree .git/refs/</span><br><span class="line">.git/refs/</span><br><span class="line">├── heads</span><br><span class="line">│   ├── 10.0-lkgr</span><br><span class="line">│   ├── 10.1-lkgr</span><br><span class="line">│   ├── 10.2-lkgr</span><br><span class="line">│   ├── 10.3-lkgr</span><br><span class="line">│   ├── 10.4-lkgr</span><br><span class="line">│   ├── 10.5-lkgr</span><br><span class="line">│   ├── 10.6.1</span><br><span class="line">│   └── main</span><br><span class="line">├── remotes</span><br><span class="line">│   └── origin</span><br><span class="line">│       └── HEAD</span><br><span class="line">└── tags</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  10.0-lkgr</span><br><span class="line">  10.1-lkgr</span><br><span class="line">  10.2-lkgr</span><br><span class="line">  10.3-lkgr</span><br><span class="line">  10.4-lkgr</span><br><span class="line">  10.5-lkgr</span><br><span class="line">  10.6-lkgr</span><br><span class="line">  10.6.1</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="获取所有的分支名到本地：方法二"><a href="#获取所有的分支名到本地：方法二" class="headerlink" title="获取所有的分支名到本地：方法二"></a>获取所有的分支名到本地：方法二</h3><p>若想直接clone仓库的时候clone所有的分支与tag名字到本地，可采用如下方式。此时本地含有所有branch与tags名字，但是使用指令查看远程分支名字为空；远程tag名字因为是联网的，所以不为空。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ref: https://gist.github.com/fernandoaleman/853916e1903b475820f5416bfe048cb8</span></span><br><span class="line"><span class="comment"># Clone repo</span></span><br><span class="line">git <span class="built_in">clone</span> --mirror https://github.com/v8/v8.git app/.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change into app directory</span></span><br><span class="line"><span class="built_in">cd</span> app</span><br><span class="line"><span class="comment">### 此时会发现.git有packed-refs文件，推测存放了所有本地分支名与本地tag名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Update git config</span></span><br><span class="line">git config --<span class="built_in">unset</span> core.bare</span><br><span class="line"></span><br><span class="line"><span class="comment"># Checkout master branch</span></span><br><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line">$ tree .git/refs/</span><br><span class="line">.git/refs/</span><br><span class="line">├── heads</span><br><span class="line">└── tags</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  10.0-lkgr</span><br><span class="line">  10.1-lkgr</span><br><span class="line">  10.2-lkgr</span><br><span class="line">  10.3-lkgr</span><br><span class="line">  10.4-lkgr</span><br><span class="line">  10.5-lkgr</span><br><span class="line">  10.6-lkgr</span><br><span class="line">  10.6.1</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面输出为空</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line">$ git tag </span><br><span class="line">0.1.5</span><br><span class="line">0.2.5</span><br><span class="line">0.3.9.5</span><br><span class="line">0.4.9.3</span><br><span class="line">1.0.3.6</span><br><span class="line">1.1.10.17</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要联网</span></span><br><span class="line">$ git ls-remote --tags origin</span><br><span class="line">3a1ab8c626dfee28a5cafb6632b28e284c4cffb3        refs/tags/0.1.5</span><br><span class="line">727e995b7bba3c57fb1e5c156d386ca11894f781        refs/tags/0.2.5</span><br><span class="line">554479e0453f3ff3dc814dba686d8c7fbdf472c3        refs/tags/0.3.9.5</span><br><span class="line">987f25d8dd6faa1e1ccd0bca3558ee982a788019        refs/tags/0.4.9.3</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git ls-remote --tags</span><br><span class="line">From https://github.com/v8/v8.git</span><br><span class="line">3a1ab8c626dfee28a5cafb6632b28e284c4cffb3        refs/tags/0.1.5</span><br><span class="line">727e995b7bba3c57fb1e5c156d386ca11894f781        refs/tags/0.2.5</span><br><span class="line">554479e0453f3ff3dc814dba686d8c7fbdf472c3        refs/tags/0.3.9.5</span><br><span class="line">987f25d8dd6faa1e1ccd0bca3558ee982a788019        refs/tags/0.4.9.3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="寻找git中大文件"><a href="#寻找git中大文件" class="headerlink" title="寻找git中大文件"></a>寻找git中大文件</h2><h3 id="基础脚本"><a href="#基础脚本" class="headerlink" title="基础脚本"></a>基础脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all |</span><br><span class="line">  git cat-file --batch-check=<span class="string">'%(objecttype) %(objectname) %(objectsize) %(rest)'</span> |</span><br><span class="line">  sed -n <span class="string">'s/^blob //p'</span> |</span><br><span class="line">  sort --numeric-sort --key=2 |</span><br><span class="line">  cut -c 1-12,41- |</span><br><span class="line">  $(<span class="built_in">command</span> -v gnumfmt || <span class="built_in">echo</span> numfmt) --field=2 --to=iec-i --suffix=B --padding=7 --round=nearest</span><br></pre></td></tr></table></figure><p>输出结果类似如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">0d99bb931299  530KiB path/to/some-image.jpg</span><br><span class="line">2ba44098e28f   12MiB path/to/hires-image.png</span><br><span class="line">bd1741ddce0d   63MiB path/to/some-video-1080p.mp4</span><br></pre></td></tr></table></figure><p>对于MacOS，numfmt不支持，所以要么去掉最后一行让其显示bytes sizes，要么执行<code>brew install coreutils</code>。</p><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>为了实现功能更加丰富的过滤，你需要在<code>sort</code>行之前添加对应的过滤指令。</p><p>To <strong>exclude files that are present in <code>HEAD</code></strong>, insert the following line:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -vF --file=&lt;(git ls-tree -r HEAD | awk <span class="string">'&#123;print $3&#125;'</span>) |</span><br></pre></td></tr></table></figure><p>To <strong>show only files exceeding given size</strong> (e.g. 1 MiB = 220 B), insert the following line:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'$2 &gt;= 2^20'</span> |</span><br></pre></td></tr></table></figure><h3 id="原始输出"><a href="#原始输出" class="headerlink" title="原始输出"></a>原始输出</h3><p>当去掉上述指令的最后两行，你将会得到原始输出，未经过format。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">0d99bb93129939b72069df14af0d0dbda7eb6dba 542455 path/to/some-image.jpg</span><br><span class="line">2ba44098e28f8f66bac5e21210c2774085d2319b 12446815 path/to/hires-image.png</span><br><span class="line">bd1741ddce0d07b72ccf69ed281e09bf8a2d0b2f 65183843 path/to/some-video-1080p.mp4</span><br></pre></td></tr></table></figure><h2 id="lfs"><a href="#lfs" class="headerlink" title="lfs"></a>lfs</h2><h3 id="创建一个新的-Git-LFS-仓库"><a href="#创建一个新的-Git-LFS-仓库" class="headerlink" title="创建一个新的 Git LFS 仓库"></a>创建一个新的 Git LFS 仓库</h3><p>要创建一个新的支持 Git LFS 的仓库，你需要在创建仓库后运行 git lfs install：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># initialize Git</span></span><br><span class="line">$ mkdir Atlasteroids</span><br><span class="line">$ <span class="built_in">cd</span> Atlasteroids</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/tpettersen/Atlasteroids/.git/</span><br><span class="line"><span class="comment"># initialize Git LFS</span></span><br><span class="line">$ git lfs install</span><br><span class="line">Updated pre-push hook.</span><br><span class="line">Git LFS initialized.</span><br></pre></td></tr></table></figure><p>这将在你的仓库中安装一个特殊的 pre-push <strong><a href="https://www.atlassian.com/git/tutorials/git-hooks" target="_blank" rel="noopener">Git 钩子</a></strong>，该钩子将在你执行 git push 的时候传输 Git LFS 文件到服务器上。</p><h3 id="克隆现有的-Git-LFS-仓库"><a href="#克隆现有的-Git-LFS-仓库" class="headerlink" title="克隆现有的 Git LFS 仓库"></a>克隆现有的 Git LFS 仓库</h3><p>安装 Git LFS 后，你可以像往常一样使用 git clone 命令来克隆 Git LFS 仓库。<strong>在克隆过程的结尾，Git 将检出默认分支（通常是 master），并且将自动为你下载完成检出过程所需的所有 Git LFS 文件</strong>。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@bitbucket.org:tpettersen/Atlasteroids.gitCloning into <span class="string">'Atlasteroids'</span>...</span><br><span class="line">remote: Counting objects: 156, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (154/154), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 156 (delta 87), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (156/156), 54.04 KiB | 31.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (87/87), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">Downloading Assets/Sprites/projectiles-spritesheet.png (21.14 KB)</span><br><span class="line">Downloading Assets/Sprites/productlogos_cmyk-spritesheet.png (301.96 KB)</span><br><span class="line">Downloading Assets/Sprites/shuttle2.png (1.62 KB)</span><br><span class="line">Downloading Assets/Sprites/space1.png (1.11 MB)</span><br><span class="line">Checking out files: 100% (81/81), <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>仓库里有 4 个 PNG 文件被 Git LFS 跟踪。执行 git clone 命令时，<strong>在从仓库中检出指针文件的时候，Git LFS 文件被一个一个下载下来</strong>。</p><p>另外，若想git clone的时候，不下载lfs文件，则执行<code>GIT_LFS_SKIP_SMUDGE=1 git clone &lt;repository-addr&gt;</code>。使用这种方法，以后即使 git pull, 也不会把大文件拉下来了。如果以后想把大文件再拉下来的话，可以用 git lfs pull。</p><p>如果是对于一个曾经正常clone下来的workspace，也可以用类似的方法<code>GIT_LFS_SKIP_SMUDGE=1 git pull</code>去pull，则不会将大文件pull下来；而且以后再pull的时候也不会。</p><h3 id="加快克隆速度"><a href="#加快克隆速度" class="headerlink" title="加快克隆速度"></a>加快克隆速度</h3><p>如果你正在克隆包含大量 LFS 文件的仓库，显式使用 git lfs clone 命令可提供更好的性能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git lfs <span class="built_in">clone</span> git@bitbucket.org:tpettersen/Atlasteroids.git</span><br><span class="line">Cloning into <span class="string">'Atlasteroids'</span>...</span><br><span class="line">remote: Counting objects: 156, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (154/154), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 156 (delta 87), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (156/156), 54.04 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (87/87), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">Git LFS: (4 of 4 files) 1.14 MB / 1.15 MB</span><br></pre></td></tr></table></figure><p>git lfs clone 命令不会一次下载一个 Git LFS 文件，而是等到检出（checkout）完成后再<strong>批量下载</strong>所有必需的 Git LFS 文件。这利用了并行下载的优势，并显著减少了产生的 HTTP 请求和进程的数量（这对于提高 Windows 的性能尤为重要）。</p><h3 id="拉取并检出"><a href="#拉取并检出" class="headerlink" title="拉取并检出"></a><strong>拉取并检出</strong></h3><p>就像克隆一样，你可以使用常规的 git pull 命令拉取 Git LFS 仓库。拉取完成后，所有需要的 Git LFS 文件都会作为自动检出过程的一部分而被下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Updating 4784e9d..7039f0a</span><br><span class="line">Downloading Assets/Sprites/powerup.png (21.14 KB)</span><br><span class="line">Fast-forward</span><br><span class="line">Assets/Sprites/powerup.png | 3 +</span><br><span class="line">Assets/Sprites/powerup.png.meta | 4133 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">2 files changed, 4136 insertions(+)</span><br><span class="line">create mode 100644 Assets/Sprites/projectiles-spritesheet.png</span><br><span class="line">create mode 100644 Assets/Sprites/projectiles-spritesheet.png.meta</span><br></pre></td></tr></table></figure><p>不需要显式的命令即可获取 Git LFS 内容。然而，如果检出因为意外原因而失败，你可以通过使用 git lfs pull 命令来下载当前提交的所有丢失的 Git LFS 内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git lfs pull</span><br><span class="line">Git LFS: (4 of 4 files) 1.14 MB / 1.15 MB</span><br></pre></td></tr></table></figure><h3 id="加快拉取速度"><a href="#加快拉取速度" class="headerlink" title="加快拉取速度"></a><strong>加快拉取速度</strong></h3><p>像 git lfs clone 命令一样，git lfs pull 命令批量下载 Git LFS 文件。如果你知道自上次拉取以来已经更改了大量文件，则不妨显式使用 git lfs pull 命令来批量下载 Git LFS 内容，而禁用在检出期间自动下载 Git LFS。这可以通过在调用 git pull 命令时使用-c 选项覆盖 Git 配置来完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git -c filter.lfs.smudge= -c filter.lfs.required=<span class="literal">false</span> pull &amp;&amp; git lfs pull</span><br></pre></td></tr></table></figure><p>由于输入的内容很多，你可能希望创建一个简单的<strong><a href="https://link.zhihu.com/?target=https%3A//blogs.atlassian.com/2014/10/advanced-git-aliases/" target="_blank" rel="noopener">Git 别名</a></strong>来为你执行批处理的 Git 和 Git LFS 拉取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.plfs <span class="string">"\!git -c filter.lfs.smudge= -c filter.lfs.required=false pull &amp;&amp; git lfs pull"</span></span><br><span class="line">$ git plfs</span><br></pre></td></tr></table></figure><p>当需要下载大量的 Git LFS 文件时，这将大大提高性能（同样，尤其是在 Windows 上）。</p><h3 id="使用-Git-LFS-跟踪文件"><a href="#使用-Git-LFS-跟踪文件" class="headerlink" title="使用 Git LFS 跟踪文件"></a><strong>使用 Git LFS 跟踪文件</strong></h3><p>当向仓库中添加新的大文件类型时，你需要通过使用 git lfs track 命令指定一个模式来告诉 Git LFS 对其进行跟踪：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git lfs track <span class="string">"*.ogg"</span></span><br><span class="line">Tracking *.ogg</span><br></pre></td></tr></table></figure><p>请注意，”*.ogg”周围的引号很重要。省略它们将导致通配符被 shell 扩展，并将为当前目录中的每个.ogg 文件创建单独的条目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># probably not what you want</span></span><br><span class="line">$ git lfs track *.ogg</span><br><span class="line">Tracking explode.ogg</span><br><span class="line">Tracking music.ogg</span><br><span class="line">Tracking phaser.ogg</span><br></pre></td></tr></table></figure><p>Git LFS 支持的模式与.gitignore 支持的模式相同，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># track all .ogg files in any directory</span></span><br><span class="line">$ git lfs track <span class="string">"*.ogg"</span></span><br><span class="line"><span class="comment"># track files named music.ogg in any directory</span></span><br><span class="line">$ git lfs track <span class="string">"music.ogg"</span></span><br><span class="line"><span class="comment"># track all files in the Assets directory and all subdirectories</span></span><br><span class="line">$ git lfs track <span class="string">"Assets/"</span></span><br><span class="line"><span class="comment"># track all files in the Assets directory but *not* subdirectories</span></span><br><span class="line">$ git lfs track <span class="string">"Assets/*"</span></span><br><span class="line"><span class="comment"># track all ogg files in Assets/Audio</span></span><br><span class="line">$ git lfs track <span class="string">"Assets/Audio/*.ogg"</span></span><br><span class="line"><span class="comment"># track all ogg files in any directory named Music</span></span><br><span class="line">$ git lfs track <span class="string">"**/Music/*.ogg"</span></span><br><span class="line"><span class="comment"># track png files containing "xxhdpi" in their name, in any directory</span></span><br><span class="line">$ git lfs track <span class="string">"*xxhdpi*.png</span></span><br></pre></td></tr></table></figure><p>这些模式是相对于你运行 git lfs track 命令的目录的。为了简单起见，最好是在仓库根目录运行 git lfs track。需要注意的是，Git LFS 不支持像.gitignore 那样的负模式（negative patterns）。</p><p>运行 git lfs track 后，你会在你的运行命令的仓库中发现名为.gitattributes 的新文件。.gitattributes 是一种 Git 机制，用于将特殊行为绑定到某些文件模式。Git LFS 自动创建或更新.gitattributes 文件，以将跟踪的文件模式绑定到 Git LFS 过滤器。但是，你需要将对.gitattributes 文件的任何更改自己提交到仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git lfs track <span class="string">"*.ogg"</span></span><br><span class="line">Tracking *.ogg</span><br><span class="line">$ git add .gitattributes</span><br><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/.gitattributes b/.gitattributes</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..b6dd0bb</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/.gitattributes</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+*.ogg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">$ git commit -m <span class="string">"Track ogg files with Git LFS"</span></span><br></pre></td></tr></table></figure><p>为了便于维护，通过始终从仓库的根目录运行 git lfs track，将所有 Git LFS 模式保持在单个.gitattributes 文件中是最简单的。然而，你可以通过调用不带参数的 git lfs track 命令来显示 Git LFS 当前正在跟踪的所有模式的列表（以及它们在其中定义的.gitattributes 文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git lfs track</span><br><span class="line">Listing tracked paths</span><br><span class="line">*.stl (.gitattributes)</span><br><span class="line">*.png (Assets/Sprites/.gitattributes)</span><br><span class="line">*.ogg (Assets/Audio/.gitattributes)</span><br></pre></td></tr></table></figure><p>你可以通过从.gitattributes 文件中删除相应的行，或者通过运行 git lfs untrack 命令来停止使用 Git LFS 跟踪特定模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git lfs untrack <span class="string">"*.ogg"</span></span><br><span class="line">Untracking *.ogg</span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/.gitattributes b/.gitattributes</span><br><span class="line">index b6dd0bb..e69de29 100644</span><br><span class="line">--- a/.gitattributes</span><br><span class="line">+++ b/.gitattributes</span><br><span class="line">@@ -1 +0,0 @@</span><br><span class="line">-*.ogg filter=lfs diff=lfs merge=lfs -text</span><br></pre></td></tr></table></figure><p>运行 git lfs untrack 命令后，你自己必须再次提交.gitattributes 文件的更改。</p><h3 id="提交和推送"><a href="#提交和推送" class="headerlink" title="提交和推送"></a><strong>提交和推送</strong></h3><p>你可以按常规方式提交并推送到包含 Git LFS 内容的仓库。如果你已经提交了被 Git LFS 跟踪的文件的变更，则当 Git LFS 内容传输到服务器时，你会从 git push 中看到一些其他输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Git LFS: (3 of 3 files) 4.68 MB / 4.68 MB</span><br><span class="line">Counting objects: 8, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (8/8), 1.16 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 8 (delta 1), reused 0 (delta 0)</span><br><span class="line">To git@bitbucket.org:tpettersen/atlasteroids.git</span><br><span class="line">7039f0a..b3684d3 master -&gt; master</span><br></pre></td></tr></table></figure><p>如果由于某些原因传输 LFS 文件失败，推送将被终止，你可以放心地重试。与 Git 一样，Git LFS 存储也是<em>内容寻址</em> 的（<strong>而不是按文件名寻址</strong>）：内容是根据密钥存储的，该密钥是内容本身的 SHA-256 哈希。这意味着重新尝试将 Git LFS 文件传输到服务器总是安全的；你不可能用错误的版本意外覆盖 Git LFS 文件的内容。</p><h2 id="git瘦身"><a href="#git瘦身" class="headerlink" title="git瘦身"></a>git瘦身</h2><p>有的时候经常将大文件添加到了git仓库，并且提交了，这个时候就需要重写存储库会删除不需要的历史记录，从而使存储库更小。 git filter-repo是用于快速重写Git存储库历史记录的工具，用法可以点击<a href="https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html#EXAMPLES" target="_blank" rel="noopener">这里</a>。</p><p>首先，安装插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install git-filter-repo</span><br></pre></td></tr></table></figure><p>然后查看top 100 大文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all | grep <span class="string">"<span class="variable">$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -100 | awk '&#123;print $1&#125;')</span>"</span></span><br></pre></td></tr></table></figure><p><img src="/Tools/Git/git常用指令与使用技巧/15990318563766.jpg" alt="img" style="zoom:50%"></p><blockquote><p>这里当然可以使用<code>寻找git中大文件</code>小节中的指令。</p></blockquote><p>大文件多数集中在Pods文件夹内，移除Pods记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-repo --path-glob <span class="string">'YMMCargoModule/Pods/*'</span> --invert-paths --force</span><br></pre></td></tr></table></figure><p><img src="/Tools/Git/git常用指令与使用技巧/15990320262625.jpg" alt="img"></p><p>这个时候，本地仓库就重写完毕了，需要提交到github：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master --force</span><br></pre></td></tr></table></figure><p>可以发现，所有的提交记录都存在，但是仓库大小变小了。</p><h2 id="重写某个repo的git历史"><a href="#重写某个repo的git历史" class="headerlink" title="重写某个repo的git历史"></a>重写某个repo的git历史</h2><p>碰见一种情况是，提交到github的时候，没有使用的邮箱不对，导致在Github没有记录你的Contributions，解决方法是使用脚本来改变某个repo的Git历史。</p><p>在执行这段脚本前，你需要准备的信息：</p><ol><li><p>Mac、Linux下打开Terminal，Windows下打开命令提示符（command prompt）</p></li><li><p>给你的repo创建一个全新的clone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare https://github.com/user/repo.git</span><br><span class="line">cd repo.git</span><br></pre></td></tr></table></figure></li><li><p>复制粘贴脚本，并根据你的信息修改以下变量：<code>旧的Email地址</code>，<code>正确的用户名</code>，<code>正确的邮件地址</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git filter-branch --env-filter <span class="string">'</span></span><br><span class="line"><span class="string">OLD_EMAIL="旧的Email地址"</span></span><br><span class="line"><span class="string">CORRECT_NAME="正确的用户名"</span></span><br><span class="line"><span class="string">CORRECT_EMAIL="正确的邮件地址"</span></span><br><span class="line"><span class="string">if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">'</span> --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure></li><li><p>按 <code>Enter键</code> 执行脚本。</p></li><li><p>用<code>git log</code>命令看看新 Git 历史有没有错误</p></li><li><p>把正确历史 push 到 Github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force --tags origin <span class="string">'refs/heads/*'</span></span><br></pre></td></tr></table></figure></li><li><p>删掉刚刚临时创建的 clone</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">rm -rf repo.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="git某个人或者某个组织的全部代码"><a href="#git某个人或者某个组织的全部代码" class="headerlink" title="git某个人或者某个组织的全部代码"></a>git某个人或者某个组织的全部代码</h2><p>不管在Linux上或者Windows上，都可以使用下面代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CNTX=&#123;users|orgs&#125;; NAME=&#123;username|orgname&#125;; PAGE=1</span><br><span class="line">curl <span class="string">"https://api.github.com/<span class="variable">$CNTX</span>/<span class="variable">$NAME</span>/repos?page=<span class="variable">$PAGE</span>&amp;per_page=100"</span> |</span><br><span class="line">  grep -e <span class="string">'git_url*'</span> |</span><br><span class="line">  cut -d \" -f 4 |</span><br><span class="line">  xargs -L1 git <span class="built_in">clone</span></span><br></pre></td></tr></table></figure><ul><li>设置<code>CNTX=users</code> and <code>NAME=yourusername</code>，下载<code>yourusername</code>的所有代码</li><li>设置<code>CNTX=orgs</code> and <code>NAME=yourorgname</code>，下载<code>yourorgname</code>的所有代码</li><li>设置<code>PAGE=num</code>，最大页面大小是100，因此您必须多次调用它才能获得所有存储库，此时下载第<code>num</code>的所有代码。</li></ul><p>但是若这样设置，可能会报错<code>{&quot;message&quot;:&quot;API rate limit exceeded for 203.205.141.118. (But here&#39;s the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)&quot;,&quot;documentation_url&quot;:&quot;https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting&quot;}</code>，此时可以在<code>curl</code>后面加上<code>-u your-username</code>，其中<code>your-username</code>是你的github账户，并且会提示你输入对应的代码。</p><p>举个例子，比如git clone <code>zdaiot</code>的所有代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CNTX=users; NAME=zdaiot; PAGE=1</span><br><span class="line">curl -u zdaiot <span class="string">"https://api.github.com/<span class="variable">$CNTX</span>/<span class="variable">$NAME</span>/repos?page=<span class="variable">$PAGE</span>&amp;per_page=100"</span> |</span><br><span class="line">  grep -e <span class="string">'git_url*'</span> |</span><br><span class="line">  cut -d \" -f 4 |</span><br><span class="line">  xargs -L1 git <span class="built_in">clone</span></span><br></pre></td></tr></table></figure><p>再比如，git clone <code>apple</code>组织的所有代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CNTX=orgs; NAME=apple; PAGE=1</span><br><span class="line">curl -u zdaiot <span class="string">"https://api.github.com/<span class="variable">$CNTX</span>/<span class="variable">$NAME</span>/repos?page=<span class="variable">$PAGE</span>&amp;per_page=100"</span> |</span><br><span class="line">  grep -e <span class="string">'git_url*'</span> |</span><br><span class="line">  cut -d \" -f 4 |</span><br><span class="line">  xargs -L1 git <span class="built_in">clone</span></span><br></pre></td></tr></table></figure><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><h3 id="下拉时冲突"><a href="#下拉时冲突" class="headerlink" title="下拉时冲突"></a>下拉时冲突</h3><p><code>git pull</code>遇到错误：<code>error: Your local changes to the following files would be overwritten by merge:</code></p><p><strong>方法1：</strong>如果你想保留刚才本地修改的代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull origin master</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p></p><p><strong>方法2：</strong>如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p></p><p>当远程有文件<code>test.py</code>，本地有未跟踪的文件<code>test.py</code>，此时使用<code>git pull</code> 更新本地仓库时，可能出现<code>error: The following untracked working tree files would be overwritten by merge:</code>。</p><p>解决方法（待验证）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin </span><br><span class="line">git clean -f </span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h3 id="上传时冲突"><a href="#上传时冲突" class="headerlink" title="上传时冲突"></a>上传时冲突</h3><p><code>git push</code>的时候报错<code>hint: Updates were rejected because the tip of your current branch is behind</code>。</p><p>若想本地分支强行覆盖远程分支，以github分支为<code>master</code>为例，则执行如下指令。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master -f</span><br></pre></td></tr></table></figure><p></p><p>否则的话，就先执行<code>git pull</code>操作，若报错了，则参考上述<code>下拉时冲突</code>小节。</p><h2 id="其它错误"><a href="#其它错误" class="headerlink" title="其它错误"></a>其它错误</h2><h3 id="git-file-is-being-edited-by"><a href="#git-file-is-being-edited-by" class="headerlink" title="git file is being edited by"></a>git file is being edited by</h3><p>当遇到这个问题的时候。通常显示的是一个nano编辑器。首先会问你是否选项，这个时候输入<code>y</code>即可。然后会显示一般情况下的nano编辑器样子，按<code>ctrl+o</code>，保持当前修改。然后会让你输入文件名，随便输入即可，然后回车，输入<code>y</code>，最后按下<code>ctrl+x</code>退出，git就会正常工作。</p><h3 id="error-src-refspec-master-does-not-match-any"><a href="#error-src-refspec-master-does-not-match-any" class="headerlink" title="error: src refspec master does not match any"></a>error: src refspec master does not match any</h3><p>一般有两个原因</p><h4 id="原因1：没有提交过"><a href="#原因1：没有提交过" class="headerlink" title="原因1：没有提交过"></a>原因1：没有提交过</h4><p>Maybe you just need to commit. I ran into this when I did:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir repo &amp;&amp; <span class="built_in">cd</span> repo</span><br><span class="line">git remote add origin /path/to/origin.git</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><p><strong>Oops! Never committed!</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br><span class="line">error: src refspec master does not match any.</span><br></pre></td></tr></table></figure><p>All I had to do was:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"initial commit"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h4 id="原因2：分支名字错误"><a href="#原因2：分支名字错误" class="headerlink" title="原因2：分支名字错误"></a>原因2：分支名字错误</h4><p>Try <code>git show-ref</code> to see what refs you have. Is there a <code>refs/heads/master</code>?</p><p>Due to the recent “Replacing master with main in GitHub” action, you may notice that there is a <code>refs/heads/main</code>. As a result, the following command may change from <code>git push origin HEAD:master</code> to <code>git push origin HEAD:main</code></p><p>所以得看下现在分支名字是什么，有可能是<code>git push origin main</code></p><h3 id="git-master-branch-has-no-upstream-branch"><a href="#git-master-branch-has-no-upstream-branch" class="headerlink" title="git master branch has no upstream branch"></a>git master branch has no upstream branch</h3><p><img src="/Tools/Git/git常用指令与使用技巧/20171214142540334.png" alt="img"></p><p>具体原因： 出现这种情况主要是由于远程仓库太多，且分支较多。在默认情况下，git push时一般会上传到origin下的master分支上，然而当repository和branch过多，而又没有设置关联时，git就会产生疑问，因为它无法判断你的push目标。</p><blockquote><p> Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init命令默认创建它，并且大多数人都懒得去改动它</p><p>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。origin” 是当你运行git clone时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。</p></blockquote><p>解决办法其实就是确定这两个值，方法有两种：</p><p>解决办法其实就是确定这两个值，方法有两种：</p><ul><li>第一种如上图中的提示：<code>git push --set-upstream origin master</code>。其中的<code>origin</code>是你在<code>clone</code>远程代码时，git为你创建的指向这个远程代码库的标签，它指向repository。为了能清楚了解你要指向的repository，可以用命令<code>git remote -v</code>进行查看。<code>master</code>是你远程的branch，可以用<code>git branch -a</code>查看所有分支，远程分支是红色的部分。然后确定好这两个值后，将值换掉即可。</li><li>另一种方法是：<code>git push -u origin master</code>。同样根据自己的需要，替换<code>origin</code>和<code>master</code>。</li></ul><p>两个命令的区别是第一条命令是要保证你的远程分支存在，如果不存在，也就无法进行关联。而第二条指令即使远程没有你要关联的分支，它也会自动创建一个出来，以实现关联。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/misakaqunianxiatian/article/details/51103734" target="_blank" rel="noopener">git pull遇到错误：error: Your local changes to the following files would be overwritten by merge:</a><br><a href="https://shiyousan.com/post/636470505667009340" target="_blank" rel="noopener">解决.gitignore文件忽略规则无效git依然跟踪修改的问题</a><br><a href="https://blog.csdn.net/shiren1118/article/details/7761203" target="_blank" rel="noopener">github上的版本和本地版本冲突的解决方法</a><br><a href="https://blog.csdn.net/top_code/article/details/50381432" target="_blank" rel="noopener">it 提示fatal: remote origin already exists 错误解决办法</a><br><a href="https://man.linuxde.net/nano" target="_blank" rel="noopener">nano命令</a><br><a href="https://stackoverflow.com/questions/23401652/fatal-the-current-branch-master-has-no-upstream-branch" target="_blank" rel="noopener">fatal: The current branch master has no upstream branch</a><br><a href="https://blog.csdn.net/arkblue/article/details/9568249" target="_blank" rel="noopener">git 查看远程分支、本地分支、创建分支、把分支推到远程repository、删除本地分支</a><br><a href="https://blog.csdn.net/B_H_L/article/details/17266849" target="_blank" rel="noopener">git 如何让单个文件回退到指定的版本</a><br><a href="https://blog.csdn.net/sinat_36184075/article/details/80115000" target="_blank" rel="noopener">【git】强制覆盖本地代码（与git远程仓库保持一致）</a><br><a href="https://www.educative.io/edpresso/how-to-delete-remote-branches-in-git" target="_blank" rel="noopener">How to delete remote branches in Git</a><br><a href="https://segmentfault.com/a/1190000004318632" target="_blank" rel="noopener">为什么Github没有记录你的Contributions</a><br><a href="https://www.zhihu.com/question/23028445/answer/268319296" target="_blank" rel="noopener">github多账号如何切换？ - Tyrael.Liu的回答 - 知乎</a><br><a href="https://www.codenong.com/9162919/" target="_blank" rel="noopener">关于gitignore：Git中的白名单和子目录</a><br><a href="https://www.jianshu.com/p/cc740394faf5" target="_blank" rel="noopener">git修改分支名称</a><br><a href="https://blog.csdn.net/DinnerHowe/article/details/79082769" target="_blank" rel="noopener">git切换到某个tag</a><br><a href="https://action121.github.io/2020/09/02/Git%E7%98%A6%E8%BA%AB.html" target="_blank" rel="noopener">Git瘦身</a><br><a href="https://www.cnblogs.com/objectZhu/p/13205803.html" target="_blank" rel="noopener">git pull报错: The following untracked working tree files would be overwritten by merge：</a><br><a href="https://stackoverflow.com/questions/4181861/message-src-refspec-master-does-not-match-any-when-pushing-commits-in-git" target="_blank" rel="noopener">Message ‘src refspec master does not match any’ when pushing commits in Git</a><br><a href="https://stackoverflow.com/questions/19576742/how-to-clone-all-repos-at-once-from-github" target="_blank" rel="noopener">How to clone all repos at once from GitHub?</a><br><a href="https://stackoverflow.com/questions/33655700/github-api-fetch-issues-with-exceeds-rate-limit-prematurely" target="_blank" rel="noopener">Github API: Fetch issues with exceeds rate limit prematurely</a><br><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.3-Git-log-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">5.3 Git log 高级用法</a><br><a href="https://www.jianshu.com/p/250c42a3c4bd" target="_blank" rel="noopener">git push 所有分支</a><br><a href="https://stackoverflow.com/questions/7853332/how-to-change-git-log-date-formats" target="_blank" rel="noopener">How to change Git log date formats</a><br><a href="https://www.greetingtech.com/memos/1573574400003" target="_blank" rel="noopener">git tag命令常用用法整理</a><br><a href="https://stackoverflow.com/questions/1474115/how-to-find-the-tag-associated-with-a-given-git-commit" target="_blank" rel="noopener">How to find the tag associated with a given git commit?</a><br><a href="https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtltngtemegemHEADv1510em" target="_blank" rel="noopener">—distributed-even-if-your-workflow-isnt</a><br><a href="https://blog.csdn.net/u012145252/article/details/81775362" target="_blank" rel="noopener">git status 显示中文和解决中文乱码</a><br><a href="https://stackoverflow.com/questions/10622179/how-to-find-identify-large-commits-in-git-history" target="_blank" rel="noopener">How to find/identify large commits in git history?</a><br><a href="https://blog.csdn.net/benben_2015/article/details/78803753" target="_blank" rel="noopener">Git master branch has no upstream branch的解决</a><br><a href="https://blog.csdn.net/ustccw/article/details/79068547" target="_blank" rel="noopener">git 放弃修改，放弃增加文件操作</a><br><a href="https://stackoverflow.com/questions/10312521/how-do-i-fetch-all-git-branches" target="_blank" rel="noopener">How do I fetch all Git branches?</a><br><a href="https://www.sunzhongwei.com/total-number-of-history-of-commit-git-statistics" target="_blank" rel="noopener">Git 统计历史提交的 Commit 总数</a><br><a href="https://juejin.cn/post/6844904179794870280" target="_blank" rel="noopener">Git删除分支/恢复分支</a><br><a href="https://stackoverflow.com/questions/50010761/why-do-some-commits-belong-to-no-branch" target="_blank" rel="noopener">Why do some commits belong to no branch?</a><br><a href="https://www.zhihu.com/question/38305012/answer/625881308" target="_blank" rel="noopener">git pull 和 git fetch的区别？ - 波罗学的回答 - 知乎</a><br><a href="https://worktile.com/kb/ask/22877.html" target="_blank" rel="noopener">git fetch 和git pull区别</a><br><a href="https://blog.csdn.net/weixin_44966641/article/details/122561998" target="_blank" rel="noopener">git merge和rebase的区别与选择</a><br><a href="https://www.jianshu.com/p/f23f72251abc" target="_blank" rel="noopener">git rebase 和 git merge 的区别</a><br><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener">Merging vs. Rebasing</a><br><a href="http://ybin.cc/git/gitignore-syntax/" target="_blank" rel="noopener">彻底理解.gitignore</a><br><a href="https://blog.csdn.net/nirendao/article/details/104954495" target="_blank" rel="noopener">git clone与git pull的时候不拉大文件</a><br><a href="https://zhuanlan.zhihu.com/p/146683392" target="_blank" rel="noopener">详解 Git 大文件存储（Git LFS</a><br><a href="https://stackoverflow.com/a/23259612/15304315" target="_blank" rel="noopener">How to ignore certain files in Git</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/" title="git常用指令与使用技巧">https://www.zdaiot.com/Tools/Git/git常用指令与使用技巧/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/github/" rel="tag"><i class="fa fa-tag"></i> github</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Linux/博客搭建/网页部署到服务器以及浏览器预览PDF/" rel="prev" title="网页部署到服务器以及浏览器预览PDF"><i class="fa fa-chevron-left"></i> 网页部署到服务器以及浏览器预览PDF</a></div><div class="post-nav-item"> <a href="/MLFrameworks/Pytorch/Pytorch冻结部分模型参数/" rel="next" title="Pytorch冻结部分模型参数">Pytorch冻结部分模型参数<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用指令"><span class="nav-number">1.</span> <span class="nav-text">常用指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git-config"><span class="nav-number">2.</span> <span class="nav-text">git config</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置用户名和邮箱"><span class="nav-number">2.1.</span> <span class="nav-text">配置用户名和邮箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#status显示中文"><span class="nav-number">2.2.</span> <span class="nav-text">status显示中文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tag"><span class="nav-number">3.</span> <span class="nav-text">tag</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#切换到tag"><span class="nav-number">3.1.</span> <span class="nav-text">切换到tag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看tag"><span class="nav-number">3.2.</span> <span class="nav-text">查看tag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建tag"><span class="nav-number">3.3.</span> <span class="nav-text">创建tag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推送tag到远程服务器"><span class="nav-number">3.4.</span> <span class="nav-text">推送tag到远程服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除tag"><span class="nav-number">3.5.</span> <span class="nav-text">删除tag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tag与commit"><span class="nav-number">3.6.</span> <span class="nav-text">tag与commit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#diff"><span class="nav-number">4.</span> <span class="nav-text">diff</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mv"><span class="nav-number">5.</span> <span class="nav-text">mv</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fetch与pull"><span class="nav-number">6.</span> <span class="nav-text">fetch与pull</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rebase与merge"><span class="nav-number">7.</span> <span class="nav-text">rebase与merge</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#merge"><span class="nav-number">7.1.</span> <span class="nav-text">merge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rebase"><span class="nav-number">7.2.</span> <span class="nav-text">rebase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交互式rebase"><span class="nav-number">7.3.</span> <span class="nav-text">交互式rebase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rebase-的黄金法则"><span class="nav-number">7.4.</span> <span class="nav-text">Rebase 的黄金法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">7.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤git-log提交历史"><span class="nav-number">8.</span> <span class="nav-text">过滤git log提交历史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#按数量"><span class="nav-number">8.1.</span> <span class="nav-text">按数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按日期"><span class="nav-number">8.2.</span> <span class="nav-text">按日期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按作者"><span class="nav-number">8.3.</span> <span class="nav-text">按作者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按提交信息"><span class="nav-number">8.4.</span> <span class="nav-text">按提交信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按文件"><span class="nav-number">8.5.</span> <span class="nav-text">按文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按内容"><span class="nav-number">8.6.</span> <span class="nav-text">按内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按范围"><span class="nav-number">8.7.</span> <span class="nav-text">按范围</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gitignore"><span class="nav-number">9.</span> <span class="nav-text">.gitignore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法-pattern-format"><span class="nav-number">9.1.</span> <span class="nav-text">语法(pattern format)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#语法规则"><span class="nav-number">9.1.1.</span> <span class="nav-text">语法规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双星号语法规则"><span class="nav-number">9.1.2.</span> <span class="nav-text">双星号语法规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gitignore白名单"><span class="nav-number">9.2.</span> <span class="nav-text">.gitignore白名单</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#忽略某个文件夹"><span class="nav-number">9.2.1.</span> <span class="nav-text">忽略某个文件夹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忽略某类文件"><span class="nav-number">9.2.2.</span> <span class="nav-text">忽略某类文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忽略某个文件夹，但是保留某些特殊文件"><span class="nav-number">9.2.3.</span> <span class="nav-text">忽略某个文件夹，但是保留某些特殊文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建立白名单，只保留某些文件夹或者目录"><span class="nav-number">9.2.4.</span> <span class="nav-text">建立白名单，只保留某些文件夹或者目录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gitignore规则无效"><span class="nav-number">9.3.</span> <span class="nav-text">.gitignore规则无效</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#未进行提交操作的处理方式"><span class="nav-number">9.3.1.</span> <span class="nav-text">未进行提交操作的处理方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件已经进行提交操作的处理方式"><span class="nav-number">9.3.2.</span> <span class="nav-text">文件已经进行提交操作的处理方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忽略更改的文件（临时）"><span class="nav-number">9.3.3.</span> <span class="nav-text">忽略更改的文件（临时）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git放弃修改"><span class="nav-number">10.</span> <span class="nav-text">git放弃修改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本地修改了一些文件-并没有使用-git-add-到暂存区-，想放弃修改"><span class="nav-number">10.1.</span> <span class="nav-text">本地修改了一些文件 (并没有使用 git add 到暂存区)，想放弃修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地新增了一些文件-并没有-git-add-到暂存区-，想放弃修改。"><span class="nav-number">10.2.</span> <span class="nav-text">本地新增了一些文件 (并没有 git add 到暂存区)，想放弃修改。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地修改-新增了一些文件，已经-git-add-到暂存区，想放弃修改"><span class="nav-number">10.3.</span> <span class="nav-text">本地修改 / 新增了一些文件，已经 git add 到暂存区，想放弃修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地通过-git-add-和-git-commit-后，想要撤销此次-commit"><span class="nav-number">10.4.</span> <span class="nav-text">本地通过 git add 和 git commit 后，想要撤销此次 commit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建立与远程仓库的连接"><span class="nav-number">11.</span> <span class="nav-text">建立与远程仓库的连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#远程仓库强制覆盖本地仓库"><span class="nav-number">12.</span> <span class="nav-text">远程仓库强制覆盖本地仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看历史commit总数"><span class="nav-number">13.</span> <span class="nav-text">查看历史commit总数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看commit位于哪些分支"><span class="nav-number">14.</span> <span class="nav-text">查看commit位于哪些分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#commit不属于任何分支"><span class="nav-number">15.</span> <span class="nav-text">commit不属于任何分支</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#恢复被删除的分支"><span class="nav-number">15.1.</span> <span class="nav-text">恢复被删除的分支</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git分支重命名"><span class="nav-number">16.</span> <span class="nav-text">git分支重命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拉取所有分支"><span class="nav-number">17.</span> <span class="nav-text">拉取所有分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地、远程分支与tag名"><span class="nav-number">18.</span> <span class="nav-text">本地、远程分支与tag名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取远程分支名到本地"><span class="nav-number">18.1.</span> <span class="nav-text">获取远程分支名到本地</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取所有的分支名到本地：方法一"><span class="nav-number">18.2.</span> <span class="nav-text">获取所有的分支名到本地：方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取所有的分支名到本地：方法二"><span class="nav-number">18.3.</span> <span class="nav-text">获取所有的分支名到本地：方法二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#寻找git中大文件"><span class="nav-number">19.</span> <span class="nav-text">寻找git中大文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础脚本"><span class="nav-number">19.1.</span> <span class="nav-text">基础脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤"><span class="nav-number">19.2.</span> <span class="nav-text">过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原始输出"><span class="nav-number">19.3.</span> <span class="nav-text">原始输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lfs"><span class="nav-number">20.</span> <span class="nav-text">lfs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个新的-Git-LFS-仓库"><span class="nav-number">20.1.</span> <span class="nav-text">创建一个新的 Git LFS 仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#克隆现有的-Git-LFS-仓库"><span class="nav-number">20.2.</span> <span class="nav-text">克隆现有的 Git LFS 仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加快克隆速度"><span class="nav-number">20.3.</span> <span class="nav-text">加快克隆速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拉取并检出"><span class="nav-number">20.4.</span> <span class="nav-text">拉取并检出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加快拉取速度"><span class="nav-number">20.5.</span> <span class="nav-text">加快拉取速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Git-LFS-跟踪文件"><span class="nav-number">20.6.</span> <span class="nav-text">使用 Git LFS 跟踪文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提交和推送"><span class="nav-number">20.7.</span> <span class="nav-text">提交和推送</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git瘦身"><span class="nav-number">21.</span> <span class="nav-text">git瘦身</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重写某个repo的git历史"><span class="nav-number">22.</span> <span class="nav-text">重写某个repo的git历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git某个人或者某个组织的全部代码"><span class="nav-number">23.</span> <span class="nav-text">git某个人或者某个组织的全部代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冲突解决"><span class="nav-number">24.</span> <span class="nav-text">冲突解决</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下拉时冲突"><span class="nav-number">24.1.</span> <span class="nav-text">下拉时冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上传时冲突"><span class="nav-number">24.2.</span> <span class="nav-text">上传时冲突</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其它错误"><span class="nav-number">25.</span> <span class="nav-text">其它错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-file-is-being-edited-by"><span class="nav-number">25.1.</span> <span class="nav-text">git file is being edited by</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#error-src-refspec-master-does-not-match-any"><span class="nav-number">25.2.</span> <span class="nav-text">error: src refspec master does not match any</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原因1：没有提交过"><span class="nav-number">25.2.1.</span> <span class="nav-text">原因1：没有提交过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原因2：分支名字错误"><span class="nav-number">25.2.2.</span> <span class="nav-text">原因2：分支名字错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-master-branch-has-no-upstream-branch"><span class="nav-number">25.3.</span> <span class="nav-text">git master branch has no upstream branch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">26.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">320</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">54</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">386</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2.5m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">37:48</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '0d00fcae3bb09d29abeb6db41d9dc077',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>