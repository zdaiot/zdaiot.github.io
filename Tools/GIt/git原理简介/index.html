<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="在学习git的时候，感觉jingsam写的很不错，边学习边理解一下。强烈建立看原文，作者很牛掰。 Git对象从根本上来讲，Git是一个内容寻址的文件系统，其次才是一个版本控制系统。记住这点，对于理解Git的内部原理及其重要。所谓“内容寻址的文件系统”，意思是根据文件内容的hash码来定位文件。这就意味着同样内容的文件，在这个文件系统中会指向同一个位置，不会重复存储。 Git对象包含三种：数据对象、"><meta name="keywords" content="github,git"><meta property="og:type" content="article"><meta property="og:title" content="git原理简介"><meta property="og:url" content="https://www.zdaiot.com/Tools/Git/git原理简介/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="在学习git的时候，感觉jingsam写的很不错，边学习边理解一下。强烈建立看原文，作者很牛掰。 Git对象从根本上来讲，Git是一个内容寻址的文件系统，其次才是一个版本控制系统。记住这点，对于理解Git的内部原理及其重要。所谓“内容寻址的文件系统”，意思是根据文件内容的hash码来定位文件。这就意味着同样内容的文件，在这个文件系统中会指向同一个位置，不会重复存储。 Git对象包含三种：数据对象、"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git原理简介/2018-06-03-1.png"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git原理简介/2018-06-03-2.png"><meta property="og:image" content="https://www.zdaiot.com/Tools/Git/git原理简介/pDAzG.png"><meta property="og:updated_time" content="2023-03-28T09:52:27.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="git原理简介"><meta name="twitter:description" content="在学习git的时候，感觉jingsam写的很不错，边学习边理解一下。强烈建立看原文，作者很牛掰。 Git对象从根本上来讲，Git是一个内容寻址的文件系统，其次才是一个版本控制系统。记住这点，对于理解Git的内部原理及其重要。所谓“内容寻址的文件系统”，意思是根据文件内容的hash码来定位文件。这就意味着同样内容的文件，在这个文件系统中会指向同一个位置，不会重复存储。 Git对象包含三种：数据对象、"><meta name="twitter:image" content="https://www.zdaiot.com/Tools/Git/git原理简介/2018-06-03-1.png"><link rel="canonical" href="https://www.zdaiot.com/Tools/Git/git原理简介/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>git原理简介 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/Tools/Git/git原理简介/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> git原理简介<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/Tools/Git/git原理简介.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-28 17:52:27" itemprop="dateCreated datePublished" datetime="2023-03-28T17:52:27+08:00">2023-03-28</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Tools/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>28k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>25 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>在学习git的时候，感觉<a href="https://jingsam.github.io/" target="_blank" rel="noopener">jingsam</a>写的很不错，边学习边理解一下。强烈建立看原文，作者很牛掰。</p><h2 id="Git对象"><a href="#Git对象" class="headerlink" title="Git对象"></a>Git对象</h2><p><strong>从根本上来讲，Git是一个内容寻址的文件系统，其次才是一个版本控制系统。</strong>记住这点，对于理解Git的内部原理及其重要。所谓“内容寻址的文件系统”，意思是<strong>根据文件内容的hash码来定位文件</strong>。这就意味着同样内容的文件，在这个文件系统中会指向同一个位置，不会重复存储。</p><p>Git对象包含三种：数据对象、树对象、提交对象。Git文件系统的设计思路与linux文件系统相似，即将<strong>文件的内容与文件的属性分开存储</strong>，文件内容以“装满字节的袋子”存储在文件系统中，文件名、所有者、权限等文件属性信息则另外开辟区域进行存储。在Git中，<strong>数据对象相当于文件内容，树对象相当于文件目录树，提交对象则是对文件系统的快照。</strong></p><p>下面的章节，会分别对每种对象进行说明。开始说明之前，先初始化一个Git文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir git-test</span><br><span class="line">$ <span class="built_in">cd</span> git-test</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>接下来的操作都会在<code>git-test</code>这个目录中进行。</p><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>数据对象是文件的内容，不包括文件名、权限等信息。Git会根据文件内容计算出一个hash值，以hash值作为文件索引存储在Git文件系统中。由于相同的文件内容的hash值是一样的，因此Git将同样内容的文件只会存储一次。<code>git hash-object</code>可以用来计算文件内容的hash值，并将生成的数据对象存储到Git文件系统中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'version 1'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'version 2'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'new file'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">fa49b077972391ad58037050f2a75f74e3671e92</span><br></pre></td></tr></table></figure><p>上面示例中，<code>-w</code>表示将数据对象写入到Git文件系统中，如果不加这个选项，那么只计算文件的hash值而不写入；<code>--stdin</code>表示从标准输入中获取文件内容，当然也可以指定一个文件路径代替此选项。</p><p>上面讲数据对象写入到Git文件系统中，那如何读取数据对象呢？<code>git cat-file</code>可以用来实现所有Git对象的读取，包括数据对象、树对象、提交对象的查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">version 1</span><br><span class="line">$ git cat-file -t 83baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><p>上面示例中，<code>-p</code>表示查看Git对象的内容，<code>-t</code>表示查看Git对象的类型。</p><p>通过这一节，我们能够对Git文件系统中的数据对象进行读写。但是，我们需要记住每一个数据对象的hash值，才能访问到Git文件系统中的任意数据对象，这显然是不现实的。数据对象只是解决了文件内容存储的问题，而文件名的存储则需要通过下一节的树对象来解决。</p><h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>树对象是文件目录树，记录了文件获取目录的名称、类型、模式信息。使用<code>git update-index</code>可以为数据对象指定名称和模式，然后使用<code>git write-tree</code>将树对象写入到Git文件系统中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br><span class="line">$ git write-tree</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br></pre></td></tr></table></figure><p><code>--add</code>表示新增文件名，如果第一次添加某一文件名，必须使用此选项；<code>--cacheinfo &lt;mode&gt; &lt;object&gt; &lt;path&gt;</code>是要添加的数据对象的模式、hash值和路径，<code>&lt;path&gt;</code>意味着为数据对象不仅可以指定单纯的文件名，也可以使用路径。另外要注意的是，使用<code>git update-index</code>添加完文件后，一定要使用<code>git write-tree</code>写入到Git文件系统中，否则只会存在于index区域。</p><p>树对象仍然可以使用<code>git cat-file</code>查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30  test.txt</span><br><span class="line">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">tree</span><br></pre></td></tr></table></figure><p>上面表示这个树对象只有<code>test.txt</code>这个文件，接下来我们将<code>version 2</code>的数据对象指定为<code>test.txt</code>，并添加一个新文件<code>new.txt</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git update-index --cacheinfo 100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line">$ git update-index --add --cacheinfo 100644 fa49b077972391ad58037050f2a75f74e3671e92 new.txt</span><br><span class="line">$ git write-tree</span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341</span><br></pre></td></tr></table></figure><p>查看树对象<code>0155eb</code>，可以发现这个树对象有两个文件了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92  new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a  test.txt</span><br></pre></td></tr></table></figure><p>我们甚至可以使用<code>git read-tree</code>，将已添加的树对象读取出来，作为当前树的子树：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">read</span>-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git write-tree</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br></pre></td></tr></table></figure><p><code>--prefix</code>表示把子树对象放到哪个目录下。查看树对象，可以发现当前树对象有一个文件夹和两个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579  bak</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92  new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a  test.txt</span><br></pre></td></tr></table></figure><p>最终，整个树对象的结构如下图：</p><p><img src="/Tools/Git/git原理简介/2018-06-03-1.png" alt="img" style="zoom:50%"></p><p>树对象解决了文件名的问题，而且，由于我们是分阶段提交树对象的，树对象可以看做是开发阶段源代码目录树的一次次快照，因此我们可以是用树对象作为源代码版本管理。但是，这里仍然有问题需要解决，即我们需要记住每个树对象的hash值，才能找到个阶段的源代码文件目录树。在源代码版本控制中，我们还需要知道谁提交了代码、什么时候提交的、提交的说明信息等，接下来的提交对象就是为了解决这个问题的。</p><h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p>提交对象是用来保存提交的作者、时间、说明这些信息的，可以使用<code>git commit-tree</code>来将提交对象写入到Git文件系统中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'first commit'</span> | git commit-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">db1d6f137952f2b24e3c85724ebd7528587a067a</span><br></pre></td></tr></table></figure><p>上面<code>commit-tree</code>除了要指定提交的树对象，也要提供提交说明，至于提交的作者和时间，则是根据环境变量自动生成，并不需要指定。这里需要提醒一点的是，读者在测试时，得到的提交对象hash值一般和这里不一样，这是因为提交的作者和时间是因人而异的。</p><p>提交对象的查看，也是使用<code>git cat-file</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p db1d6f137952f2b24e3c85724ebd7528587a067a</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span><br><span class="line">committer jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure><p>上面是属于首次提交，那么接下来的提交还需要指定使用<code>-p</code>指定父提交对象，这样代码版本才能成为一条时间线：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'second commit'</span> | git commit-tree 0155eb4229851634a0f03eb265b69f5a2d56f341 -p db1d6f137952f2b24e3c85724ebd7528587a067a</span><br><span class="line">d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c</span><br></pre></td></tr></table></figure><p>使用<code>git cat-file</code>查看一下新的提交对象，可以看到相比于第一次提交，多了<code>parent</code>部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c</span><br><span class="line">tree 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">parent db1d6f137952f2b24e3c85724ebd7528587a067a</span><br><span class="line">author jingsam &lt;jing-sam@qq.com&gt; 1528022722 +0800</span><br><span class="line">committer jingsam &lt;jing-sam@qq.com&gt; 1528022722 +0800</span><br><span class="line"></span><br><span class="line">second commit</span><br></pre></td></tr></table></figure><p>最后，我们再将树对象<code>3c4e9c</code>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'third commit'</span> | git commit-tree 3c4e9cd789d88d8d89c1073707c3585e41b0e614 -p d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c</span><br><span class="line">3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</span><br></pre></td></tr></table></figure><p>使用<code>git log</code>可以查看整个提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span> 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</span><br><span class="line">commit 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</span><br><span class="line">Author: jingsam &lt;jing-sam@qq.com&gt;</span><br><span class="line">Date:   Sun Jun 3 18:47:29 2018 +0800</span><br><span class="line"></span><br><span class="line">    third commit</span><br><span class="line"></span><br><span class="line"> bak/test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">commit d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c</span><br><span class="line">Author: jingsam &lt;jing-sam@qq.com&gt;</span><br><span class="line">Date:   Sun Jun 3 18:45:22 2018 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line"> new.txt  | 1 +</span><br><span class="line"> test.txt | 2 +-</span><br><span class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit db1d6f137952f2b24e3c85724ebd7528587a067a</span><br><span class="line">Author: jingsam &lt;jing-sam@qq.com&gt;</span><br><span class="line">Date:   Sun Jun 3 18:41:43 2018 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>最终的提交对象的结构如下图：</p><p><img src="/Tools/Git/git原理简介/2018-06-03-2.png" alt="img" style="zoom:50%"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Git中的数据对象解决了数据存储的问题，树对象解决了文件名存储问题，提交对象解决了提交信息的存储问题。</strong>另外，对于git中的某个文件，一般来说，每次修改之后commit，都会新建一个数据对象进行存储（可以看后面关于<code>.git/objects/pack</code>文件夹的介绍）。</p><p>从Git设计中可以看出，Linus对一个源代码版本控制系统做了很好的抽象和解耦，每种对象解决的问题都很明确，相比于使用一种数据结构，无疑更灵活和更易维护。每种Git对象都有一个hash值，这个值是怎么计算出来的？Git的各种对象是如何存储的？我们继续看下一节。</p><h2 id="Git对象的hash方法"><a href="#Git对象的hash方法" class="headerlink" title="Git对象的hash方法"></a>Git对象的hash方法</h2><p>Git中的数据对象、树对象和提交对象的hash方法原理是一样的，可以描述为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header = <span class="string">"&lt;type&gt; "</span> + content.length + <span class="string">"\0"</span></span><br><span class="line"><span class="built_in">hash</span> = sha1(header + content)</span><br></pre></td></tr></table></figure><p>上面公式表示，Git在计算对象hash时，首先会在对象头部添加一个<code>header</code>。这个<code>header</code>由3部分组成：第一部分表示对象的类型，可以<strong>取值<code>blob</code>、<code>tree</code>、<code>commit</code>以分别表示数据对象、树对象、提交对象</strong>；第二部分是数据的字节长度；第三部分是一个空字节，用来将<code>header</code>和<code>content</code>分隔开。将<code>header</code>添加到<code>content</code>头部之后，<strong>使用<code>sha1</code>算法计算出一个40位的hash值</strong>。</p><p>在手动计算Git对象的hash时，有两点需要注意：</p><ol><li><p><strong><code>header</code>中第二部分关于数据长度的计算，一定是字节的长度而不是字符串的长度</strong>；</p></li><li><p><strong><code>header + content</code>的操作并不是字符串级别的拼接，而是二进制级别的拼接</strong>。</p></li></ol><p>各种Git对象的hash方法相同，不同的在于：</p><ol><li><p>头部类型不同，数据对象是<code>blob</code>，树对象是<code>tree</code>，提交对象是<code>commit</code>；</p></li><li><p>数据内容不同，数据对象的内容可以是任意内容，而树对象和提交对象的内容有固定的格式。</p></li></ol><p>接下来分别讲数据对象、树对象和提交对象的具体的hash方法。</p><h3 id="数据对象-1"><a href="#数据对象-1" class="headerlink" title="数据对象"></a>数据对象</h3><p>数据对象的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob &lt;content length&gt;&lt;NULL&gt;&lt;content&gt;</span><br></pre></td></tr></table></figure><p>从上一节中我们知道，使用<code>git hash-object</code>可以计算出一个40位的hash值，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"what is up, doc?"</span> | git <span class="built_in">hash</span>-object --stdin</span><br><span class="line">bd9dbf5aae1a3862dd1526723246b20206e5fc37</span><br></pre></td></tr></table></figure><p>注意，上面在<code>echo</code>后面使用了<code>-n</code>选项，用来阻止自动在字符串末尾添加换行符，否则会导致实际传给<code>git hash-object</code>是<code>what is up, doc?\n</code>，而不是我们直观认为的<code>what is up, doc?</code>。</p><p>为验证前面提到的Git对象hash方法，我们使用<code>openssl sha1</code>来手动计算<code>what is up, doc?</code>的hash值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"blob 16\0what is up, doc?"</span> | openssl sha1</span><br><span class="line">bd9dbf5aae1a3862dd1526723246b20206e5fc37</span><br></pre></td></tr></table></figure><p>可以发现，手动计算出的hash值与<code>git hash-object</code>计算出来的一模一样。</p><p>在Git对象hash方法的注意事项中，提到<strong><code>header</code>中第二部分关于数据长度的计算，一定是字节的长度而不是字符串的长度</strong>。由于<code>what is up, doc?</code>只有英文字符，在UTF8中恰好字符的长度和字节的长度都等于16，很容易将这个长度误解为字符的长度。假设我们以<code>中文</code>来试验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"中文"</span> | git <span class="built_in">hash</span>-object --stdin</span><br><span class="line">efbb13322ba66f682e179ebff5eeb1bd6ef83972</span><br><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"blob 2\0中文"</span> | openssl sha1</span><br><span class="line">d1dc2c3eed26b05289bddb857713b60b8c23ed29</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>git hash-object</code>和<code>openssl sha1</code>计算出来的hash值根本不一样。这是因为<code>中文</code>两个字符作为UTF格式存储后的字符长度不是2，具体是多少呢？可以使用<code>wc</code>来计算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"中文"</span> | wc -c</span><br><span class="line">       6</span><br></pre></td></tr></table></figure><p><code>中文</code>字符串的字节长度是6，重新手动计算发现得出的hash值就能对应上了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"blob 6\0中文"</span> | openssl sha1</span><br><span class="line">efbb13322ba66f682e179ebff5eeb1bd6ef83972</span><br></pre></td></tr></table></figure><h3 id="树对象-1"><a href="#树对象-1" class="headerlink" title="树对象"></a>树对象</h3><p>树对象的内容格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree &lt;content length&gt;&lt;NUL&gt;&lt;file mode&gt; &lt;filename&gt;&lt;NUL&gt;&lt;item sha&gt;...</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>&lt;item sha&gt;</code>部分是二进制形式的sha1码，而不是十六进制形式的sha1码。</p><p>我们从上一节摘出一个树对象做实验，其内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30  test.txt</span><br></pre></td></tr></table></figure><p>我们首先使用<code>xxd</code>把<code>83baae61804e65cc73a7201a7252750c76066a30</code>转换成为二进制形式，并将结果保存为<code>sha1.txt</code>以方便后面做追加操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"83baae61804e65cc73a7201a7252750c76066a30"</span> | xxd -r -p &gt; sha1.txt</span><br><span class="line">$ cat tree-items.txt</span><br><span class="line">���a�Ne�s� rRu</span><br><span class="line">              vj0%</span><br></pre></td></tr></table></figure><p>接下来构造content部分，并保存至文件<code>content.txt</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"100644 test.txt\0"</span> | cat - sha1.txt &gt; content.txt</span><br><span class="line">$ cat content.txt</span><br><span class="line">100644 test.txt���a�Ne�s� rRu</span><br><span class="line">                             vj0%</span><br></pre></td></tr></table></figure><p>计算content的长度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat content.txt | wc -c</span><br><span class="line">      36</span><br></pre></td></tr></table></figure><p>那么最终该树对象的内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"tree 36\0"</span> | cat - content.txt</span><br><span class="line">tree 36100644 test.txt���a�Ne�s� rRu</span><br><span class="line">                                    vj0%</span><br></pre></td></tr></table></figure><p>最后使用<code>openssl sha1</code>计算hash值，可以发现和实验的hash值是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"tree 36\0"</span> | cat - content.txt | openssl sha1</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br></pre></td></tr></table></figure><h3 id="提交对象-1"><a href="#提交对象-1" class="headerlink" title="提交对象"></a>提交对象</h3><p>提交对象的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">commit &lt;content length&gt;&lt;NUL&gt;tree &lt;tree sha&gt;</span><br><span class="line">parent &lt;parent sha&gt;</span><br><span class="line">[parent &lt;parent sha&gt; <span class="keyword">if</span> several parents from merges]</span><br><span class="line">author &lt;author name&gt; &lt;author e-mail&gt; &lt;timestamp&gt; &lt;timezone&gt;</span><br><span class="line">committer &lt;author name&gt; &lt;author e-mail&gt; &lt;timestamp&gt; &lt;timezone&gt;</span><br><span class="line"></span><br><span class="line">&lt;commit message&gt;</span><br></pre></td></tr></table></figure><p>我们从上一节摘出一个提交对象做实验，其内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'first commit'</span> | git commit-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">db1d6f137952f2b24e3c85724ebd7528587a067a</span><br><span class="line">$ git cat-file -p db1d6f137952f2b24e3c85724ebd7528587a067a</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span><br><span class="line">committer jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure><p>这里需要注意的是，由于<code>echo &#39;first commit&#39;</code>没有添加<code>-n</code>选项，因此实际的提交信息是<code>first commit\n</code>。使用<code>wc</code>计算出提交内容的字节数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span></span><br><span class="line"><span class="string">author jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span></span><br><span class="line"><span class="string">committer jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">first commit\n"</span> | wc -c</span><br><span class="line">     163</span><br></pre></td></tr></table></figure><p>那么，这个提交对象的<code>header</code>就是<code>commit 163\0</code>，手动把头部添加到提交内容中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit 163\0tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span><br><span class="line">committer jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span><br><span class="line"></span><br><span class="line">first commit\n</span><br></pre></td></tr></table></figure><p>使用<code>openssl sha1</code>计算这个上面内容的hash值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"commit 163\0tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span></span><br><span class="line"><span class="string">author jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span></span><br><span class="line"><span class="string">committer jingsam &lt;jing-sam@qq.com&gt; 1528022503 +0800</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">first commit\n"</span> | openssl sha1</span><br><span class="line">db1d6f137952f2b24e3c85724ebd7528587a067a</span><br></pre></td></tr></table></figure><p>可以看见，与实验的hash值是一样的。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这篇文章详细地分析了Git中的数据对象、树对象和提交对象的hash方法，可以发现原理是非常简单的。数据对象和提交对象打印出来的内容与存储内容组织是一模一样的，可以很直观的理解。对于树对象，其打印出来的内容和实际存储是有区别的，增加了一些实现上的难度。例如，使用二进制形式的hash值而不是直观的十六进制形式。</p><h2 id="Git对象如何存储"><a href="#Git对象如何存储" class="headerlink" title="Git对象如何存储"></a>Git对象如何存储</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>数据对象、树对象和提交对象都是存储在<code>.git/objects</code>目录下，目录的结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">|-- objects</span><br><span class="line">    |-- 01</span><br><span class="line">    |   |-- 55eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">    |-- 1f</span><br><span class="line">    |   |-- 7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">    |-- 83</span><br><span class="line">        |-- baae61804e65cc73a7201a7252750c76066a30</span><br></pre></td></tr></table></figure><p>从上面的目录结构可以看出，Git对象的40位hash分为两部分：头两位作为文件夹，后38位作为对象文件名。所以一个Git对象的存储路径规则为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.git/objects/<span class="built_in">hash</span>[0, 2]/<span class="built_in">hash</span>[2, 40]</span><br></pre></td></tr></table></figure><p>这里就产生了一个疑问：为什么Git要这么设计目录结构，而不直接用Git对象的40位hash作为文件名？原因是有两点：</p><ol><li><p>有些文件系统对目录下的文件数量有限制。例如，FAT32限制单目录下的最大文件数量是65535个，如果使用U盘拷贝Git文件就可能出现问题。</p></li><li><p>有些文件系统访问文件是一个线性查找的过程，目录下的文件越多，访问越慢。</p></li></ol><p>在<code>Git对象哈希</code>小节中，我们知道Git对象会在原内容前加个一个头部：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store = header + content</span><br></pre></td></tr></table></figure><p>Git对象在存储前，会使用zlib的deflate算法进行压缩，即简要描述为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zlib_store = zlib.deflate(store)</span><br></pre></td></tr></table></figure><p>压缩后的<code>zlib_store</code>按照Git对象的路径规则存储到<code>.git/objects</code>目录下。</p><p>总结下Git对象存储的算法步骤：</p><ol><li><p>计算<code>content</code>长度，构造<code>header</code>;</p></li><li><p>将<code>header</code>添加到<code>content</code>前面，构造Git对象；</p></li><li><p>使用sha1算法计算Git对象的40位hash码；</p></li><li><p>使用zlib的deflate算法压缩Git对象；</p></li><li><p>将压缩后的Git对象存储到<code>.git/objects/hash[0, 2]/hash[2, 40]</code>路径下;</p></li></ol><h3 id="Nodejs实现"><a href="#Nodejs实现" class="headerlink" title="Nodejs实现"></a>Nodejs实现</h3><p>接下来，我们使用Nodejs来实现<code>git hash-object -w</code>的功能，即计算Git对象的hash值并存储到Git文件系统中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(<span class="string">'fs'</span>)</span><br><span class="line">const crypto = require(<span class="string">'crypto'</span>)</span><br><span class="line">const zlib = require(<span class="string">'zlib'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> gitHashObject(content, <span class="built_in">type</span>) &#123;</span><br><span class="line">  // 构造header</span><br><span class="line">  const header = `<span class="variable">$&#123;type&#125;</span> <span class="variable">$&#123;Buffer.from(content).length&#125;</span>\0`</span><br><span class="line"></span><br><span class="line">  // 构造Git对象</span><br><span class="line">  const store = Buffer.concat([Buffer.from(header), Buffer.from(content)])</span><br><span class="line"></span><br><span class="line">  // 计算<span class="built_in">hash</span></span><br><span class="line">  const sha1 = crypto.createHash(<span class="string">'sha1'</span>)</span><br><span class="line">  sha1.update(store)</span><br><span class="line">  const <span class="built_in">hash</span> = sha1.digest(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">  // 压缩Git对象</span><br><span class="line">  const zlib_store = zlib.deflateSync(store)</span><br><span class="line"></span><br><span class="line">  // 存储Git对象</span><br><span class="line">  fs.mkdirSync(`.git/objects/<span class="variable">$&#123;hash.substring(0, 2)&#125;</span>`)</span><br><span class="line">  fs.writeFileSync(`.git/objects/<span class="variable">$&#123;hash.substring(0, 2)&#125;</span>/<span class="variable">$&#123;hash.substring(2, 40)&#125;</span>`, zlib_store)</span><br><span class="line"></span><br><span class="line">  console.log(<span class="built_in">hash</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用入口</span><br><span class="line">gitHashObject(process.argv[2], process.argv[3])</span><br></pre></td></tr></table></figure><p>最后，测试下能否正确存储Git对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js <span class="string">'hello, world'</span> blob</span><br><span class="line">8c01d89ae06311834ee4b1fab2f0414d35f01102</span><br><span class="line">$ git cat-file -p 8c01d89ae06311834ee4b1fab2f0414d35f01102</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>由此可见，我们生成了一个合法的Git数据对象，证明算法是正确的。</p><h2 id="Git引用"><a href="#Git引用" class="headerlink" title="Git引用"></a>Git引用</h2><p>首先来搞清楚什么是Git引用，前文讲了Git提交对象的哈希、存储原理，理论上我们只要知道该对象的hash值，就能往前推出整个提交历史，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</span><br><span class="line">3ac728ac62f0a7b5ac201fd3ed1f69165df8be31 third commit</span><br><span class="line">d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c second commit</span><br><span class="line">db1d6f137952f2b24e3c85724ebd7528587a067a first commit</span><br></pre></td></tr></table></figure><p>现在问题来了，提交对象的这40位hash值不好记忆，Git引用相当于给40位hash值取一个别名，便于识别和读取。<strong>Git引用对象都存储在<code>.git/refs</code>目录下，该目录下有3个子文件夹<code>heads</code>、<code>tags</code>和<code>remotes</code>，分别对应于HEAD引用、标签引用和远程引用</strong>，下面分别讲一讲每种引用的原理。</p><h3 id="HEAD引用"><a href="#HEAD引用" class="headerlink" title="HEAD引用"></a>HEAD引用</h3><p><strong>HEAD引用是用来指向每个分支的最后一次提交对象</strong>，这样切换到一个分支之后，才能知道分支的“尾巴”在哪里。<strong>HEAD引用存储在<code>.git/refs/heads</code>目录下</strong>，有多少个分支，就有相应的同名HEAD引用对象。例如代码库里面有<code>master</code>和<code>test</code>两个分支，那么<code>.git/refs/heads</code>目录下就存在<code>master</code>和<code>test</code>两个文件，分别记录了分支的最后一次提交。</p><p>HEAD引用的内容就是提交对象的hash值，理论上我们可以手动地构造一个HEAD引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"3ac728ac62f0a7b5ac201fd3ed1f69165df8be31"</span> &gt; .git/refs/heads/master</span><br></pre></td></tr></table></figure><p>Git提供了一个专有命令<code>update-ref</code>，用来查看和修改Git引用对象，当然也包括HEAD引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/heads/master 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</span><br><span class="line">$ git update-ref refs/heads/master</span><br><span class="line">3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</span><br></pre></td></tr></table></figure><p>上面的命令我们将<code>master</code>分支的HEAD指向了<code>3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</code>，现在用<code>git log</code>查看下<code>master</code>的提交历史，可以发现最后一次提交就是所更新的hash值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline master</span><br><span class="line">3ac728ac62f0a7b5ac201fd3ed1f69165df8be31 (HEAD -&gt; master) third commit</span><br><span class="line">d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c second commit</span><br><span class="line">db1d6f137952f2b24e3c85724ebd7528587a067a first commit</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>HEAD -&gt; master</code>表示当前整个代码库级别的HEAD引用为master分支。具体含义请往下看。</p></blockquote><p>同理，可以使用同样的方法更新<code>test</code>分支的HEAD：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/heads/<span class="built_in">test</span> d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c</span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline <span class="built_in">test</span></span><br><span class="line">d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c (<span class="built_in">test</span>) second commit</span><br><span class="line">db1d6f137952f2b24e3c85724ebd7528587a067a first commit</span><br></pre></td></tr></table></figure><blockquote><p>若当前整个代码库级别的HEAD引用为test分支，则会显示<code>(HEAD -&gt; test)</code>。</p></blockquote><p><code>.git/refs/heads</code>目录下存储了每个分支的HEAD，那怎么知道代码库当前处于哪个分支呢？这就需要一个代码库级别的HEAD引用。<strong><code>.git/HEAD</code>这个文件就是整个代码库级别的HEAD引用</strong>。我们先查看一下<code>.git/HEAD</code>文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>我们发现<code>.git/HEAD</code>文件的内容不是40位hash值，而像是指向<code>.git/refs/heads/master</code>。尝试切换到<code>test</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="built_in">test</span></span><br><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>切换分支后，<code>.git/HEAD</code>文件的内容也跟着指向<code>.git/refs/heads/test</code>。<code>.git/HEAD</code>也是HEAD引用对象，与一般引用不同的是，它是“符号引用”。符号引用类似于文件的快捷方式，链接到要引用的对象上。</p><p>Git提供专门的命令<code>git symbolic-ref</code>，用来查看和更新符号引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git symbolic-ref HEAD refs/heads/master</span><br><span class="line">$ git symbolic-ref HEAD refs/heads/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>至此，我们分析了两种HEAD引用，一种是分支级别的HEAD引用，用来记录各分支的最后一次提交，存储在<code>.git/refs/heads</code>目录下，使用<code>git update-ref</code>来维护；一种是代码库级别的HEAD引用，用来记录代码库所处的分支，存储在<code>.git/HEAD</code>文件，使用<code>git symbolic-ref</code>来维护。</p><h3 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h3><p>标签引用，顾名思义就是给Git对象打标签，便于记忆。例如，我们可以将某个提交对象打v1.0标签，表示是1.0版本。标签引用都存储在<code>.git/refs/tags</code>里面。</p><p>标签引用和HEAD引用本质是Git引用对象，同样使用<code>git update-ref</code>来查看和修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/tags/v1.0 d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c</span><br><span class="line">$ cat .git/refs/tags/v1.0</span><br><span class="line">d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c</span><br></pre></td></tr></table></figure><p>还有一种标签引用称为“附注引用”，可以为标签添加说明信息。上面的标签引用打了一个<code>v1.0</code>的标签表示发布1.0版本，有时候发布软件的时候除了版本号信息，还要写更新说明。附注引用就是用来实现打标签的同时，也可以附带说明信息。</p><p>附注引用是怎么实现的呢？与常规标签引用不同的是，它不直接指向提交对象，而是新建一个Git对象存储到<code>.git/objects</code>中，用来记录附注信息，然后附注标签指向这个Git对象。</p><p>使用<code>git tag</code>建立一个附注标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31 -m <span class="string">"test tag"</span></span><br><span class="line">$ cat .git/refs/tags/v1.1</span><br><span class="line">8be4d8e4e8e80711dd7bae304ccfa63b35a6eb8c</span><br></pre></td></tr></table></figure><p>使用<code>git cat-file</code>来查看附注标签所指向的Git对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 8be4d8e4e8e80711dd7bae304ccfa63b35a6eb8c</span><br><span class="line">object 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</span><br><span class="line"><span class="built_in">type</span> commit</span><br><span class="line">tag v1.1</span><br><span class="line">tagger jingsam &lt;jing-sam@qq.com&gt; 1529481368 +0800</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> tag</span><br></pre></td></tr></table></figure><p>可以看到，上面的Git对象存储了我们填写的附注信息。</p><p>总之，普通的标签引用和附注引用同样都是存储的是40位hash值，指向一个Git对象，所不同的是普通的标签引用是直接指向提交对象，而附注标签是指向一个附注对象，附注对象再指向具体的提交对象。</p><p>另外，本质上标签引用并不是只可以指向提交对象，实际上可以指向任何Git对象，即可以给任何Git对象打标签。</p><h3 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h3><p>远程引用，类似于<code>.git/refs/heads</code>中存储的本地仓库各分支的最后一次提交，在<code>.git/refs/remotes</code>是用来记录多个远程仓库各分支的最后一次提交。</p><p>我们可以使用<code>git remote</code>来管理远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:jingsam/git-test.git</span><br></pre></td></tr></table></figure><p>上面添加了一个<code>origin</code>远程链接，接下来我们把本地仓库的<code>master</code>推送到远程仓库上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (9/9), 720 bytes | 360.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:jingsam/git-test.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><p>这时候在<code>.git/refs/remotes</code>中的远程引用就会更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/remotes/origin/master</span><br><span class="line">3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</span><br></pre></td></tr></table></figure><p>和本地仓库的<code>master</code>比较一下，发现是一模一样的，表示远程分支和本地分支是同步的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">3ac728ac62f0a7b5ac201fd3ed1f69165df8be31</span><br></pre></td></tr></table></figure><p>由于远程引用也是Git引用对象，所以理论上也可以使用<code>git update-ref</code>来手动维护。但是，我们需要先把代码与远程仓库进行同步，在远程仓库中找到对应分支的HEAD，然后使用<code>git update-ref</code>进行更新，过程比较麻烦。而我们在执行<code>git pull</code>或<code>git push</code>这样的高层命令的时候，远程引用会自动更新。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>到这里，三种Git引用都已分析完毕。总的来说，三种Git引用都统一存储到<code>.git/refs</code>目录下，Git引用中的内容都是40位的hash值，指向某个Git对象，这个对象可以是任意的Git对象，可以是数据对象、树对象、提交对象。三种Git引用都可以使用<code>git update-ref</code>来手动维护。</p><p>三种Git引用对象所不同的是，分别存储于<code>.git/refs/heads</code>、<code>.git/refs/tags</code>、<code>.git/refs/remotes</code>，存储的文件夹不同，赋予了引用对象不同的功能。<strong>HEAD引用用来记录本地各个分支的最后一次提交，标签引用用来给任意Git对象打标签，远程引用正式用来记录远程各个分支的最后一次提交。</strong></p><h2 id="git文件夹"><a href="#git文件夹" class="headerlink" title=".git文件夹"></a>.git文件夹</h2><p>新建一个git仓库，新建一个<code>a.py</code>，第一次提交<code>add a.py</code>后，<code>.git</code>文件夹如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── fsmonitor-watchman.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── pre-merge-commit.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   ├── pre-receive.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── push-to-checkout.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── b4</span><br><span class="line">│   │   └── 615222fc0906f8bbd5a2f6c86824ed7cdff6be</span><br><span class="line">│   ├── c2</span><br><span class="line">│   │   └── e5936fe3786bc72d6bf8f7278f733571c09e48</span><br><span class="line">│   ├── ed</span><br><span class="line">│   │   └── 0a1ffd4b9ad6c8d2dd687ebd30762087cec86e</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure><h3 id="COMMIT-EDITMSG"><a href="#COMMIT-EDITMSG" class="headerlink" title="COMMIT_EDITMSG"></a>COMMIT_EDITMSG</h3><p>COMMIT-EDITMSG是一个临时文件，存储最后一次提交的message，当敲入<code>git commit</code>命令，不加<code>-m</code>的话， 会打开编辑器，其实就是在编辑此文件，而你退出编辑器后，git 会把此文件内容写入 commit 记录。 而执行<code>git commit -m &#39;add a.py&#39;</code>时，<code>add a.py</code>就是COMMIT_EDITMSG的文件内容。</p><p>例如打开文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add a.py</span><br></pre></td></tr></table></figure><p>该文件的一个应用场景：当你git pull 远程仓库后，新增了很多提交，淹没了本地提交记录，直接 <code>cat .git/COMMIT_EDITMSG</code> 就可以弄清楚自己最后工作的位置了。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>整个代码库级别的HEAD引用，也就是当前位于哪个分支。打开内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p><code>config</code> 文件包含项目特有的配置选项。</p><p>Git配置分为三个级别：</p><ol><li>系统级别：system。</li><li>全局级别（用户级别）：global。</li><li>本地级别：local。</li></ol><p>本地级别的配置信息，就记录在<code>config</code> 文件中，使用<code>git config --local</code>或<code>git config 不加任何参数</code>命令进行配置。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">	repositoryformatversion = 0</span><br><span class="line">	filemode = false</span><br><span class="line">	bare = false</span><br><span class="line">	logallrefupdates = true</span><br><span class="line">	symlinks = false</span><br><span class="line">	ignorecase = true</span><br></pre></td></tr></table></figure><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>仓库的描述信息。打开文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unnamed repository; edit this file <span class="string">'description'</span> to name the repository.</span><br></pre></td></tr></table></figure><p>说明：该文件仅供 GitWeb (Github 的一种前身) 程序使用，我们无需关心。</p><h3 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>和其它版本控制系统一样，Git 能在特定的重要动作发生时，触发自定义脚本（钩子脚本）。这些被称为钩子的脚本可以在提交 (commit)、变基 (rebase)、拉取 ( pull ) 操作的前后运行。脚本名预示着它的执行时机。如我们可以编写 pre-push 的作为钩子，进行推送代码前的检查。</p><p>钩子分为：客户端的钩子和服务器端的钩子。客户端钩子由提交和合并这样的操作所调用，而服务器端钩子作用于接收被推送的提交这样的联网操作。</p><p>当你用 <code>git init</code> 命令初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本都是 shell 脚本，其中一些还混杂了 Perl 代码。你可以使用任何你熟悉的语言编写Git钩子脚本，如Ruby 或 Python等编写的可执行脚本，都可以正常使用。比如打开<code>hooks/pre-push.sample</code>，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">remote=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">url=<span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line"></span><br><span class="line">zero=$(git <span class="built_in">hash</span>-object --stdin &lt;/dev/null | tr <span class="string">'[0-9a-f]'</span> <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> local_ref local_oid remote_ref remote_oid</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">test</span> <span class="string">"<span class="variable">$local_oid</span>"</span> = <span class="string">"<span class="variable">$zero</span>"</span></span><br><span class="line">	<span class="keyword">then</span></span><br><span class="line">		<span class="comment"># Handle delete</span></span><br><span class="line">		:</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">test</span> <span class="string">"<span class="variable">$remote_oid</span>"</span> = <span class="string">"<span class="variable">$zero</span>"</span></span><br><span class="line">		<span class="keyword">then</span></span><br><span class="line">			<span class="comment"># New branch, examine all commits</span></span><br><span class="line">			range=<span class="string">"<span class="variable">$local_oid</span>"</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment"># Update to existing branch, examine new commits</span></span><br><span class="line">			range=<span class="string">"<span class="variable">$remote_oid</span>..<span class="variable">$local_oid</span>"</span></span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># Check for WIP commit</span></span><br><span class="line">		commit=$(git rev-list -n 1 --grep <span class="string">'^WIP'</span> <span class="string">"<span class="variable">$range</span>"</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">"<span class="variable">$commit</span>"</span></span><br><span class="line">		<span class="keyword">then</span></span><br><span class="line">			<span class="built_in">echo</span> &gt;&amp;2 <span class="string">"Found WIP commit in <span class="variable">$local_ref</span>, not pushing"</span></span><br><span class="line">			<span class="built_in">exit</span> 1</span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>将编写好的可执行脚本（不带扩展名），放入 <code>.git</code> 目录下的 <code>hooks</code> 子目录中，即可激活该钩子脚本。</p><ol><li><p><code>pre-commit</code> 钩子：在创建提交信息前运行，它用于检查即将提交的快照。例如，检查是否有所遗漏，确保测试运行，以及核查代码。</p><p>如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 <code>git commit --no-verify</code> 来绕过这个环节。</p><p>你可以利用该钩子，来检查代码风格是否一致、尾随空白字符是否存在，或新方法的文档是否适当等操作。</p></li><li><p><code>commit-msg</code> 钩子：接收一个参数，此参数存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。</p></li><li><p><code>post-commit</code> 钩子：在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 <code>git log -1 HEAD</code> 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情。</p></li></ol><p>这里只简单介绍三个<code>hooks</code>目录中的钩子脚本，如果想查看更多钩子示例脚本说明，可以查看<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90#_git_hooks" target="_blank" rel="noopener">Git 钩子</a>，简略信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -F1：在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"，1代表一个文件占据一行。</span></span><br><span class="line">$ ls -F1 hooks</span><br><span class="line">prepare-commit-msg.sample*  <span class="comment"># git commit 之前，编辑器启动之前触发，传入 COMMIT_FILE，COMMIT_SOURCE，SHA1</span></span><br><span class="line">commit-msg.sample*          <span class="comment"># git commit 之前，编辑器退出后触发，传入 COMMIT_EDITMSG 文件名</span></span><br><span class="line">pre-commit.sample*          <span class="comment"># git commit 之前，commit-msg 通过后触发，譬如校验文件名是否含中文</span></span><br><span class="line">pre-push.sample*            <span class="comment"># git push 之前触发</span></span><br><span class="line"></span><br><span class="line">pre-receive.sample*         <span class="comment"># git push 之后，服务端更新 ref 前触发</span></span><br><span class="line">update.sample*              <span class="comment"># git push 之后，服务端更新每一个 ref 时触发，用于针对每个 ref 作校验等</span></span><br><span class="line">post-update.sample*         <span class="comment"># git push 之后，服务端更新 ref 后触发</span></span><br><span class="line"></span><br><span class="line">pre-rebase.sample*          <span class="comment"># git rebase 之前触发，传入 rebase 分支作参数</span></span><br><span class="line">applypatch-msg.sample*      <span class="comment"># 用于 git am 命令提交信息校验</span></span><br><span class="line">pre-applypatch.sample*      <span class="comment"># 用于 git am 命令执行前动作</span></span><br><span class="line">fsmonitor-watchman.sample*  <span class="comment"># 配合 core.fsmonitor 设置来更好监测文件变化</span></span><br></pre></td></tr></table></figure><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p><code>index</code>文件：该文件就是我们平时说的 <strong>暂存区</strong> （stage），是一个二进制文件，保存了下次将提交的文件列表信息，我们执行<code>git add</code>命令后，这个文件就会更新刚刚添加的文件信息。</p><p>我们可以使用<code>git ls-files --stage</code>命令看到当前仓库中每一个文件及其所对应的文件对象。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  git ls-files --stage     </span><br><span class="line">100644 4d91c814eb85fd49d32441ef1d4e7aa921e59374 0       .gitignore</span><br></pre></td></tr></table></figure><p>提示：刚刚初始化的Git本地版本库中是没有<code>index</code>文件的，只有执行一次暂存操作后，才在<code>.git</code>目录自动生成<code>index</code>文件。</p><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p><code>info</code> 目录包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 <code>.gitignore</code> 文件中的忽略模式（ignored patterns），它不会影响到其他人，也不会提交到版本库中去。<code>.gitignore</code> 文件会被提交到版本库。</p><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>此文件夹主要记录每个分支的每次修改的日志。比如说<code>logs/refs/heads/master</code>内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000000000000000000000000000 ed0a1ffd4b9ad6c8d2dd687ebd30762087cec86e zdaiot &lt;zdaiot@163.com&gt; 1685004210 +0800	commit (initial): add a.py</span><br></pre></td></tr></table></figure><p>打开logs文件夹可以看到其中有两个文件，<code>refs</code>文件夹和<code>HEAD</code>文件。</p><h4 id="HEAD文件"><a href="#HEAD文件" class="headerlink" title="HEAD文件"></a>HEAD文件</h4><p>HEAD文件保存的是，所有的引起HEAD指针移动的操作记录，使用<code>git reflog</code>命令，查询的结果就是来自这个文件。</p><h4 id="refs目录"><a href="#refs目录" class="headerlink" title="refs目录"></a>refs目录</h4><p><code>refs</code>文件夹中有两个文件夹：<code>heads</code>目录和<code>remotes</code>目录。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v                                                            </span><br><span class="line">group   xxxx.git (fetch)</span><br><span class="line">group   xxxx.git (push)</span><br><span class="line">origin  yyyy.git (fetch)</span><br><span class="line">origin  yyyy.git (push)</span><br><span class="line"></span><br><span class="line">$ tree .git/logs</span><br><span class="line">.</span><br><span class="line">├── HEAD</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   ├── develop</span><br><span class="line">    │   └── master</span><br><span class="line">    └── remotes</span><br><span class="line">        ├── group   <span class="comment"># 一个远程链接</span></span><br><span class="line">        │   ├── develop</span><br><span class="line">        │   └── master</span><br><span class="line">        └── origin  <span class="comment"># 另外一个远程链接</span></span><br><span class="line">            ├── develop</span><br><span class="line">            └── master</span><br></pre></td></tr></table></figure><ul><li><code>heads</code>目录中都是以分支命名的文件，即：每个文件名对应着本地版本库的一个分支。每个文件中，记录的都是该分支历史操作记录。</li><li><code>remotes</code>目录和<code>heads</code>目录的作用同理，只不过<code>remotes</code>目录中存储的是远程分支的历史操作记录。</li></ul><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>heads目录中所有分支历史操作记录的总和，是HEAD文件文件的内容。</p><p>例如版本库中有两个分支，分别查看他们历史操作记录，我们可以看到，<code>master</code>分支和<code>dev</code>分支的历史操作记录总和，就是HEAD文件中的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查看master分支的历史操作记录</span></span><br><span class="line">L@DESKTOP-T2AI2SU MINGW64 /j/git-repository/git_learning (dev)</span><br><span class="line">$ cat .git/logs/refs/heads/master</span><br><span class="line">0000000000000000000000000000000000000000 f58d840994fe43cf8cdf8fe036dbadb393b7df62 sun_wk &lt;sun_wk@126.com&gt; 1619073338 +0800      commit (initial): 第1次提交</span><br><span class="line">f58d840994fe43cf8cdf8fe036dbadb393b7df62 d6f67eeefe7e0d49cdaf6cadb50d219e9b0d5674 sun_wk &lt;sun_wk@126.com&gt; 1619073495 +0800      commit: 第2次提交</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看dev分支的历史操作记录</span></span><br><span class="line">L@DESKTOP-T2AI2SU MINGW64 /j/git-repository/git_learning (dev)</span><br><span class="line">$ cat .git/logs/refs/heads/dev</span><br><span class="line">0000000000000000000000000000000000000000 d6f67eeefe7e0d49cdaf6cadb50d219e9b0d5674 sun_wk &lt;sun_wk@126.com&gt; 1619073563 +0800      branch: Created from HEAD</span><br><span class="line">d6f67eeefe7e0d49cdaf6cadb50d219e9b0d5674 d00abd3a31bfa95cc88e1fb2df21421b2d3743a9 sun_wk &lt;sun_wk@126.com&gt; 1619073598 +0800      commit: 第3次提交</span><br><span class="line">d00abd3a31bfa95cc88e1fb2df21421b2d3743a9 9ec0e8f8a861d8da31427f0508aa4c00d3242988 sun_wk &lt;sun_wk@126.com&gt; 1619073751 +0800      commit: 第4次提交</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看HEAD文件的历史操作记录。</span></span><br><span class="line">L@DESKTOP-T2AI2SU MINGW64 /j/git-repository/git_learning (dev)</span><br><span class="line">$ cat .git/logs/HEAD</span><br><span class="line">0000000000000000000000000000000000000000 f58d840994fe43cf8cdf8fe036dbadb393b7df62 sun_wk &lt;sun_wk@126.com&gt; 1619073338 +0800      commit (initial): 第1次提交</span><br><span class="line">f58d840994fe43cf8cdf8fe036dbadb393b7df62 d6f67eeefe7e0d49cdaf6cadb50d219e9b0d5674 sun_wk &lt;sun_wk@126.com&gt; 1619073495 +0800      commit: 第2次提交</span><br><span class="line">d6f67eeefe7e0d49cdaf6cadb50d219e9b0d5674 d6f67eeefe7e0d49cdaf6cadb50d219e9b0d5674 sun_wk &lt;sun_wk@126.com&gt; 1619073563 +0800      checkout: moving from master to dev</span><br><span class="line">d6f67eeefe7e0d49cdaf6cadb50d219e9b0d5674 d00abd3a31bfa95cc88e1fb2df21421b2d3743a9 sun_wk &lt;sun_wk@126.com&gt; 1619073598 +0800      commit: 第3次提交</span><br><span class="line">d00abd3a31bfa95cc88e1fb2df21421b2d3743a9 9ec0e8f8a861d8da31427f0508aa4c00d3242988 sun_wk &lt;sun_wk@126.com&gt; 1619073751 +0800      commit: 第4次提交</span><br></pre></td></tr></table></figure><h3 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h3><p>详细可以看前文<code>Git对象如何存储</code>小节。我们这里只介绍pack和info文件夹。</p><p>Git 往磁盘保存对象时默认使用的格式叫松散对象 (loose object) 格式，当你对同一个文件修改哪怕一行，git 都会使用全新的文件存储这个修改了的文件，放在了objects中。Git 时不时地将这些对象打包至一个叫 packfile 的二进制文件以节省空间并提高效率，当版本库中有太多的松散对象，或者你手动执行 <code>git gc</code> 命令，或者你向远程服务器执行推送时，Git 都会这样做。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -<span class="built_in">type</span> f</span><br><span class="line">.git/objects/6d/c700c37fb6af03239b8ea6f1d58db1a8819464</span><br><span class="line"></span><br><span class="line">$ git gc</span><br><span class="line">Enumerating objects: 1, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line"></span><br><span class="line">$ find .git/objects -<span class="built_in">type</span> f</span><br><span class="line">.git/objects/info/packs</span><br><span class="line">.git/objects/pack/pack-d9059144205ae43ab3472bebfd7976a8f52de3c2.idx</span><br><span class="line">.git/objects/pack/pack-d9059144205ae43ab3472bebfd7976a8f52de3c2.pack</span><br><span class="line"></span><br><span class="line">$ cat .git/objects/info/packs</span><br><span class="line">P pack-d9059144205ae43ab3472bebfd7976a8f52de3c2.pack</span><br></pre></td></tr></table></figure><p>这里只有6d一个文件夹，已经成功打包到pack里了，即使有很多很多文件对象，执行 git gc 后都会全部打包到 pack 里。.pack 存储对象文件，.idx 是索引文件，用于允许它们被随机访问；info 文件夹记录对象存储的附加信息，这里存储着打包后的文件名。</p><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p>详细可以看前文<code>Git引用小节</code></p><h3 id="packed-refs"><a href="#packed-refs" class="headerlink" title="packed-refs"></a>packed-refs</h3><p>前面有提过<code>git gc</code>会打包objects，其实它会做的另一件事是打包你的引用到一个单独的文件。 假设你的仓库包含以下分支与标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/refs -<span class="built_in">type</span> f</span><br><span class="line">.git/refs/heads/experiment</span><br><span class="line">.git/refs/heads/master</span><br><span class="line">.git/refs/tags/v1.0</span><br><span class="line">.git/refs/tags/v1.1</span><br></pre></td></tr></table></figure><p>如果你执行了 <code>git gc</code> 命令，<code>refs</code> 目录中将不会再有这些文件。 为了保证效率 Git 会将它们移动到名为 <code>.git/packed-refs</code> 的文件中，就像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/packed-refs</span><br><span class="line"><span class="comment"># pack-refs with: peeled fully-peeled</span></span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment</span><br><span class="line">ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0</span><br><span class="line">9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1</span><br><span class="line">^1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure><p><strong>如果你更新了引用，Git 并不会修改这个文件，而是向 <code>refs/heads</code> 创建一个新的文件</strong>。 为了获得指定引用的正确 SHA-1 值，<strong>Git 会首先在 <code>refs</code> 目录中查找指定的引用，然后再到 <code>packed-refs</code> 文件中查找</strong>。 所以，如果你在 <code>refs</code> 目录中找不到一个引用，那么它或许在 <code>packed-refs</code> 文件中。</p><p>注意这个文件的最后一行，它会以 <code>^</code> 开头。 这个符号表示它上一行的标签是tag标签，<code>^</code> 所在的那一行是tag标签指向的那个提交。</p><p>最后，值得注意的是，<code>.git/packed-refs</code>中关于refs的内容并不是固定的。直接<code>git clone</code>的可能含有<code>refs/remotes/origin/xxx</code>与<code>refs/tags/xxx</code>，而<code>git clone --mirror</code>得到的bare仓库，可能含有<code>refs/heads/xxx</code>与<code>refs/tags/xxx</code>。具体情况可以直接查看该文件的内容。</p><h2 id="与-的区别"><a href="#与-的区别" class="headerlink" title="~与^的区别"></a>~与^的区别</h2><p>波浪号<code>~</code>，英文名叫 <strong>tilde</strong>。脱字符<code>^</code>，英文名叫<strong>caret</strong>。那么关于这两个该怎么区分呢？</p><p>在<a href="https://stackoverflow.com/a/12527561/15304315" target="_blank" rel="noopener">What’s the difference between HEAD^ and HEAD~ in Git?</a>中介绍如下：</p><p><strong>Rules of thumb</strong></p><ul><li>Use <code>~</code> most of the time — to go back a number of generations, usually what you want</li><li>Use <code>^</code> on merge commits — because they have two or more (immediate) parents</li></ul><p><strong>Mnemonics:</strong></p><ul><li>Tilde <code>~</code> is almost linear in appearance and wants to go backward in a straight line</li><li>Caret <code>^</code> suggests an interesting segment of a tree or a fork in the road</li></ul><p>该如何理解呢？看如下例子。在该例子中，A、B、D、G位于同一个branch，D由G与H merge合并而来，所以<code>G=D^1</code>，G是D第一个parent；<code>H=D^2</code>，H是D的第二个parent。</p><p>B是A的当前分支所在时间线中的父节点，所以<code>B=A~1</code>；D是A在当前分支所在时间线中的父节点的父节点，所以<code>D=A~2</code>。</p><p><img src="/Tools/Git/git原理简介/pDAzG.png" alt="enter image description here" style="zoom:67%"></p><p>关于更详细的例子可以参考<a href="https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtltngtemegemHEADv1510em：" target="_blank" rel="noopener">https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtltngtemegemHEADv1510em：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">G   H   I   J</span><br><span class="line"> \ /     \ /</span><br><span class="line">  D   E   F</span><br><span class="line">   \  |  / \</span><br><span class="line">    \ | /   |</span><br><span class="line">     \|/    |</span><br><span class="line">      B     C</span><br><span class="line">       \   /</span><br><span class="line">        \ /</span><br><span class="line">         A</span><br><span class="line"></span><br><span class="line">A =      = A^0</span><br><span class="line">B = A^   = A^1     = A~1</span><br><span class="line">C =      = A^2</span><br><span class="line">D = A^^  = A^1^1   = A~2</span><br><span class="line">E = B^2  = A^^2</span><br><span class="line">F = B^3  = A^^3</span><br><span class="line">G = A^^^ = A^1^1^1 = A~3</span><br><span class="line">H = D^2  = B^^2    = A^^^2  = A~2^2</span><br><span class="line">I = F^   = B^3^    = A^^3^</span><br><span class="line">J = F^2  = B^3^2   = A^^3^2</span><br></pre></td></tr></table></figure><h2 id="SSH与HTTPS区别"><a href="#SSH与HTTPS区别" class="headerlink" title="SSH与HTTPS区别"></a>SSH与HTTPS区别</h2><p>git可以使用四种主要的协议来传输资料: 本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 git 协议。其中，本地协议由于目前大都是进行远程开发和共享代码所以一般不常用，而git协议由于缺乏授权机制且较难架设所以也不常用。</p><p>最常用的便是SSH和HTTP(S)协议。git关联远程仓库可以使用http协议或者ssh协议。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>ssh：</strong></p><ul><li>一般使用22端口；</li><li>通过先在本地生成SSH密钥对再把公钥上传到服务器；</li><li>速度相较慢点</li></ul><p><strong>https：</strong></p><ul><li>一般使用443端口；</li><li>通过用户名/密码授权，可用性比较高；</li><li>速度相较快点</li></ul><p>一般企业防火墙会打开80和443这两个http/https协议的端口，因此在架设了企业防火墙的时候使用http就可以很好的绕开安全限制使用git了，很方便；而对于ssh来说，企业防火墙很可能没打开22端口。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>clone项目：</strong></p><ul><li>使用ssh方式时，需要配置ssh key，即要将生成的SSH密钥对的公钥上传至服务器；</li><li>使用https方式时，没有要求，可以直接克隆下来。</li></ul><blockquote><p>当clone public仓库时，若没有上传本地ssh key，则无法通过ssh clone仓库。</p></blockquote><p><strong>push项目</strong>（前提是你有这个仓库的push权限）：</p><ul><li><p>使用ssh方式时，不需要验证用户名和密码，之前配置过ssh key(如果你没设置密码)，直接push即可；</p></li><li><p>使用https方式时，需要验证用户名和密码。</p></li></ul><p><strong>总结：</strong></p><ul><li><p>HTTPS利于匿名访问，适合开源项目，可以方便被别人克隆和读取(但没有push权限)；</p></li><li><p>SSH不利于匿名访问，比较适合内部项目，只要配置了SSH公钥极可自由实现clone和push操作。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/a/12527561/15304315" target="_blank" rel="noopener">What’s the difference between HEAD^ and HEAD~ in Git?</a><br><a href="https://stackoverflow.com/a/29120883/15304315" target="_blank" rel="noopener">What’s the difference between HEAD^ and HEAD~ in Git?</a><br><a href="https://www.cnblogs.com/wannananana/p/12059806.html" target="_blank" rel="noopener">【git】git中使用https和ssh协议的区别以及它们的用法</a><br><a href="https://jingsam.github.io/2018/06/03/git-objects.html" target="_blank" rel="noopener">Git内部原理之Git对象</a><br><a href="https://jingsam.github.io/2018/06/15/git-storage.html" target="_blank" rel="noopener">Git内部原理之Git对象存储</a><br><a href="https://jingsam.github.io/2018/06/09/git-hash.html" target="_blank" rel="noopener">Git内部原理之Git对象哈希</a><br><a href="https://jingsam.github.io/2018/10/12/git-reference.html" target="_blank" rel="noopener">Git内部原理之Git引用</a><br><a href="https://www.jianshu.com/p/4cc3959dd6c2" target="_blank" rel="noopener">【学了就忘】Git原理 — 58.详解.git目录（二）</a><br><a href="https://www.jianshu.com/p/23012e3f9519" target="_blank" rel="noopener">【学了就忘】Git原理 — 57.详解.git目录（一）</a><br><a href="https://zhuanlan.zhihu.com/p/106243588" target="_blank" rel="noopener">通过 .git 目录深入理解 Git！</a><br><a href="https://juejin.cn/post/7082011668984627213" target="_blank" rel="noopener">Git｜探寻Git如何管理文件版本的小秘密</a><br><a href="https://blog.csdn.net/start_mao/article/details/94609238" target="_blank" rel="noopener">Git——.git目录详解</a><br><a href="https://juejin.cn/post/6844903986839945229" target="_blank" rel="noopener">解析.git文件夹，深入了解git内部原理</a><br><a href="https://git-scm.com/book/en/v2/Git-Internals-Maintenance-and-Data-Recovery" target="_blank" rel="noopener">10.7 Git Internals - Maintenance and Data Recovery</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/Tools/Git/git原理简介/" title="git原理简介">https://www.zdaiot.com/Tools/Git/git原理简介/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/github/" rel="tag"><i class="fa fa-tag"></i> github</a><a href="/tags/git/" rel="tag"><i class="fa fa-tag"></i> git</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Linux/维护/bash属性、startup文件与history/" rel="prev" title="bash属性、startup文件与history"><i class="fa fa-chevron-left"></i> bash属性、startup文件与history</a></div><div class="post-nav-item"> <a href="/Linux/博客搭建/剖析 NPM 的包管理机制/" rel="next" title="剖析 NPM 的包管理机制">剖析 NPM 的包管理机制<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Git对象"><span class="nav-number">1.</span> <span class="nav-text">Git对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据对象"><span class="nav-number">1.1.</span> <span class="nav-text">数据对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树对象"><span class="nav-number">1.2.</span> <span class="nav-text">树对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提交对象"><span class="nav-number">1.3.</span> <span class="nav-text">提交对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git对象的hash方法"><span class="nav-number">2.</span> <span class="nav-text">Git对象的hash方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据对象-1"><span class="nav-number">2.1.</span> <span class="nav-text">数据对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树对象-1"><span class="nav-number">2.2.</span> <span class="nav-text">树对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提交对象-1"><span class="nav-number">2.3.</span> <span class="nav-text">提交对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git对象如何存储"><span class="nav-number">3.</span> <span class="nav-text">Git对象如何存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">3.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nodejs实现"><span class="nav-number">3.2.</span> <span class="nav-text">Nodejs实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git引用"><span class="nav-number">4.</span> <span class="nav-text">Git引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HEAD引用"><span class="nav-number">4.1.</span> <span class="nav-text">HEAD引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标签引用"><span class="nav-number">4.2.</span> <span class="nav-text">标签引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程引用"><span class="nav-number">4.3.</span> <span class="nav-text">远程引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git文件夹"><span class="nav-number">5.</span> <span class="nav-text">.git文件夹</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#COMMIT-EDITMSG"><span class="nav-number">5.1.</span> <span class="nav-text">COMMIT_EDITMSG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HEAD"><span class="nav-number">5.2.</span> <span class="nav-text">HEAD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#config"><span class="nav-number">5.3.</span> <span class="nav-text">config</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#description"><span class="nav-number">5.4.</span> <span class="nav-text">description</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hooks"><span class="nav-number">5.5.</span> <span class="nav-text">hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#介绍"><span class="nav-number">5.5.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举例说明"><span class="nav-number">5.5.2.</span> <span class="nav-text">举例说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#index"><span class="nav-number">5.6.</span> <span class="nav-text">index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#info"><span class="nav-number">5.7.</span> <span class="nav-text">info</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#logs"><span class="nav-number">5.8.</span> <span class="nav-text">logs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HEAD文件"><span class="nav-number">5.8.1.</span> <span class="nav-text">HEAD文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#refs目录"><span class="nav-number">5.8.2.</span> <span class="nav-text">refs目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#说明"><span class="nav-number">5.8.3.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objects"><span class="nav-number">5.9.</span> <span class="nav-text">objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#refs"><span class="nav-number">5.10.</span> <span class="nav-text">refs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#packed-refs"><span class="nav-number">5.11.</span> <span class="nav-text">packed-refs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与-的区别"><span class="nav-number">6.</span> <span class="nav-text">~与^的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSH与HTTPS区别"><span class="nav-number">7.</span> <span class="nav-text">SSH与HTTPS区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特点"><span class="nav-number">7.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用"><span class="nav-number">7.2.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">320</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">54</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">377</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2.5m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">37:18</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '9cd2455e8f2457270ac43343c733d03d',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>