<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="首先声明，本篇文章大部分内容来自于网络，具体参考在下面参考小节中给出，我只是将他们进行整理并加上自己的理解。 第一节主要介绍了矩阵向量求导的定义、分子分母布局以及常用的默认布局。第二节主要介绍了如何使用定义法求矩阵向量的导数。第三节主要介绍了如何使用微分法来求解标量对向量的求导，以及标量对矩阵的求导，该节包含了机器学习以及深度学习中的常见的求导过程。第四节主要介绍了矩阵向量求导链式法则，对于推导深"><meta name="keywords" content="矩阵导数"><meta property="og:type" content="article"><meta property="og:title" content="矩阵求导法则与性质"><meta property="og:url" content="https://www.zdaiot.com/Math/矩阵求导法则与性质/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="首先声明，本篇文章大部分内容来自于网络，具体参考在下面参考小节中给出，我只是将他们进行整理并加上自己的理解。 第一节主要介绍了矩阵向量求导的定义、分子分母布局以及常用的默认布局。第二节主要介绍了如何使用定义法求矩阵向量的导数。第三节主要介绍了如何使用微分法来求解标量对向量的求导，以及标量对矩阵的求导，该节包含了机器学习以及深度学习中的常见的求导过程。第四节主要介绍了矩阵向量求导链式法则，对于推导深"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2019-12-23T14:26:35.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="矩阵求导法则与性质"><meta name="twitter:description" content="首先声明，本篇文章大部分内容来自于网络，具体参考在下面参考小节中给出，我只是将他们进行整理并加上自己的理解。 第一节主要介绍了矩阵向量求导的定义、分子分母布局以及常用的默认布局。第二节主要介绍了如何使用定义法求矩阵向量的导数。第三节主要介绍了如何使用微分法来求解标量对向量的求导，以及标量对矩阵的求导，该节包含了机器学习以及深度学习中的常见的求导过程。第四节主要介绍了矩阵向量求导链式法则，对于推导深"><link rel="canonical" href="https://www.zdaiot.com/Math/矩阵求导法则与性质/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>矩阵求导法则与性质 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/Math/矩阵求导法则与性质/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 矩阵求导法则与性质<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/Math/矩阵求导法则与性质.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-11-25 17:12:26" itemprop="dateCreated datePublished" datetime="2018-11-25T17:12:26+08:00">2018-11-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-12-23 22:26:35" itemprop="dateModified" datetime="2019-12-23T22:26:35+08:00">2019-12-23</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>30k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>28 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>首先声明，本篇文章大部分内容来自于网络，具体参考在下面<code>参考</code>小节中给出，我只是将他们进行整理并加上自己的理解。</p><p>第一节主要介绍了矩阵向量求导的定义、分子分母布局以及常用的默认布局。第二节主要介绍了如何使用定义法求矩阵向量的导数。第三节主要介绍了如何使用微分法来求解标量对向量的求导，以及标量对矩阵的求导，该节包含了机器学习以及深度学习中的常见的求导过程。第四节主要介绍了矩阵向量求导链式法则，对于推导深度学习中的BP具有很大的帮助。而第五节主要介绍了矩阵对矩阵求导，这部分主要作为扩展内容，在机器学习领域很少用到。最后一节将常用的公式进行了总结，方便查阅。</p><p>介绍矩阵求导法则，以及常用的求导公式、迹函数、行列式求导结论。在介绍之前，我们对本文的符号统一一下：</p><ul><li>对于标量，统一用小写斜体字母表示，例如$f,x,y$</li><li>对于向量，统一用小写正体字母表示，例如$\mathrm y,\mathrm x$</li><li>对于矩阵，统一用大写正体字母表示，例如$\mathrm X$，矩阵的大小统一用 $m \times n$表示（$m$行$n$列矩阵）</li></ul><p>更进一步，为了便于描述，后面如果没有指明，则求导的自变量用$x$表示标量，$\mathrm{x}$表示n维向量，$\mathrm{X}$表示$m \times n$维度的矩阵，求导的因变量用$y$表示标量，$\mathrm{y}$表示m维向量，$\mathrm{Y}$表示$p \times q$维度的矩阵。</p><h2 id="求导定义与求导布局"><a href="#求导定义与求导布局" class="headerlink" title="求导定义与求导布局"></a>求导定义与求导布局</h2><h3 id="矩阵向量求导引入"><a href="#矩阵向量求导引入" class="headerlink" title="矩阵向量求导引入"></a>矩阵向量求导引入</h3><p>在高等数学里面，我们已经学过了标量对标量的求导，比如标量$y$对标量$x$的求导，可以表示为$\frac{\partial y}{\partial x}$。</p><p>有些时候，我们会有一组标量$y_i,i=1,2,…,m$来对一个标量$x$的求导,那么我们会得到一组标量求导的结果：$\frac{\partial y_i}{\partial x}, i=1,2.,,,m$。</p><p>如果我们把这组标量写成向量的形式，即得到维度为m的一个向量$\mathrm{y}$对一个标量$x$的求导，那么结果也是一个m维的向量：$\frac{\partial \mathrm{y}}{\partial x}$。</p><p>可见，所谓向量对标量的求导，其实就是向量里的每个分量分别对标量求导，最后把求导的结果排列在一起，按一个向量表示而已。类似的结论也存在于标量对向量的求导，向量对向量的求导，向量对矩阵的求导，矩阵对向量的求导，以及矩阵对矩阵的求导等。</p><p><strong>总而言之，所谓的向量矩阵求导本质上就是多元函数求导，仅仅是把把函数的自变量，因变量以及标量求导的结果排列成了向量矩阵的形式（当然这种排列是人为指定的），方便表达与计算，更加简洁而已。</strong></p><h3 id="矩阵向量求导定义"><a href="#矩阵向量求导定义" class="headerlink" title="矩阵向量求导定义"></a>矩阵向量求导定义</h3><p>根据求导的自变量和因变量是标量，向量还是矩阵，我们有9种可能的矩阵求导定义，如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">自变量\因变量</th><th style="text-align:center">标量$y$</th><th style="text-align:center">向量$\mathrm y$</th><th style="text-align:center">矩阵$\mathrm Y$</th></tr></thead><tbody><tr><td style="text-align:center">标量$x$</td><td style="text-align:center">$\frac{\partial y}{\partial x}$</td><td style="text-align:center">$\frac{\partial \mathrm{y}}{\partial x}$</td><td style="text-align:center">$\frac{\partial \mathrm{Y}}{\partial x}$</td></tr><tr><td style="text-align:center">向量$\mathrm x$</td><td style="text-align:center">$\frac{\partial y}{\partial \mathrm{x}}$</td><td style="text-align:center">$\frac{\partial \mathrm{y}}{\partial \mathrm{x}}$</td><td style="text-align:center">$\frac{\partial \mathrm{Y}}{\partial \mathrm{x}}$</td></tr><tr><td style="text-align:center">矩阵$\mathrm X$</td><td style="text-align:center">$\frac{\partial y}{\partial \mathrm{X}}$</td><td style="text-align:center">$\frac{\partial \mathrm{y}}{\partial \mathrm{X}}$</td><td style="text-align:center">$\frac{\partial \mathrm{Y}}{\partial \mathrm{X}}$</td></tr></tbody></table></div><p>这9种里面，标量对标量的求导高数里面就有，不需要我们单独讨论。</p><p>现在我们来看一个例子，维度为$m$的一个向量$\mathrm y$对一个标量$x$求导，那么结果也是一个$m$维的向量：$\frac{\partial \mathrm{y}}{\partial x}$。这是我们表格里面向量对标量求导的情况。这里有一个问题没有讲到，就是<strong>这个m维的求导结果排列成的m维向量到底应该是列向量还是行向量？</strong></p><p>这个问题的答案是：行向量或者列向量皆可！毕竟<strong>我们求导的本质只是把标量求导的结果排列起来，至于是按行排列还是按列排列都是可以的</strong>。但是这样也有问题，在我们机器学习算法法优化过程中，如果行向量或者列向量随便写，那么结果就不唯一，乱套了。</p><p>为了解决这个问题，我们引入求导布局的概念。</p><h3 id="分子布局与分母布局"><a href="#分子布局与分母布局" class="headerlink" title="分子布局与分母布局"></a>分子布局与分母布局</h3><p>为了解决矩阵向量求导的结果不唯一，我们引入求导布局。最基本的求导布局有两个：分子布局(numerator layout)和分母布局(denominator layout )。</p><p><strong>对于分子布局来说，我们求导结果的维度以分子为主，</strong>比如对于我们上面对标量求导的例子，结果的维度和分子的维度是一致的。也就是说，如果向量$\mathrm y$是一个$m$维列向量，那么求导结果$\frac{\partial \mathrm{y}}{\partial x}$也是一个$m$维列向量。如果向量$\mathrm y$是一个$m$为行向量，那么求导结果$\frac{\partial \mathrm{y}}{\partial x}$也是一个$m$维行向量。</p><p><strong>对于分母布局来说，我们求导结果的维度以分母为主，</strong>比如对于我们上面对标量求导的例子，如果向量$\mathrm y$是一个$m$维列向量，那么求导结果$\frac{\partial \mathrm{y}}{\partial x}$是一个$m$维行向量。如果向量$\mathrm y$是一个$m$为行向量，那么求导结果$\frac{\partial \mathrm{y}}{\partial x}$是一个$m$维列向量。</p><blockquote><p>上面例子中，分母是一个标量，维度就是1，按理说根本不存在以分子维度（因为标量只有一个维度）为主的因素。这里可以理解为此时以分子的转置为主。</p></blockquote><p>可见，对于分子布局和分母布局的结果来说，两者相差一个转置。</p><p><strong>再举一个例子，</strong>标量$y$对矩阵$ \mathrm{X}$求导，那么如果按分母布局，则求导结果的维度和矩阵$X$的维度$m \times n$是一致的。如果是分子布局，则求导结果的维度为$n \times m$。</p><p>这样，对于标量对向量或者矩阵求导，向量或者矩阵对标量求导这4种情况，对应的分子布局和分母布局的排列方式已经确定了。</p><p>稍微麻烦点的是向量对向量的求导，本文只讨论列向量对列向量的求导，其他的行向量求导只是差一个转置而已。比如$m$维列向量$\mathrm{y}$对$n$维列向量$\mathrm{x}$求导。它的求导结果在分子布局和分母布局各是什么呢？对于这2个向量求导，那么一共有$m \times n$个标量对标量的求导。求导的结果一般是排列为一个矩阵。<strong>如果是分子布局，则矩阵的第一个维度以分子为准</strong>，即结果是一个$m \times n$的矩阵，如下：</p><script type="math/tex;mode=display">
\frac{\partial  \mathrm{y}}{\partial \mathrm{x}} = \left( \begin{array}{ccc} \frac{\partial y_1}{\partial x_1}& \frac{\partial y_1}{\partial x_2}& \ldots & \frac{\partial y_1}{\partial x_n}\\  \frac{\partial y_2}{\partial x_1}& \frac{\partial y_2}{\partial x_2} & \ldots & \frac{\partial y_2}{\partial x_n}\\   \vdots&  \vdots &  \ddots & \vdots \\ \frac{\partial y_m}{\partial x_1}& \frac{\partial y_m}{\partial x_2} & \ldots & \frac{\partial y_m}{\partial x_n}  \end{array} \right)</script><p>上边这个按分子布局的向量对向量求导的结果矩阵，我们一般叫做<strong>雅克比 (Jacobian)矩阵</strong>。有的资料上会使用$ \frac{\partial \mathrm{y}}{\partial \mathrm{x^T}}$来定义雅克比矩阵，意义是一样的。</p><p><strong>如果是按分母布局，则求导的结果矩阵的第一维度会以分母为准</strong>，即结果是一个$n \times m$的矩阵，如下：</p><script type="math/tex;mode=display">
\frac{\partial  \mathrm{y}}{\partial \mathrm{x}} = \left( \begin{array}{ccc} \frac{\partial y_1}{\partial x_1}& \frac{\partial y_2}{\partial x_1}& \ldots & \frac{\partial y_m}{\partial x_1}\\  \frac{\partial y_1}{\partial x_2}& \frac{\partial y_2}{\partial x_2} & \ldots & \frac{\partial y_m}{\partial x_2}\\   \vdots&  \vdots &  \ddots & \vdots \\ \frac{\partial y_1}{\partial x_n}& \frac{\partial y_2}{\partial x_n} & \ldots & \frac{\partial y_m}{\partial x_n}  \end{array} \right)</script><p>上边这个按分母布局的向量对向量求导的结果矩阵，我们一般叫做<strong>梯度矩阵</strong>。有的资料上会使用$ \frac{\partial \mathrm{y^T}}{\partial \mathrm{x}}$来定义梯度矩阵，意义是一样的。</p><p>有了布局的概念，我们对于上面5种求导类型，可以各选择一种布局来求导。但是对于某一种求导类型，不能同时使用分子布局和分母布局求导。</p><p>但是在机器学习算法原理的资料推导里，我们并没有看到说正在使用什么布局，也就是说布局被隐含了，这就需要自己去推演，比较麻烦。但是<strong>一般来说我们会使用一种叫混合布局的思路</strong>，即</p><ul><li>如果是向量或者矩阵对标量求导，则使用分子布局为准</li><li>如果是标量对向量或者矩阵求导，则以分母布局为准</li><li>对于向量对对向量求导，有些分歧，<a href="https://www.cnblogs.com/pinard/" target="_blank" rel="noopener">刘建平大牛</a>的所有文章中会以分子布局的雅克比矩阵为主。</li></ul><p>具体总结如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">自变量\因变量</th><th style="text-align:center">标量$y$</th><th style="text-align:center">列向量$\mathrm y$</th><th style="text-align:center">矩阵$\mathrm Y$</th></tr></thead><tbody><tr><td style="text-align:center">标量$x$</td><td style="text-align:center">/</td><td style="text-align:center">$\frac{\partial \mathrm{y}}{\partial x}$<br>分子布局：m维列向量（默认布局）<br>分母布局：m维行向量</td><td style="text-align:center">$\frac{\partial \mathrm{Y}}{\partial x}$</td></tr><tr><td style="text-align:center">列向量$\mathrm x$</td><td style="text-align:center">$\frac{\partial y}{\partial \mathrm{x}}$<br>分子布局：n维行向量<br>分母布局：n维列向量（默认布局）</td><td style="text-align:center">$\frac{\partial \mathrm{y}}{\partial \mathrm{x}}$<br>分子布局：$m \times n$雅克比矩阵（默认布局）<br>分母布局：$n \times m$梯度矩阵</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">矩阵$\mathrm X$</td><td style="text-align:center">$\frac{\partial y}{\partial \mathrm{X}}$<br><br>分子布局：$n \times m$矩阵<br><br>分母布局：$m \times n$矩阵（默认布局）</td><td style="text-align:center">/</td><td style="text-align:center">/</td></tr></tbody></table></div><p>上面表格中，对于分子布局，若分子为标量，也就是维度为1，那么第一维度会以分母的转置维度为准；对于分母布局，若分母为标量，也就是维度为1，那么第一维度会以分子的转置维度为准。因为上面说过，所谓的向量矩阵求导本质上就是多元函数求导，仅仅是把把函数的自变量，因变量以及标量求导的结果排列成了向量矩阵的形式（当然这种排列是人为指定的），方便表达与计算，更加简洁而已。</p><h2 id="矩阵向量求导之定义法"><a href="#矩阵向量求导之定义法" class="headerlink" title="矩阵向量求导之定义法"></a>矩阵向量求导之定义法</h2><p>上面讨论了向量矩阵求导的9种定义与求导布局的概念。本节我们就讨论下其中的标量对向量求导，标量对矩阵求导, 以及向量对向量求导这三种场景的基本求解思路。</p><p>对于本节中的标量对向量或矩阵求导这两种情况，如前文所说，以分母布局为默认布局。向量对向量求导，以分子布局为默认布局。如遇到其他文章中的求导结果和本节不同，请先确认使用的求导布局是否一样。另外，由于机器学习中向量或矩阵对标量求导的场景很少见，本系列不会单独讨论这两种求导过程。</p><h3 id="用定义法求解标量对向量求导"><a href="#用定义法求解标量对向量求导" class="headerlink" title="用定义法求解标量对向量求导"></a>用定义法求解标量对向量求导</h3><p><strong>标量对向量求导，严格来说是实值函数对向量的求导</strong>。即定义实值函数$f: R^{n} \to R$，自变量$\mathrm{x}$是n维向量，而输出$y$是标量。对于一个给定的实值函数，如何求解$\frac{\partial y}{\partial \mathrm{x}}$呢？</p><p>首先我们想到的是基于<strong>矩阵求导的定义</strong>来做，由于<strong>所谓标量对向量的求导，其实就是标量对向量里的每个分量分别求导，最后把求导的结果排列在一起，按一个向量表示而已。</strong>那么我们可以将实值函数对向量的每一个分量来求导，最后找到规律，得到求导的结果向量。</p><p>首先我们来看一个简单的例子：$y=\mathrm{a}^T\mathrm{x}$，求解$\frac{\partial \mathrm{a}^T\mathrm{x}}{\partial \mathrm{x}}$</p><p>根据定义，我们先对$\mathrm{x}$的第i个分量进行求导，这是一个标量对标量的求导，如下：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm{a}^T\mathrm{x}}{\partial x_i} = \frac{\partial \sum\limits_{j=1}^n a_jx_j}{\partial x_i} = \frac{\partial a_ix_i}{\partial x_i} =a_i</script><p>可见，对向量的第i个分量的求导结果就等于向量$\mathrm{a}$的第i个分量。由于我们是分母布局，最后所有求导结果的分量组成的是一个n维列向量。那么其实就是向量$\mathrm{a}$。也就是说：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm{a}^T\mathrm{x}}{\partial \mathrm{x}} = \mathrm{a}</script><p>同样的思路，我们也可以直接得到：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm{x}^T\mathrm{a}}{\partial \mathrm{x}} = \mathrm{a}</script><p>给一个简单的测试，大家看看自己能不能按定义法推导出：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm{x}^T\mathrm{x}}{\partial \mathrm{x}} =2\mathrm{x}</script><p>再来看一个复杂一点点的例子：$y=\mathrm{x}^T\mathrm{A}\mathrm{x}$，求解$\frac{\partial \mathrm{x}^T\mathrm{A}\mathrm{x}}{\partial \mathrm{x}}$。</p><p>我们对$\mathrm{x}$的第k个分量$x_k$进行求导如下：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm{x}^T\mathrm{A}\mathrm{x}}{\partial x_k} = \frac{\partial \sum\limits_{i=1}^n\sum\limits_{j=1}^n x_iA_{ij}x_j}{\partial x_k} = \sum\limits_{i=1}^n A_{ik}x_i + \sum\limits_{j=1}^n A_{kj}x_j</script><p>这个第k个分量的求导结果稍微复杂些了，仔细观察一下，第一部分是矩阵$\mathrm{A}$的第k列转置后和$x$相乘得到，第二部分是矩阵$\mathrm{A}$的第k行和$x$相乘得到，排列好就是:</p><script type="math/tex;mode=display">
\frac{\partial \mathrm{x}^T\mathrm{A}\mathrm{x}}{\partial \mathrm{x}} = \mathrm{A}^T\mathrm{x} + \mathrm{A}\mathrm{x}</script><p>从上面可以看出：</p><ul><li>定义法求导对于简单的实值函数是很容易的</li><li>但是复杂的实值函数就算求出了任意一个分量的导数，要排列出最终的求导结果还挺麻烦的</li></ul><p>因此我们需要找到其他的简便一些的方法来整体求导，而不是每次都先去针对任意一个分量，再进行排列。</p><h3 id="标量对向量求导的一些基本法则"><a href="#标量对向量求导的一些基本法则" class="headerlink" title="标量对向量求导的一些基本法则"></a>标量对向量求导的一些基本法则</h3><p>在我们寻找一些简单的方法前，我们简单看下标量对向量求导的一些基本法则，这些法则和标量对标量求导的过程类似。</p><p>1）常量对向量的求导结果为0。</p><p>2）线性法则：如果$f,g$都是<strong>实值函数</strong>，$c_1,c_2$为常数，则：</p><script type="math/tex;mode=display">
\frac{\partial (c_1f(\mathrm{x})+c_2g(\mathrm{x})}{\partial \mathrm{x}} = c_1\frac{\partial f(\mathrm{x})}{\partial \mathrm{x}} +c_2\frac{\partial g(\mathrm{x})}{\partial \mathrm{x}}</script><p>3) 乘法法则：如果$f,g$都是<strong>实值函数</strong>，则：</p><script type="math/tex;mode=display">
\frac{\partial f(\mathrm{x})g(\mathrm{x})}{\partial \mathrm{x}} = f(\mathrm{x})\frac{\partial g(\mathrm{x})}{\partial \mathrm{x}} +\frac{\partial f(\mathrm{x})}{\partial \mathrm{x}} g(\mathrm{x})</script><p>要注意的是如果不是实值函数，则不能这么使用乘法法则。</p><p>4) 除法法则：如果$f,g$都是<strong>实值函数</strong>，且$g(\mathrm{x}) \neq 0$，则：</p><script type="math/tex;mode=display">
\frac{\partial f(\mathrm{x})/g(\mathrm{x})}{\partial \mathrm{x}} = \frac{1}{g^2(\mathrm{x})}(g(\mathrm{x})\frac{\partial f(\mathrm{x})}{\partial \mathrm{x}} - f(\mathrm{x})\frac{\partial g(\mathrm{x})}{\partial \mathrm{x}})</script><h3 id="用定义法求解标量对矩阵求导"><a href="#用定义法求解标量对矩阵求导" class="headerlink" title="用定义法求解标量对矩阵求导"></a>用定义法求解标量对矩阵求导</h3><p>现在我们来看看定义法如何解决标量对矩阵的求导问题。其实思路和上一小节的标量对向量的求导是类似的，只是最后的结果是一个和自变量同型的矩阵。</p><p>我们还是以一个例子来说明。$y=\mathrm{a}^T\mathrm{X}\mathrm{b}$，求解$\frac{\partial \mathrm{a}^T\mathrm{X}\mathrm{b}}{\partial \mathrm{X}}$。其中，$\mathrm{a}$是$m$维列向量，$\mathrm{b}$是$n$维列向量，$\mathrm{X}$是$m \times n$的矩阵。</p><p>我们对矩阵$\mathrm{X}$的任意一个位置的$X_{ij}$求导，如下：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm{a}^T\mathrm{X}\mathrm{b}}{\partial X_{ij}} =  \frac{\partial \sum\limits_{p=1}^m\sum\limits_{q=1}^n a_pX_{pq}b_q}{\partial X_{ij}} =  \frac{\partial  a_iX_{ij}b_j}{\partial X_{ij}} = a_ib_j</script><p>即求导结果在$(i,j)$位置的求导结果是$\mathrm{a}$向量第i个分量和$\mathrm{b}$第j个分量的乘积，将所有的位置的求导结果排列成一个$m \times n$的矩阵，即为$ab^T$，这样最后的求导结果为：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm{a}^T\mathrm{X}\mathrm{b}}{\partial \mathrm{X}} = ab^T</script><p>简单的求导的确不难，但是如果是比较复杂的标量对矩阵求导，比如$y=\mathrm{a}^Texp(\mathrm{X}\mathrm{b})$，对任意标量求导容易，排列起来还是蛮麻烦的，也就是我们遇到了和标量对向量求导一样的问题，<strong>定义法比较适合解决简单的问题，复杂的求导需要更简便的方法。</strong>这个方法我们在下一大节来讲。</p><p>同时，标量对矩阵求导也有和第二节对向量求导类似的基本法则，这里就不累述了。</p><h3 id="用定义法求解向量对向量求导"><a href="#用定义法求解向量对向量求导" class="headerlink" title="用定义法求解向量对向量求导"></a>用定义法求解向量对向量求导</h3><p>这里我们也同样给出向量对向量求导的定义法的具体例子。</p><p>先来一个简单的例子: $\mathrm{y} = \mathrm{A} \mathrm{x} $，其中$ \mathrm{A}$为$n \times m$的矩阵。$\mathrm{x}, \mathrm{y}$分别为$m,n$维向量。需要求导$\frac{\partial \mathrm{A}\mathrm{x}}{\partial \mathrm{x}}$，根据定义，结果应该是一个$n \times m$的矩阵。</p><p>先求矩阵$\mathrm A$的第i行和向量$\mathrm x$的内积对向量$\mathrm x$的第j分量求导，用定义法求解过程如下：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm{A_i}\mathrm{x}}{\partial \mathrm{x_j}} = \frac{\partial A_{ij}x_j}{\partial \mathrm{x_j}}= A_{ij}</script><p>可见矩阵 $\mathrm{A}$的第i行和向量的内积对向量的第j分量求导的结果就是矩阵 $\mathrm{A}$的$(i,j)$位置的值。排列起来就是一个矩阵了，由于我们分子布局，所以排列出的结果是$ \mathrm{A}$，而不是 $\mathrm{A}^T$。</p><h3 id="定义法矩阵向量求导的局限"><a href="#定义法矩阵向量求导的局限" class="headerlink" title="定义法矩阵向量求导的局限"></a>定义法矩阵向量求导的局限</h3><p>使用定义法虽然已经求出一些简单的向量矩阵求导的结果，但是<strong>对于复杂的求导式子，则中间运算会很复杂</strong>，同时<strong>求导出的结果排列也是很头痛的</strong>。下一大节我们讨论使使用矩阵微分和迹函数的方法来求解矩阵向量求导。</p><h2 id="矩阵向量求导之微分法"><a href="#矩阵向量求导之微分法" class="headerlink" title="矩阵向量求导之微分法"></a>矩阵向量求导之微分法</h2><p>定义法求解矩阵向量求导的方法对于比较复杂的求导式子，中间运算会很复杂，同时排列求导出的结果也很麻烦。因此我们需要其他的一些求导方法。本节我们讨论使用微分法来求解标量对向量的求导，以及标量对矩阵的求导。</p><p>本节的标量对向量的求导，以及标量对矩阵的求导使用分母布局。如果遇到其他资料求导结果不同，请先确认布局是否一样。</p><h3 id="矩阵微分"><a href="#矩阵微分" class="headerlink" title="矩阵微分"></a>矩阵微分</h3><p>在高数里面我们学习过标量的导数和微分，他们之间有这样的关系：$df =f’(x)dx$。如果是<strong>多变量</strong>的情况，则微分可以写成：</p><script type="math/tex;mode=display">
df=\sum\limits_{i=1}^n\frac{\partial f}{\partial x_i}dx_i = (\frac{\partial f}{\partial \mathrm{x}})^Td\mathrm{x}</script><p>从上次我们可以发现<strong>标量对向量的求导</strong>和<strong>它的向量微分</strong>有一个转置的关系。</p><p>现在我们再推广到矩阵。对于矩阵微分，我们的定义为：</p><script type="math/tex;mode=display">
df=\sum\limits_{i=1}^m\sum\limits_{j=1}^n\frac{\partial f}{\partial X_{ij}}dX_{ij} = tr((\frac{\partial f}{\partial \mathrm{X}})^Td\mathrm{X})</script><p>其中第二步使用了矩阵迹的性质，即迹函数等于主对角线的和。即</p><script type="math/tex;mode=display">
tr(A^TB) = \sum\limits_{i,j}A_{ij}B_{ij}</script><p>从上面矩阵微分的式子，我们可以看到<strong>矩阵微分</strong>和它的<strong>导数</strong>也有一个转置的关系，不过在外面套了一个迹函数而已。由于标量的迹函数就是它本身，那么<strong>矩阵微分和向量微分可以统一表示</strong>，即：</p><script type="math/tex;mode=display">
df= tr((\frac{\partial f}{\partial \mathrm{X}})^Td\mathrm{X})\;\; \;df= tr((\frac{\partial f}{\partial \mathrm{x}})^Td\mathrm{x})</script><h3 id="矩阵微分的性质"><a href="#矩阵微分的性质" class="headerlink" title="矩阵微分的性质"></a>矩阵微分的性质</h3><p>我们在讨论如何使用矩阵微分来求导前，先看看矩阵微分的性质：</p><p>1）微分加减法：$d(\mathrm X+ \mathrm Y) =d\mathrm X+d \mathrm Y, d(\mathrm X- \mathrm Y) =d\mathrm X-d \mathrm Y$</p><p>2) 微分乘法：$d(\mathrm X \mathrm Y) =(d\mathrm X) \mathrm Y + \mathrm X(d \mathrm Y)$；$d(\mathrm X\mathrm Y\mathrm Z) =(d\mathrm X)\mathrm Y\mathrm Z + X(d\mathrm Y)\mathrm Z+ \mathrm X\mathrm Y(d\mathrm Z)$</p><p>3) 微分转置：$d(\mathrm X^T) =(d\mathrm X)^T$</p><p>4) 微分的迹：$dtr(\mathrm X) =tr(d\mathrm X)$</p><p>5) 微分哈达马乘积： $d(\mathrm X \odot \mathrm Y) = \mathrm X\odot d \mathrm Y + d\mathrm X \odot \mathrm Y$</p><p>6) 逐元素求导：$d \sigma(\mathrm X) =\sigma’(\mathrm X) \odot d\mathrm X$，$\sigma (\mathrm X)=[\sigma (\mathrm X_{ij})]$是逐元素标量函数运算，$\sigma’(\mathrm X)=[\sigma’ (\mathrm X_{ij})]$是逐元素求导数运算。例如：</p><script type="math/tex;mode=display">
\mathrm X=\left[ \begin{array}{c}  \mathrm X_{11}, \mathrm X_{12} \\ \mathrm X_{21}, \mathrm X_{22}\end{array} \right]</script><script type="math/tex;mode=display">
dsin(\mathrm X)=\left[  \begin{array}{c} cos \mathrm X_{11} d \mathrm X_{11}, cos \mathrm X_{12} d \mathrm X_{12} \\  cos \mathrm X_{21} d \mathrm X_{21} ,  cos \mathrm X_{22} d \mathrm X_{22}  \end{array} \right] = cos(\mathrm X) \odot d\mathrm X</script><p>7) 逆矩阵微分：$d \mathrm X^{-1}= -\mathrm X^{-1}d\mathrm X\mathrm X^{-1}$。此式可在$\mathrm X \mathrm X ^{-1}=I$两侧微分来证明。</p><p>8) 行列式微分：$d |\mathrm X|= tr(\mathrm X^$表示$\mathrm X$的伴随矩阵；在$\mathrm X$可逆时又可以写作$d |\mathrm X|= |\mathrm X|tr(\mathrm X^{-1}d\mathrm X)$。此式可用Laplace展开来证明，详见张贤达《矩阵分析与应用》第279页。</p><p>有了这些性质，我们再来看看如何由矩阵微分来求导数。</p><blockquote><p>所谓哈达马乘积也就是两个维度相同的矩阵按像素相乘。</p></blockquote><h3 id="使用微分法求解矩阵向量求导"><a href="#使用微分法求解矩阵向量求导" class="headerlink" title="使用微分法求解矩阵向量求导"></a>使用微分法求解矩阵向量求导</h3><p>由于上一小节我们已经得到了矩阵微分和导数关系，现在我们就来使用微分法求解矩阵向量求导。</p><p>若<strong>标量函数$f$</strong>是矩阵$\mathrm X$经加减乘法、逆、行列式、逐元素函数等运算构成，则使用相应的运算法则对$f$求微分，再使用迹函数技巧给$df$套上迹并将其它项交换至$dX$左侧，那么对于迹函数里面在$dX$左边的部分，我们只需要加一个转置就可以得到导数了。</p><p>这里需要用到的迹函数的技巧主要有这么几个：</p><p>1) 标量的迹等于自己：$tr(x) =x$</p><p>2) 转置不变：$tr( \mathrm A^T) =tr( \mathrm A)$</p><p>3) 交换率：$tr( \mathrm A \mathrm B) =tr( \mathrm B \mathrm A)$，<strong>需要满足$ \mathrm A, \mathrm B^T$同维度。</strong></p><p>4) 加减法：$tr(\mathrm X+ \mathrm Y) =tr(\mathrm X)+tr( \mathrm Y), tr(\mathrm X- \mathrm Y) =tr(\mathrm X)-tr( \mathrm Y)$</p><p>5) 矩阵乘法和迹交换：$tr(( \mathrm A\odot \mathrm B)^T \mathrm C)= tr( \mathrm A^T( \mathrm B \odot \mathrm C))$，需要满足$ \mathrm A、 \mathrm B、 \mathrm C$同维度。</p><p>先看第一个例子，我们使用上一篇定义法中的一个求导问题：</p><script type="math/tex;mode=display">
y=\mathbf{a}^T\mathbf{X}\mathbf{b}, 求\frac{\partial y}{\partial \mathbf{X}}</script><p><strong>首先，</strong>我们使用微分乘法的性质对$f$求关于$\mathrm X$微分，得到：</p><script type="math/tex;mode=display">
dy = d\mathbf{a}^T\mathbf{X}\mathbf{b} + \mathbf{a}^Td\mathbf{X}\mathbf{b} + \mathbf{a}^T\mathbf{X}d\mathbf{b} = \mathbf{a}^Td\mathbf{X}\mathbf{b}</script><p>在这一步，从第一个等号到第二个等号主要是用了上面矩阵微分性质（2）。从第二个等号到第三个等号主要是因为微分$d(\mathrm a^T)$以及$d \mathrm b$因变量部分不是自变量的函数（$\mathrm a$和$\mathrm b$作为因变量都不包含$\mathrm X$），因此导数为0。</p><blockquote><p>高等数学中说得：函数$y=f(x)$在点$x_0$可微的充分必要条件是函数$f(x)$在点$x_0$可导，且当$f(x)$在点$x_0$可微时，其微分一定是：</p><script type="math/tex;mode=display">
dy = f'(x_0) \Delta x</script><p>从中可以看出，微分也是针对变量的，如果是常量的微分，那么变化值就是0。在求导过程中，除了要求导的部分为变量，其余部分均为已知常量。</p></blockquote><p><strong>第二步，</strong>就是两边套上迹函数，即：</p><script type="math/tex;mode=display">
dy =tr(dy) = tr(\mathbf{a}^Td\mathbf{X}\mathbf{b}) = tr(\mathbf{b}\mathbf{a}^Td\mathbf{X})</script><p>其中第一到第二个等号使用了上面迹函数性质1。第三到第四个等号用到了上面迹函数的性质3，也就是$\mathrm b^T = \mathrm a^T d \mathrm X$。</p><p><strong>最后，</strong>根据我们<strong>矩阵导数和微分的定义</strong>，迹函数里面在$d \mathrm X$左边的部分$\mathrm{b}\mathrm{a}^T$，加上一个转置即为我们要求的导数，即：</p><script type="math/tex;mode=display">
\frac{\partial f}{\partial \mathbf{X}} = (\mathbf{b}\mathbf{a}^T)^T =ab^T</script><p>以上就是微分法的基本流程，先求微分再做迹函数变换，最后得到求导结果。比起定义法，我们现在不需要去对矩阵中的单个标量进行求导了。</p><p>再来看看</p><script type="math/tex;mode=display">
y=\mathbf{a}^Texp(\mathbf{X}\mathbf{b}), 求\frac{\partial y}{\partial \mathbf{X}}</script><script type="math/tex;mode=display">
\begin{eqnarray} 
\begin{split}
dy &=&tr(dy)\\ &=& tr(\mathbf{a}^Tdexp(\mathbf{X}\mathbf{b}))\\ &=& tr\left(\mathbf{a}^T \left(exp \left(\mathbf{X}\mathbf{b}\right) \odot d\left(\mathbf{X}\mathbf{b}\right)\right)\right) \\&=& tr\left(\left(\mathbf{a}  \odot exp\left(\mathbf{X}\mathbf{b}\right) \right)^T d\mathbf{X}\mathbf{b}\right) \\&=&  tr(\mathbf{b}\left(\mathbf{a}  \odot exp\left(\mathbf{X}\mathbf{b}\right) \right)^T d\mathbf{X})
\end{split}
\end{eqnarray}</script><p>上面第二个到第三个等号使用上面矩阵微分性质6（也就是$\sigma$函数为$exp$函数，对$\mathrm X \mathrm b$逐元素求导），其中第三到第四个等号使用了上面迹函数的性质5。从第四个到第五个等号使用了上面迹函数的性质3（因为这里只关注求导，所以对于$\mathrm A$和$\mathrm B^T$同维度的问题并没有强调，实际使用的时候要保证相容），这样我们的求导结果为：</p><script type="math/tex;mode=display">
\frac{\partial y}{\partial \mathbf{X}} =(\mathbf{a}  \odot exp(\mathbf{X}\mathbf{b}) )b^T</script><p>以上就是微分法的基本思路。</p><h3 id="迹函数对向量矩阵求导"><a href="#迹函数对向量矩阵求导" class="headerlink" title="迹函数对向量矩阵求导"></a>迹函数对向量矩阵求导</h3><p>由于微分法使用了迹函数的技巧，那么迹函数对对向量矩阵求导这一大类问题，使用微分法是最简单直接的。下面给出一些常见的迹函数的求导过程，也顺便给大家熟练掌握微分法的技巧。</p><p>首先是$\frac{\partial tr(\mathrm A\mathrm B)}{\partial \mathrm A} = \mathrm B^T, \frac{\partial tr(\mathrm A\mathrm B)}{\partial \mathrm B} =\mathrm A^T$，这个直接根据<strong>矩阵微分的定义</strong>即可得到。</p><p>再来看看$\frac{\partial tr(\mathrm W^T\mathrm A\mathrm W)}{\partial \mathrm W}$：</p><script type="math/tex;mode=display">
d(tr(\mathrm W^T\mathrm A\mathrm W)) = tr(d\mathrm W^T\mathrm A\mathrm W +\mathrm W^T\mathrm Ad\mathrm W) \\ = tr(d\mathrm W^T\mathrm A\mathrm W)+tr(\mathrm W^T\mathrm Ad\mathrm W)\\ = tr((d\mathrm W)^T\mathrm A\mathrm W) + tr(\mathrm W^T\mathrm Ad\mathrm W) \\ = tr(\mathrm W^T\mathrm A^Td\mathrm W) +  tr(\mathrm W^T\mathrm Ad\mathrm W)\\ = tr(\mathrm W^T(\mathrm A+\mathrm A^T)d\mathrm W)</script><p>因此可以得到：</p><script type="math/tex;mode=display">
\frac{\partial tr(\mathrm W^T\mathrm A\mathrm W)}{\partial \mathrm W} = (\mathrm A+\mathrm A^T)\mathrm W</script><p>最后来个更加复杂的迹函数求导：$\frac{\partial tr(B^TX^TCXB)}{\partial X} $：</p><script type="math/tex;mode=display">
d(tr(\mathrm B^T\mathrm X^T\mathrm C\mathrm X\mathrm B)) = tr(\mathrm B^Td\mathrm X^T\mathrm C\mathrm X\mathrm B) + tr(\mathrm B^T\mathrm X^T\mathrm Cd\mathrm X\mathrm B) \\ = tr((d\mathrm X)^T\mathrm C\mathrm X\mathrm B\mathrm B^T) + tr(\mathrm B\mathrm B^T\mathrm X^T\mathrm Cd\mathrm X)\\ = tr(\mathrm B\mathrm B^T\mathrm X^T\mathrm C^TdX) + tr(\mathrm B\mathrm B^T\mathrm X^T\mathrm Cd\mathrm X)\\ = tr((\mathrm B\mathrm B^T\mathrm X^T\mathrm C^T + \mathrm B\mathrm B^T\mathrm X^TC\mathrm )d\mathrm X)</script><p>因此可以得到：</p><script type="math/tex;mode=display">
\frac{\partial tr(\mathrm B^T\mathrm X^T\mathrm C\mathrm X\mathrm B)}{\partial \mathrm X}= (\mathrm C+\mathrm C^T)\mathrm X\mathrm B\mathrm B^T</script><h3 id="微分法求导小结"><a href="#微分法求导小结" class="headerlink" title="微分法求导小结"></a>微分法求导小结</h3><p>使用矩阵微分，可以在不对向量或矩阵中的某一元素单独求导再拼接，因此会比较方便，当然熟练使用的前提是对上面矩阵微分的性质，以及迹函数的性质熟练运用。</p><p>还有一些场景，求导的自变量和因变量直接有复杂的多层链式求导的关系，此时微分法使用起来也有些麻烦。如果我们可以利用一些常用的简单求导结果，再使用链式求导法则，则会非常的方便。因此下一节我们讨论向量矩阵求导的链式法则。</p><h2 id="矩阵向量求导链式法则"><a href="#矩阵向量求导链式法则" class="headerlink" title="矩阵向量求导链式法则"></a>矩阵向量求导链式法则</h2><p>使用微分法来求解矩阵向量求导的方法。但是很多时候，求导的自变量和因变量直接有复杂的多层链式求导的关系，此时微分法使用起来也有些麻烦。需要一些简洁的方法。</p><p>本节我们讨论矩阵向量求导链式法则，使用该法则很多时候可以帮我们快速求出导数结果。</p><p><strong>本节的标量对向量的求导，标量对矩阵的求导使用分母布局， 向量对向量的求导使用分子布局。</strong>如果遇到其他资料求导结果不同，请先确认布局是否一样。</p><h3 id="向量对向量求导的链式法则"><a href="#向量对向量求导的链式法则" class="headerlink" title="向量对向量求导的链式法则"></a>向量对向量求导的链式法则</h3><p>首先我们来看看向量对向量求导的链式法则。假设多个向量存在依赖关系，比如三个向量$\mathbf{x} \to \mathbf{y} \to \mathbf{z}$存在依赖关系，则我们有下面的链式求导法则：</p><script type="math/tex;mode=display">
\frac{\partial \mathbf{z}}{\partial \mathbf{x}} = \frac{\partial \mathbf{z}}{\partial \mathbf{y}}\frac{\partial \mathbf{y}}{\partial \mathbf{x}}</script><p>该法则也可以推广到更多的向量依赖关系。但是要注意的是要求所有有依赖关系的变量都是向量，如果有一个$\mathbf{Y}$是矩阵，比如是$\mathbf{x} \to \mathbf{Y} \to \mathbf{z}$， 则上式并不成立。</p><p>从矩阵维度相容的角度也很容易理解上面的链式法则，假设$\mathbf{x} , \mathbf{y} ,\mathbf{z}$分别是$m,n.p$维向量，则求导结果$\frac{\partial \mathbf{z}}{\partial \mathbf{x}}$是一个$p \times m$的雅克比矩阵，而右边$\frac{\partial \mathbf{z}}{\partial \mathbf{y}}$是一个$p \times n$的雅克比矩阵，$\frac{\partial \mathbf{y}}{\partial \mathbf{x}}$是一个$n \times m$的矩阵，两个雅克比矩阵的乘积维度刚好是$p \times m$，和左边相容。</p><h3 id="标量对多个向量的链式求导法则"><a href="#标量对多个向量的链式求导法则" class="headerlink" title="标量对多个向量的链式求导法则"></a>标量对多个向量的链式求导法则</h3><p>我们的机器学习算法中，最终要优化的一般是一个标量损失函数，因此最后求导的目标是标量，无法使用上一节的链式求导法则，比如由2个向量，最后得到1个标量的依赖关系：$\mathbf{x} \to \mathbf{y} \to z$，此时很容易发现维度不相容。</p><p>假设$\mathbf{x} , \mathbf{y} $分别是$m,n$维向量，那么$\frac{\partial z}{\partial \mathbf{x}}$的求导结果是一个$m \times 1$的向量，而$\frac{\partial z}{\partial \mathbf{y}}$是一个$n \times 1$的向量，$\frac{\partial \mathbf{y}}{\partial \mathbf{x}}$是一个$n \times m$的雅克比矩阵，右边的向量和矩阵是没法直接乘的。</p><p>但是假如我们把标量求导的部分都做一个转置，那么维度就可以相容了，也就是：</p><script type="math/tex;mode=display">
(\frac{\partial z}{\partial \mathbf{x}})^T = (\frac{\partial z}{\partial \mathbf{y}})^T\frac{\partial \mathbf{y}}{\partial \mathbf{x}}</script><p>但是毕竟我们要求导的是$(\frac{\partial z}{\partial \mathbf{x}})$，而不是它的转置，因此两边转置我们可以得到标量对多个向量求导的链式法则：</p><script type="math/tex;mode=display">
\frac{\partial z}{\partial \mathbf{x}} = (\frac{\partial \mathbf{y}}{\partial \mathbf{x}} )^T\frac{\partial z}{\partial \mathbf{y}}</script><p>如果是标量对更多的向量求导，比如$\mathbf{y_1} \to \mathbf{y_2} \to …\to \mathbf{y_n} \to z$，则其链式求导表达式可以表示为：</p><script type="math/tex;mode=display">
\frac{\partial z}{\partial \mathbf{y_1}} = (\frac{\partial \mathbf{y_n}}{\partial \mathbf{y_{n-1}}} \frac{\partial \mathbf{y_{n-1}}}{\partial \mathbf{y_{n-2}}} ...\frac{\partial \mathbf{y_2}}{\partial \mathbf{y_1}})^T\frac{\partial z}{\partial \mathbf{y_n}}</script><p>这里我们给一个最常见的最小二乘法求导的例子。最小二乘法优化的目标是最小化如下损失函数：</p><script type="math/tex;mode=display">
l=( \mathrm X\theta - \mathrm y)^T(\mathrm X\theta - \mathrm y)</script><p>我们优化的损失函数$l$是一个标量，而模型参数$\theta$是一个向量，期望L对$\theta$求导，并求出导数等于0时候的极值点。我们假设向量$\mathrm z = \mathrm X\theta - \mathrm y$，则$l=\mathrm z^T \mathrm z$， $\theta \to \mathrm z \to l$存在链式求导的关系，因此：</p><script type="math/tex;mode=display">
\frac{\partial l}{\partial \mathbf{\theta}} = (\frac{\partial z}{\partial \theta} )^T\frac{\partial l}{\partial \mathbf{z}} = \mathrm X^T(2 \mathrm z) =2\mathrm X^T(\mathrm X\theta - \mathrm y)</script><p>其中这一步转换使用了如下求导公式：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm X\theta - \mathrm y}{\partial \theta} = \mathrm X</script><script type="math/tex;mode=display">
\frac{\partial \mathrm z^T\mathrm z}{\partial \mathrm z} = 2\mathrm z</script><p>这两个式子我们在前几篇里已有求解过，现在可以直接拿来使用了，非常方便。</p><p>当然上面的问题使用微分法求导数也是非常简单的，这里只是给出链式求导法的思路。</p><h3 id="标量对多个矩阵的链式求导法则"><a href="#标量对多个矩阵的链式求导法则" class="headerlink" title="标量对多个矩阵的链式求导法则"></a>标量对多个矩阵的链式求导法则</h3><p>下面我们再来看看标量对多个矩阵的链式求导法则，假设有这样的依赖关系：$\mathbf{X} \to \mathbf{Y} \to z$,那么我们有：</p><script type="math/tex;mode=display">
\frac{\partial z}{\partial \mathrm X_{ij}} = \sum\limits_{k,l}\frac{\partial z}{\partial \mathrm Y_{kl}} \frac{\partial \mathrm Y_{kl}}{\partial \mathrm X_{ij}} =tr((\frac{\partial z}{\partial \mathrm Y})^T\frac{\partial \mathrm Y}{\partial \mathrm X_{ij}})</script><p>这里大家会发现我们没有给出基于矩阵整体的链式求导法则，主要原因是矩阵对矩阵的求导是比较复杂的定义，我们目前也未涉及。因此<strong>只能给出对矩阵中一个标量的链式求导方法</strong>。这个方法并不实用，因为我们并不想每次都基于定义法来求导最后再去排列求导结果。</p><p>虽然我们没有全局的标量对矩阵的链式求导法则，但是对于一些线性关系的链式求导，我们还是可以得到一些有用的结论的。</p><p>我们来看这个常见问题：$\mathrm A,\mathrm X,\mathrm B,\mathrm Y$都是矩阵，$z$是标量，其中$z= f(\mathrm Y), \mathrm Y=\mathrm A\mathrm X+\mathrm B$，我们要求出$\frac{\partial z}{\partial \mathrm X}$，这个问题在机器学习中是很常见的。此时，我们并不能直接整体使用矩阵的链式求导法则，因为矩阵对矩阵的求导结果不好处理。</p><p>这里我们回归初心，使用定义法试一试，先使用上面的标量链式求导公式：</p><script type="math/tex;mode=display">
\frac{\partial z}{\partial \mathrm X_{ij}} = \sum\limits_{k,l}\frac{\partial z}{\partial \mathrm Y_{kl}} \frac{\partial \mathrm Y_{kl}}{\partial \mathrm X_{ij}}</script><p>我们再来看看<strong>后半部分的导数：</strong></p><script type="math/tex;mode=display">
\frac{\partial \mathrm Y_{kl}}{\partial  \mathrm X_{ij}} =  \frac{\partial \sum\limits_s( \mathrm A_{ks} \mathrm X_{sl})}{\partial  \mathrm X_{ij}} =  \frac{\partial  \mathrm A_{ki} \mathrm X_{il}}{\partial  \mathrm X_{ij}} = \mathrm A_{ki}\delta_{lj}</script><p>其中$\delta_{lj}$在$l=j$时为1，否则为0。 对上面式子进行解释：因为$\mathrm Y_{kl}$由$\mathrm A$的第k行与$\mathrm X$的第l列相乘得到，所以有$\mathrm Y_{kl}=\sum\limits_s( \mathrm A_{ks} \mathrm X_{sl})$，而等式后面只有当$s=i,l=j$时，其对$\mathrm X_{ij}$求导才有值，也就是最终求导结果为$\mathrm A_{ki}$。</p><p>那么最终的标签链式求导公式转化为：</p><script type="math/tex;mode=display">
\frac{\partial z}{\partial  \mathrm X_{ij}} = \sum\limits_{k,l}\frac{\partial z}{\partial  \mathrm Y_{kl}}  \mathrm A_{ki}\delta_{lj} = \sum\limits_{k}\frac{\partial z}{\partial  \mathrm Y_{kj}} \mathrm  A_{ki}</script><p>即矩阵$ \mathrm A^T$的第i行和$\frac{\partial z}{\partial \mathrm Y} $的第j列的内积。排列成矩阵即为：</p><script type="math/tex;mode=display">
\frac{\partial z}{\partial  \mathrm X} =  \mathrm A^T\frac{\partial z}{\partial  \mathrm Y}</script><p>总结下就是：</p><script type="math/tex;mode=display">
z= f(Y),  \mathrm Y= \mathrm A \mathrm X+ \mathrm B \to \frac{\partial z}{\partial  \mathrm X} =  \mathrm A^T\frac{\partial z}{\partial \mathrm  Y}</script><p>这结论在$\mathbf{x}$是一个向量的时候也成立，即：</p><script type="math/tex;mode=display">
z= f(\mathbf{y}), \mathbf{y}= \mathrm A\mathbf{x}+\mathbf{b} \to \frac{\partial z}{\partial \mathbf{x}} =  \mathrm A^T\frac{\partial z}{\partial \mathbf{y}}</script><p>如果要求导的自变量在左边，线性变换在右边，也有类似稍有不同的结论如下，证明方法是类似的，这里直接给出结论：</p><script type="math/tex;mode=display">
z= f( \mathrm Y), \mathrm  Y= \mathrm X \mathrm A+ \mathrm B \to \frac{\partial z}{\partial \mathrm  X} = \frac{\partial z}{\partial  \mathrm Y} \mathrm A^T</script><script type="math/tex;mode=display">
z= f(\mathbf{y}), \mathbf{y}= \mathrm X\mathbf{a}+\mathbf{b} \to \frac{\partial z}{\partial \mathbf{X}} = \frac{\partial z}{\partial \mathbf{y}}\mathbf{a}^T</script><p><strong>使用好上述四个结论，对于机器学习尤其是深度学习里的求导问题可以非常快的解决，大家可以试一试。</strong></p><h3 id="矩阵向量求导小结"><a href="#矩阵向量求导小结" class="headerlink" title="矩阵向量求导小结"></a>矩阵向量求导小结</h3><p>矩阵向量求导在前面我们讨论三种方法，定义法，微分法和链式求导法。在同等情况下，优先考虑链式求导法，尤其是第三节的四个结论。其次选择微分法、在没有好的求导方法的时候使用定义法是最后的保底方案。</p><p>基本上大家看了系列里这四篇后对矩阵向量求导就已经很熟悉了，对于机器学习中出现的矩阵向量求导问题已足够。这里还没有讲到的是矩阵对矩阵的求导，还有矩阵对向量，向量对矩阵求导这三种形式，这个我们在系列的下一篇，也是最后一篇简单讨论一下，如果大家只是关注机器学习的优化问题，不涉及其他应用数学问题的，可以不关注。</p><h2 id="矩阵对矩阵的求导"><a href="#矩阵对矩阵的求导" class="headerlink" title="矩阵对矩阵的求导"></a>矩阵对矩阵的求导</h2><p>在前面几个小节中，我们主要讨论了标量对向量矩阵的求导，以及向量对向量的求导。本节我们就讨论下之前没有涉及到的矩阵对矩阵的求导，还有矩阵对向量，向量对矩阵求导这几种形式的求导方法。</p><p><strong>本节所有求导布局以分母布局为准</strong>，为了适配矩阵对矩阵的求导，<strong>本节向量对向量的求导也以分母布局为准，这和前面的小节不同，需要注意。</strong></p><h3 id="矩阵对矩阵求导的定义"><a href="#矩阵对矩阵求导的定义" class="headerlink" title="矩阵对矩阵求导的定义"></a>矩阵对矩阵求导的定义</h3><p>假设我们有一个$p \times q$的矩阵$\mathrm F$要对$m \times n$的矩阵$\mathrm X$求导，那么根据我们第一篇求导的定义，矩阵$\mathrm F$中的$p<em>q$个值要对矩阵$\mathrm X$中的$m</em>n$个值分别求导，那么<strong>求导的结果一共会有$m<em>n</em>p*q$个。那么求导的结果如何排列呢？</strong>方法有很多种。</p><p>最直观可以想到的求导定义有2种：</p><p>第一种是矩阵$\mathrm F$对矩阵$\mathrm X$中的每个值$\mathrm X_{ij}$求导，这样对于矩阵$\mathrm X$每一个位置(i,j)求导得到的结果是一个矩阵$\frac{\partial \mathrm F}{\partial \mathrm X_{ij}}$,可以理解为矩阵$\mathrm X$的每个位置都被替换成一个$p \times q$的矩阵，最后我们得到了一个$mp \times nq$的矩阵。</p><p>第二种和第一种类似，可以看做矩阵$\mathrm F$中的每个值$\mathrm F_{kl}$分别对矩阵$X$求导，这样矩阵$\mathrm F$每一个位置(k,l)对矩阵$\mathrm X$求导得到的结果是一个矩阵$\frac{\partial \mathrm F_{kl}}{\partial \mathrm X}$, 可以理解为矩阵$\mathrm F$的每个位置都被替换成一个$m \times n$的矩阵，最后我们得到了一个$mp \times nq$的矩阵。</p><p>这两种定义虽然没有什么问题，但是很难用于实际的求导，比如类似我们在<a href="https://www.cnblogs.com/pinard/p/10791506.html" target="_blank" rel="noopener">机器学习中的矩阵向量求导(三) 矩阵向量求导之微分法</a>中很方便使用的微分法求导。</p><p>目前<strong>主流的矩阵对矩阵求导定义是对矩阵先做向量化，然后再使用向量对向量的求导。</strong>而这里的向量化一般是使用<strong>列向量化</strong>。也就是说，现在我们的矩阵对矩阵求导可以表示为：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm F}{\partial \mathrm X} = \frac{\partial vec(\mathrm F)}{\partial vec(\mathrm X)}</script><p>对于矩阵$\mathrm F$，列向量化后，$vec(\mathrm F)$的维度是$pq \times 1$的向量，同样的，$vec(\mathrm X)$的维度是$mn \times 1$的向量。最终求导的结果，这里我们使用分母布局，得到的是一个$mn \times pq$的矩阵。</p><h3 id="矩阵对矩阵求导的微分法"><a href="#矩阵对矩阵求导的微分法" class="headerlink" title="矩阵对矩阵求导的微分法"></a>矩阵对矩阵求导的微分法</h3><p>按第一节的向量化的矩阵对矩阵求导有什么好处呢？主要是为了使用类似于前面讲过的微分法求导。回忆之前标量对向量矩阵求导的微分法里，我们有：</p><script type="math/tex;mode=display">
df= tr((\frac{\partial f}{\partial \mathbf{X}})^Td\mathbf{X})</script><p>这里矩阵对矩阵求导我们有：</p><script type="math/tex;mode=display">
vec(d\mathrm F) =\frac{\partial vec(\mathrm F)^T}{\partial vec(\mathrm X)} vec(d\mathrm X) = \frac{\partial \mathrm F^T}{\partial \mathrm X} vec(d\mathrm X)</script><p>和之前标量对矩阵的微分法相比，这里的迹函数被矩阵向量化代替了。</p><p>矩阵对矩阵求导的微分法，也有一些法则可以直接使用。主要集中在矩阵向量化后的运算法则，以及向量化和克罗内克积之间的关系。关于矩阵向量化和克罗内克积，具体可以参考张贤达的《矩阵分析与应用》，这里只给出微分法会用到的常见转化性质, 相关证明可以参考张的书。</p><p>矩阵向量化的主要运算法则有：</p><p>1) 线性性质：$vec(\mathrm A+\mathrm B) =vec(\mathrm A) +vec(\mathrm B)$</p><p>2) 矩阵乘法：$vec(\mathrm A\mathrm X \mathrm B)= (\mathrm B^T \bigotimes \mathrm A)vec(\mathrm X)$，其中$\bigotimes$是克罗内克积。</p><p>3) 矩阵转置：$vec(\mathrm A^T) =\mathrm K_{mn}vec(\mathrm A)$，其中$\mathrm A$是$m \times n$的矩阵，$\mathrm K_{mn}$是$mn \times mn$的交换矩阵，用于矩阵列向量化和行向量化之间的转换。</p><p>4) 逐元素乘法：$vec(\mathrm A \odot \mathrm X) = diag(\mathrm A)vec(\mathrm X)$, 其中$diag(\mathrm A)$是$mn \times mn$的对角矩阵，对角线上的元素是矩阵$\mathrm A$按列向量化后排列出来的。</p><p>克罗内克积的主要运算法则有：</p><p>1) $(\mathrm A \bigotimes \mathrm B)^T = \mathrm A^T \bigotimes \mathrm B^T$</p><p>2) $vec(ab^T) = b \bigotimes a$</p><p>3) $(\mathrm A \bigotimes \mathrm B)(\mathrm C \bigotimes \mathrm D )=\mathrm A \mathrm C \bigotimes \mathrm B \mathrm D$</p><p>4) $\mathrm K_{mn} =\mathrm K_{nm}^T, \mathrm K_{mn} \mathrm K_{nm}=\mathrm I$</p><p>使用上面的性质，求出$vec(d\mathrm F)$关于$ vec(d\mathrm X)$的表达式，则表达式左边的转置即为我们要求的$\frac{\partial vec(\mathrm F)}{\partial vec(\mathrm X)} $，或者说$\frac{\partial \mathrm F}{\partial \mathrm X} $</p><h3 id="矩阵对矩阵求导实例"><a href="#矩阵对矩阵求导实例" class="headerlink" title="矩阵对矩阵求导实例"></a>矩阵对矩阵求导实例</h3><p>下面我们给出一个使用微分法求解矩阵对矩阵求导的实例。</p><p>首先我们来看看：$\frac{\partial \mathrm A \mathrm X \mathrm B}{\partial \mathrm X}$，假设 $\mathrm A, \mathrm X, \mathrm B$都是矩阵，$\mathrm X$是$m \times n$的矩阵。</p><p>首先求$d \mathrm F$，和之前第三篇的微分法类似，我们有:</p><script type="math/tex;mode=display">
d\mathrm F =\mathrm Ad\mathrm X\mathrm B</script><p>然后我们两边列向量化(之前的微分法是套上迹函数)，得到：</p><script type="math/tex;mode=display">
vec(d\mathrm F) = vec(\mathrm Ad\mathrm X\mathrm B) = (\mathrm B^T \bigotimes \mathrm A)vec(d\mathrm X)</script><p>其中，第二个式子使用了上面矩阵向量化的性质2。</p><p>这样，我们就得到了求导结果为：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm A\mathrm X\mathrm B}{\partial \mathrm X} =  (\mathrm B^T \bigotimes \mathrm A)^T = \mathrm B \bigotimes \mathrm  A^T</script><p>利用上面的结果我们也可以得到：</p><script type="math/tex;mode=display">
\frac{\partial \mathrm A\mathrm X}{\partial \mathrm X} = \mathrm I_n \bigotimes \mathrm A^T</script><script type="math/tex;mode=display">
\frac{\partial \mathrm X\mathrm B}{\partial \mathrm X} = \mathrm B \bigotimes \mathrm I_m</script><p>来个复杂一些的：$\frac{\partial \mathrm Aexp(\mathrm B \mathrm X \mathrm C)\mathrm D}{\partial \mathrm X}$</p><p>首先求微分得到：</p><script type="math/tex;mode=display">
d \mathrm F =A [dexp( \mathrm B \mathrm X \mathrm C)] \mathrm D =  \mathrm A[exp( \mathrm B \mathrm X \mathrm C) \odot ( \mathrm Bd \mathrm X \mathrm C)] \mathrm D</script><p>两边矩阵向量化，我们有：</p><script type="math/tex;mode=display">
vec(d \mathrm F) = ( \mathrm D^T \bigotimes  \mathrm A) vec[exp( \mathrm B \mathrm X \mathrm C) \odot ( \mathrm Bd \mathrm X \mathrm C)] \\=  ( \mathrm D^T \bigotimes  \mathrm A) diag(exp( \mathrm B \mathrm X \mathrm C))vec( \mathrm Bd \mathrm X \mathrm C) \\= ( \mathrm D^T \bigotimes  \mathrm A) diag(exp( \mathrm B \mathrm X \mathrm C))( \mathrm C^T\bigotimes  \mathrm B)vec(d \mathrm X)</script><p>其中第一个等式使用了矩阵向量化性质2，第二个等式使用了矩阵向量化性质4， 第三个等式使用了矩阵向量化性质2。</p><p>这样我们最终得到：</p><script type="math/tex;mode=display">
\frac{\partial  \mathrm Aexp( \mathrm B \mathrm X \mathrm C) \mathrm D}{\partial  \mathrm X} \\= [( \mathrm D^T \bigotimes  \mathrm A) diag(exp( \mathrm B \mathrm X \mathrm C))( \mathrm C^T\bigotimes  \mathrm B)]^T \\= ( \mathrm C \bigotimes  \mathrm B^T) diag(exp( \mathrm B \mathrm X \mathrm C)) ( \mathrm D\bigotimes \mathrm  A^T )</script><h3 id="矩阵对矩阵求导小结"><a href="#矩阵对矩阵求导小结" class="headerlink" title="矩阵对矩阵求导小结"></a>矩阵对矩阵求导小结</h3><p>由于矩阵对矩阵求导的结果包含克罗内克积，因此和之前我们讲到的其他类型的矩阵求导很不同，在机器学习算法优化中中，我们一般不在推导的时候使用矩阵对矩阵的求导，除非只是做定性的分析。<strong>如果遇到矩阵对矩阵的求导不好绕过，一般可以使用<a href="https://www.cnblogs.com/pinard/p/10825264.html" target="_blank" rel="noopener">机器学习中的矩阵向量求导(四) 矩阵向量求导链式法则</a>中第三节最后的几个链式法则公式来避免。</strong></p><h2 id="常用结论"><a href="#常用结论" class="headerlink" title="常用结论"></a>常用结论</h2><h3 id="实值函数相对于实向量的梯度"><a href="#实值函数相对于实向量的梯度" class="headerlink" title="实值函数相对于实向量的梯度"></a>实值函数相对于实向量的梯度</h3><p>设$f(\mathrm x) = \mathrm x = [x_1,…,x_n]^T$</p><script type="math/tex;mode=display">
\frac{\partial (f (\mathrm x))^T}{\partial \mathrm x}  = \frac{\partial \mathrm x^T}{\partial \mathrm x}  = \mathrm I_{n\times n}</script><script type="math/tex;mode=display">
\frac{\partial (f (\mathrm x))}{\partial \mathrm x^T}  = \frac{\partial \mathrm  x}{\partial \mathrm x^T}  = \mathrm I_{n\times n}</script><script type="math/tex;mode=display">
\frac{\partial f (\mathrm x)}{\partial \mathrm x}  = \frac{\partial \mathrm x}{\partial \mathrm x}  = vec(\mathrm I_{n\times n})</script><script type="math/tex;mode=display">
\frac{\partial (f (\mathrm x))^T}{\partial \mathrm x^T}  = \frac{\partial\mathrm  x^T}{\partial \mathrm x^T}  = vec(\mathrm I_{n\times n})^T</script><p>其中，vec表示向量化矩阵，按列将矩阵表示为向量，具体可见Wikipedia。</p><p>另外，还有一些常用的，总结如下</p><p>1) $f(\mathrm x) = \mathrm A\mathrm x$，则</p><script type="math/tex;mode=display">
\frac{\partial f (\mathrm x)}{\partial \mathrm x^T}  = \frac{\partial (\mathrm A\mathrm x)}{\partial \mathrm x^T}  =\mathrm A</script><p>2) $f(\mathrm x) = \mathrm x^T\mathrm A\mathrm x$，则</p><script type="math/tex;mode=display">
\frac{\partial f (\mathrm x)}{\partial \mathrm x}  = \frac{\partial (\mathrm x^T\mathrm A\mathrm x)}{\partial \mathrm x}  =\mathrm A\mathrm x+\mathrm A^T\mathrm x</script><p>3) $f(\mathrm x) = \mathrm a^T\mathrm x$，则</p><script type="math/tex;mode=display">
\frac{\partial \mathrm a^T\mathrm x}{\partial \mathrm x}  = \frac{\partial \mathrm x^T\mathrm a}{\partial \mathrm x}  =\mathrm a</script><p>4) $f(\mathrm x) = \mathrm x^T\mathrm A\mathrm y$，则</p><script type="math/tex;mode=display">
\frac{\partial \mathrm x^T\mathrm A\mathrm y}{\partial \mathrm x}  = \mathrm A\mathrm y</script><script type="math/tex;mode=display">
\frac{\partial \mathrm x^T\mathrm A\mathrm y}{\partial\mathrm  A}  = \mathrm x\mathrm y^T</script><p>5)</p><script type="math/tex;mode=display">
df(\mathrm X) = tr((\frac{\partial f(\mathrm X)}{\partial \mathrm X})^T d \mathrm X)</script><p>6) 矩阵微分也满足线性法则、乘积法则。</p><p>7) 矩阵的逆的微分</p><script type="math/tex;mode=display">
d(\mathrm X^{-1}) = -\mathrm X^{-1}(d\mathrm X)\mathrm X^{-1}</script><h3 id="迹函数"><a href="#迹函数" class="headerlink" title="迹函数"></a>迹函数</h3><h4 id="迹函数相对于矩阵的梯度"><a href="#迹函数相对于矩阵的梯度" class="headerlink" title="迹函数相对于矩阵的梯度"></a>迹函数相对于矩阵的梯度</h4><script type="math/tex;mode=display">
\frac{\partial (tr (\mathrm Z\mathrm Z^T))}{\partial \mathrm Z}  = \frac{\partial (tr (\mathrm Z^T\mathrm Z))}{\partial \mathrm Z}  = 2\mathrm Z</script><h4 id="矩阵微分算子和迹算子的可交换性"><a href="#矩阵微分算子和迹算子的可交换性" class="headerlink" title="矩阵微分算子和迹算子的可交换性"></a>矩阵微分算子和迹算子的可交换性</h4><script type="math/tex;mode=display">
d(tr(\mathrm X)) = tr(d(\mathrm X)) = \sum\limits_{i=1}^{n} d\mathrm X_{ii}</script><h4 id="常见性质"><a href="#常见性质" class="headerlink" title="常见性质"></a>常见性质</h4><p>1)</p><script type="math/tex;mode=display">
\frac{\partial tr( \mathrm A )}{\partial  \mathrm A }  = I_{n\times n}</script><p>2)</p><script type="math/tex;mode=display">
\frac{\partial tr( \mathrm A  \mathrm B  )}{\partial  \mathrm A }  =  \mathrm B  ^T</script><p>3)</p><script type="math/tex;mode=display">
d(tr( \mathrm A  \mathrm X  \mathrm B  )) = tr( \mathrm A (d \mathrm X ) \mathrm B  ) = tr( \mathrm B   \mathrm A (dx))</script><script type="math/tex;mode=display">
\frac{\partial tr( \mathrm A  \mathrm X  \mathrm B  )}{\partial  \mathrm X }  = ( \mathrm B   \mathrm A )^T =  \mathrm A ^T \mathrm B  ^T</script><p>4)</p><script type="math/tex;mode=display">
d(tr( \mathrm A  \mathrm X ^{-1} \mathrm B  )) = tr( \mathrm A (d \mathrm X ^{-1}) \mathrm B  ) = -tr( \mathrm A  \mathrm X ^{-1}(d \mathrm X ) \mathrm X ^{-1} \mathrm B  ) = -tr( \mathrm X ^{-1} \mathrm B   \mathrm A  \mathrm X ^{-1}d \mathrm X )</script><script type="math/tex;mode=display">
\frac{\partial tr( \mathrm A  \mathrm X ^{-1} \mathrm B  )}{\partial  \mathrm X } = -( \mathrm X ^{-1} \mathrm B   \mathrm A  \mathrm X ^{-1})^T = - \mathrm X ^{-T} \mathrm A ^T \mathrm B  ^T \mathrm X ^{-T}</script><p>5)</p><script type="math/tex;mode=display">
\frac{\partial tr( \mathrm X ^T \mathrm X )}{\partial  \mathrm X }  = 2 \mathrm X</script><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><h4 id="行列式相对于矩阵的梯度"><a href="#行列式相对于矩阵的梯度" class="headerlink" title="行列式相对于矩阵的梯度"></a>行列式相对于矩阵的梯度</h4><script type="math/tex;mode=display">
\frac{\partial | \mathrm Z |}{\partial  \mathrm Z }   = | \mathrm Z |( \mathrm Z ^{-1})^T</script><h4 id="微分形式"><a href="#微分形式" class="headerlink" title="微分形式"></a>微分形式</h4><script type="math/tex;mode=display">
d| \mathrm X | = tr(| \mathrm X |  \mathrm X ^{-1} d \mathrm X )</script><h4 id="常见性质-1"><a href="#常见性质-1" class="headerlink" title="常见性质"></a>常见性质</h4><p>1)</p><script type="math/tex;mode=display">
\begin{align} d| \mathrm A  \mathrm X  \mathrm B  | &=& tr(| \mathrm A  \mathrm X  \mathrm B  | ( \mathrm A  \mathrm X  \mathrm B  )^{-1}d( \mathrm A  \mathrm X  \mathrm B  )) \nonumber\\&=& tr(| \mathrm A  \mathrm X  \mathrm B  | ( \mathrm A  \mathrm X  \mathrm B  )^{-1} \mathrm A (d \mathrm X ) \mathrm B  ) \nonumber\\&=& tr(| \mathrm A  \mathrm X  \mathrm B  |  \mathrm B  ( \mathrm A  \mathrm X  \mathrm B  )^{-1} \mathrm A (d \mathrm X ))\nonumber\end{align}</script><script type="math/tex;mode=display">
\frac{\partial | \mathrm A  \mathrm X  \mathrm B  |}{\partial  \mathrm X }   = | \mathrm A  \mathrm X  \mathrm B  | \mathrm A ^T( \mathrm B  ^T \mathrm X ^T \mathrm A ^T)^{-1} \mathrm B  ^T</script><p>2)</p><script type="math/tex;mode=display">
\frac{\partial | \mathrm X |}{\partial  \mathrm X } = | \mathrm X |  \mathrm X ^{-T}</script><p>3)</p><script type="math/tex;mode=display">
\frac{\partial | \mathrm X  \mathrm X ^T|}{\partial  \mathrm X } = 2| \mathrm X  \mathrm X ^T| ( \mathrm X  \mathrm X ^{T})^{-1} \mathrm X</script><h2 id="二范数求导"><a href="#二范数求导" class="headerlink" title="二范数求导"></a>二范数求导</h2><p>例如二范数$J=\frac{1}{2}||\mathrm a^L-\mathrm y||_2^2$，对$\mathrm a^L$求导，其中$\mathrm a^L$与$\mathrm y$均为$m$列向量。</p><p>则展开$J$可得：</p><script type="math/tex;mode=display">
J=\frac{1}{2} \sum_{i=1}^{m}(\mathrm a_i^L-\mathrm y_i)^2 \\
= \frac{1}{2} \left((\mathrm a_1^L-\mathrm y_1)^2+(\mathrm a_2^L-\mathrm y_2)^2+\cdots+(\mathrm a_m^L-\mathrm y_m)^2 \right)</script><p>对该式子对$a_1^L$求导，得到$a_1^L-y_1$，同理可对该式子对$a_i^L$分别求导得到$a_i^L-y_i$，所以$J$对$a^L$求导，结果为$a^L-y$。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/crazy_scott/article/details/80557814" target="_blank" rel="noopener">矩阵求导法则与性质</a><br><a href="https://www.jianshu.com/p/e818917ffd9d" target="_blank" rel="noopener">机器学习-矩阵求导</a><br><a href="https://www.cnblogs.com/pinard/p/10750718.html" target="_blank" rel="noopener">机器学习中的矩阵向量求导(一) 求导定义与求导布局</a><br><a href="https://www.cnblogs.com/pinard/p/10773942.html" target="_blank" rel="noopener">机器学习中的矩阵向量求导(二) 矩阵向量求导之定义法</a><br><a href="https://www.cnblogs.com/pinard/p/10791506.html" target="_blank" rel="noopener">机器学习中的矩阵向量求导(三) 矩阵向量求导之微分法</a><br><a href="https://www.cnblogs.com/pinard/p/10825264.html" target="_blank" rel="noopener">机器学习中的矩阵向量求导(四) 矩阵向量求导链式法则</a><br><a href="https://www.cnblogs.com/pinard/p/10930902.html" target="_blank" rel="noopener">机器学习中的矩阵向量求导(五) 矩阵对矩阵的求导</a><br><a href="https://zhuanlan.zhihu.com/p/24709748" target="_blank" rel="noopener">矩阵求导术（上）</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/Math/矩阵求导法则与性质/" title="矩阵求导法则与性质">https://www.zdaiot.com/Math/矩阵求导法则与性质/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/矩阵导数/" rel="tag"><i class="fa fa-tag"></i> 矩阵导数</a></div><div class="post-nav"><div class="post-nav-item"><a href="/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/" rel="prev" title="卷积神经网络前向与反向传播"><i class="fa fa-chevron-left"></i> 卷积神经网络前向与反向传播</a></div><div class="post-nav-item"> <a href="/MachineLearning/卷积神经网络/caffe imcol详解/" rel="next" title="caffe imcol详解">caffe imcol详解<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#求导定义与求导布局"><span class="nav-number">1.</span> <span class="nav-text">求导定义与求导布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵向量求导引入"><span class="nav-number">1.1.</span> <span class="nav-text">矩阵向量求导引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵向量求导定义"><span class="nav-number">1.2.</span> <span class="nav-text">矩阵向量求导定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分子布局与分母布局"><span class="nav-number">1.3.</span> <span class="nav-text">分子布局与分母布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵向量求导之定义法"><span class="nav-number">2.</span> <span class="nav-text">矩阵向量求导之定义法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用定义法求解标量对向量求导"><span class="nav-number">2.1.</span> <span class="nav-text">用定义法求解标量对向量求导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标量对向量求导的一些基本法则"><span class="nav-number">2.2.</span> <span class="nav-text">标量对向量求导的一些基本法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用定义法求解标量对矩阵求导"><span class="nav-number">2.3.</span> <span class="nav-text">用定义法求解标量对矩阵求导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用定义法求解向量对向量求导"><span class="nav-number">2.4.</span> <span class="nav-text">用定义法求解向量对向量求导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义法矩阵向量求导的局限"><span class="nav-number">2.5.</span> <span class="nav-text">定义法矩阵向量求导的局限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵向量求导之微分法"><span class="nav-number">3.</span> <span class="nav-text">矩阵向量求导之微分法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵微分"><span class="nav-number">3.1.</span> <span class="nav-text">矩阵微分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵微分的性质"><span class="nav-number">3.2.</span> <span class="nav-text">矩阵微分的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用微分法求解矩阵向量求导"><span class="nav-number">3.3.</span> <span class="nav-text">使用微分法求解矩阵向量求导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迹函数对向量矩阵求导"><span class="nav-number">3.4.</span> <span class="nav-text">迹函数对向量矩阵求导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微分法求导小结"><span class="nav-number">3.5.</span> <span class="nav-text">微分法求导小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵向量求导链式法则"><span class="nav-number">4.</span> <span class="nav-text">矩阵向量求导链式法则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向量对向量求导的链式法则"><span class="nav-number">4.1.</span> <span class="nav-text">向量对向量求导的链式法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标量对多个向量的链式求导法则"><span class="nav-number">4.2.</span> <span class="nav-text">标量对多个向量的链式求导法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标量对多个矩阵的链式求导法则"><span class="nav-number">4.3.</span> <span class="nav-text">标量对多个矩阵的链式求导法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵向量求导小结"><span class="nav-number">4.4.</span> <span class="nav-text">矩阵向量求导小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵对矩阵的求导"><span class="nav-number">5.</span> <span class="nav-text">矩阵对矩阵的求导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵对矩阵求导的定义"><span class="nav-number">5.1.</span> <span class="nav-text">矩阵对矩阵求导的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵对矩阵求导的微分法"><span class="nav-number">5.2.</span> <span class="nav-text">矩阵对矩阵求导的微分法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵对矩阵求导实例"><span class="nav-number">5.3.</span> <span class="nav-text">矩阵对矩阵求导实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵对矩阵求导小结"><span class="nav-number">5.4.</span> <span class="nav-text">矩阵对矩阵求导小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用结论"><span class="nav-number">6.</span> <span class="nav-text">常用结论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实值函数相对于实向量的梯度"><span class="nav-number">6.1.</span> <span class="nav-text">实值函数相对于实向量的梯度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迹函数"><span class="nav-number">6.2.</span> <span class="nav-text">迹函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迹函数相对于矩阵的梯度"><span class="nav-number">6.2.1.</span> <span class="nav-text">迹函数相对于矩阵的梯度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵微分算子和迹算子的可交换性"><span class="nav-number">6.2.2.</span> <span class="nav-text">矩阵微分算子和迹算子的可交换性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见性质"><span class="nav-number">6.2.3.</span> <span class="nav-text">常见性质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行列式"><span class="nav-number">6.3.</span> <span class="nav-text">行列式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#行列式相对于矩阵的梯度"><span class="nav-number">6.3.1.</span> <span class="nav-text">行列式相对于矩阵的梯度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#微分形式"><span class="nav-number">6.3.2.</span> <span class="nav-text">微分形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见性质-1"><span class="nav-number">6.3.3.</span> <span class="nav-text">常见性质</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二范数求导"><span class="nav-number">7.</span> <span class="nav-text">二范数求导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">313</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">53</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">369</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2.1m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">31:16</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '71017138c5eb7ba0f643aab7bd653a35',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>