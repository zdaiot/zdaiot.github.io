<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="首先，该文章来自于极客时间网站，王争的专栏——《数据结构与算法之美》，我这里只是做简单的解释、记录并添加自己的见解，只是作为个人笔记，若侵权，马上删除。最后建议直接去该网站上购买该课程看原作者的讲解，一来是支持作者，二来是作者写的确实不错。 我们知道，二分查找要依赖于数组的随机访问特性，那么如果数据存储在链表中怎么使用二分查找呢？这就需要将链表进行改造，使其支持二分查找。改造后的数据结构称为”跳表"><meta name="keywords" content="跳表"><meta property="og:type" content="article"><meta property="og:title" content="16跳表：为什么Redis一定要用跳表来实现有序集合"><meta property="og:url" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="首先，该文章来自于极客时间网站，王争的专栏——《数据结构与算法之美》，我这里只是做简单的解释、记录并添加自己的见解，只是作为个人笔记，若侵权，马上删除。最后建议直接去该网站上购买该课程看原作者的讲解，一来是支持作者，二来是作者写的确实不错。 我们知道，二分查找要依赖于数组的随机访问特性，那么如果数据存储在链表中怎么使用二分查找呢？这就需要将链表进行改造，使其支持二分查找。改造后的数据结构称为”跳表"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/e18303fcedc068e5a168de04df956f6d.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/14753c824a5ee4a976ea799727adc78e.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/492206afe5e2fef9f683c7cff83afa65.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/46d283cd82c987153b3fe0c76dfba8a9.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/d03bef9a64a0368e6a0d23ace8bd450c.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/100e9d6e5abeaae542cf7841be3f8255.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/0b0680ecf500f9349fc142e1a9eb73f7.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/192c480664e35591360cee96ff2f8395.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/65379f0651bc3a7cfd13ab8694c4d26c.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/c863074c01c26538cf0134eaf8dc67c5.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/a861445d0b53fc842f38919365b004a7.jpg"><meta property="og:updated_time" content="2020-01-15T15:41:03.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="16跳表：为什么Redis一定要用跳表来实现有序集合"><meta name="twitter:description" content="首先，该文章来自于极客时间网站，王争的专栏——《数据结构与算法之美》，我这里只是做简单的解释、记录并添加自己的见解，只是作为个人笔记，若侵权，马上删除。最后建议直接去该网站上购买该课程看原作者的讲解，一来是支持作者，二来是作者写的确实不错。 我们知道，二分查找要依赖于数组的随机访问特性，那么如果数据存储在链表中怎么使用二分查找呢？这就需要将链表进行改造，使其支持二分查找。改造后的数据结构称为”跳表"><meta name="twitter:image" content="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/e18303fcedc068e5a168de04df956f6d.jpg"><link rel="canonical" href="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>16跳表：为什么Redis一定要用跳表来实现有序集合 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 16跳表：为什么Redis一定要用跳表来实现有序集合<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-01-15 23:41:03" itemprop="dateCreated datePublished" datetime="2020-01-15T23:41:03+08:00">2020-01-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DataStructureAlgorithm/" itemprop="url" rel="index"><span itemprop="name">DataStructureAlgorithm</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.2k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>首先，该文章来自于极客时间网站，王争的专栏——《数据结构与算法之美》，我这里只是做简单的解释、记录并添加自己的见解，只是作为个人笔记，若侵权，马上删除。最后建议直接去该网站上购买该课程看原作者的讲解，一来是支持作者，二来是作者写的确实不错。</p><p>我们知道，二分查找要依赖于数组的随机访问特性，那么如果数据存储在链表中怎么使用二分查找呢？这就需要将链表进行改造，使其支持二分查找。改造后的数据结构称为<strong>”跳表“（Skip list）</strong>。它是一种各方面性能都比较优秀的动态数据结构，可以支持<strong>快速的插入、删除、查找操作</strong>，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。</p><p>Redis（Key-Value数据库） 中的有序集合（Sorted Set）就是用跳表来实现的。通过后面的讲解我们会知道，红黑树也可以实现快速的插入、删除和查找操作。那 Redis 为什么会选择用跳表来实现有序集合呢？ 为什么不用红黑树呢？</p><h2 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h2><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/e18303fcedc068e5a168de04df956f6d.jpg" alt="img" style="zoom:60%"></p><p>那怎么提高查找效率呢？我们可以对链表建立一级“索引”，每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做索引或者索引层。如下图所示，down 表示 down指针，指向下一级结点。</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/14753c824a5ee4a976ea799727adc78e.jpg" alt="img" style="zoom:60%"></p><p>如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们<strong>通过索引层结点的 down 指针，下降到原始链表这一层</strong>，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。</p><p>因此，加了一层索引后，查找一个结点需要遍历的结点个数减少了，也就是查找效率提高了。那如果再加一级索引呢？</p><p>跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在我们再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/492206afe5e2fef9f683c7cff83afa65.jpg" alt="img" style="zoom:60%"></p><p>再举一个数据量很大的例子，如下图为一个结点为64的链表，建立五级索引。</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/46d283cd82c987153b3fe0c76dfba8a9.jpg" alt="img" style="zoom:60%"></p><p>从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点。当链表的长度 n 比较大时，比如1000,10000的时候，在构建索引之后，查找效率的提升会非常明显。</p><p>这种<strong>链表加多级索引的结构，就是跳表。</strong></p><h2 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h2><p>首先我们思考一个问题：如果链表里有 n 个结点，会有多少级索引呢？</p><p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是$n/(2^k)$。</p><p>假设索引有 h 级，<strong>最高级的索引有 2 个结点</strong>。通过上面的公式，我们可以得到 $n/(2^h)=2$，从而求得 $h=log_2n-1$。如果包含原始链表这一层，整个跳表的高度就是 $log_2n$。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 $O(m*logn)$。</p><p>按照前面这种索引结构，我们每一级索引都<strong>最多只需要遍历 3 个结点</strong>，也就是说 m=3，为什么是 3 呢？假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，<strong>每一级索引都最多只需要遍历 3 个结点。</strong></p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/d03bef9a64a0368e6a0d23ace8bd450c.jpg" alt="img" style="zoom:60%"></p><p>通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 $O(logn)$。这个查找的时间复杂度跟二分查找是一样的。不过这个查询效率的提升，是拿空间换时间得到的。</p><h2 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h2><p>下面我们分析下跳表的空间复杂度。跳表的空间复杂度分析并不难，我在前面说了，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/100e9d6e5abeaae542cf7841be3f8255.jpg" alt="img" style="zoom:60%"></p><p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，<strong>跳表的空间复杂度是 O(n)</strong>。也就是说，<strong>如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。</strong></p><p>如果我们每三个节点或者每五个节点抽一个节点到上级检索，就可以减少所占的存储空间了。如下图所示：</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/0b0680ecf500f9349fc142e1a9eb73f7.jpg" alt="img" style="zoom:60%"></p><p>从图中可以看出，第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。为了方便计算，我们假设最高一级的索引结点个数是 1。我们把每级索引的结点个数都写下来，也是一个等比数列。</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/192c480664e35591360cee96ff2f8395.jpg" alt="img" style="zoom:60%"></p><p>通过等比数列求和公式，总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。<strong>尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</strong></p><p>在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 $O(logn)$。</p><p>对于插入操作，在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是，这里<strong>为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。</strong></p><p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 $O(logn)$，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 $O(logn)$。如下图所示：</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/65379f0651bc3a7cfd13ab8694c4d26c.jpg" alt="img" style="zoom:60%"></p><p>对于删除操作<strong>，如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。</strong>因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以<strong>在查找要删除的结点的时候，一定要获取前驱结点。</strong>当然，如果我们用的是双向链表，就不需要考虑这个问题了。</p><h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/c863074c01c26538cf0134eaf8dc67c5.jpg" alt="img" style="zoom:60%"></p><p>作为一种动态数据结构，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p><p>对于后面要讲的红黑树、AVL 树这样平衡二叉树，是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过<strong>随机函数</strong>来维护前面提到的“平衡性”。</p><p>当我们往跳表中插入数据的时候，通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到<strong>第一级到第 K 级这 K 级</strong>索引中。</p><p><img src="/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/a861445d0b53fc842f38919365b004a7.jpg" alt="img" style="zoom:60%"></p><p>随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。至于随机函数的选择，如果你感兴趣的话，可以看看作者在 GitHub 上的代码或者 Redis 中关于有序集合的跳表实现。跳表的实现比较复杂， 但是实现并不是本节的重点，不用死记硬背代码。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>现在我们思考下开篇的问题：为什么 Redis 要用跳表来实现有序集合，而不是红黑树？</p><p>Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。不过散列表暂时没有学过，所以先忽略。Redis 中的有序集合支持的核心操作主要有下面这几个：</p><ul><li>插入一个数据；</li><li>删除一个数据；</li><li>查找一个数据；</li><li>按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；</li><li>迭代输出有序序列</li></ul><p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，<strong>按照区间来查找数据这个操作，红黑树的效率没有跳表高。</strong></p><p>对于按照区间查找数据这个操作，<strong>跳表可以做到 O(logn) 的时间复杂度定位区间的起点</strong>，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</p><p>当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，<strong>跳表更容易代码实现</strong>。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，<strong>跳表更加灵活</strong>，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p><p>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。实际中的红黑树可以直接拿来使用，但是对于跳表，要自己实现。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>跳表使用<strong>空间换时间</strong>的设计思路，通过构建<strong>多级索引</strong>来提高查询的效率，实现了<strong>基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)。</strong></p><p><strong>跳表的空间复杂度是 O(n)。</strong>不过，跳表的实现非常灵活，可以通过<strong>改变索引构建策略，有效平衡执行效率和内存消耗。</strong>虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们<strong>为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</strong></p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>如果每三个或者五个结点提取一个结点作为上级索引，对应的在跳表中查询数据的时间复杂度是多少呢？</p><p>答：时间复杂度应该不变，还是O(logn)。假设每 5 个节点提取，那么<strong>最高一层有 5 个节点</strong>，而跳表高度为 $log_5n$，每层最多需要查找 6 个节点，即 $O(mlog_5n)$ 中的 $m = 6$。最终，时间复杂度为 $O(log_5n)$。空间复杂度为 $O(n)$，虽然省去了一部分索引节点，但是似乎意义不大。</p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/" title="16跳表：为什么Redis一定要用跳表来实现有序集合">https://www.zdaiot.com/DataStructureAlgorithm/16跳表：为什么Redis一定要用跳表来实现有序集合/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/跳表/" rel="tag"><i class="fa fa-tag"></i> 跳表</a></div><div class="post-nav"><div class="post-nav-item"><a href="/DataStructureAlgorithm/15二分查找（下）：如何快速定位IP对应的省份地址/" rel="prev" title="15二分查找（下）：如何快速定位IP对应的省份地址"><i class="fa fa-chevron-left"></i> 15二分查找（下）：如何快速定位IP对应的省份地址</a></div><div class="post-nav-item"> <a href="/DataStructureAlgorithm/17散列表（上）：Word文档中的单词拼写检查功能是如何实现的/" rel="next" title="17散列表（上）：Word文档中的单词拼写检查功能是如何实现的">17散列表（上）：Word文档中的单词拼写检查功能是如何实现的<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何理解“跳表”？"><span class="nav-number">1.</span> <span class="nav-text">如何理解“跳表”？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用跳表查询到底有多快？"><span class="nav-number">2.</span> <span class="nav-text">用跳表查询到底有多快？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳表是不是很浪费内存？"><span class="nav-number">3.</span> <span class="nav-text">跳表是不是很浪费内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高效的动态插入和删除"><span class="nav-number">4.</span> <span class="nav-text">高效的动态插入和删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳表索引动态更新"><span class="nav-number">5.</span> <span class="nav-text">跳表索引动态更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答开篇"><span class="nav-number">6.</span> <span class="nav-text">解答开篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内容小结"><span class="nav-number">7.</span> <span class="nav-text">内容小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#课后思考"><span class="nav-number">8.</span> <span class="nav-text">课后思考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">324</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">56</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">381</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2.3m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">34:13</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '2841d491b27f8316bbd22ee2a09d4273',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>