<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="二叉树二叉树遍历模板 前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点  注意点：  以根访问顺序决定是什么遍历  左子树都是优先右子树"><meta name="keywords" content="数据结构,算法"><meta property="og:type" content="article"><meta property="og:title" content="LeetCode总结"><meta property="og:url" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="二叉树二叉树遍历模板 前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点  注意点：  以根访问顺序决定是什么遍历  左子树都是优先右子树"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/5389db651086bd4bcd42dd5c4552f180b553a9b204cfc1013523dfe09beac382-1.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/db22bdb60035e45f8c354b3f45f2a844260d6cafcf81528d2c4f1b51e484fb45-2.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/2036dfe7e991f00dfb788a9b84a17bb6fac337e81c09bdf57e683d028a6952bc-未命名文件.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/360dbd3b89c25324287f4cef2c22ba8a20e946891ac887f70703b211893aafa0-5.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/b531fb496fd478a2db6ba7bc805cda08b825771817dd24cdd616946a89800fbb-6.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/9b5c6e99aa89284c8a7b423bc36fec7af39fac3f8bb709e77483e574e02ef1cd-7.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/5b578a2e33a4f87536c7fe50f71ac01904ae689b26ee3e2751dac0144f009d77-8.jpg"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/441ac778821dc26689b31466bced9f61ec241f092bf7e4f0f8699ef4fa3be1b2-1559826097853.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/xor.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/three.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/1598143339-uPRKJZ-image.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/33834ed636a0fcd634b0b790cb6a096ac935b3a0d4159e32259638d19c73dd3d-捕获5.PNG"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/4e410caf37485a65a95b6af228b564464099cf430ca695872125f0b13a147b19-捕获6.PNG"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/image-20200910195806939.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/309271bd1f94c57fd4e19f5eee624dd2ad3ef8e4d5a3b6eca5556e9f2e43a3bc-file_1576477912310"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/17_telephone_keypad.png"><meta property="og:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/b581bdde1cef982f0af3182af17fc3c41960c76a7445af0dcfd445c89b4c2eaa-「力扣」第%2093%20题：复原%20IP%20地址-1.png"><meta property="og:updated_time" content="2020-07-24T02:08:47.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="LeetCode总结"><meta name="twitter:description" content="二叉树二叉树遍历模板 前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点  注意点：  以根访问顺序决定是什么遍历  左子树都是优先右子树"><meta name="twitter:image" content="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image.png"><link rel="canonical" href="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>LeetCode总结 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> LeetCode总结<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/DataStructureAlgorithm/LeetCode总结.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-07-24 10:08:47" itemprop="dateCreated datePublished" datetime="2020-07-24T10:08:47+08:00">2020-07-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DataStructureAlgorithm/" itemprop="url" rel="index"><span itemprop="name">DataStructureAlgorithm</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>36k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>33 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树遍历模板"><a href="#二叉树遍历模板" class="headerlink" title="二叉树遍历模板"></a>二叉树遍历模板</h3><ol><li><strong>前序遍历</strong>：<strong>先访问根节点</strong>，再前序遍历左子树，再前序遍历右子树</li><li><strong>中序遍历</strong>：先中序遍历左子树，<strong>再访问根节点</strong>，再中序遍历右子树</li><li><strong>后序遍历</strong>：先后序遍历左子树，再后序遍历右子树，<strong>再访问根节点</strong></li></ol><p>注意点：</p><ol><li><p>以根访问顺序决定是什么遍历</p></li><li><p>左子树都是优先右子树</p></li></ol><p>练习：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>递归法三要素：</p><ol><li>确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型；</li><li>确定终止条件；</li><li>确定单层递归逻辑：这里需要假定嵌套问题已经解决了。</li></ol><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>前序遍历（迭代法）不难写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        TreeNode* node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) result.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        st.push(node-&gt;right);  <span class="comment">// 栈是先进后出，访问顺序是根左右，所以先让右节点入栈</span></span><br><span class="line">        st.push(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用迭代法很难写出统一的模板，在迭代过程中，有两个操作，<strong>一个是处理：将元素放进result数组中，一个是访问：遍历节点。</strong>前序遍历的顺序是中左右，要先访问的元素是中间节点，要处理的元素也是中间节点，要访问的元素和要处理的元素顺序是一致的，都是中间节点，所以才能写出相对简洁的代码。</p><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><p>中序遍历，可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;  <span class="comment">// 一层一层的向下访问，直到树左边的底层</span></span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// </span></span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/DataStructureAlgorithm/LeetCode总结/4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image.png" alt="4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image" style="zoom:50%"></p><p>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        TreeNode* node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) result.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        st.push(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序</span></span><br><span class="line">        st.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(result.begin(), result.end()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h4><blockquote><p>给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><p>该题目可以使用递归的方法解决，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftD, rightD;</span><br><span class="line">    <span class="keyword">if</span>(isBalancedCore(root-&gt;left, leftD) &amp;&amp; isBalancedCore(root-&gt;right, rightD)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(leftD-rightD) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            depth = <span class="number">1</span> + (leftD &gt; rightD?leftD:rightD);</span><br><span class="line">            <span class="comment">// depth = max(leftD, rightD) + 1;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth;</span><br><span class="line">    <span class="keyword">return</span> isBalancedCore(root, depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/" target="_blank" rel="noopener">彻底吃透前中后序递归法（递归三部曲）和迭代法（不统一写法与统一写法）</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>链表代码经常考察点在于指针的理解，也就是<code>NULL</code>指针的处理，比如说有一个结构体<code>Node</code>，结构体指针为<code>node*</code>，访问结构体成员变量<code>node-&gt;val</code>的时候，要先判断<code>node</code>是否等于<code>NULL</code>。</p><p>常用技巧：</p><ol><li>设置哑点可以简化很多判断和处理</li><li>快慢指针、双指针的使用</li><li>得到链表的中心节点之后翻转链表（可以翻转前半部分，也可以翻转后半部分。翻转前半部分指针代码更加简单）</li></ol><p>这里补充一个常用代码，链表借助双指针，找到中间节点<code>slow</code>，若链表为偶数个元素，则<code>slow</code>节点在前半段的最后一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow, fast = head, head.next</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">	fast, slow = fast.next.next, slow.next</span><br></pre></td></tr></table></figure><p>若写成下面形式，则若链表为偶数个元素，则<code>slow</code>节点在后半段的第一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow, fast = head, head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">	fast, slow = fast.next.next, slow.next</span><br></pre></td></tr></table></figure><h3 id="常见题目-1"><a href="#常见题目-1" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></h4><blockquote><p>给定一个<strong>排序</strong>链表，删除所有重复的元素，使得每个元素只出现一次。</p></blockquote><p>这个题目需要使用双指针的方法，一个指针记录前一个指针，一个指针记录当前遍历到的指针。若两个指针的元素值相同，则删除当前节点，否则的话，更新两个指针。</p><p>参考代码如下。为了简化代码，这里使用了<code>cur</code>和<code>cur-&gt;next</code>代替双指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">        <span class="comment">// 如果节点值相同</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;   <span class="comment">// 不需要更新cur指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></h4><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p></blockquote><p>这个题目和上一个题目的区别在于，上一个题目重复出现的只保留一个，而这里重复出现的数字则需要全部删除。</p><p>首先，在上一个题目中首节点是不可能被删除的，而在本题目中首节点是有可能被删除的，所以需要借助<strong>哑点</strong>处理。另外需要删除所有重复的数字，刚拿到题目的思路是采用三指针的方法，但是这种方法的容易出错并且代码比较复杂。</p><p>因此可以换一种思路，我们使用双指针法，指针<code>l</code>记录左节点，指针<code>r</code>记录右节点。每次循环的时候，初始化<code>l=r</code>，若<code>l-&gt;val=r-&gt;val</code>则不断向后移动<code>r</code>指针。</p><ol><li>若<code>l-&gt;next==r</code>，则说明<code>l-&gt;val</code>肯定是唯一的，将<code>l</code>指针放到结果中，但此时<code>r-&gt;val</code>不一定是唯一的，所以重新初始化<code>l=r</code>；</li><li>若<code>l-&gt;next!=r</code>，则说明<code>l</code>到<code>r-&gt;pre</code>之间所有的值都是重复的，不更新结果，同样此时<code>r-&gt;val</code>不一定是唯一的，所以重新初始化<code>l=r</code>；</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;        </span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);  <span class="comment">// 哑点</span></span><br><span class="line">    ListNode* node = dummy;</span><br><span class="line">    </span><br><span class="line">    ListNode* r = head;</span><br><span class="line">    <span class="keyword">for</span>(ListNode* l=head; l!=<span class="literal">NULL</span>; l=r) &#123;  <span class="comment">// 不管l节点是不是唯一，r节点是否唯一都不能得到结论，所以更新l=r</span></span><br><span class="line">        <span class="keyword">while</span>(r &amp;&amp; l-&gt;val==r-&gt;val) r = r-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;next == r) &#123;  <span class="comment">// 若满足则说明l节点肯定是唯一的，不能用r-l==1，因为两个都是表示地址</span></span><br><span class="line">            node-&gt;next = l;  <span class="comment">// 将l指针添加到最后结果中</span></span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 不要忘记置为NULL，否则结果会混乱</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h4><blockquote><p>反转一个单链表。</p></blockquote><p>该题是典型的双指针题目，需要用一个<code>pre</code>指针记录前一个节点，一个<code>node</code>指针记录当前节点。这里需要注意的地方是<code>pre</code>指针的初始化特别重要，需要初始化为<code>pre=NULL</code>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pNode = head;</span><br><span class="line">    ListNode* pPre = <span class="literal">NULL</span>;  <span class="comment">// 这个初始化很重要</span></span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">        ListNode* pNext = pNode-&gt;next;  <span class="comment">// 记录下一个节点          </span></span><br><span class="line">        pNode-&gt;next = pPre;</span><br><span class="line">        pPre = pNode;</span><br><span class="line">        pNode = pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pPre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></h4><blockquote><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。<strong>说明:</strong>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。也就是说 <em>m</em> 和 <em>n</em> 的下标都是从1开始的。</p></blockquote><p>这个题目有一个要求就是一趟扫描完成反转。定义两个指针，分别为<code>g</code>（guard）和<code>p</code>（point）。首先根据参数<code>m</code>确定<code>g</code>和<code>p</code>的位置。将<code>g</code>移动到第一个要反转的节点前面，将<code>p</code>移动到第一个要反转的节点位置上。以<code>m=2,n=4</code>为例：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/5389db651086bd4bcd42dd5c4552f180b553a9b204cfc1013523dfe09beac382-1.png" alt="5389db651086bd4bcd42dd5c4552f180b553a9b204cfc1013523dfe09beac382-1"></p><p>然后使用头插法，将<code>p</code>后面的元素删除，然后添加到<code>g</code>的后面，重复该步骤。如下图所示：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/db22bdb60035e45f8c354b3f45f2a844260d6cafcf81528d2c4f1b51e484fb45-2.png" alt="db22bdb60035e45f8c354b3f45f2a844260d6cafcf81528d2c4f1b51e484fb45-2" style="zoom:67%"></p><p>最后返回<code>dummyHead-&gt;next</code>。</p><p>这里需要注意的是，根据<code>m</code>是否等于1，返回的结果是不一样的。为了避免对这些情况进行分类讨论，可以借助哑点。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    ListNode* g = dummyHead;</span><br><span class="line">    ListNode* p = dummyHead-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>; i++) &#123; <span class="comment">// 将g移动到第一个要反转的节点的前面，将p移动到第一个要反转的节点的位置上</span></span><br><span class="line">        g = g-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-m; i++) &#123;  <span class="comment">// 由上图可得知，并不需要更新g、p指针</span></span><br><span class="line">        ListNode* removed = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        removed-&gt;next = g-&gt;next;  <span class="comment">// 注意这个地方不能直接等于p，画到第二次循环即可明白</span></span><br><span class="line">        g-&gt;next = removed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h4><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p></blockquote><p>这个一个很典型的需要借助哑点来简化代码的题目。思想比较简单，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">        cur-&gt;next = l2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur-&gt;next = l1;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></h4><blockquote><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。你应当保留两个分区中每个节点的初始相对位置。</p></blockquote><p>这个题目可以使用双哑点指针解决。</p><p>参考代码如下，这里需要注意的是，因为涉及到节点的拼接，所以要避免陷入死循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* little = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* big = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* node1 = little;</span><br><span class="line">    ListNode* node2 = big;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val &lt; x) &#123;</span><br><span class="line">            node1-&gt;next = head;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node2-&gt;next = head;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node2-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 避免返回结果的时候陷入死循环</span></span><br><span class="line">    node1-&gt;next = big-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> little-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></h4><blockquote><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p></blockquote><p>题目要求时间空间复杂度分别为$O(nlogn)$和$O(1)$，根据时间复杂度我们自然想到二分法，从而联想到归并排序（快速排序平均时间复杂度为$O(nlogn)$ ）；对数组进行归并排序的空间复杂度为$O(n)$，分别由新开辟数组$O(n)$和递归函数调用$O(logn)$组成，而根据链表特性：</p><ol><li>数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间</li><li>递归额外空间：递归调用函数将带来$O(logn)$的空间复杂度，若希望达到$O(1)$空间复杂度，则不能使用递归</li></ol><p>为了方便理解，先阐述一下基于<strong>递归方法</strong>的思路：</p><p><strong>分割环节：</strong>找到当前链表中点，并从中点将链表断开</p><ul><li>使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</li><li>找到中点 slow 后，执行 slow.next = None <strong>将链表切断</strong>。</li><li>递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。</li><li>cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。</li></ul><p><strong>合并环节：</strong>将两个排序链表合并，转化为一个排序链表。</p><ul><li>双指针法合并，建立辅助ListNode h 作为头部。</li><li>设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li><li>返回辅助ListNode h 作为头部的下个节点 h.next。</li><li>时间复杂度 O(l + r)，l, r 分别代表两个链表长度。</li></ul><p><strong>当题目输入的 <code>head == None</code> 时，直接返回None。</strong></p><p>示意图如下：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png" alt="Picture2.png" style="zoom:50%"></p><p>接下来阐述一下<strong>基于循环</strong>的方式，也就是<strong>从底至顶直接合并</strong>。需要使用迭代的方式替换上述<strong>分割环节</strong>，该环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。</p><p>每一轮合并merge操作针对的单元都有固定长度intv，例如：</p><ul><li>第一轮合并时intv = 1，即将整个链表切分为多个长度为1的单元，并按顺序两两排序合并，合并完成的已排序单元长度为2。</li><li>第二轮合并时intv = 2，即将整个链表切分为多个长度为2的单元，并按顺序两两排序合并，合并完成已排序单元长度为4。</li><li>以此类推，直到单元长度intv &gt;= 链表长度，代表已经排序完成。</li></ul><p>根据以上推论，我们可以仅根据intv计算每个单元边界，并完成链表的每轮排序合并，例如:</p><ul><li>当intv = 1时，将链表第1和第2节点排序合并，第3和第4节点排序合并，……。</li><li>当intv = 2时，将链表第1-2和第3-4节点排序合并，第5-6和第7-8节点排序合并，……。</li><li>当intv = 4时，将链表第1-4和第5-8节点排序合并，第9-12和第13-16节点排序合并，……。</li></ul><p>此方法时间复杂度$O(nlogn)$，空间复杂度$O(1)$。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png" alt="Picture1.png" style="zoom:50%"></p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);  <span class="comment">// 设置哑点</span></span><br><span class="line">    res-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前每个组别的长度</span></span><br><span class="line">    <span class="keyword">int</span> intv = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(intv &lt; length) &#123;</span><br><span class="line">        <span class="comment">// h用于遍历，注意这次每次都需要这样的初始化，res每次也会更新，其next指向排序后的第一个指针</span></span><br><span class="line">        ListNode* pre = res;</span><br><span class="line">        ListNode* h = res-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两两一组的遍历各个小块，当h为空的时候，加大intv</span></span><br><span class="line">        <span class="keyword">while</span>(h) &#123;</span><br><span class="line">            <span class="comment">// h1是第一个块的开头，h2是第二个块的开头</span></span><br><span class="line">            ListNode* h1 = h;</span><br><span class="line">            <span class="comment">// 向前移动intv个，得到第二个块的开头h</span></span><br><span class="line">            <span class="keyword">int</span> i = intv;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; h) &#123;</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) </span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 此时第二个块没有值，也就可以删除了</span></span><br><span class="line">        </span><br><span class="line">            i = intv;</span><br><span class="line">            ListNode* h2 = h;</span><br><span class="line">            <span class="comment">// 得到第三个块的开始坐标h，方便接下来的循环</span></span><br><span class="line">            <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; h) &#123;</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始进行合并，注意这里循环的时候不能够使用h1和h2，因为并没有截断</span></span><br><span class="line">            <span class="keyword">int</span> c1 = intv;</span><br><span class="line">            <span class="keyword">int</span> c2 = intv - i; <span class="comment">// c2的长度可能比intv短</span></span><br><span class="line">            <span class="keyword">while</span>(c1&gt;<span class="number">0</span> &amp;&amp; c2&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(h1-&gt;val &lt; h2-&gt;val) &#123;</span><br><span class="line">                    pre-&gt;next = h1;</span><br><span class="line">                    h1 = h1-&gt;next;</span><br><span class="line">                    c1--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre-&gt;next = h2;</span><br><span class="line">                    h2 = h2-&gt;next;</span><br><span class="line">                    c2--;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有一方有剩余</span></span><br><span class="line">            <span class="keyword">if</span>(c1&gt;<span class="number">0</span>) </span><br><span class="line">                pre-&gt;next = h1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c2&gt;<span class="number">0</span>) </span><br><span class="line">                pre-&gt;next = h2;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 排序好的链表末尾指针pre的next指向第三块的开始坐标</span></span><br><span class="line">            <span class="keyword">while</span>(c1&gt;<span class="number">0</span> || c2&gt;<span class="number">0</span>) &#123;  </span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                c1--;</span><br><span class="line">                c2--;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = h;</span><br><span class="line">        &#125;</span><br><span class="line">        intv *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></h4><blockquote><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></blockquote><p>这个题目根据一头一尾取元素的特性。可以分为三个步骤：</p><ol><li>将链表平均分为两半，并从中间截断，防止陷入死循环</li><li>将第二个链表逆序</li><li>依次连接两个链表</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* slow = head;  <span class="comment">// slow指向的是中间元素</span></span><br><span class="line">    ListNode* fast = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* mid = slow-&gt;next;  <span class="comment">// mid指向第二个链表的首元素</span></span><br><span class="line">    slow-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 进行截断，防止陷入死循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 旋转后面的链表，最终pre指向旋转后首元素</span></span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 这个初始化需要注意</span></span><br><span class="line">    <span class="keyword">while</span>(mid) &#123;</span><br><span class="line">        ListNode* third = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = pre;</span><br><span class="line">        pre = mid;</span><br><span class="line">        mid = third;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始进行拼接操作</span></span><br><span class="line">    ListNode* node = head;</span><br><span class="line">    <span class="keyword">while</span>(pre) &#123;</span><br><span class="line">        ListNode* third = node-&gt;next;</span><br><span class="line">        node-&gt;next = pre;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;next = third;</span><br><span class="line">        node = third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h4><blockquote><p>给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。如果链表中存在环，则返回 true 。 否则，返回 false 。请尝试使用 <em>O(1)</em>（即，常量）内存解决此问题。</p></blockquote><p>这个题目可以使用快慢指针的方法，若链表中存在环，则快慢指针肯定存在相等的情况，否则的话肯定不存在环。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head-&gt;next;  <span class="comment">// 访问肯定不会报错，但是不是NULL就不一定了</span></span><br><span class="line">    <span class="keyword">while</span>(fast!=slow) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="comment">// 肯定不存在环了</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h4><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。</p></blockquote><p>这个题目和上一个题目的区别在于本题目不仅要判断是不是有环，而且要得到入环的第一个节点。</p><p>阶段一：判断存在环；阶段二：找到环的入口，下面对第二个阶段进行讨论。</p><p>当环很大的时候，这个过程用示意图表示如下图所示。其实这个结论对于环很小的时候也适用。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/2036dfe7e991f00dfb788a9b84a17bb6fac337e81c09bdf57e683d028a6952bc-未命名文件.png" alt="未命名文件.png"></p><p>为了更加严谨的证明这个结论，我们不对环的大小进行限制进行讨论。</p><ol><li>假设链表共有 <em>a</em>+<em>b</em> 个节点，其中 <strong>链表头部到链表入口</strong> 有 <em>a</em> 个节点（不计链表入口节点）， <strong>链表环</strong> 有 <em>b</em> 个节点。设快慢指针分别走了$f,s$步，则在两个指针<strong>第一次相遇</strong>有：<ul><li>fast指针走的是slow步数的两倍，即$f=2s$</li><li>fast比slow<strong>多走了</strong>$n$个环的长度，即$f=s+nb$；（ 双指针都走过 <em>a</em> 步，然后在环内绕圈直到重合，重合时 <code>fast</code> 比 <code>slow</code> 多走 <strong>环的长度整数倍</strong> ）</li><li>以上两式相减得：$f=2nb,s=nb$，即<code>fast</code>和<code>slow</code> 指针分别走了 2<em>n</em>，<em>n</em> 个 <strong>环的周长</strong> （注意： <em>n</em> 是未知数，不同链表的情况不同）</li></ul></li><li>此时，若让指针从链表头部一直向前走并统计步数$k$，那么所有走到链表入口节点时的步数是：$k=a+nb$（先走 $a$ 步到入口节点，之后每绕 1 圈环（ $b$ 步）都会再次到入口节点）。而目前slow指针已经走了$nb$步了，只需要再走$a$步停下来即为环的入口。但是此时不知道$a$的值，所以仍然使用双指针法，让另外一个指针从链表头部出发，与slow一起向前走$a$步后，两者在入口节点重合。</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre=head, *post=head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(post==<span class="literal">NULL</span> || post-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 肯定不存在环</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        post = post-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(pre == post)  <span class="comment">// 第一次相遇停止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="keyword">while</span>(pre != post) &#123;  <span class="comment">// 再次相遇停止</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        post = post-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></h4><blockquote><p>请判断一个链表是否为回文链表。你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p></blockquote><p>若想使用$O(1)$的空间复杂度解决这个题目，可以使用<strong>快慢指针遍历的同时翻转前半部分，然后与后半部分比较即可。</strong>这个技巧也经常被其他题目使用。</p><p>值得注意的是，这里将<code>fast</code>和<code>slow</code>指针都初始化为了<code>head</code>，若将<code>fast</code>初始化为<code>head-&gt;next</code>，则当链表有偶数个元素的时候，最后一个中位数没办法处理到。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ListNode* prepre=<span class="literal">NULL</span>, *pre=head;  <span class="comment">// pre指针指向前半部分翻转后的首地址</span></span><br><span class="line">    ListNode* slow=head, *fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;  <span class="comment">// 快慢指针遍历的同时翻转前半部分</span></span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        pre-&gt;next = prepre;    </span><br><span class="line">        prepre = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast)  <span class="comment">// 说明链表元素有奇数个，此时slow在中位数上，需要向后移动一位；若链表元素为偶数个，slow在后半段的开头位置</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">NULL</span> &amp;&amp; slow!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;val != slow-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></h4><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的 深拷贝。</p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><ul><li>val：一个表示 Node.val 的整数。</li><li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。</li></ul></blockquote><p>该题主要有两个思路。</p><p>第一个思路是不借助外部存储空间，使用三步走的方法。</p><p><strong>第一步</strong>，根据遍历到的原节点创建对应的新节点，每个新创建的节点是在原节点后面，比如下图中原节点<strong>1</strong>不再指向原原节点<strong>2</strong>，而是指向新节点<strong>1</strong></p><p><img src="/DataStructureAlgorithm/LeetCode总结/360dbd3b89c25324287f4cef2c22ba8a20e946891ac887f70703b211893aafa0-5.jpg" alt="5.jpg" style="zoom:67%"></p><p><strong>第二步</strong>是最关键的一步，用来设置新链表的随机指针</p><p><img src="/DataStructureAlgorithm/LeetCode总结/b531fb496fd478a2db6ba7bc805cda08b825771817dd24cdd616946a89800fbb-6.jpg" alt="6.jpg" style="zoom:67%"></p><p>此时可以观察到一个规律，原节点<code>i</code>的随机指针(如果有的话)，指向的是原节点<code>j</code>。那么新节点<code>i</code>的随机指针，指向的是原节点<code>j</code>的<strong>next</strong>。</p><p><strong>第三步</strong>就简单了，只要将两个链表分离开，再返回新链表就可以了</p><p><img src="/DataStructureAlgorithm/LeetCode总结/9b5c6e99aa89284c8a7b423bc36fec7af39fac3f8bb709e77483e574e02ef1cd-7.jpg" alt="7.jpg"></p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    Node* node = head;</span><br><span class="line">    <span class="comment">// 开始复制</span></span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        newNode-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = newNode;</span><br><span class="line">        node = newNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始复制随机指针</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;random)</span><br><span class="line">            node-&gt;next-&gt;random = node-&gt;random-&gt;next;</span><br><span class="line">        node = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始拆分链表，借助哑点让newNode在node的前面，可以简化代码，不需要对newNode-&gt;next是否为空进行特殊判断了</span></span><br><span class="line">    Node* newHead = <span class="keyword">new</span> Node(<span class="number">-1</span>);</span><br><span class="line">    Node* newNode = newHead;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        newNode-&gt;next = node-&gt;next;</span><br><span class="line">        newNode = newNode-&gt;next;</span><br><span class="line">        node-&gt;next = newNode-&gt;next;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个解法是借助额外存储空间，也就是借助哈希表来解决这个问题。</p><p>首先创建一个哈希表，再遍历原链表，遍历的同时再不断创建新节点。我们将原节点作为<strong>key</strong>，新节点作为<strong>value</strong>放入哈希表中。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/5b578a2e33a4f87536c7fe50f71ac01904ae689b26ee3e2751dac0144f009d77-8.jpg" alt="8.jpg"></p><p>第二步我们再遍历原链表，这次我们要将新链表的next和random指针给设置上。</p><p>参考代码如下，我这里将next指针的设置放在了第一个循环中，这个位置其实无所谓。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; um;</span><br><span class="line">    Node* newHead = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">    um[head] = newHead;</span><br><span class="line">    Node* pre2 = newHead;</span><br><span class="line">    Node* cur1 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur1) &#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(cur1-&gt;val);</span><br><span class="line">        um[cur1] = newNode;</span><br><span class="line">        pre2-&gt;next = newNode;</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">        pre2 = pre2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur1 = head;</span><br><span class="line">    Node* cur2 = newHead;</span><br><span class="line">    <span class="keyword">while</span>(cur1) &#123;</span><br><span class="line">        cur2-&gt;random = um[cur1-&gt;random];</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/" target="_blank" rel="noopener">Java-双指针-头插法</a><br><a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/" target="_blank" rel="noopener">Sort List （归并排序链表）</a><br><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/xiang-xi-tu-jie-ken-ding-kan-de-ming-bai-by-xixili/" target="_blank" rel="noopener">详细图解(肯定看的明白)</a><br><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/" target="_blank" rel="noopener">环形链表 II（双指针法，清晰图解）</a><br><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-1zhan-2kuai-man-zhi-zhen-fan-zhu/" target="_blank" rel="noopener">回文链表（1.栈，2.快慢指针+翻转）</a><br><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/liang-chong-shi-xian-tu-jie-138-fu-zhi-dai-sui-ji-/" target="_blank" rel="noopener">两种实现+图解 138. 复制带随机指针的链表</a></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h3><ol><li>栈的特点是后入先出。根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 <strong>DFS 深度搜索</strong>。</li><li>队列一般用于<strong>BFS广度搜索</strong>，类似一层一层的搜索。</li></ol><h3 id="栈常见题目"><a href="#栈常见题目" class="headerlink" title="栈常见题目"></a>栈常见题目</h3><h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h4><blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) —— 将元素 x 推入栈中。</li><li>pop() —— 删除栈顶的元素。</li><li>top() —— 获取栈顶元素。</li><li>getMin() —— 检索栈中的最小元素。</li></ul></blockquote><p>这个题目要在常数时间内检索到最小元素，那么可以借助额外的一个栈保存当前最小元素。其中<code>push</code>函数比较特殊，这里给出其实现，其余的均不给出了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;INT_MAX&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s.push(x);</span><br><span class="line">    <span class="comment">// 注意这个必须每次和top比较，不能拿个全局值</span></span><br><span class="line">    vec.push_back(min(vec.back(), x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h4><blockquote><p>根据 <a href="https://baike.baidu.com/item/逆波兰式/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) <em>( 3 + 4 ) 。该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + )</em> ) 。</p></blockquote><p>我们一般看到的都是中缀表达式，但这对于计算机来说就很不友好了。例如$4+13/5$，计算机从左到右扫描的话，扫到13还要判断13以后是什么运算符，还要比较优先级。是比较麻烦的。但是转换为中缀表达式之后，即为<code>[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</code>，计算机可以按照栈里面的顺序处理，不需要考虑优先级，也不需要后退了。</p><p>对于本题的解决思路为：</p><ol><li>定义一个栈辅助计算；</li><li>当遇到运算符”+”、”-“、”*”、”/“时，从栈中pop出两个数字计算，运算结果入栈；否则将数字入栈。</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokens.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tokens.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> c = tokens[i];</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">"+"</span> || c==<span class="string">"-"</span> || c==<span class="string">"*"</span> || c==<span class="string">"/"</span>) &#123;</span><br><span class="line">            <span class="comment">// 弹出最前面两个元素</span></span><br><span class="line">            <span class="keyword">int</span> first = vec.back();</span><br><span class="line">            vec.pop_back();</span><br><span class="line">            <span class="keyword">int</span> two = vec.back();</span><br><span class="line">            vec.pop_back();</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">"+"</span>) vec.push_back(two+first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">"-"</span>) vec.push_back(two-first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">"*"</span>) vec.push_back(two*first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">"/"</span>) vec.push_back(two/first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vec.push_back(atoi(c.c_str()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></h4><blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p></blockquote><p>本题难点在于括号内嵌套括号，需要<strong>从内向外</strong>生成与拼接字符串，这与栈的<strong>先入后出</strong>特性对应。</p><p>构建辅助栈<code>stack</code>，遍历字符串<code>s</code>中每个字符<code>c</code>：</p><ul><li>当<code>c</code>为数字时，将数字字符转化为数字<code>multi</code>，用于后续倍数计算</li><li>当<code>c</code>为字母时，在<code>res</code>尾部添加<code>c</code></li><li>当 <code>c</code> 为<code>[</code> 时，将当前 multi 和 res 入栈，并分别置空置 0：<ul><li>记录此 <code>[</code> 前的临时结果 res 至栈，用于发现对应 <code>]</code> 后的拼接操作；</li><li>记录此 <code>[</code> 前的倍数 <code>multi</code> 至栈，用于发现对应 <code>]</code> 后，获取 <code>multi × [...]</code>字符串。</li><li>进入到新 <code>[</code> 后，res 和 multi 重新记录</li></ul></li><li>当 <code>c</code> 为 <code>]</code> 时，stack 出栈，拼接字符串 <code>res = last_res + cur_multi * res</code>，其中:<ul><li><code>last_res</code>是上个 <code>[</code> 到当前 <code>[</code> 的字符串，例如 <code>&quot;3[a2[c]]&quot;</code> 中的 <code>c</code>；</li><li><code>cur_multi</code>是当前 <code>[</code> 到 <code>]</code> 内字符串的重复倍数，例如<code>&quot;3[a2[c]]&quot;</code> 中的 2。</li></ul></li></ul><p>返回字符串<code>res</code>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; sta;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            num += c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) &#123;  <span class="comment">//遇到[压栈数字和字符串，置零置空</span></span><br><span class="line">            sta.push(make_pair(num, res));</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            res = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>) &#123;  <span class="comment">//遇到]出栈数字和字符串，组装</span></span><br><span class="line">            <span class="keyword">int</span> n = sta.top().first;  <span class="comment">//n指示的是res的循环次数，不是a的</span></span><br><span class="line">            <span class="built_in">string</span> a = sta.top().second;</span><br><span class="line">            sta.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="comment">// 将a拼接到n次res前面</span></span><br><span class="line">                a = a + res;</span><br><span class="line">            res = a;  <span class="comment">// 更新当前的已有字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></h4><blockquote><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">&gt;     <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这个题目明显是深度优先遍历的题目。深度优先遍历有三个关键点：</p><ol><li>遍历路径：假设目前所在的节点为<code>node</code>，则由该点向此点的邻居节点做深度搜索</li><li>遍历终止条件：若节点<code>node==NULL</code>，则返回<code>NULL</code>；若出现在哈希表中，则已经遍历过了，返回对应的新节点</li><li>如何避免重复遍历：在遍历的同时，使用一个哈希表记录原始节点和新节点的对应关系，这样若访问过了，直接返回对应的新节点即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; mp; <span class="comment">// 声明在外面</span></span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mp.count(node)) <span class="keyword">return</span> mp[node]; <span class="comment">// 如果已经访问过了，则直接从哈希表中取出对应的克隆节点返回</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> new_root = <span class="keyword">new</span> Node(node-&gt;val); <span class="comment">// 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span></span><br><span class="line">    mp[node] = new_root;  <span class="comment">// 哈希表存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp;e : node-&gt;neighbors) &#123; <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">        mp[node]-&gt;neighbors.push_back(cloneGraph(e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p></blockquote><p>该题目也是典型的深度优先遍历题目。</p><p><strong>深度优先遍历</strong>有如下三个关键点：</p><ol><li>遍历路径：假设目前指针在岛屿中的<code>(i,j)</code>点，那么由该点向此点的上下左右 <code>(i+1,j)</code>,<code>(i-1,j)</code>,<code>(i,j+1)</code>,<code>(i,j-1)</code> 做深度搜索。</li><li>遍历终止条件：<code>(i,j)</code>越过矩阵边界；<code>grid[i][j] == &#39;2&#39;</code>代表此分支已经越过岛屿边界</li><li>如何避免重复遍历：搜索岛屿的同时，执行 <code>grid[i][j] = &#39;2&#39;</code>，即将岛屿所有节点删除，以免之后重复搜索相同岛屿。</li></ol><p><strong>主循环（深度优先遍历不一定都对这个分析，因为本题在DFS的时候，会中断掉，所以需要分析）：</strong>遍历整个矩阵，当遇到<code>grid[i][j] == &#39;1&#39;</code> 时，从此点开始做深度优先搜索 dfs，岛屿数 count + 1 且在深度优先搜索中删除此岛屿。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=grid.size() || j&gt;=grid[<span class="number">0</span>].size()|| grid[i][j] != <span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">    infect(grid, i<span class="number">-1</span>, j);</span><br><span class="line">    infect(grid, i+<span class="number">1</span>, j);</span><br><span class="line">    infect(grid, i, j<span class="number">-1</span>);</span><br><span class="line">    infect(grid, i, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                infect(grid, i, j);                </span><br><span class="line">                nums++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4><blockquote><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p></blockquote><p>这个题目是典型的单调栈题目。单调栈分为单调递增栈和单调递减栈：</p><ol><li>单调递增栈，即栈中的元素都是单调不递减的。<ul><li>若新元素大于等于栈顶元素，则入栈</li><li>若新元素小于栈顶元素，则不断弹栈，直到新元素大于等于栈顶元素，将新元素入栈</li></ul></li><li>单调递减栈，即栈中的元素都是单调不递增的。<ul><li>若新元素小于等于栈顶元素，则入栈</li><li>若新元素大于栈顶元素，则不断弹栈，直到新元素小于等于栈顶元素，将新元素入栈</li></ul></li></ol><p>解决本问题需要借助<strong>单调递增栈+哨兵技巧</strong>。具体思路为：</p><p>首先，在栈中记录高度是不可以的，因为计算矩阵还需要计算宽度，而宽度是需要是由下标确定的。记录下标也可以从数组中得到对应的高度。因此应该记录的是下标。</p><p>其次，考虑找到第<code>i</code>个位置最大面积。是以<code>i</code>为中心，向左找第一个小于<code>heights[i]</code>的位置<code>left_i</code>；向右找第一个小于于<code>heights[i]</code>的位置<code>right_i</code>，那么对应的宽度为<code>right_i - left_i -1</code>，即最大面积为<code>heights[i] * (right_i - left_i -1)</code>，如下图所示：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/441ac778821dc26689b31466bced9f61ec241f092bf7e4f0f8699ef4fa3be1b2-1559826097853.png" alt="1559826097853.png"></p><p>这样的一个要求与单调递增栈的性质不谋而合。考虑新元素比栈顶元素严格小的情况，此时需要出栈</p><ol><li>新元素是出栈元素向后找第一个比其小的元素</li><li>新栈顶元素是出栈元素向前找第一个比其小的元素</li></ol><p>最后，这里需要借助哨兵技巧，这是因为：</p><ol><li>若输入是递增的话，则代码无法弹出计算面积，需要在<code>heights</code>数组后面加上一个<code>0</code>，这样就可以强迫栈内元素出栈计算面积了</li><li>考虑首元素计算时需要知道左边第一个小于它的元素位置，所以在<code>heights</code>数组前面加上一个<code>0</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 添加哨兵</span></span><br><span class="line">    heights.insert(heights.begin(), <span class="number">0</span>);</span><br><span class="line">    heights.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;heights.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 注意这个判断要用while，如果要用top必须让sta不等于空</span></span><br><span class="line">        <span class="keyword">while</span>(!sta.empty() &amp;&amp; heights[sta.top()]&gt;heights[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = heights[sta.top()];</span><br><span class="line">            sta.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i表示向后找第一个比其小的元素下标，sta.top()表示向前找第一个比其小的元素</span></span><br><span class="line">            ans = max(ans, (i-sta.top()<span class="number">-1</span>)*num);</span><br><span class="line">        &#125;</span><br><span class="line">        sta.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列常见题目"><a href="#队列常见题目" class="headerlink" title="队列常见题目"></a>队列常见题目</h3><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></h4><blockquote><p>使用栈实现队列的下列操作：</p><ul><li>push(x) — 将一个元素放入队列的尾部。</li><li>pop() — 从队列首部移除元素。</li><li>peek() — 返回队列首部的元素。</li><li>empty() — 返回队列是否为空。</li></ul></blockquote><p>使用两个栈，一个栈（<code>stackPush</code>）用于元素进栈，一个栈（<code>stackPop</code>）用于元素出栈；</p><p><code>push</code>的时候，直接<code>push</code>到<code>stackPush</code>栈中</p><p><code>pop()</code> 或者 <code>peek()</code> 的时候：</p><p>（1）如果 <code>stackPop</code> 里面有元素，直接从 <code>stackPop</code> 里弹出或者 <code>peek</code> 元素；</p><p>（2）如果 <code>stackPop</code> 里面没有元素，一次性将 <code>stackPush</code> 里面的所有元素倒入 <code>stackPop</code>。</p><p>为此，可以写一个 <code>shift</code> 辅助方法，一次性将 <code>stackPush</code> 里的元素倒入 <code>stackPop</code>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackPush;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackPop;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    stackPush.push(x);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackPop.empty()) &#123;  <span class="comment">// 只有当stackPop为空的时候，才会执行下面的转移操作</span></span><br><span class="line">        <span class="keyword">while</span>(!stackPush.empty()) &#123;</span><br><span class="line">            stackPop.push(stackPush.top());</span><br><span class="line">            stackPush.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shift();</span><br><span class="line">    <span class="keyword">int</span> val = stackPop.top();</span><br><span class="line">    stackPop.pop();</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shift();</span><br><span class="line">    <span class="keyword">return</span> stackPop.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stackPop.empty() &amp;&amp; stackPush.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a><a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 矩阵</a></h4><blockquote><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。</p></blockquote><p>广度优先搜索大概可以分为两种：</p><ol><li>对于<strong>「Tree 的 BFS」 （典型的「单源 BFS」）</strong>：首先把 root 节点入队，再一层一层遍历</li><li>对于<strong>「图 的 BFS」 （「多源 BFS」）</strong> 其实也是一样的，不过需要注意以下两点：<ul><li>Tree 只有 1 个 root，而图可以有多个源点，所以首先需要把多个源点都入队；</li><li>Tree 是有向的因此不需要标识是否访问过，而对于无向图来说，必须得标志是否访问过。并且为了防止某个节点多次入队，需要在其入队之前就将其设置成已访问！</li></ul></li></ol><p>那么对于本题而言，可以借助广度优先搜索完成，具体思路是首先将每个源点 0 入队，然后从各个 0 <strong>同时开始</strong>一圈一圈的向 1 扩散（每个 1 都是被离它最近的 0 扩散到的 ）。扩散的时候可以实时更新矩阵元素的值来几记录距离（即扩散的层次）并同时标志是否访问过。这里需要注意的是，需要首先将所有非 0 的元素统一设置为<code>-1</code>这个无效距离值来标记这个位置的<code>1</code>没有访问过。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="comment">// 先将所有的零入列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                q.push(make_pair(i, j));</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                matrix[i][j] = <span class="number">-1</span>; <span class="comment">// 表明没有被访问过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx&#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 开始由零一圈一圈的向外扩散</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front().first;</span><br><span class="line">        <span class="keyword">int</span> y = q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = x + dx[k];</span><br><span class="line">            <span class="keyword">int</span> j = y + dy[k];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;rows &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;cols &amp;&amp; matrix[i][j]==<span class="number">-1</span>) &#123;</span><br><span class="line">                matrix[i][j] = matrix[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.push(make_pair(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/150-ni-bo-lan-biao-da-shi-qiu-zhi-zhan-de-jing-dia/" target="_blank" rel="noopener">150. 逆波兰表达式求值:【栈的经典应用】详解</a><br><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/java-yi-dong-yi-jie-xiao-lu-gao-by-spirit-9-19/" target="_blank" rel="noopener">Java 易懂,易解,效率高</a><br><a href="https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/" target="_blank" rel="noopener">字符串解码（辅助栈法 / 递归法，清晰图解）</a><br><a href="https://leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode-solution/" target="_blank" rel="noopener">克隆图</a><br><a href="https://leetcode-cn.com/problems/number-of-islands/solution/number-of-islands-shen-du-you-xian-bian-li-dfs-or-/" target="_blank" rel="noopener">200. 岛屿数量（DFS / BFS）</a><br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/" target="_blank" rel="noopener">暴力解法、栈（单调栈、哨兵技巧）</a><br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/" target="_blank" rel="noopener">找两边第一个小于它的值</a><br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-by-ikaruga/" target="_blank" rel="noopener">【柱状图中最大的矩形】单调栈入门，使用单调栈快速寻找边界</a><br><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/shi-yong-liang-ge-zhan-yi-ge-zhuan-men-ru-dui-yi-g/" target="_blank" rel="noopener">负负得正，使用两个栈，一个专门入队，一个专门出队</a><br><a href="https://leetcode-cn.com/problems/01-matrix/solution/2chong-bfs-xiang-jie-dp-bi-xu-miao-dong-by-sweetie/" target="_blank" rel="noopener">2种BFS，详解DP， 🤷‍♀️必须秒懂！</a></p><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><h3 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h3><ol><li><p>移除最后一个1：<code>a = n&amp;(n-1);</code></p></li><li><p>获取最右端的一个1：<code>a = n&amp;(-n);</code></p></li><li><p>异或满足交换律且两个相同元素异或结果为0：<code>a=a^b^b=b^a^b;</code></p></li><li><p>整数的二进制编码：</p><ul><li>正数的编码为原码，如8的二进制编码为：00001000</li><li>负数的编码为最高位为1，其余位等于原码取反加1，如-8的二进制编码为：1…1111000</li></ul></li><li><p>两个数交换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b</span><br><span class="line">b = a^b</span><br><span class="line">a = a^b</span><br></pre></td></tr></table></figure></li><li><p><code>^</code>：相当于无进位的求和；<code>&amp;</code>相当于求每位的进位数。</p></li></ol><h3 id="常见题目-2"><a href="#常见题目-2" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h4><blockquote><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p></blockquote><p>这个题目比较简单，使用到了上面的规律3。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        num ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a></h4><blockquote><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p></blockquote><p>最简单的思路是统计数组元素二进制表达中每个位置1出现的次数。若某个位置1出现的次数不能被3整除，则说明目标元素的该位置为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num: nums) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">31</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num&amp;mask == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">        res = res&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        res += dp[i]%<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种思路是使用位运算符的性质。</p><p><strong>XOR异或运算符可以用来检测出现奇数次的位：</strong>0与任何数异或均为该数，而两个相同数异或结果为0。</p><script type="math/tex;mode=display">
0 \land x=x \\
x \land x = 0</script><p>以此类推，只有某个位置的数字出现奇数次时，该位的掩码才不为 0。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/xor.png" alt="img" style="zoom:50%"></p><p>因此，可以检测出出现一次的位和出现三次的位，但是要区分这两种情况。这个时候需要借助AND和NOT运算：为了区分出现一次的数字和出现三次的数字，使用两个位掩码：seen_once 和 seen_twice。思路是：</p><ul><li><p>仅当 seen_twice 未变时，改变 seen_once。</p></li><li><p>仅当 seen_once 未变时，改变seen_twice。</p></li></ul><p>可以看到，位掩码 <code>seen_once</code> 仅保留出现一次的数字，不保留出现三次的数字。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/three.png" alt="img" style="zoom:50%"></p><p>对应的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seenOnce = <span class="number">0</span>, seenTwice = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">        seenOnce = ~seenTwice &amp; (seenOnce ^ num);</span><br><span class="line">        seenTwice = ~seenOnce &amp; (seenTwice ^ num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seenOnce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a></h4><blockquote><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p></blockquote><p>由异或性质可得，若将所有的数字进行异或，最终结果为只出现一次的那两个元素异或的结果。接下来考察其的某个非0位（比如最低非0位），那么只出现一次的两个数中，在这个位上一个为0，一个为1。由此可以将数组中的元素分成两部分，重新遍历，求两个异或值。参</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">        mask ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = mask &amp; (-mask);   <span class="comment">// 得到最右端的1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num1=<span class="number">0</span>, num2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num&amp;index)</span><br><span class="line">            num1 ^= num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num2 ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;num1, num2&#125;;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></h4><blockquote><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p></blockquote><p>该题考察的是上面的性质1。具体来说，每次都将最后一个1变成0，然后结果加1。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        n = n&amp;(n<span class="number">-1</span>);   <span class="comment">// 将最后一个为1变成0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></h4><blockquote><p>给定一个非负整数 <strong>num</strong>。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p></blockquote><p>这个题目可以使用动态规划来做。对于所有的数字，只有两类：</p><ol><li><p>奇数：二进制表示中，奇数一定比前面的那个偶数多一个1，因为多的就是最低位的 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例： </span><br><span class="line">0 = 0       1 = 1</span><br><span class="line">2 = 10      3 = 11</span><br></pre></td></tr></table></figure></li><li><p>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">2 = 10       4 = 100       8 = 1000</span><br><span class="line">3 = 11       6 = 110       12 = 1100</span><br></pre></td></tr></table></figure></li></ol><p>另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    result.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)   <span class="comment">// 奇数</span></span><br><span class="line">            result.push_back(result[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.push_back(result[i&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></h4><blockquote><p>颠倒给定的 32 位无符号整数的二进制位。比如输入<code>00000010100101000001111010011100</code>，输出<code>00111001011110000010100101000000</code>。</p></blockquote><p>依次颠倒即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--) &#123;</span><br><span class="line">        ans = ans&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        ans += n&amp;<span class="number">1</span>;</span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span>;   <span class="comment">// 右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. 数字范围按位与</a></h4><blockquote><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p></blockquote><p>按位相与的结果可以概括为：两个位的值都为1，按位与的结果才为 1，否则必为 0。可以得到两个结论：</p><ol><li>多个数字按位与，其结果中值为 1 的位绝对不会增加，只有可能减少。</li><li>多个数字按位与，其结果中值为 1 的位，在多个数字中的对应位必然也为 1。</li></ol><p>因题目传参用了有符号整型（实际上都是大于0的），忽略符号位后，还剩31位。从高位到低位依次编号为 0, 1, 2, 3, … 29, 30。首先来寻找一下n和m的二进制最长相同前缀，设这个前缀长度为x。因为<strong>加法只会影响连续的低位</strong>，所以 <code>[n,m]</code> 中的所有数字的长度为 x 的二进制前缀都是相等的。那也就导致，按位与的结果的长度x的二进制前缀也相同。</p><p>因为n和m的最长相同前缀长度为 x，此时 x 有两种情况：</p><ol><li>x = 31。即 n 和 m 完全相等。这种情况没啥好说的，答案就是 n&amp;m。这种情况太简单了，不做讨论。</li><li>0 &lt;= x &lt; 31。因为 n &gt;= m，所以 m 的第 x 位必然为 0，而 n 的第 x 为必然为 1。(不然就成 m &gt;= n 了)</li></ol><p>从 n 的后缀 0abcd… 累加到 m 的后缀 1hijk… 这个过程中，不管abcd…，hijk… 取值如何，必然要经过 10000…。0abcd… 和 10000… 使得答案中长度为 31-x 的后缀必然都为 0。</p><p>例如n 和 m 的二进制及最长前缀如下图所示，后缀 <strong>011 累加到 110 必然经过 100。011 和 100 保证了答案中长度为 3 的后缀必然均为 0。</strong></p><p><img src="/DataStructureAlgorithm/LeetCode总结/1598143339-uPRKJZ-image.png" alt="image.png" style="zoom:50%"></p><p>所以对应的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 最高位开始</span></span><br><span class="line">    <span class="keyword">int</span> anw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(mask &gt; <span class="number">0</span> &amp;&amp; (m&amp;mask) == (n&amp;mask)) &#123; <span class="comment">//寻找相同前缀</span></span><br><span class="line">        anw |= m&amp;mask;  <span class="comment">// 将该位的结果使用或运算更新到anw的对应位置</span></span><br><span class="line">        mask &gt;&gt;= <span class="number">1</span>;  <span class="comment">// 判断下一个低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></h4><blockquote><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p></blockquote><p>这道题目如果采用暴力方法，肯定能够做出来，但是肯定会超时。如果采用滑窗的方法，那么何时收缩窗口，难以确定。所以该题目其实考察的是前缀和和位运算。</p><p>我们知道，一个数加上偶数不改变奇偶性，例如奇数+偶数=奇数，偶数+偶数=偶数。那么如果子串<code>[0,i]</code>奇偶性和<code>[0,j]</code>相同，那么子串<code>[i+1,j]</code>一定偶数。</p><p>只考虑每个元音的奇偶次数，可以用二进制进行记录：定义<code>aeiou</code> 分别对应二进制 <code>00001，00010，00100，01000，10000</code>。其中 0 表示对应元音出现了偶数次数，1 表示奇数。</p><p>从左到右遍历字符串，不断更新<code>dp</code>：<code>dp[pattern]</code> 的作用是用来记录当前索引值下对应的元音奇偶次数组合特征。例如：如果 pattern 为 10，也就是对应二进制<code>01010</code>，<code>dp[pattern] = 8</code>的意思为，当索引值为 8 的时候，e 和 o 都出现了奇数次，其它元音为偶数次。</p><p>根据异或运算规律，异或本身为 <code>0</code>，所以当重复出现偶数次，对应位变为 <code>0</code>，否则为 <code>1</code>。由这个规律可以断定，当再次出现这个 <code>pattern</code> 的时候，一定出现了偶数次。例如<code>pattern</code> 的值变化为 <code>31--&gt;30--&gt;28--&gt;29--&gt;31</code>，对应的二进制位 <code>[11111]--&gt;[11110]--&gt;[11100]--&gt;[11101]--&gt;[11111]</code>，此时对应的一个合理字符串变化为<code>aeiou</code> —&gt; <code>aeioua</code> —&gt;<code>aeiouae</code>—&gt;<code>aeiouaea</code>—&gt;<code>aeiouaeae</code>。由此可见，从 <code>aeiou</code> 到 <code>aeiouaeae</code> 这个过程中，多余出来的 <code>aeae</code> 为符合条件的字符串。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, pattern = <span class="number">0</span>, n = s.length();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(<span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="number">-1</span>);</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'e'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'i'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'o'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'u'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (~pos[pattern]) &#123;</span><br><span class="line">            ans = max(ans, i + <span class="number">1</span> - pos[pattern]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pos[pattern] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetcode/" target="_blank" rel="noopener">只出现一次的数字 II</a><br><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/ju-hao-li-jie-de-wei-yun-suan-si-lu-by-time-limit/" target="_blank" rel="noopener">巨好理解的位运算思路</a><br><a href="https://blog.csdn.net/a435262767/article/details/104748036/" target="_blank" rel="noopener">【leetcode】5337. 每个元音包含偶数次的最长子字符串( Find the Longest Substring Containing Vowels in Even Counts)</a><br><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/xiang-xi-jie-shi-by-will_never_die/" target="_blank" rel="noopener">小学生解释</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找模板"><a href="#二分查找模板" class="headerlink" title="二分查找模板"></a>二分查找模板</h3><p><strong>适用情况：</strong>给一个有序数组和目标值，找到第一个/最后一个/任何一次出现的索引，如果没有返回-1。时间复杂度$O(logn)$。</p><p>常使用的模板主要有三个，可通过下面几道典型题目进行总结练习：</p><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p><strong>模板一：在排序数组中查找目标元素任何一次出现的位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot, left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        pivot = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[pivot] == target) </span><br><span class="line">            <span class="keyword">return</span> pivot;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[pivot]) </span><br><span class="line">            right = pivot - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            left = pivot + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板二：在排序数组中查找目标元素的第一个位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end-begin)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            begin = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span> || nums[begin] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板三：在排序数组中查找目标元素的第一个位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end-begin+<span class="number">1</span>)/<span class="number">2</span>;  <span class="comment">// 这个地方注意</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            begin = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span> || nums[begin] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用模板的关键点在于：</strong></p><ol><li>确定mid元素和目标元素的关系；进而得到缩小区间的方法</li><li>由缩小区间的方法，判断出来是第几个模板</li><li>如果不是第一个模板，则需要对最终元素进行特殊处理</li><li>对其余特殊情况进行特殊处理</li></ol><h3 id="常见题目-3"><a href="#常见题目-3" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h4><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p></blockquote><p>考虑插入的位置为pos，则成立的条件为：</p><script type="math/tex;mode=display">
nums[pos-1] < target <= nums[pos]</script><p>这个条件可以转换为：<strong>在一个有序数组中找第一个大于等于 target 的下标。</strong>套用模板一可以得到下面代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></h4><blockquote><p>编写一个高效的算法来判断 $m \times n$ 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul></blockquote><p>这个问题其实是与<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a>思想一致，只是需要将一维数组的下标转换为二维数字的下标即可。根据模板一参考代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool searchMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int target) &#123;</span><br><span class="line">    int m = matrix.size();</span><br><span class="line">    if (m == 0) return false;</span><br><span class="line">    int n = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    // 二分查找</span><br><span class="line">    int left = 0, right = m * n - 1;</span><br><span class="line">    int pivotIdx, pivotElement;</span><br><span class="line">    while (left &lt;= right) &#123;</span><br><span class="line">        pivotIdx = (left + right) / 2;</span><br><span class="line">        pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">        if (target == pivotElement) </span><br><span class="line">            return true;</span><br><span class="line">        else if (target &lt; pivotElement) </span><br><span class="line">            right = pivotIdx - 1;</span><br><span class="line">        else </span><br><span class="line">            left = pivotIdx + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></h4><blockquote><p> 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p></blockquote><p>这个明显可以使用模板二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 当前版本不是错误的</span></span><br><span class="line">        <span class="keyword">if</span>(!isBadVersion(mid)) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。请找出其中最小的元素。你可以假设数组中不存在重复元素。</p></blockquote><p>旋转数据查找这类题目的解决关键在于：</p><ol><li>通过画图将问题模型抽象为下图：</li></ol><p><img src="/DataStructureAlgorithm/LeetCode总结/33834ed636a0fcd634b0b790cb6a096ac935b3a0d4159e32259638d19c73dd3d-捕获5.PNG" alt="捕获5.PNG" style="zoom:80%"></p><ol><li>考虑和最后一个元素比较大小</li><li>考虑旋转点在0，也就是没有任何旋转的特殊情况</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end =  nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; nums[end])</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; nums[end])  <span class="comment">// 可以这样写，因为while条件，决定了cur!=end</span></span><br><span class="line">            end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。请找出其中最小的元素。注意数组中可能存在重复的元素。</p></blockquote><p>这个题目是上一道题目的区别在于，该题目的元素是可以重复的。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/4e410caf37485a65a95b6af228b564464099cf430ca695872125f0b13a147b19-捕获6.PNG" alt="捕获6.PNG"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end =  nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; nums[end])</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; nums[end])</span><br><span class="line">            end = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 无法判断mid的位置，可能位于最小值的前面，也可能后面。唯一可以确定的是最小值在end的左边</span></span><br><span class="line">            end--;   <span class="comment">// 跟上一题题解的区别</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 (不包含重复元素)</p></blockquote><p>这个题目和上两个题目不同点在于该题目是搜索特定元素，而前两个题目是找到最小元素值。</p><p>解题思路是：根据<code>arr[mid]</code>与<code>arr[end]</code>的值大小关系，划分出完全有序部分和部分有序部分。接着对于前半段有序的情况，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>；若是后半段有序，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[end]) &#123;  <span class="comment">// mid到end有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[end]) <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 从start到mid有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; target&gt;=nums[start])  <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。(包含重复元素)</p></blockquote><p>这个题目和上一个题目的不同点在于该题目中的元素是可以重复的。</p><p>解题思路是：根据<code>arr[mid]</code>与<code>arr[end]</code>的值大小关系，划分出完全有序部分和部分有序部分。接着对于前半段有序的情况，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>；若是后半段有序，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[end]) &#123;  <span class="comment">// mid到end有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[end]) <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[end]) &#123;  <span class="comment">// 从start到mid有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; target&gt;=nums[start])  <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">// 无法判断哪一个是单调区间，极端情况下，退化为从end到start的遍历查找</span></span><br><span class="line">            end--;  <span class="comment">// 跟上一题题解的区别</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/tong-guo-hua-tu-geng-neng-shen-ke-li-jie-er-fen-fa/" target="_blank" rel="noopener">通过画图来深刻理解二分法</a><br><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/tong-guo-hua-tu-lai-shen-ke-li-jie-er-fen-fa-by-ch/" target="_blank" rel="noopener">通过画图来深刻理解二分法</a></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>原理可以参考<a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a>。</p><p>C++代码可以参考<a href="https://github.com/zdaiot/DataStructure-And-Algorithm" target="_blank" rel="noopener">DataStructure-And-Algorithm</a>。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划：是一种解决问 题的思想，大规模问题的结果，是由小规模问 题的结果运算得来的。动态规划可用递归来实现(Memorization Search)。递归只是一种程序的实现方式。</p><h3 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h3><p><strong>使用场景，需要满足几个条件：</strong></p><ol><li><p>满足以下条件之一：</p><p>求最大/最小值（Maximum/Minimum ）</p><p>求是否可行（Yes/No ）</p><p>求可行个数（Count(*) ）</p></li><li><p>最优子结构（如果不能利用子问题的最优解获得整个问题的最优解，那么这种问题就不具有最优子结构。简单来说后面阶段的状态要能够通过前面阶段的状态推导出来，对应的一定能写出来状态转移方程）</p></li><li><p>重复子问题</p></li><li><p>满足不能排序或者交换（Can not sort / swap ）</p></li></ol><p>如题：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a> 位置可以交换，所以不用动态规划</p><p><strong>四点要素：</strong></p><ol><li>状态 State：灵感，创造力，存储<strong>小规模问题</strong>的结果</li><li>方程 Function：状态之间的联系，怎么通过小的状态，来算大的状态</li><li>初始化 Intialization：最极限的小状态是什么，起点</li><li>答案 Answer：最大的那个状态是什么，终点</li></ol><blockquote><p>动态规划的tabel通常会为长度+1，<code>tabel[0]</code>的初始化很重要，通常可以简化很多操作。但是这样操作的时候记住遍历原数组的时候，下标减1。</p></blockquote><p><strong>常见四种类型：</strong></p><ol><li>矩阵类型（10%）</li><li>序列类型（40%）</li><li>两个序列类型（40%）</li><li>零钱和背包（10%）</li></ol><blockquote><p>贪心算法大多题目靠背答案，所以如果能用动态规划就尽量用动规，不用贪心算法。</p></blockquote><h3 id="矩阵类型（10-）"><a href="#矩阵类型（10-）" class="headerlink" title="矩阵类型（10%）"></a>矩阵类型（10%）</h3><h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h4><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p></blockquote><p>这是一个典型的动态规划问题。</p><ol><li>状态State：用<code>f[i][j]</code>表示从三角顶部走到位置<code>(i,j)</code>的最小路径和。这里的位置<code>(i,j)</code>表示第 i 行第 j 列（下标从0开始）</li><li>方程：若<code>j=0</code>，则<code>f[i][j]=f[i−1][0]+c[i][0]</code>；若<code>j=i</code>，则<code>f[i][j]=f[i−1][i−1]+c[i][i]</code>；<code>f[i][j] = min(f[i−1][j−1], f[i−1][j]) + c[i][j]</code>，<code>c[i][j]</code>表示位置<code>(i,j)</code>对应的元素值。需要注意第 <code>i</code> 行有 <code>i+1</code> 个元素，在计算状态转移的时候注意不要</li><li>初始化：<code>f[0][0]</code></li><li>答案：<code>max(f[n-1][:])</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];   <span class="comment">// j=0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];  <span class="comment">// j=i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *min_element(f[n - <span class="number">1</span>].begin(), f[n - <span class="number">1</span>].end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾方法一中的状态转移方程，可以发现<code>f[i][j]</code>只与<code>f[i-1][..]</code>有关，而与<code>f[i-2][..]</code>及之前的状态无关。可以使用两个长度为$n$的一位数组进行，根据$i$的奇偶性进行转移。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/image-20200910195806939.png" alt="image-20200910195806939"></p><p>优化空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> curr = i % <span class="number">2</span>;   <span class="comment">// 分奇偶性</span></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">1</span> - curr;</span><br><span class="line">        f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];  <span class="comment">// j=0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            f[curr][j] = min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle[i][i];  <span class="comment">// j=i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *min_element(f[(n - <span class="number">1</span>) % <span class="number">2</span>].begin(), f[(n - <span class="number">1</span>) % <span class="number">2</span>].end());  <span class="comment">// 注意这个结尾的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><blockquote><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。</p></blockquote><p>很明显这个题目是求最优解的；存在最优子结构；并且存在重复子问题（若采用回溯法，相同子路径会重复出现）。可以使用动态规划来求解。按照上面所说的四个要素：</p><ol><li>状态State：<code>f[x][y]</code>为从起点走到 x,y 的最短路径</li><li>方程：<code>f[x][y] = min(f[x-1][y], f[x][y-1]) + A[x][y]</code></li><li>初始化：<code>f[0][0] = A[0][0]、f[i][0] = sum(0,0 -&gt; i,0)、 f[0][i] = sum(0,0 -&gt; 0,i)</code></li><li>答案：<code>f[m-1][n-1]</code></li></ol><p>其实，仔细分析状态转移方程，发现<code>f[x][y]</code>只与上一行正上方元素和该行左边元素有关，因此可以省略掉<code>x</code>维，使用一维数组代替二维数组完成动态规划。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(grid[<span class="number">0</span>].size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)</span><br><span class="line">                vec[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                vec[j] = vec[j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                vec[j] = vec[j] + grid[i][j]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                vec[j] = min(vec[j], vec[j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><blockquote><p>一个机器人位于一个 m x n 网格的左上角。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。 问总共有多少条不同的路径？</p></blockquote><p>这个问题可以转换为，最多有多少条不同的路径，所以是一个求最优解的问题；存在最优子结构；假设<code>f[x][y]</code>表示从 x 到 y 最多有多少条路径，那么在求解<code>f[x+1][y]、f[x][y+1]</code>都需要求解<code>f[x][y]</code>，所以存在重复子问题，可以使用动态规划解决。按照上面所说的四个要素：</p><ol><li>定义State：<code>f[x][y]</code>表示从 x 到 y 最多有多少条路径</li><li>方程：<code>f[x][y]=f[x][y-1]+f[x-1][y]</code></li><li>初始化：<code>f[i][0]=f[0][i]=1</code></li><li>答案：<code>f[m-1][n-1]</code></li></ol><p>仔细分析状态转移方程，发现<code>f[x][y]</code>只与上一行正上方元素和该行左边元素有关，因此可以省略掉<code>x</code>维，使用一维数组代替二维数组完成动态规划。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;=<span class="number">0</span> || n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)</span><br><span class="line">                vec[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vec[j] = vec[j] + vec[j<span class="number">-1</span>];</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h4><blockquote><p>一个机器人位于一个 m x n 网格的左上角 。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p></blockquote><p>这个问题和上面问题的区别在于，这里加上了一个障碍物。使用动态规划，按照上面所说的四个要素：</p><ol><li>定义State：<code>f[x][y]</code>表示从 x 到 y 最多有多少条路径。若当前位置为障碍物，则<code>f[x][y]=0</code>，下面讨论没有障碍物时候的状态转移以及初始化</li><li>方程：<code>f[x][y]=f[x][y-1]+f[x-1][y]</code></li><li>初始化：<code>f[0][0]=1、f[i][0]=f[i-1][0]、f[0][i]=f[0][i]</code>，这个初始化因为障碍物存在，不能全部置为1</li><li>答案：<code>f[m-1][n-1]</code></li></ol><p>仔细分析状态转移方程，发现<code>f[x][y]</code>只与上一行正上方元素和该行左边元素有关，因此可以省略掉<code>x</code>维，使用一维数组代替二维数组完成动态规划。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(obstacleGrid[<span class="number">0</span>].size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;obstacleGrid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;obstacleGrid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">                vec[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)</span><br><span class="line">                    vec[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                    vec[j] = vec[j] + vec[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列类型（40-）"><a href="#序列类型（40-）" class="headerlink" title="序列类型（40%）"></a>序列类型（40%）</h3><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h4><blockquote><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><p>这应该是最简单的动态规划问题。按照上面四个要素进行分析：</p><ol><li>状态State：<code>f(x)</code>爬到台阶 x 有多少种方法</li><li>方程：<code>f(x)=f(x-1)+f(x-2)</code></li><li>初始化：<code>f(1)=1、f(2)=2</code></li><li>答案：<code>f(n)</code></li></ol><p>分析状态转移方程，发现<code>f(x)</code>只与前两个状态有关，所以可以用两个变量保存这两个状态即可。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> vec[n<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = vec[<span class="number">0</span>] + vec[<span class="number">1</span>];</span><br><span class="line">        vec[<span class="number">0</span>] = vec[<span class="number">1</span>];</span><br><span class="line">        vec[<span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h4><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。</p></blockquote><p>这个题目有两种解法。</p><p>第一种方法是借助<strong>贪心算法</strong>，使用一个变量<code>k</code>记录能够跳到的<strong>最远元素的下标</strong>（从0开始）。依次遍历数组的元素，若<code>k</code>大于等于当前下标，证明可以跳到该元素，然后看是否需要更新<code>k</code>以及是否已经可以跳到最后一个位置了；若<code>k</code>小于当前下标，则证明无法跳到该元素，返回<code>false</code>。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= i) &#123;</span><br><span class="line">            k = max(k, nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= nums.size()<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法是借助动态规划，该方法求解过程并没有贪心简单。还是按照上面四个要素进行分析：</p><ol><li>状态State：<code>f[i]</code>表示 i 下标能不能到达</li><li>方程：<code>f[i] = OR(f[j],j&lt;i&amp;&amp;j能跳到i)</code> 判断之前所有的点最后一跳是否<strong>存在</strong>能跳到当前点的（<code>OR</code>表示存在）。</li><li>初始化：<code>f(0)=1</code></li><li>答案：<code>f(n-1)</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(n, <span class="literal">false</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; j+nums[j]&gt;=i) &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></h4><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p></blockquote><p>跟上一道题目一样，这也是典型的<strong>贪心算法，每次都是贪心的选择最远距离，通过局部最优解得到全局最优解。</strong>这里的贪心有两种方法。</p><p><strong>第一种方法是反向查找出发位置。</strong>有多个位置通过跳跃可以达到最后一个位置，直观上，可以贪心地选择距离最后一个位置最远的那个位置，可以从左到右遍历数组，选择第一个满足要求的位置。找到最后一步跳跃前所在的位置之后，继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。这种思路需要遍历多遍（时间复杂度为$O(n^2)$），C++会超时，这里给出Java版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> position = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                position = i;</span><br><span class="line">                steps++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种方法是正向查找可达到的最大位置。</strong>假设第一个元素最远可以跳 j 个位置，将从这 j 个位置开始能够跳到的最远距离记做 sum；使用 end 变量（初始化为0）记录第一步可以跳的最远距离；依次遍历所有位置，若当前位置下标大于 end，则证明需要再跳一步，此时需要更新end和step。另外，我们不会遍历到最后一个元素，因为若刚好<code>end=n-1</code>，那么遍历到最后一个元素时，会凭空的多一个step。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++) &#123;  <span class="comment">// 注意没有遍历到最后一个元素</span></span><br><span class="line">        sum = max(sum, i+nums[i]); <span class="comment">// 用于记录该step能跃过的所有节点中，下一个能跳过的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(i == end) &#123;  <span class="comment">// 需要再跳，才有可能到最终元素，注意更新end</span></span><br><span class="line">            end = sum;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><blockquote><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p></blockquote><p>对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。根据这样的思路，可以使用动态规划的方法解决本题。</p><ol><li>状态State：定义<code>dp[i][j]</code>为<code>s[i, j]</code>是否为回文子串</li><li>方程：<code>dp[i][j] = dp[i+1][j-1] and (s[i]==s[j])</code></li><li>初始化：<code>dp[i][i]=1、dp[i][j]=s[i][j] if j-i=1</code></li><li>答案：若<code>dp[i][j]=1</code>，则判断是否需要更新最终的最长回文子串答案</li></ol><p><strong>这道题需要注意的是<code>dp[i][j]</code>的更新次序</strong>，参考代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;n; l++) &#123;  <span class="comment">// j-i的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+l&lt;n; i++) &#123; <span class="comment">// 开始坐标，注意停止条件</span></span><br><span class="line">            <span class="keyword">int</span> j = i+l; <span class="comment">// 结束坐标</span></span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = s[i]==s[j];</span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i]==s[j]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; l+<span class="number">1</span>&gt;ans.size())</span><br><span class="line">                ans = s.substr(i, l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. 分割回文串 II</a></h4><blockquote><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。返回符合要求的最少分割次数。</p></blockquote><ol><li>状态State：<code>dp[i]</code>表示前缀子串 <code>s[0,i]</code> 分割成若干个回文子串所需要最小分割次数</li><li>方程：若<code>s[0,i]</code>本身为回文串，则<code>d[i]=0</code>；否则<code>dp[i] = min([dp[j] + 1 for j in range(i) if s[j+1, i] 是回文])</code></li><li>初始化：<code>dp[0]=0</code></li><li>答案：<code>s[n-1]</code></li></ol><p>可以看到这个问题其实包含了<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a>子问题，与之相似的<a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a>却是一个回溯法解决的题目。该题目的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;n; l++) &#123;    <span class="comment">// j-i的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+l&lt;n; i++) &#123;   <span class="comment">// 开始坐标，注意停止条件</span></span><br><span class="line">            <span class="keyword">int</span> j = i + l;   <span class="comment">// 结束坐标</span></span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = s[i]==s[j];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i]==s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        vec[i] = i;  <span class="comment">// 初始化最大所需切割次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;  <span class="comment">// 若s[o,i]为回文串</span></span><br><span class="line">            vec[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j+<span class="number">1</span>][i] == <span class="number">1</span>)</span><br><span class="line">                vec[i] = min(vec[i], vec[j] + <span class="number">1</span>);  <span class="comment">// 找到最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h4><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。子序列下标可以不连续。</p></blockquote><ol><li>状态State：<code>f[i]</code>表示从0开始到 i 结尾的最长序列长度</li><li>方程：<code>f[i] = max(f[j])+1 ,a[j]&lt;a[i] and j&lt;i</code></li><li>初始化：<code>f[i]=1</code></li><li>答案：<code>max(f[0]...f[n-1])</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 特殊输入测试</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                dp[i] = max(dp[j]+<span class="number">1</span>, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h4><blockquote><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p></blockquote><ol><li>状态State：<code>f[i]</code>表示前 i 个字符是否可以被划分</li><li>方程：<code>f[i] = f[j] &amp;&amp; s[j~i-1] in wordDict, j&lt;i</code>（注意下标）</li><li>初始化：<code>f[0]=true</code></li><li>答案：<code>f[n]</code></li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> wordDictSet = <span class="built_in">unordered_set</span> &lt;<span class="built_in">string</span>&gt; ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word: wordDict) &#123;</span><br><span class="line">        wordDictSet.insert(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dp = <span class="built_in">vector</span> &lt;<span class="keyword">bool</span>&gt; (s.size() + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) &#123;   <span class="comment">// 注意下标</span></span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个序列类型（40-）"><a href="#两个序列类型（40-）" class="headerlink" title="两个序列类型（40%）"></a>两个序列类型（40%）</h3><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h4><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p></blockquote><ol><li>状态State：<code>dp[i][j]</code>为text1前 i 个和text2前 j 个字符最长公共子序列</li><li>方程：若<code>text1[i-1]=text2[j-1]</code>，则<code>dp[i][j]=dp[i-1][j-1]+1</code>；否则<code>dp[i][j]=max(dp[i-1][j], dp[i][j-1])</code></li><li>初始化：<code>dp[0][i]=dp[i][0]=0</code></li><li>答案：<code>dp[m][n]</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = text1.size();</span><br><span class="line">    <span class="keyword">int</span> length2 = text2.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(length1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(length2+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=length2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h4><blockquote><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p></blockquote><ol><li><p>状态State：<code>dp[i][j]</code>为word1前 i 个字符编辑为word2前 j 个字符最少需要多少次操作</p></li><li><p>方程：若<code>word1[i-1]==word2[j-1]</code>，则<code>dp[i][j]=dp[i-1][j-1]</code>；否则<code>dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code>。</p><p>对<code>dp[i-1][j-1]</code>表示替换操作，<code>dp[i-1][j]</code>表示删除操作，<code>dp[i][j-1]</code>表示插入操作的补充理解：以 word1 为 “horse”，word2 为 “ros”，求<code>dp[5][3]</code> 为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：</p><ul><li><code>dp[i-1][j-1]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符<code>word1[4]</code>（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，<code>word2[2]</code>）</li><li><code>dp[i][j-1]</code>，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</li><li><code>dp[i-1][j]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</li></ul></li><li><p>初始化：<code>dp[0][i] = i、dp[i][0] = i;</code></p></li><li>答案：<code>dp[m][n]</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = word1.size();</span><br><span class="line">    <span class="keyword">int</span> length2 = word2.size();</span><br><span class="line">    <span class="keyword">if</span>(length1*length2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> word1.size()+word2.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(length1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(length2+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length2; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=length1; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=length2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> minV = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                minV = min(minV, dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp[i][j] = minV + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零钱和背包（10-）"><a href="#零钱和背包（10-）" class="headerlink" title="零钱和背包（10%）"></a>零钱和背包（10%）</h3><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h4><blockquote><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p></blockquote><ol><li>状态State：<code>dp[i]</code>组成总金额为 i 所需的最少硬币个数</li><li>方程：<code>dp[i]=min(dp[i-coins[j]]+1)</code></li><li>初始化：<code>dp[0]=0、dp[i]=amount+1(i&gt;0)</code></li><li>答案：若<code>dp[amount]==amount+1</code>，则返回<code>-1</code>；否则返回<code>dp[amount]</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>, amount+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;coins.size(); j++)</span><br><span class="line">            <span class="keyword">if</span>(i-coins[j] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i] = min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="92-背包问题"><a href="#92-背包问题" class="headerlink" title="92. 背包问题"></a><a href="https://www.lintcode.com/problem/backpack/description" target="_blank" rel="noopener">92. 背包问题</a></h4><blockquote><p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]。你不可以将物品进行切割。</p></blockquote><ol><li>状态State：<code>dp[i][j]</code>表示前<code>i</code>个物品，能不能填满容量为<code>j</code>的背包。</li><li>方程：<code>dp[i][j] = dp[i-1][j] OR dp[i-1][j-A[i-1]]</code>。注意<code>i</code>表示前<code>i</code>个物品，换算到下标时为<code>i-1</code></li><li>初始化：<code>dp[0][0]=True</code></li><li>答案：<code>j if dp[m-1][j]=1 else -1 for j in range(m, -1, -1)</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j-A[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[n][j])</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，本题所用的存储空间可以优化。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=A[i<span class="number">-1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-A[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[j])</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">01背包问题</a></h4><blockquote><p>有 <em>N</em> 件物品和一个容量是 <em>V</em> 的背包。每件物品只能使用一次。第 <em>i</em> 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输入第一行N、V分别表示物品数量和背包容积；接下来有N行，每行两个整数$v_i,w_i$，分别表示第$i$个物品的体积和价值。输出最大价值。</p></blockquote><p>这个问题是典型的动态规划问题。最大的特点是每一件物品只能使用一次。</p><ol><li>状态State：定义<code>f[i][j]</code>为所有选法集合中，只从前<code>i</code>个物品中选，并且总体积 $\leq j$ 的选法集合，它的值是这个集合中每一个选法的最大值。</li><li>方程：<code>f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i] if j&gt;=v[i])</code>。其中<code>f[i-1][j]</code>表示不选第<code>i</code>个物品的集合中的最大值；<code>f[i-1][j-v[i]]+w[i]</code>表示选第<code>i</code>个物品的集合中的最大值。</li><li>初始化：<code>f[0][0]=0</code></li><li>答案：<code>f[N][V]</code></li></ol><p>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">// n goods</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v)</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化之后的代码实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">// n goods</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=v; j--) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">完全背包问题</a></h4><blockquote><p>有 <em>N</em> 件物品和一个容量是 <em>V</em> 的背包。每件物品都有无限件可用。第 <em>i</em> 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输入第一行N、V分别表示物品数量和背包容积；接下来有N行，每行两个整数$v_i,w_i$，分别表示第$i$个物品的体积和价值。输出最大价值。</p></blockquote><p>该题目和上一个题目区别在于本题的每件物品可以重复使用。同理可以采用动态规划解决该问题。</p><ol><li>状态State：定义<code>f[i][j]</code>为所有选法集合中，只从前<code>i</code>个物品中选，并且总体积 $\leq j$ 的选法集合，它的值是这个集合中每一个选法的最大值。</li><li>方程：<code>f[i][j] = max(f[i-1][j], f[i-1][j-v[i]*k]+w[i]*k if j&gt;=v[i]*k)</code>。其中<code>f[i-1][j]</code>表示不选第 i 个物品的集合中的最大值；<code>f[i-1][j-v[i]*k]+w[i]*k</code>表示选第<code>i</code>个物品<code>k</code>次的集合中的最大值。</li><li>初始化：<code>f[0][0]=0</code></li><li>答案：<code>f[N][V]</code></li></ol><p>上一道题中，逆序遍历体积是为了保证更新当前状态时，用到的状态是上一轮的状态，保证每个物品只有一次或零次；在这里，因为每个物品可以取任意多次，所以不再强求用上一轮的状态，即本轮放过的物品，在后面还可以再放，所以可以顺序遍历体积。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v; j&lt;=m; j++) &#123;</span><br><span class="line">            <span class="comment">//dp[j] = max(dp[j], dp[j-v]+w);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=j/v; k++)</span><br><span class="line">               dp[j] = max(dp[j], dp[j-k*v]+w*k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/lanchunhui/article/details/52480106" target="_blank" rel="noopener">最优子结构（optimal substructure）</a><br><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/dong-tai-gui-hua-by-liweiwei1419-2/" target="_blank" rel="noopener">动态规划（Java、Python）</a><br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">动态规划、中心扩散、Manacher 算法</a><br><a href="https://blog.csdn.net/ZK_J1994/article/details/72809260" target="_blank" rel="noopener">Python列表解析配合if else</a><br><a href="https://www.acwing.com/solution/content/3986/" target="_blank" rel="noopener">AcWing 3. 完全背包问题—一维动态规划转移过程模拟</a></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法一般用来解决需要 “找到要做某事的最小数量” 或 “找到在某些情况下适合的最大物品数量” 的问题，且提供的是无序的输入。</p><h2 id="递归思维"><a href="#递归思维" class="headerlink" title="递归思维"></a>递归思维</h2><h3 id="理论-3"><a href="#理论-3" class="headerlink" title="理论"></a>理论</h3><p>递归是一种应用非常广泛的算法（或者编程技巧）。递归分为两个步骤：<strong>去的过程叫“递”，回来的过程叫“归”</strong>。</p><p>当问题满足如下三个条件时，则适合使用递归解决：</p><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了<strong>数据规模</strong>不同，求解思路完全一样</li><li>存在递归终止条件。另外，还需要注意的是，要通过几个边界值例子，看终止条件是否足够。</li></ol><p>写递归代码有两个最关键的步骤：</p><ol><li>写出递推公式</li><li>找到终止条件</li></ol><p>理解递归代码需要把握住如下几点：</p><ol><li>如果试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区</li><li>如果一个问题 A 可以分解为若干子问题 B、C、D，<strong>可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，</strong>理解起来就简单多了。</li><li>因此，<strong>编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></li></ol><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。<strong>所有的递归代码都可以改为迭代循环的非递归写法。</strong></p><h3 id="常见题目-4"><a href="#常见题目-4" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h4><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p></blockquote><p>这道题可以采用递归的方式解决。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseStringCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    swap(s[start], s[end]);</span><br><span class="line">    reverseStringCore(s, start+<span class="number">1</span>, end<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    reverseStringCore(s, <span class="number">0</span>, s.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以采用循环以及交换元素的方式解决，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, end=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end) &#123;</span><br><span class="line">        swap(s[start], s[end]);</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h4><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p></blockquote><p>可以采用递归方法解决这个问题，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairsCore</span><span class="params">(ListNode* first, ListNode* two)</span> </span>&#123;</span><br><span class="line">    ListNode* third = two-&gt;next;</span><br><span class="line">    two-&gt;next = first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(third &amp;&amp; third-&gt;next)</span><br><span class="line">        first-&gt;next = swapPairsCore(third, third-&gt;next);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        first-&gt;next = third;</span><br><span class="line">    <span class="keyword">return</span> two;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> swapPairsCore(head, head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II</a></h4><blockquote><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p></blockquote><p>根据二叉树的性质，若根节点的值为$i$，则左子树的范围为$1\sim i-1$，右子树的范围为$i+1 \sim n$，且左子树和右子树也同样为二叉搜索树，因此可以递归的解决这个问题。</p><p>定义<code>generateTrees(start, end)</code>函数表示当前值的集合<code>[start,end]</code>，返回序列<code>[start,end]</code>生成的所有可行的二叉搜索树（使用<code>vector</code>表示，每个值均为可行二叉搜索树的根节点）。考虑枚举<code>[start,end]</code>中的值<code>i</code>为当前二叉搜索树的根，那么序列划分为了<code>[start,i−1]</code>和<code>[i+1,end]</code>两部分。递归调用这两部分，即<code>generateTrees(start, i - 1)</code>和<code>generateTrees(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，那么最后一步只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; generateTreesCore(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">    <span class="comment">// 某棵树终止</span></span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++) &#123;  <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; leftV = generateTreesCore(start, i<span class="number">-1</span>);  <span class="comment">// 获得所有可行的左子树集合（存储根节点）</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; rightV = generateTreesCore(i+<span class="number">1</span>, end);   <span class="comment">// 获得所有可行的右子树集合（存储根节点）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> nodeL:leftV) &#123;   <span class="comment">// 遍历每一个可行左子树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> nodeR:rightV) &#123;  <span class="comment">// 遍历每一个可行右子树</span></span><br><span class="line">                TreeNode* node = <span class="keyword">new</span> TreeNode(i);   <span class="comment">// 接到根节点上，形成一棵树，放到本次迭代的vecotr中</span></span><br><span class="line">                node-&gt;left = nodeL;</span><br><span class="line">                node-&gt;right = nodeR;</span><br><span class="line">                res.push_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是所有可行搜索树的根节点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    res = generateTreesCore(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h4><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p></blockquote><p>这道题其实可以用循环来做，但是一般来说，这是一道很典型的递归问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span> || N==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fib(N<span class="number">-1</span>) + fib(N<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口思想"><a href="#滑动窗口思想" class="headerlink" title="滑动窗口思想"></a>滑动窗口思想</h2><h3 id="理论-4"><a href="#理论-4" class="headerlink" title="理论"></a>理论</h3><p>这类题目更像是双指针的升级版，滑动窗口的核心是维护一个窗口集，根据窗口集来进行处理。核心步骤包括：</p><ol><li>右指针右移，窗口数据更新（注意移动的范围）</li><li>判断窗口是否需要收缩</li><li>左指针右移，窗口数据更新</li><li>根据题意计算结果</li></ol><h3 id="常见题目-5"><a href="#常见题目-5" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><blockquote><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p></blockquote><p>很明显，这个题目需要用滑动窗口去做。在 S 上滑动窗口，通过移动右指针不断扩张窗口。当窗口包含 T 全部所需的字符后，如果能收缩，就收缩窗口得到最小窗口。而判断是否包含 T 所需的全部字符，需要借助哈希表记录所有字符以及出现的位置。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; need, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p:need) &#123;  <span class="comment">// 注意必须是need循环，window可能字符并不全</span></span><br><span class="line">        <span class="keyword">if</span>(window[p.first] &lt; p.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;  <span class="comment">// need 存储 t 每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t.size(); i++)</span><br><span class="line">        need[t[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;  <span class="comment">// 注意这个初始值，是为了使用++right，而不是right++，保证统计windows时下标与need.find一致</span></span><br><span class="line">    <span class="keyword">int</span> ansL=<span class="number">-1</span>, len=INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span>&lt;<span class="keyword">int</span>(s.size())) &#123;  <span class="comment">// 注意这个right的取值</span></span><br><span class="line">        <span class="keyword">if</span>(need.find(s[++right]) != need.end()) &#123;  <span class="comment">// 右移，注意window只存储了t中出现的字符</span></span><br><span class="line">            window[s[right]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(judge(need, window) &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; len) &#123;   <span class="comment">// 记录最小字符子串的开始坐标和长度，上面用的是++right，所以这里要加1</span></span><br><span class="line">                len = right-left+<span class="number">1</span>;</span><br><span class="line">                ansL = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need.find(s[left]) != need.end())   <span class="comment">// 左移，注意window只存储了t中出现的字符</span></span><br><span class="line">                window[s[left]]--;</span><br><span class="line"></span><br><span class="line">            left++;  <span class="comment">// 注意这个left的位置，不要放在上面的if条件里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansL&gt;<span class="number">-1</span>?s.substr(ansL, len):<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的空间复杂度可以优化，使用一个哈希表，哈希表的每个字符对应的值含义为：</p><ol><li>若大于0，则滑动窗口中该字符还应该出现几次</li><li>若等于0，则滑动窗口中该字符次数的次数正好</li><li>若小于0，则滑动窗口中该字符多出现了几次</li></ol><p>对应的若哈希表中的所有值均小于等于0，则应该缩小窗口，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; need)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p:need) &#123;  <span class="comment">// 注意必须是need循环，window可能字符并不全</span></span><br><span class="line">        <span class="keyword">if</span>(p.second &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;  <span class="comment">// need 存储 t 每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t.size(); i++)</span><br><span class="line">        need[t[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;  <span class="comment">// 注意这个初始值，是为了使用++right，而不是right++，保证统计windows时下标与need.find一致</span></span><br><span class="line">    <span class="keyword">int</span> ansL=<span class="number">-1</span>, len=INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span>&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.find(s[++right]) != need.end()) &#123;</span><br><span class="line">            need[s[right]]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(judge(need) &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; len) &#123;   <span class="comment">// 记录最小字符子串的开始坐标和长度</span></span><br><span class="line">                len = right-left+<span class="number">1</span>;</span><br><span class="line">                ansL = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need.find(s[left]) != need.end())   <span class="comment">// 左移</span></span><br><span class="line">                need[s[left]]++;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansL&gt;<span class="number">-1</span>?s.substr(ansL, len):<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></h4><blockquote><p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。</p></blockquote><p>这道题乍一看比上一道题要难，该题要判断是否包含 s1 的排列，而上一道题是判断包含 T 所有字符的最小子串。其实包含 s1 的排列和包含 T 所有字符只是两个说法而已，实际在用的时候都只需要使用一个哈希表记录出现过的字符以及出现的次数即可。</p><p>另外，该题和上一道题的区别在于本题的滑动窗口大小是固定的。有两个思路可以解决这个问题。</p><p>第一个思路是使用上一道题的模板，使用一个match变量记录当前滑动窗口中有多少个字符满足了出现的次数。滑动窗口的缩小条件为当前窗口的大小大于等于 s1 的长度，注意在移动左右指针的时候，更新window窗口以及match变量的值。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; need, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p: need) &#123;  <span class="comment">// 注意必须是need循环，window可能字符并不全</span></span><br><span class="line">        <span class="keyword">if</span>(window[p.first] &lt; p.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: s1)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;  <span class="comment">// 注意这个初始值，是为了使用++right，而不是right++，保证统计windows时下标与need.find一致</span></span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span> &lt; <span class="keyword">int</span>(s2.size())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.find(s2[++right]) != need.end()) &#123;   <span class="comment">// 移动右指针的时候更新 window 和 match的值</span></span><br><span class="line">            window[s2[right]]++;</span><br><span class="line">            <span class="keyword">if</span>(window[s2[right]] == need[s2[right]]) &#123;</span><br><span class="line">                match++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right-left+<span class="number">1</span> &gt;= s1.size()) &#123;  <span class="comment">// 目标框大小固定，当超过时，缩小框</span></span><br><span class="line">            <span class="keyword">if</span>(match == need.size())  <span class="comment">// 包含了 s1 的全排列</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(need.find(s2[left]) != need.end()) &#123;  <span class="comment">// 移动左指针的时候更新 window 和 match的值</span></span><br><span class="line">                <span class="keyword">if</span>(window[s2[left]] == need[s2[left]])</span><br><span class="line">                    match--;</span><br><span class="line">                window[s2[left]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;  <span class="comment">// 注意这个left的位置，不要放在上面的if条件里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个思路是只使用一个哈希表，哈希表的每个字符对应的值含义为：</p><ol><li>若大于0，则滑动窗口中该字符还应该出现几次</li><li>若等于0，则滑动窗口中该字符次数的次数正好</li><li>若小于0，则滑动窗口中该字符多出现了几次</li></ol><p>对应的代码为（该代码是比较标准的固定窗口大小的模板）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: s1)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s2[right++];</span><br><span class="line">        need[c]--;</span><br><span class="line">        <span class="keyword">while</span>(need[c]&lt;<span class="number">0</span> &amp;&amp; left&lt;=right) &#123;  <span class="comment">// 该字符多出现了，收缩窗口</span></span><br><span class="line">            need[s2[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right-left == s1.size())  <span class="comment">// 注意上面的right++了，所以这里不需要加1了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 当满足此条件是，一定是need中所有的值均为0，否则的话一定会有小于0的值，执行上述while循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><blockquote><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序</li></ul></blockquote><p>该题目可以使用滑动窗口的思想解决，并且由题意可知这是一个固定大小窗口的题目。因此窗口收缩的判断条件为当前窗口的大小大于等于 p 的长度。另外，在收缩窗口的时候，注意判断当前窗口是否满足要求。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: p)</span><br><span class="line">        need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span>&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.find(s[++right]) != need.end()) &#123;</span><br><span class="line">            window[s[right]]++;</span><br><span class="line">            <span class="keyword">if</span>(window[s[right]] == need[s[right]])</span><br><span class="line">                match++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left+<span class="number">1</span> &gt;= p.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(match == need.size()) &#123;</span><br><span class="line">                result.push_back(left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(need.find(s[left]) != need.end()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(need[s[left]] == window[s[left]])</span><br><span class="line">                    match--;</span><br><span class="line">                window[s[left]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考上一个题目，可以简化为使用一个哈希表解决。另外，上一题目是比较标准的固定窗口大小的模板，套用之后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: p)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">while</span>(right&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        need[c]--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(need[c]&lt;<span class="number">0</span> &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            need[s[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left == p.size())</span><br><span class="line">            result.push_back(left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p></blockquote><p>这个题目明显可以使用滑窗思想解决。使用一个哈希表记录每个字符出现了多少次，窗口收缩条件为若当前字符出现了多次，则收缩左指针直到当前字符出现一次。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        record[c]++;</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span>(record[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            record[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = max(result, right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>滑动窗口的模板可以分为两个：</p><ol><li>一般模板</li><li>固定滑窗大小的模板</li></ol><p>第二个模板代码更加简洁，并且空间时间复杂度较低。若遇到固定窗口大小的题目，优先使用第二个模板。</p><h3 id="参考-6"><a href="#参考-6" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/" target="_blank" rel="noopener">不同的二叉搜索树 II</a><br><a href="https://leetcode-cn.com/problems/permutation-in-string/solution/hua-dong-chuang-kou-by-muyids-4/" target="_blank" rel="noopener">滑动窗口(十行代码)</a></p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="理论-5"><a href="#理论-5" class="headerlink" title="理论"></a>理论</h3><ol><li><p>定义：</p><ul><li>每个节点中的值必须大于（或等于）存储在其左侧子树中的<strong>任何值。</strong></li><li>每个节点中的值必须小于（或等于）存储在其右子树中的<strong>任何值。</strong></li></ul></li><li><p>二叉搜索树的<strong>中序遍历是递增序列</strong>，这个性质经常能够使用到。</p></li><li><p>二叉搜索树经常使用<strong>递归</strong>方法实现。</p></li><li>在平均情况下，能够在 $\mathcal{O}(\log N)$ 的时间内完成搜索和插入元素。</li></ol><h3 id="常见题目-6"><a href="#常见题目-6" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p></blockquote><p>这个题目的难点在于，一个节点的左子树节点值必须都小于该节点，而该节点的右子树节点值必须大于该节点。因此递归过程中需要使用两个变量在递归的时候记录端点值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBSTCore</span><span class="params">(TreeNode* node, <span class="keyword">long</span> <span class="keyword">long</span> minV, <span class="keyword">long</span> <span class="keyword">long</span> maxV)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;val&lt;=minV || node-&gt;val&gt;=maxV) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValidBSTCore(node-&gt;left, minV, node-&gt;val) &amp;&amp; isValidBSTCore(node-&gt;right, node-&gt;val, maxV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> minV = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxV = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBSTCore(root, minV, maxV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h4><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p></blockquote><p>考虑最简单的插入方式。将插入的节点作为叶子节点插入。插入到哪个叶节点可以遵循如下原则：</p><ol><li>若<code>val &gt; node.val</code>，且右子树为空，则插入到右子树</li><li>若<code>val &lt; node.val</code>，且左子树为空，则插入到左子树</li></ol><p>基于循环方式的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    TreeNode* newNode = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    </span><br><span class="line">    TreeNode* node = root;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &lt; val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;right = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;left = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java版本的基于递归的方式参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert into the right subtree</span></span><br><span class="line">    <span class="keyword">if</span> (val &gt; root.val) root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="comment">// insert into the left subtree</span></span><br><span class="line">    <span class="keyword">else</span> root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h4><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p></blockquote><p>该题的考察点在于二叉搜索树的定义。</p><p>首先介绍一下二叉搜索树前驱节点、后继节点的概念：</p><ol><li>前驱节点：比当前节点小的最大节点，即中序遍历序列的下一个节点。</li><li>后继节点：比当前节点大的最小节点，即中序遍历序列的前一个节点。</li></ol><p>然后，还需要注意几个关键点：</p><pre><code>1. 对于删除节点，只需要更改当前节点的值即可，不需要调整左右指针
   2. 删除节点的时候只需要让当前节点值等于NULL即可
   3. C++在函数内部会更改形参的值，对于实际调用或者递归的时候，要考虑形参和实参的关系
</code></pre><p>解决问题的思路为：</p><ol><li>若删除的是叶子节点，直接删除即可</li><li>如果含有右节点，则将后继节点的值赋值给当前节点，递归删除后继节点</li><li>如果含有左节点，则将前驱节点的值赋值给当前节点，递归删除前驱节点</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到前驱节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">findPre</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    node = node-&gt;left;</span><br><span class="line">    <span class="keyword">while</span>(node-&gt;right) <span class="comment">// 注意这个判断条件，可以返回不为NULL的结果</span></span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到后驱节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">findPost</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    node = node-&gt;right;</span><br><span class="line">    <span class="keyword">while</span>(node-&gt;left)</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; key) </span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);  <span class="comment">// 注意调用递归的时候更新递归子函数的更改的结果</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; key)</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) &#123;  <span class="comment">// 删除的是叶子节点</span></span><br><span class="line">            <span class="comment">//delete root;  // new对应delete，new[]对应delete[]</span></span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) &#123;  <span class="comment">// 如果含有右子树</span></span><br><span class="line">            TreeNode* post = findPost(root);</span><br><span class="line">            root-&gt;val = post-&gt;val;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, root-&gt;val); <span class="comment">// 必须采用递归的方式，不能直接置post=NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode* pre = findPre(root);</span><br><span class="line">            root-&gt;val = pre-&gt;val;</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下为什么第32行需要采用递归的方式删除。</p><p>首先，从特殊例子来看，如下图所示，节点33的前驱节点为25，后继节点为34，这两个节点均不是叶子节点，所以需要递归删除。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/309271bd1f94c57fd4e19f5eee624dd2ad3ef8e4d5a3b6eca5556e9f2e43a3bc-file_1576477912310" alt="在这里插入图片描述" style="zoom:40%"></p><p>其次，从语法上来看：</p><ol><li>函数内部若直接将<code>post=NULL</code>，则只是局部指针变量指向了<code>NULL</code>，并没有对整个树进行更改</li><li>若在函数内部<code>*post=NULL</code>，则<code>*post</code>是一个<code>TreeNode</code>对象，将该对象置为<code>NULL</code>，会隐式的调用构造函数，而<code>NULL</code>会隐式的转换为0，调用构造函数的结果会将该节点的<code>val</code>置为0，而不是将该块区域置为<code>NULL</code>。</li><li>若采用递归的方式调用，极端情况下，考虑调用的结果<code>root-&gt;right=NULL</code>，<code>root-&gt;right</code>是一个<code>TreeNode</code>指针，可以置为<code>NULL</code>。然后该次调用会将root的结果返回，直到更新整个树。</li></ol><h3 id="参考-7"><a href="#参考-7" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-2/" target="_blank" rel="noopener">二叉搜索树中的插入操作</a></p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="理论-6"><a href="#理论-6" class="headerlink" title="理论"></a>理论</h3><p>回溯法（backtrack）常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于全排列，穷尽所有可能，遍历的过程实际上是一个决策树的遍历过程。时间复杂度一般 $O(N!)$，它不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</p><p>常用模板如下，核心就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">func backtrack(选择列表,路径):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(选择列表,路径)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>在这个模板中需要注意的有：</p><ol><li>路径：也就是已经做出的选择</li><li>选择列表：也就是当前可以做的选择（可以使用<code>可以遍历的下标范围</code>或者<code>标记是否访问过的数组</code>来得到选择列表并避免回溯重复。若访问某一个元素的时候，前面的元素不在选择列表中，则可以使用前者，否则的话可以使用后者）</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件</li></ol><h3 id="常见题目-7"><a href="#常见题目-7" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h4><blockquote><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。<strong>说明：</strong>解集不能包含重复的子集。</p></blockquote><p>这道题明显是需要用回溯法解决的，因为要遍历所有可能的子集。因为不含重复元素，所以参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsetsCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">    result.push_back(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        subsetsCore(result, tmp, nums, i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    subsetsCore(result, tmp, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h4><blockquote><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。<strong>说明：</strong>解集不能包含重复的子集。</p></blockquote><p>该题和上一个题目的区别在于，本题的 nums 中是可能包含重复元素的。若还采用上一题的思路，会出现重复的子集。相比上一个题目，主要多了两个步骤：</p><ol><li>将 nums 中的元素从小到大排序，这样可以保证相同的数字挨在一起</li><li>若<code>i&gt;begin &amp;&amp; nums[i]==nums[i-1]</code>则说明该次循环还在这一级，且出现了重复元素，直接跳过。其中<code>i&gt;begin</code>保证只跳过同级的相同元素，而不同级的相同元素不会跳过</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsetsWithDupCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">    res.push_back(tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 只跳过同级的相同元素，而不同级的相同元素不会跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;begin &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        subsetsWithDupCore(res, tmp, nums, i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());  <span class="comment">// 将元素从小到大排序，方便之后跳过重复元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    subsetsWithDupCore(res, tmp, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h4><blockquote><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p></blockquote><p>因为这是一个全排列问题，在以后面数字作为首字母的时候，前面的数字也要遍历到，因此不能使用下标的变换去更新下一次的回溯范围，而只能使用标记是否访问过的数组。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuteCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flag, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size() == nums.size()) &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        flag[i] = <span class="number">1</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        permuteCore(res, tmp, flag, nums);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(nums.size(), <span class="number">0</span>);</span><br><span class="line">    permuteCore(res, tmp, flag, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h4><blockquote><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p></blockquote><p>该题和上一题的区别在于该题的序列可能包含重复数字。按照 <a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a> 的解题思路，并结合上一题的解法：</p><ol><li>将序列从小到大进行排序，这样可以让重复数字放在一块</li><li><code>i&gt;0 &amp;&amp; !flag[i-1] &amp;&amp; nums[i]==nums[i-1]</code>保证若处于不同层次的循环，且相邻两个元素相等，则不需要进行回溯了。</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuteUniqueCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flag, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size() == nums.size()) &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">/* 需要跳过的有几种情况</span></span><br><span class="line"><span class="comment">        1. flag[i] 表示当前回溯路径第i个元素已经访问了</span></span><br><span class="line"><span class="comment">        2. !flag[i-1]表示已经处于上一层回溯了，此时需要判断是否与前一个元素值相等，相等的话就不用回溯了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(flag[i] || (i&gt;<span class="number">0</span> &amp;&amp; !flag[i<span class="number">-1</span>] &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        flag[i] = <span class="number">1</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        permuteUniqueCore(res, tmp, flag, nums);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end()); <span class="comment">// 一定要排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(nums.size(), <span class="number">0</span>); <span class="comment">// 注意大小，与nums元素一一对应</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    permuteUniqueCore(res, tmp, flag, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h4><blockquote><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的数字可以<strong>无限制重复被选取。</strong></p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。</li></ul></blockquote><p>这个题目有两个地方需要注意：数组 <code>candidates</code>无重复元素、每个元素可以使用多次。使用一个变量<code>sum</code>记录当前<strong>路径</strong>的累加和，若累加和等于<code>target</code>则停止并添加到最终结果中，若累加和大于<code>target</code>则<strong>停止</strong>。因为遍历到后面的元素后，前面的元素不在回溯路径中了，所以可以使用下标范围来得到<strong>选择列表</strong>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combinationSumCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;candidates.size(); i++) &#123;</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        tmp.push_back(candidates[i]);</span><br><span class="line">        combinationSumCore(res, tmp, candidates, i, target, sum);  <span class="comment">// 注意这里的index传参为i，因为数字可以无限制重复选取</span></span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    combinationSumCore(res, tmp, candidates, <span class="number">0</span>, target, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h4><blockquote><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的每个数字在每个组合中<strong>只能使用一次。</strong></p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。</li></ul></blockquote><p>这个题目和上一个题目的区别在于：数组<code>candidates</code>可能含有重复元素、每个元素只能使用一次。根据前面的经验，处理重复元素的方法：</p><ol><li>将 <code>candidates</code> 中的元素从小到大排序，这样可以保证相同的数字挨在一起</li><li>若<code>i&gt;index &amp;&amp; candidates[i]==candidates[i-1]</code>则说明该次循环还在这一级，且出现了重复元素，直接跳过。其中<code>i&gt;index</code>保证只跳过同级的相同元素，而不同级的相同元素不会跳过</li></ol><p>另外，因为每个元素只能使用一次，因此在进行下一次回溯的时候，下标需要加1。最终参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combinationSumCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;candidates.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;index &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        tmp.push_back(candidates[i]);</span><br><span class="line">        combinationSumCore(res, tmp, candidates, i+<span class="number">1</span>, target, sum);  <span class="comment">// 注意这里的index传参为i+1，因为数字可以只能选取一次</span></span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    sort(candidates.begin(), candidates.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    combinationSumCore(res, tmp, candidates, <span class="number">0</span>, target, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h4><blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/17_telephone_keypad.png" alt="img" style="zoom:50%"></p></blockquote><p>这个题目明显要使用回溯去解决，因为要从各个按键里面找到一个字母，然后组成结果，不存在优化的可能。</p><ol><li>路径：使用<code>vector</code>记录</li><li>选择列表：当前按下数字对应的所有字母</li><li>结束条件：若当前路径的长度等于<code>digits</code>的长度，则将路径添加到最终路径，终止本次回溯</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">letterCombinationsCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span>&amp; digits, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;&amp; m, <span class="built_in">string</span>&amp; tmpS, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == digits.size()) &#123;</span><br><span class="line">        res.push_back(tmpS);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到当前数字对应的字母</span></span><br><span class="line">    <span class="built_in">string</span> s = m[digits[index]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++) &#123;</span><br><span class="line">        tmpS.push_back(s[i]);</span><br><span class="line">        letterCombinationsCore(res, digits, m, tmpS, index+<span class="number">1</span>);</span><br><span class="line">        tmpS.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(digits.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m&#123;</span><br><span class="line">        &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> tmpS;</span><br><span class="line">    letterCombinationsCore(res, digits, m, tmpS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></h4><blockquote><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。返回 <em>s</em> 所有可能的分割方案。</p></blockquote><p>这道题可以使用回溯法解决。</p><ol><li>路径：使用<code>vector&lt;string&gt;</code>记录当前所有回文子串</li><li>选择列表：从当前索引到 <code>s.size()-1</code> 均可以当做子串的结尾；若当前子串为回文子串，则继续进行回溯</li><li>结束条件：当前索引已经等于<code>s.size()</code>了，则将当前路径添加到最终结果中</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;  <span class="comment">// 使用递归+双指针的方式判断是否为回文子串，代码更加简洁</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[i++] == s[j--]) <span class="keyword">return</span> judge(s, i, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; result, <span class="keyword">int</span> begin, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp, <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin == s.size()) &#123;</span><br><span class="line">        result.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;s.size(); i++) &#123;  <span class="comment">// 每一个索引都可以作为当前子串的结尾索引</span></span><br><span class="line">        <span class="keyword">if</span>(judge(s, begin, i)) &#123;  <span class="comment">// 若为回文子串，则继续进行回溯；否则进行下一个循环</span></span><br><span class="line">            tmp.push_back(s.substr(begin, i-begin+<span class="number">1</span>));;</span><br><span class="line">            partitionCore(result, i+<span class="number">1</span>, tmp, s);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">    partitionCore(result, <span class="number">0</span>, tmp, s);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></h4><blockquote><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。</p></blockquote><p>这个题目比较复杂，借助这道题和大佬的讲解。这里详细讲解一下回溯算法的分析步骤。</p><p>回溯算法事实上就是在一个树形问题上做深度优先遍历，因此 <strong>首先需要把问题转换为树形问题</strong>。在画树形图的过程中，一定会发现有些枝叶是没有必要的，把没有必要的枝叶剪去的操作就是<strong>剪枝</strong>，在代码中一般通过 <code>break</code> 或者 <code>contine</code> 和 <code>return</code> （表示递归终止）实现。画出本题的树形图如下图所示：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/b581bdde1cef982f0af3182af17fc3c41960c76a7445af0dcfd445c89b4c2eaa-「力扣」第 93 题：复原 IP 地址-1.png" alt="「力扣」第 93 题：复原 IP 地址-1.png" style="zoom:43%"></p><ol><li>路径：这个题目麻烦的地方是IP地址之间要用<code>.</code>进行分割，若用<code>string</code>存储路径，则比较麻烦，不如直接使用<code>vector&lt;string&gt;</code>进行记录，记录完毕之后若满足条件，则再拼接到一块</li><li>选择列表：因为已经遍历过的元素，以后不会在出现了，因为可以使用下标记录下一次访问的位置。每次回溯的时候，可遍历的子串长度在<code>[1,3]</code>之间。并且需要排除如下几种情况<ul><li>若<code>子串长度+当前下标-1&gt;=.size()</code></li><li><code>0x、0xx</code>都是非法的</li><li>子串的数值不能大于255</li></ul></li><li>结束条件：<ul><li>若遍历完所有的<code>s</code>，并且已经有四段合法字符串了，则记为有效结果，结束</li><li>若没有遍历完<code>s</code>，并且已经有四段合法字符串了，则记为无效结果，结束</li></ul></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp, <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start==s.size() &amp;&amp; tmp.size()==<span class="number">4</span>) &#123; <span class="comment">// tmp有四段，并且遍历完s了</span></span><br><span class="line">        <span class="built_in">string</span> str = tmp[<span class="number">0</span>];  <span class="comment">// 这样写可以保证最后不会多一个 .</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;tmp.size(); i++)</span><br><span class="line">            str = str + <span class="string">'.'</span> + tmp[i];</span><br><span class="line">        res.push_back(str); <span class="comment">// 其中一种可行方案</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(start&lt;s.size() &amp;&amp; tmp.size()==<span class="number">4</span>)  <span class="comment">// tmp有四段，并且没有遍历完s</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len&lt;=<span class="number">3</span>; len++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(len+start<span class="number">-1</span> &gt;= s.size())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(len!=<span class="number">1</span> &amp;&amp; s[start]==<span class="string">'0'</span>)  <span class="comment">// 0x，00x非法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">string</span> str = s.substr(start, len);</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">3</span> &amp;&amp; atoi(str.c_str())&gt;<span class="number">255</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        tmp.push_back(str);</span><br><span class="line">        DFS(res, tmp, s, start+len);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">    DFS(res, tmp, s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-8"><a href="#参考-8" class="headerlink" title="参考"></a>参考</h3><p><a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">回溯算法解题套路框架</a><br><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/c-shuang-bai-hui-su-xie-fa-by-jiang-ly/" target="_blank" rel="noopener">C++ 双百回溯写法</a><br><a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/" target="_blank" rel="noopener">回溯算法（画图分析剪枝条件）</a><br><a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/" target="_blank" rel="noopener">『手画图解』DFS 回溯 细节</a></p><h2 id="参考-9"><a href="#参考-9" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/" target="_blank" rel="noopener">Sort List （归并排序链表）</a><br><a href="https://blog.csdn.net/fuxuemingzhu/article/details/101900729" target="_blank" rel="noopener">【LeetCode】代码模板，刷题必会</a><br><a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">labuladong的算法小抄</a><br><a href="https://greyireland.gitbook.io/algorithm-pattern/" target="_blank" rel="noopener">algorithm-pattern</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/" title="LeetCode总结">https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/数据结构/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a><a href="/tags/算法/" rel="tag"><i class="fa fa-tag"></i> 算法</a></div><div class="post-nav"><div class="post-nav-item"><a href="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/" rel="prev" title="Few-Shot Learning with Global Class Representations"><i class="fa fa-chevron-left"></i> Few-Shot Learning with Global Class Representations</a></div><div class="post-nav-item"> <a href="/Tools/Docker/Dockerfile指令详解/" rel="next" title="Dockerfile指令详解">Dockerfile指令详解<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树"><span class="nav-number">1.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树遍历模板"><span class="nav-number">1.1.</span> <span class="nav-text">二叉树遍历模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#递归法"><span class="nav-number">1.1.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代法"><span class="nav-number">1.1.2.</span> <span class="nav-text">迭代法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见题目"><span class="nav-number">1.2.</span> <span class="nav-text">常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#110-平衡二叉树"><span class="nav-number">1.2.1.</span> <span class="nav-text">110. 平衡二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">1.3.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理论"><span class="nav-number">2.1.</span> <span class="nav-text">理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见题目-1"><span class="nav-number">2.2.</span> <span class="nav-text">常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#83-删除排序链表中的重复元素"><span class="nav-number">2.2.1.</span> <span class="nav-text">83. 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#82-删除排序链表中的重复元素-II"><span class="nav-number">2.2.2.</span> <span class="nav-text">82. 删除排序链表中的重复元素 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#206-反转链表"><span class="nav-number">2.2.3.</span> <span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#92-反转链表-II"><span class="nav-number">2.2.4.</span> <span class="nav-text">92. 反转链表 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-合并两个有序链表"><span class="nav-number">2.2.5.</span> <span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#86-分隔链表"><span class="nav-number">2.2.6.</span> <span class="nav-text">86. 分隔链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#148-排序链表"><span class="nav-number">2.2.7.</span> <span class="nav-text">148. 排序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#143-重排链表"><span class="nav-number">2.2.8.</span> <span class="nav-text">143. 重排链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#141-环形链表"><span class="nav-number">2.2.9.</span> <span class="nav-text">141. 环形链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#142-环形链表-II"><span class="nav-number">2.2.10.</span> <span class="nav-text">142. 环形链表 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#234-回文链表"><span class="nav-number">2.2.11.</span> <span class="nav-text">234. 回文链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#138-复制带随机指针的链表"><span class="nav-number">2.2.12.</span> <span class="nav-text">138. 复制带随机指针的链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考-1"><span class="nav-number">2.3.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈和队列"><span class="nav-number">3.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理论-1"><span class="nav-number">3.1.</span> <span class="nav-text">理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈常见题目"><span class="nav-number">3.2.</span> <span class="nav-text">栈常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#155-最小栈"><span class="nav-number">3.2.1.</span> <span class="nav-text">155. 最小栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#150-逆波兰表达式求值"><span class="nav-number">3.2.2.</span> <span class="nav-text">150. 逆波兰表达式求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#394-字符串解码"><span class="nav-number">3.2.3.</span> <span class="nav-text">394. 字符串解码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#133-克隆图"><span class="nav-number">3.2.4.</span> <span class="nav-text">133. 克隆图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#200-岛屿数量"><span class="nav-number">3.2.5.</span> <span class="nav-text">200. 岛屿数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#84-柱状图中最大的矩形"><span class="nav-number">3.2.6.</span> <span class="nav-text">84. 柱状图中最大的矩形</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列常见题目"><span class="nav-number">3.3.</span> <span class="nav-text">队列常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#232-用栈实现队列"><span class="nav-number">3.3.1.</span> <span class="nav-text">232. 用栈实现队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#542-01-矩阵"><span class="nav-number">3.3.2.</span> <span class="nav-text">542. 01 矩阵</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考-2"><span class="nav-number">3.4.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制"><span class="nav-number">4.</span> <span class="nav-text">二进制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#规律"><span class="nav-number">4.1.</span> <span class="nav-text">规律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见题目-2"><span class="nav-number">4.2.</span> <span class="nav-text">常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#136-只出现一次的数字"><span class="nav-number">4.2.1.</span> <span class="nav-text">136. 只出现一次的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#137-只出现一次的数字-II"><span class="nav-number">4.2.2.</span> <span class="nav-text">137. 只出现一次的数字 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#260-只出现一次的数字-III"><span class="nav-number">4.2.3.</span> <span class="nav-text">260. 只出现一次的数字 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#191-位1的个数"><span class="nav-number">4.2.4.</span> <span class="nav-text">191. 位1的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#338-比特位计数"><span class="nav-number">4.2.5.</span> <span class="nav-text">338. 比特位计数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#190-颠倒二进制位"><span class="nav-number">4.2.6.</span> <span class="nav-text">190. 颠倒二进制位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#201-数字范围按位与"><span class="nav-number">4.2.7.</span> <span class="nav-text">201. 数字范围按位与</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1371-每个元音包含偶数次的最长子字符串"><span class="nav-number">4.2.8.</span> <span class="nav-text">1371. 每个元音包含偶数次的最长子字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考-3"><span class="nav-number">4.3.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找"><span class="nav-number">5.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找模板"><span class="nav-number">5.1.</span> <span class="nav-text">二分查找模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见题目-3"><span class="nav-number">5.2.</span> <span class="nav-text">常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#35-搜索插入位置"><span class="nav-number">5.2.1.</span> <span class="nav-text">35. 搜索插入位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#74-搜索二维矩阵"><span class="nav-number">5.2.2.</span> <span class="nav-text">74. 搜索二维矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#278-第一个错误的版本"><span class="nav-number">5.2.3.</span> <span class="nav-text">278. 第一个错误的版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#153-寻找旋转排序数组中的最小值"><span class="nav-number">5.2.4.</span> <span class="nav-text">153. 寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#154-寻找旋转排序数组中的最小值-II"><span class="nav-number">5.2.5.</span> <span class="nav-text">154. 寻找旋转排序数组中的最小值 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-搜索旋转排序数组"><span class="nav-number">5.2.6.</span> <span class="nav-text">33. 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#81-搜索旋转排序数组-II"><span class="nav-number">5.2.7.</span> <span class="nav-text">81. 搜索旋转排序数组 II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考-4"><span class="nav-number">5.3.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法"><span class="nav-number">6.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">7.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理论-2"><span class="nav-number">7.1.</span> <span class="nav-text">理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵类型（10-）"><span class="nav-number">7.2.</span> <span class="nav-text">矩阵类型（10%）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#120-三角形最小路径和"><span class="nav-number">7.2.1.</span> <span class="nav-text">120. 三角形最小路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64-最小路径和"><span class="nav-number">7.2.2.</span> <span class="nav-text">64. 最小路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62-不同路径"><span class="nav-number">7.2.3.</span> <span class="nav-text">62. 不同路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#63-不同路径-II"><span class="nav-number">7.2.4.</span> <span class="nav-text">63. 不同路径 II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列类型（40-）"><span class="nav-number">7.3.</span> <span class="nav-text">序列类型（40%）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#70-爬楼梯"><span class="nav-number">7.3.1.</span> <span class="nav-text">70. 爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55-跳跃游戏"><span class="nav-number">7.3.2.</span> <span class="nav-text">55. 跳跃游戏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45-跳跃游戏-II"><span class="nav-number">7.3.3.</span> <span class="nav-text">45. 跳跃游戏 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-最长回文子串"><span class="nav-number">7.3.4.</span> <span class="nav-text">5. 最长回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#132-分割回文串-II"><span class="nav-number">7.3.5.</span> <span class="nav-text">132. 分割回文串 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#300-最长上升子序列"><span class="nav-number">7.3.6.</span> <span class="nav-text">300. 最长上升子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#139-单词拆分"><span class="nav-number">7.3.7.</span> <span class="nav-text">139. 单词拆分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个序列类型（40-）"><span class="nav-number">7.4.</span> <span class="nav-text">两个序列类型（40%）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1143-最长公共子序列"><span class="nav-number">7.4.1.</span> <span class="nav-text">1143. 最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72-编辑距离"><span class="nav-number">7.4.2.</span> <span class="nav-text">72. 编辑距离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#零钱和背包（10-）"><span class="nav-number">7.5.</span> <span class="nav-text">零钱和背包（10%）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#322-零钱兑换"><span class="nav-number">7.5.1.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#92-背包问题"><span class="nav-number">7.5.2.</span> <span class="nav-text">92. 背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#01背包问题"><span class="nav-number">7.5.3.</span> <span class="nav-text">01背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完全背包问题"><span class="nav-number">7.5.4.</span> <span class="nav-text">完全背包问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考-5"><span class="nav-number">7.6.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贪心算法"><span class="nav-number">8.</span> <span class="nav-text">贪心算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归思维"><span class="nav-number">9.</span> <span class="nav-text">递归思维</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理论-3"><span class="nav-number">9.1.</span> <span class="nav-text">理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见题目-4"><span class="nav-number">9.2.</span> <span class="nav-text">常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#344-反转字符串"><span class="nav-number">9.2.1.</span> <span class="nav-text">344. 反转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-两两交换链表中的节点"><span class="nav-number">9.2.2.</span> <span class="nav-text">24. 两两交换链表中的节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#95-不同的二叉搜索树-II"><span class="nav-number">9.2.3.</span> <span class="nav-text">95. 不同的二叉搜索树 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#509-斐波那契数"><span class="nav-number">9.2.4.</span> <span class="nav-text">509. 斐波那契数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#滑动窗口思想"><span class="nav-number">10.</span> <span class="nav-text">滑动窗口思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理论-4"><span class="nav-number">10.1.</span> <span class="nav-text">理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见题目-5"><span class="nav-number">10.2.</span> <span class="nav-text">常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#76-最小覆盖子串"><span class="nav-number">10.2.1.</span> <span class="nav-text">76. 最小覆盖子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#567-字符串的排列"><span class="nav-number">10.2.2.</span> <span class="nav-text">567. 字符串的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#438-找到字符串中所有字母异位词"><span class="nav-number">10.2.3.</span> <span class="nav-text">438. 找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-无重复字符的最长子串"><span class="nav-number">10.2.4.</span> <span class="nav-text">3. 无重复字符的最长子串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">10.3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考-6"><span class="nav-number">10.4.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">11.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理论-5"><span class="nav-number">11.1.</span> <span class="nav-text">理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见题目-6"><span class="nav-number">11.2.</span> <span class="nav-text">常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#98-验证二叉搜索树"><span class="nav-number">11.2.1.</span> <span class="nav-text">98. 验证二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#701-二叉搜索树中的插入操作"><span class="nav-number">11.2.2.</span> <span class="nav-text">701. 二叉搜索树中的插入操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#450-删除二叉搜索树中的节点"><span class="nav-number">11.2.3.</span> <span class="nav-text">450. 删除二叉搜索树中的节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考-7"><span class="nav-number">11.3.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回溯法"><span class="nav-number">12.</span> <span class="nav-text">回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理论-6"><span class="nav-number">12.1.</span> <span class="nav-text">理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见题目-7"><span class="nav-number">12.2.</span> <span class="nav-text">常见题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#78-子集"><span class="nav-number">12.2.1.</span> <span class="nav-text">78. 子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#90-子集-II"><span class="nav-number">12.2.2.</span> <span class="nav-text">90. 子集 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-全排列"><span class="nav-number">12.2.3.</span> <span class="nav-text">46. 全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47-全排列-II"><span class="nav-number">12.2.4.</span> <span class="nav-text">47. 全排列 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-组合总和"><span class="nav-number">12.2.5.</span> <span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#40-组合总和-II"><span class="nav-number">12.2.6.</span> <span class="nav-text">40. 组合总和 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-电话号码的字母组合"><span class="nav-number">12.2.7.</span> <span class="nav-text">17. 电话号码的字母组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#131-分割回文串"><span class="nav-number">12.2.8.</span> <span class="nav-text">131. 分割回文串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#93-复原IP地址"><span class="nav-number">12.2.9.</span> <span class="nav-text">93. 复原IP地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考-8"><span class="nav-number">12.3.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考-9"><span class="nav-number">13.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">305</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">364</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">30:07</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '01ce349200c68e39dd2c5701aadfbe55',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>