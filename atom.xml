<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zdaiot</title>
  
  <subtitle>404NotFound</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zdaiot.com/"/>
  <updated>2022-04-15T12:10:24.000Z</updated>
  <id>https://www.zdaiot.com/</id>
  
  <author>
    <name>zdaiot</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TensorFlow中的Queue</title>
    <link href="https://www.zdaiot.com/MLFrameworks/TensorFlow/TensorFlow%E4%B8%AD%E7%9A%84Queue/"/>
    <id>https://www.zdaiot.com/MLFrameworks/TensorFlow/TensorFlow中的Queue/</id>
    <published>2022-04-15T12:10:24.000Z</published>
    <updated>2022-04-15T12:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>事先声明，本文章大部分内容来源于<a href="https://www.jianshu.com/p/d063804fb272" target="_blank" rel="noopener">理解TensorFlow的Queue</a>，并添加个人理解。</p><p>Queue相关的概念只有三个：</p><ul><li><code>Queue</code>是TF队列和缓存机制的实现</li><li><code>QueueRunner</code>是TF中对操作Queue的线程的封装</li><li><code>Coordinator</code>是TF中用来协调线程运行的工具</li></ul><p>虽然它们经常同时出现，但这三样东西在TensorFlow里面是可以单独使用的，不妨先分开来看待。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>根据实现的方式不同，分成具体的几种类型，例如：</p><ul><li>tf.FIFOQueue 按入列顺序出列的队列</li><li>tf.RandomShuffleQueue 随机顺序出列的队列</li><li>tf.PaddingFIFOQueue 以固定长度批量出列的队列</li><li>tf.PriorityQueue 带优先级出列的队列</li><li>… …</li></ul><p>这些类型的Queue除了自身的性质不太一样外，创建、使用的方法基本是相同的。</p><p>以FIFOQueue为例，创建函数的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.FIFOQueue(capacity, dtypes, shapes=<span class="literal">None</span>, names=<span class="literal">None</span> ...)</span><br></pre></td></tr></table></figure><p>Queue主要包含<strong>入列（enqueue）</strong>和<strong>出列（dequeue）</strong>两个操作。enqueue（入队）操作返回计算图中的一个Operation节点，dequeue操作返回一个Tensor值。Tensor在创建时同样只是一个定义（或称为“声明”），需要放在Session中运行才能获得真正的数值。下面是一个单独使用Queue的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.InteractiveSession()</span><br><span class="line"></span><br><span class="line">q = tf.FIFOQueue(<span class="number">2</span>, <span class="string">"float"</span>)</span><br><span class="line">init = q.enqueue_many(([<span class="number">0</span>,<span class="number">0</span>],))  <span class="comment"># 入列多个元素</span></span><br><span class="line"></span><br><span class="line">x = q.dequeue()</span><br><span class="line">y = x+<span class="number">1</span></span><br><span class="line">q_inc = q.enqueue([y])</span><br><span class="line"></span><br><span class="line">init.run()</span><br><span class="line">q_inc.run()</span><br><span class="line">q_inc.run()</span><br><span class="line">q_inc.run()</span><br><span class="line">x.<span class="keyword">eval</span>()  <span class="comment"># 返回1</span></span><br><span class="line">x.<span class="keyword">eval</span>()  <span class="comment"># 返回2</span></span><br><span class="line">x.<span class="keyword">eval</span>()  <span class="comment"># 卡住</span></span><br></pre></td></tr></table></figure><p>注意，如果一次性入列超过Queue Size的数据，enqueue操作会卡住，直到有数据（被其他线程）从队列取出。对一个已经取空的队列使用dequeue操作也会卡住，直到有新的数据（从其他线程）写入。</p><h2 id="QueueRunner"><a href="#QueueRunner" class="headerlink" title="QueueRunner"></a>QueueRunner</h2><p>Tensorflow的计算主要在使用CPU/GPU和内存，而数据读取涉及磁盘操作，速度远低于前者操作。因此通常会<strong>使用多个线程读取数据，然后使用一个线程消费数据。QueueRunner就是来管理这些读写队列的线程的。</strong></p><p>QueueRunner需要与Queue一起使用（这名字已经注定了它和Queue脱不开干系），但并不一定必须使用Coordinator。看下面这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line">q = tf.FIFOQueue(<span class="number">10</span>, <span class="string">"float"</span>)  </span><br><span class="line">counter = tf.Variable(<span class="number">0.0</span>)  <span class="comment">#计数器</span></span><br><span class="line"><span class="comment"># 给计数器加一</span></span><br><span class="line">increment_op = tf.assign_add(counter, <span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># 将计数器加入队列</span></span><br><span class="line">enqueue_op = q.enqueue(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建QueueRunner</span></span><br><span class="line"><span class="comment"># 用多个线程向队列添加数据</span></span><br><span class="line"><span class="comment"># 这里实际创建了4个线程，两个增加计数，两个执行入队</span></span><br><span class="line">qr = tf.train.QueueRunner(q, enqueue_ops=[increment_op, enqueue_op] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程</span></span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">tf.global_variables_initializer().run()</span><br><span class="line"><span class="comment"># 启动入队线程</span></span><br><span class="line">qr.create_threads(sess, start=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">print</span> (sess.run(q.dequeue()))</span><br></pre></td></tr></table></figure><p>增加计数的进程会不停的后台运行，执行入队的进程会先执行10次（因为队列长度只有10），然后主线程开始消费数据，当一部分数据消费被后，入队的进程又会开始执行。最终主线程消费完20个数据后停止，但其他线程继续运行，程序不会结束。</p><h2 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h2><p>Coordinator是个用来保存线程组运行状态的协调器对象，它和TensorFlow的Queue没有必然关系，是可以单独和Python线程使用的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(coord, id)</span>:</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> coord.should_stop():</span><br><span class="line">        print(id)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 只有1号线程调用request_stop方法</span></span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="number">2</span> <span class="keyword">and</span> id == <span class="number">1</span>):</span><br><span class="line">            coord.request_stop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程</span></span><br><span class="line">coord = tf.train.Coordinator()</span><br><span class="line"><span class="comment"># 使用Python API创建10个线程</span></span><br><span class="line">threads = [threading.Thread(target=loop, args=(coord, i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动所有线程，并等待线程结束</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads: t.start()</span><br><span class="line">coord.join(threads)</span><br></pre></td></tr></table></figure><p>将这个程序运行起来，会发现所有的子线程执行完两个周期后都会停止，主线程会等待所有子线程都停止后结束，从而使整个程序结束。由此可见，只要有任何一个线程调用了Coordinator的<code>request_stop</code>方法，所有的线程都可以通过<code>should_stop</code>方法感知并停止当前线程。</p><p>将QueueRunner和Coordinator一起使用，实际上就是封装了这个判断操作，从而使任何一个现成出现异常时，能够正常结束整个程序，同时主线程也可以直接调用<code>request_stop</code>方法来停止所有子线程的执行。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>在TensorFlow中用Queue的经典模式有两种，都是配合了QueueRunner和Coordinator一起使用的。</p><p>第一种，显式的创建QueueRunner，然后调用它的<code>create_threads</code>方法启动线程。例如下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1000个4维输入向量，每个数取值为1-10之间的随机数</span></span><br><span class="line">data = <span class="number">10</span> * np.random.randn(<span class="number">1000</span>, <span class="number">4</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment"># 1000个随机的目标值，值为0或1</span></span><br><span class="line">target = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Queue，队列中每一项包含一个输入数据和相应的目标值</span></span><br><span class="line">queue = tf.FIFOQueue(capacity=<span class="number">50</span>, dtypes=[tf.float32, tf.int32], shapes=[[<span class="number">4</span>], []])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量入列数据（这是一个Operation）</span></span><br><span class="line">enqueue_op = queue.enqueue_many([data, target])</span><br><span class="line"><span class="comment"># 出列数据（这是一个Tensor定义）</span></span><br><span class="line">data_sample, label_sample = queue.dequeue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建包含4个线程的QueueRunner</span></span><br><span class="line">qr = tf.train.QueueRunner(queue, [enqueue_op] * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 创建Coordinator</span></span><br><span class="line">    coord = tf.train.Coordinator()</span><br><span class="line">    <span class="comment"># 启动QueueRunner管理的线程</span></span><br><span class="line">    enqueue_threads = qr.create_threads(sess, coord=coord, start=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 主线程，消费100个数据</span></span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">if</span> coord.should_stop():</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        data_batch, label_batch = sess.run([data_sample, label_sample])</span><br><span class="line">    <span class="comment"># 主线程计算完成，停止所有采集数据的进程</span></span><br><span class="line">    coord.request_stop()</span><br><span class="line">    coord.join(enqueue_threads)</span><br></pre></td></tr></table></figure><p>第二种，使用全局的<code>start_queue_runners</code>方法启动线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时打开多个文件，显示创建Queue，同时隐含了QueueRunner的创建</span></span><br><span class="line">filename_queue = tf.train.string_input_producer([<span class="string">"data1.csv"</span>,<span class="string">"data2.csv"</span>])</span><br><span class="line">reader = tf.TextLineReader(skip_header_lines=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># Tensorflow的Reader对象可以直接接受一个Queue作为输入</span></span><br><span class="line">key, value = reader.read(filename_queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    coord = tf.train.Coordinator()</span><br><span class="line">    <span class="comment"># 启动计算图中所有的队列线程</span></span><br><span class="line">    threads = tf.train.start_queue_runners(coord=coord)</span><br><span class="line">    <span class="comment"># 主线程，消费100个数据</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        features, labels = sess.run([data_batch, label_batch])</span><br><span class="line">    <span class="comment"># 主线程计算完成，停止所有采集数据的进程</span></span><br><span class="line">    coord.request_stop()</span><br><span class="line">    coord.join(threads)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>tf.train.string_input_produecer</code>会将一个隐含的QueueRunner添加到全局图中（类似的操作还有<code>tf.train.shuffle_batch</code>、<code>tf.train.slice_input_producer</code>等）。</p><p>由于没有显式地返回QueueRunner来用create_threads启动线程，这里使用了<code>tf.train.start_queue_runners</code>方法直接启动<code>tf.GraphKeys.QUEUE_RUNNERS</code>集合中的所有队列线程。</p><p>这两种方式在效果上是等效的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/d063804fb272" target="_blank" rel="noopener">理解TensorFlow的Queue</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事先声明，本文章大部分内容来源于&lt;a href=&quot;https://www.jianshu.com/p/d063804fb272&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;理解TensorFlow的Queue&lt;/a&gt;，并添加个人理解。&lt;/p&gt;
&lt;p&gt;Queue相关的概念只有三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Queue&lt;/code&gt;是TF队列和缓存机制的实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QueueRunner&lt;/code&gt;是TF中对操作Queue的线程的封装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Coordinator&lt;/code&gt;是TF中用来协调线程运行的工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然它们经常同时出现，但这三样东西在TensorFlow里面是可以单独使用的，不妨先分开来看待。&lt;/p&gt;
&lt;h2 id=&quot;Queue&quot;&gt;&lt;a href=&quot;#Queue&quot; class=&quot;headerlink&quot; title=&quot;Queue&quot;&gt;&lt;/a&gt;Queue&lt;/h2&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="TensorFlow" scheme="https://www.zdaiot.com/categories/MLFrameworks/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="https://www.zdaiot.com/tags/TensorFlow/"/>
    
      <category term="Queue" scheme="https://www.zdaiot.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow模型保存总结</title>
    <link href="https://www.zdaiot.com/MLFrameworks/TensorFlow/TensorFlow%E6%A8%A1%E5%9E%8B%E4%BF%9D%E5%AD%98%E6%80%BB%E7%BB%93/"/>
    <id>https://www.zdaiot.com/MLFrameworks/TensorFlow/TensorFlow模型保存总结/</id>
    <published>2022-04-09T06:32:24.000Z</published>
    <updated>2022-04-09T06:32:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>事先声明，以下大部分内容来源于<a href="https://zhuanlan.zhihu.com/p/113734249" target="_blank" rel="noopener">tensorflow 模型导出总结</a>，并加上个人见解。</p><p>tensorflow 1.0 以及2.0 提供了多种不同的模型导出格式，例如说有checkpoint，SavedModel，Frozen GraphDef，Keras model（HDF5） 以及用于移动端，嵌入式的TFLite。 </p><p>模型导出主要包含了：参数以及网络结构的导出，不同的导出格式可能是分别导出，或者是整合成一个独立的文件。</p><ul><li>参数和网络结构分开保存：checkpoint， SavedModel</li><li>只保存权重：HDF5（可选）</li><li>参数和网络结构保存在一个文件：Frozen GraphDef，HDF5（可选）</li></ul><p>在tensorflow 1.0中，可以见下图，主要有三种主要的API：Keras、Estimator以及Legacy即最初的session模型，其中tf.Keras主要保存为HDF5，Estimator保存为SavedModel，而Lagacy主要保存的是Checkpoint，并且可以通过freeze_graph，将模型变量冻结，得到Frozen GradhDef的文件。这三种格式的模型，都可以通过TFLite Converter导出为 <code>.tflite</code> 的模型文件，用于安卓/ios/嵌入式设备的serving。</p><p><img src="/MLFrameworks/TensorFlow/TensorFlow模型保存总结/v2-b71487837e3a0527aaa15fe6b35fcef6_b.jpg" alt="img"></p><p>在tensorflow 2.0中，推荐使用SavedModel进行模型的保存，所以keras默认导出格式是SavedModel，也可以通过显性使用 <code>.h5</code> 后缀，使得保存的模型格式为HDF5 。 此外其他low level API，都支持导出为SavedModel格式，以及Concrete Functions。Concrete Function是一个签名函数，有固定格式的输入和输出。 最终转化成Flatbuffer，服务端运行结束。</p><h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>checkpint（CKPT）的导出是网络结构和参数权重分开保存的。其组成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkpoint <span class="comment"># 列出该目录下，保存的所有的checkpoint列表，下面有具体的例子</span></span><br><span class="line">├── events.out.tfevents<span class="number">.1583930869</span>.prod-cloudserver-gpu169 <span class="comment"># tensorboad可视化所需文件，可以直观看出模型的结构</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    model.ckpt-13000表示前缀，代表第13000 global steps时的保存结果，我们在指定checkpoint加载时，也只需要说明前缀即可。</span></span><br><span class="line"><span class="string">    你可以只用 .ckpt-meta 和 .ckpt-data 恢复一个模型 </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">├── model.ckpt<span class="number">-13000.</span>index <span class="comment"># 可能是内部需要的某种索引来正确映射前两个文件，它通常不是必需的</span></span><br><span class="line">├── model.ckpt<span class="number">-13000.</span>data<span class="number">-00000</span>-of<span class="number">-00001</span> <span class="comment"># 包含所有变量的值，没有结构</span></span><br><span class="line">├── model.ckpt<span class="number">-13000.</span>meta <span class="comment"># 包含元图，即计算图的结构，不一定含有变量，就算有变量也没有变量的值（基本上你可以在tensorboard/graph中看到）。</span></span><br></pre></td></tr></table></figure><p>所以一个checkpoint 组成是由两个部分，三个文件组成，其中网络结构部分（meta文件），以及参数部分（参数名：index，参数值：data）</p><p>其中<code>checkpoint</code>文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model_checkpoint_path: &quot;model.ckpt-16329&quot;</span><br><span class="line">all_model_checkpoint_paths: &quot;model.ckpt-13000&quot;</span><br><span class="line">all_model_checkpoint_paths: &quot;model.ckpt-14000&quot;</span><br><span class="line">all_model_checkpoint_paths: &quot;model.ckpt-15000&quot;</span><br><span class="line">all_model_checkpoint_paths: &quot;model.ckpt-16000&quot;</span><br><span class="line">all_model_checkpoint_paths: &quot;model.ckpt-16329&quot;</span><br></pre></td></tr></table></figure><p>使用<code>tensorboard --logdir PATH_TO_CHECKPOINT --host=127.0.0.1</code>: tensorboard 会调用最新的events.out.tfevents.*文件，并生成tensorboard，例如下图：</p><p><img src="/MLFrameworks/TensorFlow/TensorFlow模型保存总结/v2-4d9cb38d90d32706892fde8d9de4b07c_b.jpg" alt="img"></p><h3 id="导出成CKPT"><a href="#导出成CKPT" class="headerlink" title="导出成CKPT"></a>导出成CKPT</h3><ul><li>tensorflow 1.0</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in tensorflow 1.0</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line">saver.save(sess=session, save_path=args.save_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若不想保存meta文件</span></span><br><span class="line">saver2save(sess=session, save_path=args.save_path, write_meta_graph=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li>estimator</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># estimator</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">通过 RunConfig 配置多少时间或者多少个steps 保存一次模型，默认600s 保存一次。</span></span><br><span class="line"><span class="string">具体参考 https://zhuanlan.zhihu.com/p/112062303</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">run_config = tf.estimator.RunConfig(</span><br><span class="line">    model_dir=FLAGS.output_dir, <span class="comment"># 模型保存路径</span></span><br><span class="line">    session_config=config,</span><br><span class="line">    save_checkpoints_steps=FLAGS.save_checkpoints_steps, <span class="comment"># 多少steps保存一次ckpt</span></span><br><span class="line">    keep_checkpoint_max=<span class="number">1</span>)</span><br><span class="line">estimator = tf.estimator.Estimator(</span><br><span class="line">  model_fn=model_fn,</span><br><span class="line">  config=run_config,</span><br><span class="line">  params=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>关于estimator的介绍可以参考：<a href="https://zhuanlan.zhihu.com/p/112062303" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112062303</a></p></blockquote><h3 id="加载CKPT"><a href="#加载CKPT" class="headerlink" title="加载CKPT"></a>加载CKPT</h3><ul><li>tf1.0<br>ckpt加载的脚本如下，加载完后，session就会是保存的ckpt了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tf1.0</span></span><br><span class="line">session = tf.Session()</span><br><span class="line">session.run(tf.global_variables_initializer())</span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line">saver.restore(sess=session, save_path=args.save_path)  <span class="comment"># 读取保存的模型</span></span><br></pre></td></tr></table></figure><ul><li>对于estimator 会自动load output_dir 中的最新的ckpt。</li><li>我们常用的<code>model_file = tf.train.latest_checkpoint(FLAGS.output_dir)</code> 获取最新的ckpt</li></ul><h3 id="Meta文件分析"><a href="#Meta文件分析" class="headerlink" title="Meta文件分析"></a>Meta文件分析</h3><p>TensorFlow的Meta文件不一定含有变量，也就是使用<code>tf.global_variables()</code>或者<code>tf.trainable_variables()</code>均返回的是空list。</p><p>被这个问题困扰了很久，但是一直查不到结果，我就从TensorFlow的源码入手分析一下。我调试了<code>saver.restore</code>的函数，最终定位到了<a href="https://github.com/tensorflow/tensorflow/blob/v1.15.5/tensorflow/python/framework/meta_graph.py#L824" target="_blank" rel="noopener">meta_graph.py#L824</a>。</p><p>相关代码如下：</p><p><img src="/MLFrameworks/TensorFlow/TensorFlow模型保存总结/image-20220410162903108.png" alt="image-20220410162903108" style="zoom: 80%;"></p><p>代码中有一个函数为<code>meta_graph_def.collection_def</code>，若这里面有<code>trainable_variables</code>才可以，但是我遇到了一个meta文件，<code>meta_graph_def.collection_def</code>为空，也就没有了变量。但是这个文件咋来的，还不是很清楚。需要进一步探索。</p><h2 id="SavedModel"><a href="#SavedModel" class="headerlink" title="SavedModel"></a>SavedModel</h2><p>SavedModel 格式是tensorflow 2.0 推荐的格式，他很好地支持了tf-serving等部署，并且可以简单被python，java等调用。</p><p>一个 SavedModel 包含了一个完整的 TensorFlow program, 包含了 weights 以及 计算图 computation. 它不需要原本的模型代码就可以加载所以很容易在 TFLite, TensorFlow.js, TensorFlow Serving, or TensorFlow Hub 上部署。</p><p>通常SavedModel由以下几个部分组成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── assets/ # 所需的外部文件，例如说初始化的词汇表文件，一般无</span><br><span class="line">├── assets.extra/ # TensorFlow graph 不需要的文件, 例如说给用户知晓的如何使用SavedModel的信息. Tensorflow 不使用这个目录下的文件。</span><br><span class="line">├── saved_model.pb # 保存的是MetaGraph的网络结构, 或者说是saved_model.pbtxt</span><br><span class="line">├── variables # 参数权重，包含了所有模型的变量(tf.Variable objects)参数</span><br><span class="line">    ├── variables.data-00000-of-00001</span><br><span class="line">    └── variables.index</span><br></pre></td></tr></table></figure><p>补充pb格式说明：GraphDef(*.pb)格式文件包含 protobuf 对象序列化后的数据，包含了计算图，可以从中得到所有运算符（operators）的细节，也包含张量（tensors）和 Variables 定义，但不包含 Variable 的值，因此只能从中恢复计算图，但一些训练的权值仍需要从 checkpoint 中恢复。</p><p>TensorFlow 一些例程中用到 *.pb 文件作为预训练模型，这和上面 GraphDef 格式稍有不同，属于冻结（Frozen）后的 GraphDef 文件，简称 FrozenGraphDef 格式。这种文件格式不包含 Variables 节点。将 GraphDef 中所有 Variable 节点转换为常量（其值从 checkpoint 获取），就变为 FrozenGraphDef 格式。代码可以参考 <code>tensorflow/python/tools/freeze_graph.py</code>。</p><p><code>*.pb</code> 为二进制文件，实际上 protobuf 也支持文本格式（<code>*.pbtxt</code>），但包含权值时文本格式会占用大量磁盘空间，一般不用。</p><h3 id="导出为SavedModel"><a href="#导出为SavedModel" class="headerlink" title="导出为SavedModel"></a>导出为SavedModel</h3><ul><li>tf 1.0 方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""tf1.0"""</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>], name=<span class="string">"myInput"</span>)</span><br><span class="line">y = tf.nn.softmax(tf.matmul(x, W) + b, name=<span class="string">"myOutput"</span>)</span><br><span class="line">tf.saved_model.simple_save(</span><br><span class="line">                sess,</span><br><span class="line">                export_dir,</span><br><span class="line">                inputs=&#123;<span class="string">"myInput"</span>: x&#125;,</span><br><span class="line">                outputs=&#123;<span class="string">"myOutput"</span>: y&#125;)</span><br></pre></td></tr></table></figure><p><code>simple_save</code> 是对于普通的tf 模型导出的最简单的方式，只需要补充简单的必要参数，有很多参数被省略，其中被省略的最重要的参数是<code>tag</code>（在下面<code>saved_model.builder.SavedModelBuilder</code>会介绍）：<code>tag</code> 是用来区别不同的 <code>MetaGraphDef</code>，这是在加载模型所需要的参数。其默认值是tag_constants.SERVING (“serve”)。对于某些节点，如果没有办法直接加name，那么可以采用 <code>tf.identity</code>， 为节点加名字，例如说CRF的输出，以及使dataset后，无法直接加input的name，都可以采用这个方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNameToTensor</span><span class="params">(someTensor, theName)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.identity(someTensor, name=theName)</span><br></pre></td></tr></table></figure><ul><li>estimator 方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""estimator"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serving_input_fn</span><span class="params">()</span>:</span></span><br><span class="line">    label_ids = tf.placeholder(tf.int32, [<span class="literal">None</span>], name=<span class="string">'label_ids'</span>)</span><br><span class="line">    input_ids = tf.placeholder(tf.int32, [<span class="literal">None</span>, FLAGS.max_seq_length], name=<span class="string">'input_ids'</span>)</span><br><span class="line">    input_mask = tf.placeholder(tf.int32, [<span class="literal">None</span>, FLAGS.max_seq_length], name=<span class="string">'input_mask'</span>)</span><br><span class="line">    segment_ids = tf.placeholder(tf.int32, [<span class="literal">None</span>, FLAGS.max_seq_length], name=<span class="string">'segment_ids'</span>)</span><br><span class="line">    input_fn = tf.estimator.export.build_raw_serving_input_receiver_fn(&#123;</span><br><span class="line">        <span class="string">'label_ids'</span>: label_ids,</span><br><span class="line">        <span class="string">'input_ids'</span>: input_ids,</span><br><span class="line">        <span class="string">'input_mask'</span>: input_mask,</span><br><span class="line">        <span class="string">'segment_ids'</span>: segment_ids,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> input_fn</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> do_export:</span><br><span class="line">   estimator._export_to_tpu = <span class="literal">False</span></span><br><span class="line">   estimator.export_saved_model(Flags.export_dir, serving_input_fn)</span><br></pre></td></tr></table></figure><ul><li>保存多个 <code>MetaGraphDef&#39;s</code>，使用到了tag</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.python.saved_model</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.saved_model <span class="keyword">import</span> tag_constants</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.saved_model.signature_def_utils_impl <span class="keyword">import</span> predict_signature_def</span><br><span class="line">builder = saved_model.builder.SavedModelBuilder(export_path)</span><br><span class="line"></span><br><span class="line">signature = predict_signature_def(inputs=&#123;<span class="string">'myInput'</span>: x&#125;,</span><br><span class="line">                                  outputs=&#123;<span class="string">'myOutput'</span>: y&#125;)</span><br><span class="line"><span class="string">""" using custom tag instead of: tags=[tag_constants.SERVING] """</span></span><br><span class="line">builder.add_meta_graph_and_variables(sess=sess,</span><br><span class="line">                                     tags=[<span class="string">"myTag"</span>],</span><br><span class="line">                                     signature_def_map=&#123;<span class="string">'predict'</span>: signature&#125;)</span><br><span class="line">builder.save()</span><br></pre></td></tr></table></figure><ul><li>ckpt转SavedModel</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_saved_model</span><span class="params">(bert_config, num_labels, use_one_hot_embeddings)</span>:</span></span><br><span class="line">  tf_config = tf.compat.v1.ConfigProto()</span><br><span class="line">  tf_config.gpu_options.allow_growth = <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">  model_file = tf.train.latest_checkpoint(FLAGS.output_dir)</span><br><span class="line">  <span class="keyword">with</span> tf.Graph().as_default(), tf.Session(config=tf_config) <span class="keyword">as</span> tf_sess:</span><br><span class="line">    label_ids = tf.placeholder(tf.int32, [<span class="literal">None</span>], name=<span class="string">'label_ids'</span>)</span><br><span class="line">    input_ids = tf.placeholder(tf.int32, [<span class="literal">None</span>, FLAGS.max_seq_length], name=<span class="string">'input_ids'</span>)</span><br><span class="line">    input_mask = tf.placeholder(tf.int32, [<span class="literal">None</span>, FLAGS.max_seq_length], name=<span class="string">'input_mask'</span>)</span><br><span class="line">    segment_ids = tf.placeholder(tf.int32, [<span class="literal">None</span>, FLAGS.max_seq_length], name=<span class="string">'segment_ids'</span>)</span><br><span class="line"> </span><br><span class="line">    loss, per_example_loss, probabilities, predictions = \</span><br><span class="line">          create_model(bert_config, <span class="literal">False</span>, input_ids, input_mask, segment_ids, label_ids,</span><br><span class="line">              num_labels, use_one_hot_embeddings)</span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line">    print(<span class="string">"restore;&#123;&#125;"</span>.format(model_file))</span><br><span class="line">    saver.restore(tf_sess, model_file)</span><br><span class="line">    tf.saved_model.simple_save(tf_sess,</span><br><span class="line">            FLAGS.output_dir,</span><br><span class="line">            inputs=&#123;</span><br><span class="line">              <span class="string">'label_ids'</span>: label_ids,</span><br><span class="line">              <span class="string">'input_ids'</span>: input_ids,</span><br><span class="line">              <span class="string">'input_mask'</span>: input_mask,</span><br><span class="line">              <span class="string">'segment_ids'</span>: segment_ids,</span><br><span class="line">            &#125;,</span><br><span class="line">            outputs=&#123;<span class="string">"probabilities"</span>: probabilities&#125;)</span><br></pre></td></tr></table></figure><ul><li>frozen graph to savedModel。注意这个方法我失败了，variables文件夹下面没有东西。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.saved_model <span class="keyword">import</span> signature_constants</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.saved_model <span class="keyword">import</span> tag_constants</span><br><span class="line"></span><br><span class="line">export_dir = <span class="string">'inference/pb2saved'</span></span><br><span class="line">graph_pb = <span class="string">'inference/robert_tiny_clue/frozen_model.pb'</span></span><br><span class="line"></span><br><span class="line">builder = tf.saved_model.builder.SavedModelBuilder(export_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.gfile.GFile(graph_pb, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    graph_def = tf.GraphDef()</span><br><span class="line">    graph_def.ParseFromString(f.read())</span><br><span class="line"></span><br><span class="line">sigs = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session(graph=tf.Graph()) <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># name="" is important to ensure we don't get spurious prefixing</span></span><br><span class="line">    tf.import_graph_def(graph_def, name=<span class="string">""</span>)</span><br><span class="line">    g = tf.get_default_graph()</span><br><span class="line">    input_ids = sess.graph.get_tensor_by_name(</span><br><span class="line">    <span class="string">"input_ids:0"</span>)</span><br><span class="line">    input_mask = sess.graph.get_tensor_by_name(</span><br><span class="line">    <span class="string">"input_mask:0"</span>)</span><br><span class="line">    segment_ids = sess.graph.get_tensor_by_name(</span><br><span class="line">    <span class="string">"segment_ids:0"</span>)</span><br><span class="line">    probabilities = g.get_tensor_by_name(<span class="string">"loss/pred_prob:0"</span>)</span><br><span class="line"></span><br><span class="line">    sigs[signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY] = \</span><br><span class="line">        tf.saved_model.signature_def_utils.predict_signature_def(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"input_ids"</span>: input_ids,</span><br><span class="line">                <span class="string">"input_mask"</span>: input_mask,</span><br><span class="line">                <span class="string">"segment_ids"</span>: segment_ids</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">"probabilities"</span>: probabilities</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">    builder.add_meta_graph_and_variables(sess,</span><br><span class="line">                                         [tag_constants.SERVING],</span><br><span class="line">                                         signature_def_map=sigs)</span><br><span class="line"></span><br><span class="line">builder.save()</span><br></pre></td></tr></table></figure><ul><li>tf.keras 2.0</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.save(<span class="string">'saved_model/my_model'</span>)  </span><br><span class="line"><span class="string">""</span><span class="string">"saved as SavedModel by default"</span><span class="string">""</span></span><br></pre></td></tr></table></figure><h3 id="加载SavedModel"><a href="#加载SavedModel" class="headerlink" title="加载SavedModel"></a>加载SavedModel</h3><p>对于在java中加载SavedModel，我们首先需要知道我们模型输入和输出，可以通过以下的脚本在terminal中运行 <code>saved_model_cli show --dir SavedModel路径 --tag_set serve --signature_def serving_default</code> 得到类似以下的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MetaGraphDef <span class="keyword">with</span> tag-set: <span class="string">'serve'</span> contains the following SignatureDefs:</span><br><span class="line"></span><br><span class="line">signature_def[<span class="string">'serving_default'</span>]:</span><br><span class="line">  The given SavedModel SignatureDef contains the following input(s):</span><br><span class="line">    inputs[<span class="string">'input_ids'</span>] tensor_info:</span><br><span class="line">        dtype: DT_INT32</span><br><span class="line">        shape: (<span class="number">-1</span>, <span class="number">128</span>)</span><br><span class="line">        name: input_ids:<span class="number">0</span></span><br><span class="line">    inputs[<span class="string">'input_mask'</span>] tensor_info:</span><br><span class="line">        dtype: DT_INT32</span><br><span class="line">        shape: (<span class="number">-1</span>, <span class="number">128</span>)</span><br><span class="line">        name: input_mask:<span class="number">0</span></span><br><span class="line">    inputs[<span class="string">'label_ids'</span>] tensor_info:</span><br><span class="line">        dtype: DT_INT32</span><br><span class="line">        shape: (<span class="number">-1</span>)</span><br><span class="line">        name: label_ids:<span class="number">0</span></span><br><span class="line">    inputs[<span class="string">'segment_ids'</span>] tensor_info:</span><br><span class="line">        dtype: DT_INT32</span><br><span class="line">        shape: (<span class="number">-1</span>, <span class="number">128</span>)</span><br><span class="line">        name: segment_ids:<span class="number">0</span></span><br><span class="line">  The given SavedModel SignatureDef contains the following output(s):</span><br><span class="line">    outputs[<span class="string">'probabilities'</span>] tensor_info:</span><br><span class="line">        dtype: DT_FLOAT</span><br><span class="line">        shape: (<span class="number">-1</span>, <span class="number">7</span>)</span><br><span class="line">        name: loss/pred_prob:<span class="number">0</span></span><br><span class="line">  Method name <span class="keyword">is</span>: tensorflow/serving/predict</span><br></pre></td></tr></table></figure><p>首先我们可以看到有inputs，以及outputs，分别是一个key为string，value为tensor的字典，每个tensor都有各自的名字。</p><p>当然我们可以通过<code>saved_model_cli show --dir SavedModel路径 --all</code>得到所有的结果，包含了<code>Concrete Functions</code>。</p><h4 id="Python-加载"><a href="#Python-加载" class="headerlink" title="Python 加载"></a>Python 加载</h4><p>我们有常见两种方式可以加载savedModel，一种是采用 <code>tf.contrib.predictor.from_saved_model</code> 传入predictor模型的inputs dict，然后得到 outputs dict。 一种是直接类似tf1.0的方式，采用 <code>tf.saved_model.loader.load</code>， feed tensor然后fetch tensor。</p><ul><li><p>采用predictor</p><p>采用predictor时， 需要传入的字典名字用的是 inputs的key，而不是tensor的names</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">predict_fn = tf.contrib.predictor.from_saved_model(args_in_use.model)</span><br><span class="line"><span class="comment"># 其中feature.xxxxxx 应该是需要feed_dict的数据</span></span><br><span class="line">prediction = predict_fn(&#123;</span><br><span class="line">                <span class="string">"input_ids"</span>: [feature.input_ids],</span><br><span class="line">                <span class="string">"input_mask"</span>: [feature.input_mask],</span><br><span class="line">                <span class="string">"segment_ids"</span>: [feature.segment_ids],</span><br><span class="line">            &#125;)</span><br><span class="line">probabilities = prediction[<span class="string">"probabilities"</span>]</span><br></pre></td></tr></table></figure><ul><li><p>tf 1.0 采用 loader</p><p>采用loader的方式是采用 session 的feed_dict 方式，该方式feed的是tenor的names，fetch的同样也是tensor 的names。其中feed_dict的key 可以直接是tensor的name，或者是采用 <code>sess.graph.get_tensor_by_name(TENSOR_NAME)</code> 得到的tensor。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session(graph=tf.Graph()) <span class="keyword">as</span> sess:</span><br><span class="line">    tf.saved_model.loader.load(sess, [<span class="string">"serve"</span>], export_path)</span><br><span class="line">    graph = tf.get_default_graph()</span><br><span class="line">    feed_dict = &#123;<span class="string">"input_ids_1:0"</span>: [feature.input_ids],</span><br><span class="line">                <span class="string">"input_mask_1:0"</span>: [feature.input_mask],</span><br><span class="line">                <span class="string">"segment_ids_1:0"</span>: [feature.segment_ids]&#125;</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    # alternative way</span></span><br><span class="line"><span class="string">    feed_dict = &#123;sess.graph.get_tensor_by_name("input_ids_1:0"): </span></span><br><span class="line"><span class="string">                          [feature.input_ids],</span></span><br><span class="line"><span class="string">                sess.graph.get_tensor_by_name("input_mask_1:0"):</span></span><br><span class="line"><span class="string">                          [feature.input_mask],</span></span><br><span class="line"><span class="string">                sess.graph.get_tensor_by_name("segment_ids_1:0"):</span></span><br><span class="line"><span class="string">                          [feature.segment_ids]&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    sess.run(<span class="string">'loss/pred_prob:0'</span>,</span><br><span class="line">               feed_dict=feed_dict)</span><br></pre></td></tr></table></figure><ul><li>tf.keras 2.0</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_model = tf.keras.models.load_model(<span class="string">'saved_model/my_model'</span>)</span><br></pre></td></tr></table></figure><h4 id="JAVA-加载"><a href="#JAVA-加载" class="headerlink" title="JAVA 加载"></a>JAVA 加载</h4><p>注意 java加载的时候，如果遇到Op not defined 的错误，是需要匹配模型训练python的tensorflow版本以及java的tensorflow版本的。</p><p>所以我们知道我们在tag-set 为serve的tag下，有4个inputs tensors，name分别为<code>input_ids:0</code>, <code>input_mask:0</code>, <code>label_ids:0</code>, <code>segment_ids:0</code>, 输出为1个，name是 <code>loss/pred_prob:0</code>。并且我们知道这些tensor的类型。</p><p>所以我们可以通过下面的java代码，进行加载，获得结果。注意我们需要传入的name中不需要传入<code>:0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.tensorflow.*</span><br><span class="line">SavedModelBundle savedModelBundle = SavedModelBundle.load(<span class="string">"./export_path"</span>, <span class="string">"serve"</span>);</span><br><span class="line">Graph graph = savedModelBundle.graph();</span><br><span class="line"></span><br><span class="line">Tensor tensor = <span class="keyword">this</span>.savedModelBundle.session().runner()</span><br><span class="line">                .feed(<span class="string">"input_ids"</span>, inputIdTensor)</span><br><span class="line">                .feed(<span class="string">"input_mask"</span>, inputMaskTensor)</span><br><span class="line">                .feed(<span class="string">"segment_ids"</span>, inputSegmentTensor)</span><br><span class="line">                .fetch(<span class="string">"loss/pred_prob"</span>)</span><br><span class="line">                .run().get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="CLI-加载"><a href="#CLI-加载" class="headerlink" title="CLI 加载"></a>CLI 加载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ saved_model_cli show --dir <span class="built_in">export</span>/1524906774 \</span><br><span class="line">  --tag_set serve --signature_def serving_default</span><br><span class="line">The given SavedModel SignatureDef contains the following input(s):</span><br><span class="line">  inputs[<span class="string">'inputs'</span>] tensor_info:</span><br><span class="line">      dtype: DT_STRING</span><br><span class="line">      shape: (-1)</span><br><span class="line">The given SavedModel SignatureDef contains the following output(s):</span><br><span class="line">  outputs[<span class="string">'classes'</span>] tensor_info:</span><br><span class="line">      dtype: DT_STRING</span><br><span class="line">      shape: (-1, 3)</span><br><span class="line">  outputs[<span class="string">'scores'</span>] tensor_info:</span><br><span class="line">      dtype: DT_FLOAT</span><br><span class="line">      shape: (-1, 3)</span><br><span class="line">Method name is: tensorflow/serving/classify</span><br><span class="line"></span><br><span class="line">$ saved_model_cli run --dir <span class="built_in">export</span>/1524906774 \</span><br><span class="line">  --tag_set serve --signature_def serving_default \</span><br><span class="line">  --input_examples <span class="string">'inputs=[&#123;"SepalLength":[5.1],"SepalWidth":[3.3],"PetalLength":[1.7],"PetalWidth":[0.5]&#125;]'</span></span><br><span class="line">Result <span class="keyword">for</span> output key classes:</span><br><span class="line">[[b<span class="string">'0'</span> b<span class="string">'1'</span> b<span class="string">'2'</span>]]</span><br><span class="line">Result <span class="keyword">for</span> output key scores:</span><br><span class="line">[[9.9919027e-01 8.0969761e-04 1.2872645e-09]]</span><br></pre></td></tr></table></figure><h2 id="Frozen-Graph"><a href="#Frozen-Graph" class="headerlink" title="Frozen Graph"></a>Frozen Graph</h2><p>frozen Graphdef 将tensorflow导出的模型的权重都freeze住，使得其都变为常量。并且模型参数和网络结构保存在同一个文件中，可以在python以及java中自由调用。</p><h3 id="导出为pb"><a href="#导出为pb" class="headerlink" title="导出为pb"></a>导出为pb</h3><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><ul><li>采用session方式保存frozen graph</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""tf1.0"""</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework.graph_util <span class="keyword">import</span> convert_variables_to_constants</span><br><span class="line"></span><br><span class="line">output_graph_def = convert_variables_to_constants(</span><br><span class="line">                    session,</span><br><span class="line">                    session.graph_def,</span><br><span class="line">                    output_node_names=[<span class="string">'loss/pred_prob'</span>])</span><br><span class="line">tf.train.write_graph(output_graph_def, args.export_dir, args.model_name, as_text=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li>采用ckpt 转换成frozen graph<br>以下采用bert tensorflow模型做演示</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">NB：首先我们要在create_model() 函数中，为我们需要的输出节点取个名字，</span></span><br><span class="line"><span class="string">  比如说我们要： probabilities = tf.nn.softmax(logits, axis=-1, name='pred_prob')</span></span><br><span class="line"><span class="string">"""</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_frozen_model</span><span class="params">(bert_config, num_labels, use_one_hot_embeddings)</span>:</span></span><br><span class="line">  tf_config = tf.compat.v1.ConfigProto()</span><br><span class="line">  tf_config.gpu_options.allow_growth = <span class="literal">True</span></span><br><span class="line">  output_node_names = [<span class="string">'loss/pred_prob'</span>]</span><br><span class="line">  </span><br><span class="line">  model_file = tf.train.latest_checkpoint(FLAGS.output_dir)</span><br><span class="line">  <span class="keyword">with</span> tf.Graph().as_default(), tf.Session(config=tf_config) <span class="keyword">as</span> tf_sess: </span><br><span class="line">    label_ids = tf.placeholder(tf.int32, [<span class="literal">None</span>], name=<span class="string">'label_ids'</span>)</span><br><span class="line">    input_ids = tf.placeholder(tf.int32, [<span class="literal">None</span>, FLAGS.max_seq_length], name=<span class="string">'input_ids'</span>)</span><br><span class="line">    input_mask = tf.placeholder(tf.int32, [<span class="literal">None</span>, FLAGS.max_seq_length], name=<span class="string">'input_mask'</span>)</span><br><span class="line">    segment_ids = tf.placeholder(tf.int32, [<span class="literal">None</span>, FLAGS.max_seq_length], name=<span class="string">'segment_ids'</span>)</span><br><span class="line"></span><br><span class="line">    create_model(bert_config, <span class="literal">False</span>, input_ids, input_mask, segment_ids, label_ids,</span><br><span class="line">            num_labels, use_one_hot_embeddings)</span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line">    print(<span class="string">"restore;&#123;&#125;"</span>.format(model_file))</span><br><span class="line">    saver.restore(tf_sess, model_file)</span><br><span class="line">    tmp_g = tf_sess.graph.as_graph_def()</span><br><span class="line">    <span class="keyword">if</span> FLAGS.use_opt:</span><br><span class="line">      input_tensors = [input_ids, input_mask, segment_ids]</span><br><span class="line">      dtypes = [n.dtype <span class="keyword">for</span> n <span class="keyword">in</span> input_tensors]</span><br><span class="line">      print(<span class="string">'optimize...'</span>)</span><br><span class="line">      tmp_g = optimize_for_inference(tmp_g,</span><br><span class="line">                                    [n.name[:<span class="number">-2</span>] <span class="keyword">for</span> n <span class="keyword">in</span> input_tensors],</span><br><span class="line">                                     output_node_names,</span><br><span class="line">                                     [dtype.as_datatype_enum <span class="keyword">for</span> dtype <span class="keyword">in</span> dtypes],</span><br><span class="line">                                     <span class="literal">False</span>)</span><br><span class="line">    print(<span class="string">'freeze...'</span>)</span><br><span class="line">    frozen_graph = tf.graph_util.convert_variables_to_constants(tf_sess, </span><br><span class="line">            tmp_g, output_node_names)</span><br><span class="line">    out_graph_path = os.path.join(FLAGS.output_dir, <span class="string">"frozen_model.pb"</span>)</span><br><span class="line">    <span class="keyword">with</span> tf.io.gfile.GFile(out_graph_path, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">      f.write(frozen_graph.SerializeToString())      </span><br><span class="line">    print(<span class="string">f'pb file saved in <span class="subst">&#123;out_graph_path&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><ul><li>采用savedModel 转换成 frozen graph</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python.tools <span class="keyword">import</span> freeze_graph</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.saved_model <span class="keyword">import</span> tag_constants</span><br><span class="line"></span><br><span class="line">input_saved_model_dir = <span class="string">"./1583934987/"</span></span><br><span class="line">output_node_names = <span class="string">"loss/pred_prob"</span></span><br><span class="line">input_binary = <span class="literal">False</span></span><br><span class="line">input_saver_def_path = <span class="literal">False</span></span><br><span class="line">restore_op_name = <span class="literal">None</span></span><br><span class="line">filename_tensor_name = <span class="literal">None</span></span><br><span class="line">clear_devices = <span class="literal">False</span></span><br><span class="line">input_meta_graph = <span class="literal">False</span></span><br><span class="line">checkpoint_path = <span class="literal">None</span></span><br><span class="line">input_graph_filename = <span class="literal">None</span></span><br><span class="line">saved_model_tags = tag_constants.SERVING</span><br><span class="line">output_graph_filename=<span class="string">'frozen_graph.pb'</span></span><br><span class="line"></span><br><span class="line">freeze_graph.freeze_graph(input_graph_filename,</span><br><span class="line">  input_saver_def_path,</span><br><span class="line">  input_binary,</span><br><span class="line">  checkpoint_path,</span><br><span class="line">  output_node_names,</span><br><span class="line">  restore_op_name,</span><br><span class="line">  filename_tensor_name,</span><br><span class="line">  output_graph_filename,</span><br><span class="line">  clear_devices,</span><br><span class="line">  <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>,</span><br><span class="line">  input_meta_graph,</span><br><span class="line">  input_saved_model_dir,</span><br><span class="line">  saved_model_tags)</span><br></pre></td></tr></table></figure><ul><li>HDF5 to pb</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freeze_session</span><span class="params">(session, keep_var_names=None, output_names=None, clear_devices=True)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Freezes the state of a session into a pruned computation graph.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Creates a new computation graph where variable nodes are replaced by</span></span><br><span class="line"><span class="string">    constants taking their current value in the session. The new graph will be</span></span><br><span class="line"><span class="string">    pruned so subgraphs that are not necessary to compute the requested</span></span><br><span class="line"><span class="string">    outputs are removed.</span></span><br><span class="line"><span class="string">    @param session The TensorFlow session to be frozen.</span></span><br><span class="line"><span class="string">    @param keep_var_names A list of variable names that should not be frozen,</span></span><br><span class="line"><span class="string">                          or None to freeze all the variables in the graph.</span></span><br><span class="line"><span class="string">    @param output_names Names of the relevant graph outputs.</span></span><br><span class="line"><span class="string">    @param clear_devices Remove the device directives from the graph for better portability.</span></span><br><span class="line"><span class="string">    @return The frozen graph definition.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    graph = session.graph</span><br><span class="line">    <span class="keyword">with</span> graph.as_default():</span><br><span class="line">        freeze_var_names = list(set(v.op.name <span class="keyword">for</span> v <span class="keyword">in</span> tf.global_variables()).difference(keep_var_names <span class="keyword">or</span> []))</span><br><span class="line">        output_names = output_names <span class="keyword">or</span> []</span><br><span class="line">        output_names += [v.op.name <span class="keyword">for</span> v <span class="keyword">in</span> tf.global_variables()]</span><br><span class="line">        input_graph_def = graph.as_graph_def()</span><br><span class="line">        <span class="keyword">if</span> clear_devices:</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> input_graph_def.node:</span><br><span class="line">                node.device = <span class="string">""</span></span><br><span class="line">        frozen_graph = tf.graph_util.convert_variables_to_constants(</span><br><span class="line">            session, input_graph_def, output_names, freeze_var_names)</span><br><span class="line">        <span class="keyword">return</span> frozen_graph</span><br><span class="line">        </span><br><span class="line">frozen_graph = freeze_session(K.get_session(),</span><br><span class="line">                              output_names=[out.op.name <span class="keyword">for</span> out <span class="keyword">in</span> model.outputs])</span><br><span class="line"></span><br><span class="line">tf.train.write_graph(frozen_graph, <span class="string">"some_directory"</span>, <span class="string">"my_model.pb"</span>, as_text=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="CLI转换工具"><a href="#CLI转换工具" class="headerlink" title="CLI转换工具"></a>CLI转换工具</h4><p>以下的工具可以快速进行ckpt到pb的转换，但是不能再原本的基础上增加tensor 的名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">freeze_graph --input_checkpoint model.ckpt-16329 \</span><br><span class="line">             --output_graph 0316_roberta.pb \</span><br><span class="line">             --output_node_names loss/pred_prob \</span><br><span class="line">             --checkpoint_version 1 \</span><br><span class="line">             --input_meta_graph model.ckpt-16329.meta \</span><br><span class="line">             --input_binary true</span><br></pre></td></tr></table></figure><h3 id="模型加载"><a href="#模型加载" class="headerlink" title="模型加载"></a>模型加载</h3><p>获取frozen graph 中节点名字的脚本如下，但是一般来说，我们的inputs都是我们定义好的placeholders。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printTensors</span><span class="params">(pb_file)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""read pb into graph_def"""</span></span><br><span class="line">    <span class="keyword">with</span> tf.gfile.GFile(pb_file, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        graph_def = tf.GraphDef()</span><br><span class="line">        graph_def.ParseFromString(f.read())</span><br><span class="line"></span><br><span class="line">    <span class="string">"""import graph_def"""</span></span><br><span class="line">    <span class="keyword">with</span> tf.Graph().as_default() <span class="keyword">as</span> graph:</span><br><span class="line">        tf.import_graph_def(graph_def)</span><br><span class="line"></span><br><span class="line">    <span class="string">"""print operations"""</span></span><br><span class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> graph.get_operations():</span><br><span class="line">        print(op.name)</span><br><span class="line"></span><br><span class="line">printTensors(<span class="string">"path-to-my-pbfile.pb"</span>)</span><br></pre></td></tr></table></figure><p>得到类似如下的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import/input_ids:0</span><br><span class="line">import/input_mask:0</span><br><span class="line">import/segment_ids:0</span><br><span class="line">...</span><br><span class="line">import/loss/pred_prob:0</span><br></pre></td></tr></table></figure><p>当我们知道我们要feed以及fetch的节点名称之后，我们就可以通过python/java加载了。<br>跟savedModel一样，对于某些节点，如果没有办法直接加name，那么可以采用 <code>tf.identity</code>， 为节点加名字，例如说CRF的输出，以及使用dataset后，无法直接加input的name，都可以采用这个方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNameToTensor</span><span class="params">(someTensor, theName)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.identity(someTensor, name=theName)</span><br></pre></td></tr></table></figure><h4 id="Python-加载-1"><a href="#Python-加载-1" class="headerlink" title="Python 加载"></a>Python 加载</h4><p>我们保存完frozen graph 模型后，假设我们的模型包含以下的tensors：</p><p>那么我们通过python加载的代码如下, 采用的是session feed和fetch的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Graph().as_default():</span><br><span class="line">    output_graph_def = tf.GraphDef()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">   load pb model</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(args_in_use.model, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        output_graph_def.ParseFromString(f.read())</span><br><span class="line">        tf.import_graph_def(output_graph_def, name=<span class="string">''</span>) <span class="comment">#name是必须的</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    enter a text and predict</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        tf.global_variables_initializer().run()</span><br><span class="line">        input_ids = sess.graph.get_tensor_by_name(</span><br><span class="line">            <span class="string">"input_ids:0"</span>)</span><br><span class="line">        input_mask = sess.graph.get_tensor_by_name(</span><br><span class="line">            <span class="string">"input_mask:0"</span>)</span><br><span class="line">        segment_ids = sess.graph.get_tensor_by_name(</span><br><span class="line">            <span class="string">"segment_ids:0"</span>)</span><br><span class="line">        output = <span class="string">"loss/pred_prob:0"</span></span><br><span class="line">        </span><br><span class="line">        feed_dict = &#123;</span><br><span class="line">            input_ids: [feature.input_ids],</span><br><span class="line">            input_mask: [feature.input_mask],</span><br><span class="line">            segment_ids: [feature.segment_ids],</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 也可以直接使用</span></span><br><span class="line">        <span class="comment"># feed_dict = &#123;</span></span><br><span class="line">        <span class="comment">#     "input_ids:0": [feature.input_ids],</span></span><br><span class="line">        <span class="comment">#     "input_mask:0": [feature.input_mask],</span></span><br><span class="line">        <span class="comment">#     "segment_ids:0": [feature.segment_ids],</span></span><br><span class="line">        <span class="comment"># &#125;</span></span><br><span class="line">        y_pred_cls = sess.run(output, feed_dict=feed_dict)</span><br></pre></td></tr></table></figure><h4 id="Java-加载"><a href="#Java-加载" class="headerlink" title="Java 加载"></a>Java 加载</h4><p>对于frozen graph，我们加载的方式和savedModel很类似，首先我们需要先启动一个session，然后在启动一个<code>runner()</code>，然后再feed模型的输入，以及fetch模型的输出。</p><p>注意 java加载的时候，如果遇到Op not defined 的错误，是需要匹配模型训练python的tensorflow版本以及java的tensorflow版本的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TensorUtil.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">generateSession</span><span class="params">(String modelPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(modelPath);</span><br><span class="line">    <span class="keyword">byte</span>[] graphDef = ByteStreams.toByteArray(TensorUtil.class.getResourceAsStream(modelPath));</span><br><span class="line">    LOGGER.info(<span class="string">"Graph Def Length: &#123;&#125;"</span>, graphDef.length);</span><br><span class="line">    Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">    graph.importGraphDef(graphDef);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Session(graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// model.class</span></span><br><span class="line"><span class="keyword">this</span>.session = TensorUtil.generateSession(modelPath);</span><br><span class="line"></span><br><span class="line">Tensor tensor = <span class="keyword">this</span>.session.runner()</span><br><span class="line">                    .feed(<span class="string">"input_ids"</span>, inputIdTensor)</span><br><span class="line">                    .feed(<span class="string">"input_mask"</span>, inputMaskTensor)</span><br><span class="line">                    .feed(<span class="string">"segment_ids"</span>, inputSegmentTensor)</span><br><span class="line">                    .fetch(<span class="string">"loss/pred_prob"</span>)</span><br><span class="line">                    .run().get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="HDF5"><a href="#HDF5" class="headerlink" title="HDF5"></a>HDF5</h2><p>HDF5 是keras or tf.keras 特有的存储格式。</p><h3 id="HDF5导出"><a href="#HDF5导出" class="headerlink" title="HDF5导出"></a>HDF5导出</h3><ul><li>导出整个模型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""默认1.0 是HDF5，但是2.0中，是SavedModel，所以需要显性地指定`.h5`后缀"""</span></span><br><span class="line">model.save(<span class="string">'my_model.h5'</span>)</span><br></pre></td></tr></table></figure><ul><li>导出模型weights</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""keras 1.0"""</span></span><br><span class="line">model.save_weights(<span class="string">'my_model_weights.h5'</span>)</span><br></pre></td></tr></table></figure><h3 id="HDF5加载"><a href="#HDF5加载" class="headerlink" title="HDF5加载"></a>HDF5加载</h3><ul><li><p>加载整个模型（无自定义部分）</p></li><li><ul><li>keras1.0</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""keras 1.0"""</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> load_model</span><br><span class="line">model = load_model(model_path)</span><br></pre></td></tr></table></figure><ul><li><ul><li>keras2.0</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""keras 2.0"""</span></span><br><span class="line">new_model = tf.keras.models.load_model(<span class="string">'my_model.h5'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>加载整个模型（含自定义部分）<br>对于有自定义layers的或者实现的模型加载，需要增加dependencies 的映射字典，例如下面的例子：</p></li><li><ul><li>keras1.0</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependencies = &#123;<span class="string">'MyLayer'</span>: MyLayer(), <span class="string">'auc'</span>: auc, <span class="string">'log_loss'</span>: log_loss&#125;</span><br><span class="line">model = load_model(model_path, custom_objects=dependencies, compile=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li><ul><li>keras 2.0</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">To save custom objects to HDF5, you must do the following:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. Define a get_config method in your object, and optionally a from_config classmethod.</span></span><br><span class="line"><span class="string">get_config(self) returns a JSON-serializable dictionary of parameters needed to recreate the object.</span></span><br><span class="line"><span class="string">from_config(cls, config) uses the returned config from get_config to create a new object. By default, this function will use the config as initialization kwargs (return cls(**config)).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. Pass the object to the custom_objects argument when loading the model. The argument must be a dictionary mapping the string class name to the Python class. E.g. tf.keras.models.load_model(path, custom_objects=&#123;'CustomLayer': CustomLayer&#125;)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>加载模型权重<br>假设你有了相同的模型构建了，那么直接运行下面的代码，加载模型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.load_weights(<span class="string">'my_model_weights.h5'</span>)</span><br></pre></td></tr></table></figure><p>如果你想要做transfer learning，即从其他的已保存的模型中加载部分的模型参数权重，自己目前的模型结构与保存的模型不同，可以通过参数的名字进行加载，加上 <code>by_name=True</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.load_weights(<span class="string">'my_model_weights.h5'</span>, by_name=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="tfLite"><a href="#tfLite" class="headerlink" title="tfLite"></a>tfLite</h2><h3 id="TFlite转换"><a href="#TFlite转换" class="headerlink" title="TFlite转换"></a>TFlite转换</h3><ul><li>savedModel to TFLite</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">--saved_model_dir:  Type: string. Specifies the full path to the directory containing the SavedModel generated in 1.X or 2.X.</span></span><br><span class="line"><span class="string">--output_file: Type: string. Specifies the full path of the output file.</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">tflite_convert \</span><br><span class="line">    --saved_model_dir=1583934987 \</span><br><span class="line">    --output_file=rbt.tflite</span><br></pre></td></tr></table></figure><ul><li>frozen graph to TFLite</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tflite_convert --graph_def_file albert_tiny_zh.pb \</span><br><span class="line">               --input_arrays <span class="string">'input_ids,input_masks,segment_ids'</span> \</span><br><span class="line">               --output_arrays <span class="string">'finetune_mrc/add, finetune_mrc/add_1'</span>\</span><br><span class="line">               --input_shapes 1,512:1,512:1,512 \</span><br><span class="line">               --output_file saved_model.tflite \</span><br><span class="line">               --enable_v1_converter \</span><br><span class="line">               --experimental_new_converter</span><br></pre></td></tr></table></figure><ul><li>HDF5 to TFLite</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--keras_model_file. Type: string. Specifies the full path of the HDF5 file containing the tf.keras model generated in 1.X or 2.X.   </span></span><br><span class="line"><span class="comment">#--output_file: Type: string. Specifies the full path of the output file.</span></span><br><span class="line">tflite_convert \</span><br><span class="line">    --keras_model_file=h5_dir/ \</span><br><span class="line">    --output_file=rbt.tflite</span><br></pre></td></tr></table></figure><p>另外，补充一个TFlite转frozen graph：</p><p>tensorflow在早期提供了转换工具（1.9版本后的tensorflow没有再提到这个功能了），具体操作可以看<a href="https://github.com/tensorflow/tensorflow/blob/r1.9/tensorflow/contrib/lite/toco/g3doc/cmdline_examples.md" target="_blank" rel="noopener">这里</a>。</p><p>有的模型TOCO工具可能会转换失败，可以参考<a href="https://gist.github.com/tworuler/bd7bd4c6cd9a8fbbeb060e7b64cfa008" target="_blank" rel="noopener">这个链接</a>。</p><h3 id="TFLite-加载"><a href="#TFLite-加载" class="headerlink" title="TFLite 加载"></a>TFLite 加载</h3><p>参考 <a href="https://link.zhihu.com/?target=https%3A//www.tensorflow.org/lite/guide/inference" target="_blank" rel="noopener">https://www.tensorflow.org/lite/guide/inference</a><br>参考 <a href="https://link.zhihu.com/?target=https%3A//github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/g3doc/r1/convert/index.md" target="_blank" rel="noopener">https://github.com/tensorflow/t</a></p><p>这里介绍一个Python的加载。</p><ul><li>当从SavedModel转换得到，并且含有SignatureDef时：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestModel</span><span class="params">(tf.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    super(TestModel, self).__init__()</span><br><span class="line"></span><br><span class="line"><span class="meta">  @tf.function(input_signature=[tf.TensorSpec(shape=[1, 10], dtype=tf.float32)])</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Simple method that accepts single input 'x' and returns 'x' + 4.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># Name the output 'result' for convenience.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'result'</span> : x + <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SAVED_MODEL_PATH = <span class="string">'content/saved_models/test_variable'</span></span><br><span class="line">TFLITE_FILE_PATH = <span class="string">'content/test_variable.tflite'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the model</span></span><br><span class="line">module = TestModel()</span><br><span class="line"><span class="comment"># You can omit the signatures argument and a default signature name will be</span></span><br><span class="line"><span class="comment"># created with name 'serving_default'.</span></span><br><span class="line">tf.saved_model.save(</span><br><span class="line">    module, SAVED_MODEL_PATH,</span><br><span class="line">    signatures=&#123;<span class="string">'my_signature'</span>:module.add.get_concrete_function()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the model using TFLiteConverter</span></span><br><span class="line">converter = tf.lite.TFLiteConverter.from_saved_model(SAVED_MODEL_PATH)</span><br><span class="line">tflite_model = converter.convert()</span><br><span class="line"><span class="keyword">with</span> open(TFLITE_FILE_PATH, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(tflite_model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the TFLite model in TFLite Interpreter</span></span><br><span class="line">interpreter = tf.lite.Interpreter(TFLITE_FILE_PATH)</span><br><span class="line"><span class="comment"># There is only 1 signature defined in the model,</span></span><br><span class="line"><span class="comment"># so it will return it by default.</span></span><br><span class="line"><span class="comment"># If there are multiple signatures then we can pass the name.</span></span><br><span class="line">my_signature = interpreter.get_signature_runner()</span><br><span class="line"></span><br><span class="line"><span class="comment"># my_signature is callable with input as arguments.</span></span><br><span class="line">output = my_signature(x=tf.constant([<span class="number">1.0</span>], shape=(<span class="number">1</span>,<span class="number">10</span>), dtype=tf.float32))</span><br><span class="line"><span class="comment"># 'output' is dictionary with all outputs from the inference.</span></span><br><span class="line"><span class="comment"># In this case we have single output 'result'.</span></span><br><span class="line">print(output[<span class="string">'result'</span>])</span><br></pre></td></tr></table></figure><ul><li>当没有SignatureDef时</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the TFLite model and allocate tensors.</span></span><br><span class="line">interpreter = tf.lite.Interpreter(model_path=<span class="string">"converted_model.tflite"</span>)</span><br><span class="line">interpreter.allocate_tensors()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get input and output tensors.</span></span><br><span class="line">input_details = interpreter.get_input_details()</span><br><span class="line">output_details = interpreter.get_output_details()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Test the model on random input data.</span></span><br><span class="line">input_shape = input_details[<span class="number">0</span>][<span class="string">'shape'</span>]</span><br><span class="line">input_data = np.array(np.random.random_sample(input_shape), dtype=np.float32)</span><br><span class="line">interpreter.set_tensor(input_details[<span class="number">0</span>][<span class="string">'index'</span>], input_data)</span><br><span class="line"></span><br><span class="line">interpreter.invoke()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The function `get_tensor()` returns a copy of the tensor data.</span></span><br><span class="line"><span class="comment"># Use `tensor()` in order to get a pointer to the tensor.</span></span><br><span class="line">output_data = interpreter.get_tensor(output_details[<span class="number">0</span>][<span class="string">'index'</span>])</span><br><span class="line">print(output_data)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/nanhuaibeian/article/details/101751439" target="_blank" rel="noopener">TensorFlow：.ckpt文件与.ckpt.meta和.ckpt.index以及.pb文件之间的关系是什么？</a><br><a href="https://sulingling123.github.io/2019/08/15/TF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BF%9D%E5%AD%98%E4%B8%8E%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">TF的三种模型的保存与加载方式</a><br><a href="https://cloud.tencent.com/developer/article/1009979" target="_blank" rel="noopener">TensorFlow 到底有几种模型格式？</a><br><a href="https://zhuanlan.zhihu.com/p/113734249" target="_blank" rel="noopener">tensorflow 模型导出总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事先声明，以下大部分内容来源于&lt;a href=&quot;https://zhuanlan.zhihu.com/p/113734249&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tensorflow 模型导出总结&lt;/a&gt;，并加上个人见解。&lt;/p&gt;
&lt;p&gt;tensorflow 1.0 以及2.0 提供了多种不同的模型导出格式，例如说有checkpoint，SavedModel，Frozen GraphDef，Keras model（HDF5） 以及用于移动端，嵌入式的TFLite。 &lt;/p&gt;
&lt;p&gt;模型导出主要包含了：参数以及网络结构的导出，不同的导出格式可能是分别导出，或者是整合成一个独立的文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数和网络结构分开保存：checkpoint， SavedModel&lt;/li&gt;
&lt;li&gt;只保存权重：HDF5（可选）&lt;/li&gt;
&lt;li&gt;参数和网络结构保存在一个文件：Frozen GraphDef，HDF5（可选）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在tensorflow 1.0中，可以见下图，主要有三种主要的API：Keras、Estimator以及Legacy即最初的session模型，其中tf.Keras主要保存为HDF5，Estimator保存为SavedModel，而Lagacy主要保存的是Checkpoint，并且可以通过freeze_graph，将模型变量冻结，得到Frozen GradhDef的文件。这三种格式的模型，都可以通过TFLite Converter导出为 &lt;code&gt;.tflite&lt;/code&gt; 的模型文件，用于安卓/ios/嵌入式设备的serving。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="TensorFlow" scheme="https://www.zdaiot.com/categories/MLFrameworks/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="https://www.zdaiot.com/tags/TensorFlow/"/>
    
      <category term="save" scheme="https://www.zdaiot.com/tags/save/"/>
    
  </entry>
  
  <entry>
    <title>数字编码</title>
    <link href="https://www.zdaiot.com/Tools/Computer/%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/"/>
    <id>https://www.zdaiot.com/Tools/Computer/数字编码/</id>
    <published>2022-03-31T07:08:55.000Z</published>
    <updated>2022-03-31T07:08:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，学完字符编码之后，准备一鼓作气，看一下数字编码。</p><h2 id="整数编码"><a href="#整数编码" class="headerlink" title="整数编码"></a>整数编码</h2><p>在C语音中，整数编码可以分为有符号整数和无符号整数。当用关键字 char short long等指定，默认的是前面有signed，如果声明为有符号类型，需要在关键字前加unsigned，如unsigned short ，unsigned long等等。</p><p>那么这些数据是如何存储的呢？</p><h3 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h3><p>首先我们来看最简单的无符号整数。假设该二进制数有$w$位，那么它能表示的数据范围为$[0,2^w−1]$。</p><p>以int8为例（也就是用8个bit来表示数字），那么取值范围为<code>0000 0000</code>到<code>1111 1111</code>，也就是<code>0</code>到<code>255</code>。这本身没有什么好讲的。</p><p>下面是在C\C++中无符号基本数据类型的最小值跟最大值(64位机器)：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>unsigned short</td><td>0</td><td>65 535</td></tr><tr><td>unsigned int</td><td>0</td><td>4 294 967 295</td></tr><tr><td>unsigned long</td><td>0</td><td>18 446 744 073 709 551 615</td></tr></tbody></table></div><h3 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h3><p>无符号整数看起来很简单，但是无法处理负数。这时候有符号整数就派上用上了。</p><h4 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h4><p>我们首先介绍几个关键概念。</p><p><strong>原码：</strong>原码表示是最简单的，第一位为符号位，其余位为相应的数值。</p><p>例如short a = 6，a 的原码就是0000 0000 0000 0110。更改 a 的值a = -18，此时 a 的原码就是1000 0000 0001 0010。</p><p><strong>反码：</strong>正数的反码与其原码相同；负数的反码是将原码中除符号位以外的所有位取反。</p><p>例如short a = 6，a 的原码和反码都是0000 0000 0000 0110。更改 a 的值a = -6，此时 a 的反码是1111 1111 1111 1001。</p><p><strong>补码：</strong>对于正数，它的补码就是其原码（原码、反码、补码都相同）；对于负数，补码等于反码加1。例如short a = 6，a 的原码、反码、补码都是0000 0000 0000 0110。更改 a 的值a = -6;，此时 a 的补码是1111 1111 1111 1010。</p><p>用公式表示该过程如下：</p><script type="math/tex; mode=display">D_{signed}(\vec{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i</script><p>其中$\vec{x}$为二进制为$w$位的向量形式，其中的分量只能是0和1。上式可以看到最高位$x_{w-1}$为符号位，最高位$x_{w-1}$为1则为负数，为0则代表正数，此时只剩下了$\sum_{i=0}^{w-2}x_i2^i$。</p><script type="math/tex; mode=display">D_{signed}([0 0 0 1])=-0*2^3+0*2^2+0*2^1+1*2^0=0+0+0+1=1\\D_{signed}([0 1 0 1])=-0*2^3+1*2^2+0*2^1+1*2^0=0+4+0+1=5\\D_{signed}([1 0 1 1])=-1*2^3+0*2^2+1*2^1+1*2^0=-8+0+2+1=-5\\D_{signed}([1 1 1 1])=-1*2^3+1*2^2+1*2^1+1*2^0=-8+4+2+1=-1</script><p>下面我们来考虑$w$位补码所能表示的范围，上面的式子所能表示的最小值是最高位为 1，其他位均为零的时候即$D_{min}=-2^{w-1}$。而最大值是最高位（符号位）为 0，其他位均为 1 时，即$D_{max}=\sum_{i=0}^{w-2}2^i=2^{w-1}-1$。所以一个$w$位的二进制数可以表示的有符号数值范围是$[-2^{w-1},2^{w-1}-1]$。</p><p>下面是在C\C++中无符号基本数据类型的最小值跟最大值(64位机器)。</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>char</td><td>-128</td><td>127</td></tr><tr><td>short</td><td>-32 768</td><td>32 767</td></tr><tr><td>int</td><td>-2 147 483 648</td><td>2 147 483 647</td></tr><tr><td>long</td><td>-9 223 372 036 854 775 808</td><td>9 223 372 036 854 775 807</td></tr></tbody></table></div><p>那么为什么补码表示的表示范围是不对称的，正数比负数要少一个？是因为有一半的位要表示负数（符号位为 1），另一半的位要表示正数（符号位为 0）。以int8为例，那么<code>1000 0000</code>和<code>0000 0000</code>分别表示正负0，但是我们并不需要负0，所以把<code>1000 0000</code>编码为了负数。</p><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>那么有了原码，计算机为什么还要用补码呢？这就需要看它们的运算情况。</p><p>假设字长为 8 位 ，那么原码的运算方式为：1 - 1 = 1 + ( -1 ) =(00000001) + (10000001) = (10000010) = -2，这显然不正确。出现的原因是这种形式下，符号位无法参与运算。当两个正数相加时是没有问题的，但是负数无法参与运算。</p><p>我们接下来看一下反码的运算：1 - 1 = 1 + ( -1 )= (00000001) + (11111110) = (11111111) = ( -0 ) 有问题。1 – 2 = 1 + ( -2 ) = (00000001) + (11111101) = (11111110) = ( -1 ) 正确。反码的问题出 现在(+0)和(-0)上，因为在人们的计算概念中零是没有正负之分的。</p><p> 再来看补码的加减运算 如下：1 - 1 = 1 + （-1） = (00000001) + (11111111) = (00000000) = 0 正确。1 – 2 = 1 + （-2）= (00000001) + (11111110) = (11111111) = ( -1 ) 正确。</p><h2 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h2><p>根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：</p><p><img src="/Tools/Computer/数字编码/times 2^E&chs=45.png" alt="img" style="zoom: 67%;"></p><p>1、(-1)^s表示<strong>符号标志位</strong>，当s=0，V为正数；当s=1，V为负数。</p><p>2、M表示有效数字，大于等于1，小于2。<strong>称作尾数(significand)。</strong></p><p>3、2为<strong>基数</strong>。</p><p>4、E则是指数部分称作<strong>阶码(exponent)</strong>。</p><p>举例来说，十进制的5.0，写成二进制是101.0，相当于1.01×2^2。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。</p><p>十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。</p><p>IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。</p><p><img src="/Tools/Computer/数字编码/bg2010060601.png" alt="img"></p><p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p><p><img src="/Tools/Computer/数字编码/bg2010060602.png" alt="img"></p><p>IEEE 754对有效数字M和指数E，还有一些特别规定。</p><p>前面说过，1≤M&lt;2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。<strong>IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。</strong>比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。</p><p>至于指数E，情况就比较复杂。</p><p>首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为<code>0~255</code>；如果E为11位，它的取值范围为<code>0~2047</code>。但是，我们知道，科学计数法中的E是可以出现负数的，<strong>所以IEEE 754规定，E的值必须再减去一个中间数，得到真实值，这个中间数称为偏置量Bias。</strong>它的数值跟存储阶码的位长有关，当阶码位长为k的时候偏置量的值为<code>2 ^ k - 1</code>。对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。</p><p>比如，2^10的E是10，所以保存成32位浮点数时，必须加上中间数，保存成10+127=137，即10001001。</p><h3 id="规格化浮点数"><a href="#规格化浮点数" class="headerlink" title="规格化浮点数"></a>规格化浮点数</h3><p><strong>E不全为0或不全为1。</strong>这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。</p><p>可以推断出它所能够表示的无符号数取值范围是<code>1~254</code>。因此，阶码值的取值范围是<code>-126 ～ 127</code>。</p><h3 id="非规格化浮点数"><a href="#非规格化浮点数" class="headerlink" title="非规格化浮点数"></a>非规格化浮点数</h3><p>非规格化浮点数的特点就是<strong>用于存储阶码的所有位全为0E全为0，存储尾数的位可以随意定制</strong>。非规格化浮点数主要用于表示那些<em>非常接近于0的数</em>。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</p><p>为啥这个地方是1-127呢？这是为了平滑过度。具体可看<a href="https://www.beansmile.com/blog/posts/details-of-ieee-float" target="_blank" rel="noopener">详谈IEEE浮点数编码机制</a>。</p><h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><p><strong>E全为1。</strong>这时如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/q932104843/article/details/69808550" target="_blank" rel="noopener">计算机整数编码系统</a><br><a href="https://zhuanlan.zhihu.com/p/54990992" target="_blank" rel="noopener">整数的编码与存储</a><br><a href="https://www.cnblogs.com/sv00/p/9865124.html" target="_blank" rel="noopener">了解浮点数的编码形式</a><br><a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示</a><br><a href="https://www.beansmile.com/blog/posts/details-of-ieee-float" target="_blank" rel="noopener">详谈IEEE浮点数编码机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，学完字符编码之后，准备一鼓作气，看一下数字编码。&lt;/p&gt;
&lt;h2 id=&quot;整数编码&quot;&gt;&lt;a href=&quot;#整数编码&quot; class=&quot;headerlink&quot; title=&quot;整数编码&quot;&gt;&lt;/a&gt;整数编码&lt;/h2&gt;&lt;p&gt;在C语音中，整数编码可以分为有符号整数和无符号整数。当用关键字 char short long等指定，默认的是前面有signed，如果声明为有符号类型，需要在关键字前加unsigned，如unsigned short ，unsigned long等等。&lt;/p&gt;
&lt;p&gt;那么这些数据是如何存储的呢？&lt;/p&gt;
&lt;h3 id=&quot;无符号整数&quot;&gt;&lt;a href=&quot;#无符号整数&quot; class=&quot;headerlink&quot; title=&quot;无符号整数&quot;&gt;&lt;/a&gt;无符号整数&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="Computer" scheme="https://www.zdaiot.com/categories/Tools/Computer/"/>
    
    
      <category term="编码" scheme="https://www.zdaiot.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>字符编码</title>
    <link href="https://www.zdaiot.com/Tools/Computer/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>https://www.zdaiot.com/Tools/Computer/字符编码/</id>
    <published>2022-03-30T12:26:55.000Z</published>
    <updated>2022-03-30T12:26:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞二进制分析的东西，对于字符编码特别糊涂，所以学习了一下，本来觉得<a href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">阮一峰的笔记</a>挺好的，但是感觉又有点问题，所以我这里在自己总结一下，以下大部分内容还是来源于<a href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">阮一峰的笔记</a>。当然我自己总结的可能也不太对（知识有限呀），之后可以再修改。</p><h2 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h2><p>计算机中，每一个二进制位（bit）有<code>0</code>和<code>1</code>两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从<code>00000000</code>到<code>11111111</code>。</p><p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p><p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），<strong>只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code></strong>。</p><h2 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h2><p>ASCII 码只能表示128个字符，对于英文是足够的，但是对于中文、日文、法语等是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的<code>é</code>的编码为130（二进制<code>10000010</code>）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p><p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p><p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。</p><p>好了，终于可以开始扯Windows的记事本了。</p><p>在早期并没有Unicode（下文介绍）的时候，可以看到编码是十分混乱的，Windows想了个办法，就是允许一个默认语言编码，就是当遇到一个字符串，不是Unicode的时候，就用<strong>默认语言编码解释（在区域和语言选项里可以改默认语言）</strong>。这个默认语言，在不同Windows语言版本里是不同的，在简体中文版里，是GBK，在繁体中文版里，是BIG5，在日文版里是JIS。</p><p>而Windows的<code>notepad.exe</code>（记事本）中的ANSI编码（如下图所示）就是这种默认编码。所以，一个中文文本，用ANSI编码保存，在简体中文版Windows就会使用GBK模式保存，拿到繁体中文Windows读取，就会使用BIG5模式读取，那么就全乱套了（文件二进制数不变，但是解码查表规则不同）。</p><p><img src="/Tools/Computer/字符编码/image-20220330203356707.png" alt="image-20220330203356707" style="zoom: 80%;"></p><h2 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h2><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p><p>可以想象，如果有一种字符集，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种统一的字符集标准。</p><p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="https://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p><h2 id="Unicode的问题"><a href="#Unicode的问题" class="headerlink" title="Unicode的问题"></a>Unicode的问题</h2><p>需要注意的是，Unicode 只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何编码。</p><p>比如，汉字<code>严</code>的 Unicode 是十六进制数<code>4E25</code>，转换成二进制数足足有15位（<code>100111000100101</code>），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p><p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p><p>它们造成的结果是：</p><p>1）出现了 Unicode 的多种编码方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。</p><p>2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</p><h2 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h2><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的编码方式。其他编码方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8 是 Unicode字符集 的编码方式之一。</strong></p><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>UTF-8 的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p><p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; Unicode符号范围     |        UTF-8编码方式</span><br><span class="line">&gt; (十六进制)        |              （二进制）</span><br><span class="line">&gt; ----------------------+---------------------------------------------</span><br><span class="line">&gt; 0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">&gt; 0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">&gt; 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">&gt; 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>下面，还是以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p><p><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p><h2 id="编码之间的转换"><a href="#编码之间的转换" class="headerlink" title="编码之间的转换"></a>编码之间的转换</h2><p>通过上一节的例子，可以看到<code>严</code>的 Unicode码 是<code>4E25</code>，UTF-8 编码是<code>E4B8A5</code>，两者是不一样的。它们之间的转换可以通过程序实现。比如用Windows平台<code>notepad.exe</code>（记事本），打开文件后，点击<code>文件</code>菜单中的<code>另存为</code>命令，会跳出一个对话框，在最底部有一个<code>编码</code>的下拉条。选择完”编码方式”后，点击”保存”按钮，文件的编码方式就立刻转换好了。</p><p><img src="/Tools/Computer/字符编码/image-20220330203356707.png" alt="image-20220330203356707" style="zoom: 80%;"></p><h2 id="Little-endian-和-Big-endian"><a href="#Little-endian-和-Big-endian" class="headerlink" title="Little endian 和 Big endian"></a>Little endian 和 Big endian</h2><p>以汉字<code>严</code>为例，Unicode 码是<code>4E25</code>，需要用两个字节存储，一个字节是<code>4E</code>，另一个字节是<code>25</code>。存储的时候，<code>4E</code>在前，<code>25</code>在后，这就是 Big endian 方式；<code>25</code>在前，<code>4E</code>在后，这是 Little endian 方式。</p><p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p><p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p><p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用大头方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小头方式。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>我们使用Winhex软件打开一个Pytorch模型文件（含网络结构），查看其二进制、ASCII编码、UTF-8编码，其中部分内容如下。</p><p><img src="/Tools/Computer/字符编码/image-20220330231545195.png" alt="image-20220330231545195" style="zoom:50%;"></p><p>注意到其中有一个<code>E7 AC AC</code>字符，对应的二进制位<code>11100111 10101100 10101100</code>，正好符合UTF-8编码，解码之后二进制为<code>0111 101100 101100</code>，再换算成16进制为<code>7B2C</code>，查找<a href="https://www.unicode.org/charts/PDF/U4E00.pdf" target="_blank" rel="noopener">Unicode字符集</a>，正好是<code>第</code>这个字。</p><p><img src="/Tools/Computer/字符编码/image-20220330233301713.png" alt="image-20220330233301713" style="zoom:50%;"></p><h2 id="实战2"><a href="#实战2" class="headerlink" title="实战2"></a>实战2</h2><p>打开”记事本”程序<code>notepad.exe</code>，新建一个文本文件，内容就是一个<code>严</code>字，依次采用<code>ANSI</code>，<code>Unicode</code>，<code>Unicode big endian</code>，<code>UTF-8-BOM</code>和<code>UTF-8</code>，编码方式保存。</p><p>然后，用文本编辑软件<a href="https://www.google.cn/search?aq=t&amp;oq=UltraEdit&amp;complete=1&amp;hl=zh-CN&amp;newwindow=1&amp;rlz=1B3GGGL_zh-CNCN216CN216&amp;q=ultraedit+下载&amp;btnG=Google+搜索&amp;meta=" target="_blank" rel="noopener">UltraEdit 中</a>的”十六进制功能”，观察该文件的内部编码方式。</p><p>1）ANSI：文件的编码就是两个字节<code>D1 CF</code>，这正是<code>严</code>的 GB2312 编码，这也暗示 GB2312 是采用大头方式存储的。</p><p>2）Unicode：编码是四个字节<code>FF FE 25 4E</code>，其中<code>FF FE</code>表明是小头方式存储，真正的编码是<code>4E25</code>。</p><p>3）Unicode big endian：编码是四个字节<code>FE FF 4E 25</code>，其中<code>FE FF</code>表明是大头方式存储。</p><p>4）UTF-8-BOM：编码是六个字节<code>EF BB BF E4 B8 A5</code>，前三个字节<code>EF BB BF</code>表示这是UTF-8编码，后三个<code>E4B8A5</code>就是<code>严</code>的具体编码，它的存储顺序与编码顺序是一致的。</p><p>5）UTF-8：编码是三个字节<code>E4 B8 A5</code>，<code>E4B8A5</code>就是<code>严</code>的具体编码，它的存储顺序与编码顺序是一致的。值得注意的是，UTF-8其实是不需要BOM，根据编码规则就可以知道这个是UTF-8了。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>补充一个知识点：二进制与十六进制的转换。</p><p>方法：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，得到的数就是一位十六位二进制数，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。</p><p>1、例：将二进制11101001.1011转换为十六进制</p><p>得到结果：将二进制11101001.1011转换为十六进制为E9.B</p><p>2、例：将101011.101转换为十六进制</p><p>因此得到结果：将二进制101011.101转换为十六进制为2B.A</p><p>3、例：将二进制1110 1010 0101转换为十六进制</p><p>结果：EA5。</p><p>验证：二进制<code>2**11+2**10+2**9+2^7+2**5+2**2+2**0=3749</code>，可以化简为<code>(2**3+2**2+2**1)*(2**8)+(2**3+2**1)*(2**4)+2**2+2**0=3749</code>。<code>1110 1010 0101</code>分别对应于<code>E A 5</code>，换算成十进制为<code>14*(16**2)+10*16+5=3749</code>。所以取四合一法是正确的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a><br><a href="https://www.zhihu.com/question/20650946/answer/15751688" target="_blank" rel="noopener">Windows 记事本的 ANSI、Unicode、UTF-8 这三种编码模式有什么区别？ - 时国怀的回答 - 知乎</a><br><a href="https://www.zhihu.com/question/20650946/answer/15745831" target="_blank" rel="noopener">Windows 记事本的 ANSI、Unicode、UTF-8 这三种编码模式有什么区别？ - 梁海的回答 - 知乎 </a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在搞二进制分析的东西，对于字符编码特别糊涂，所以学习了一下，本来觉得&lt;a href=&quot;https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰的笔记&lt;/a&gt;挺好的，但是感觉又有点问题，所以我这里在自己总结一下，以下大部分内容还是来源于&lt;a href=&quot;https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰的笔记&lt;/a&gt;。当然我自己总结的可能也不太对（知识有限呀），之后可以再修改。&lt;/p&gt;
&lt;h2 id=&quot;ASCII-码&quot;&gt;&lt;a href=&quot;#ASCII-码&quot; class=&quot;headerlink&quot; title=&quot;ASCII 码&quot;&gt;&lt;/a&gt;ASCII 码&lt;/h2&gt;&lt;p&gt;计算机中，每一个二进制位（bit）有&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从&lt;code&gt;00000000&lt;/code&gt;到&lt;code&gt;11111111&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。&lt;/p&gt;
&lt;p&gt;ASCII 码一共规定了128个字符的编码，比如空格&lt;code&gt;SPACE&lt;/code&gt;是32（二进制&lt;code&gt;00100000&lt;/code&gt;），大写的字母&lt;code&gt;A&lt;/code&gt;是65（二进制&lt;code&gt;01000001&lt;/code&gt;）。这128个符号（包括32个不能打印出来的控制符号），&lt;strong&gt;只占用了一个字节的后面7位，最前面的一位统一规定为&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="Computer" scheme="https://www.zdaiot.com/categories/Tools/Computer/"/>
    
    
      <category term="编码" scheme="https://www.zdaiot.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch Tensor形状变换</title>
    <link href="https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch%20Tensor%E5%BD%A2%E7%8A%B6%E5%8F%98%E6%8D%A2/"/>
    <id>https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch Tensor形状变换/</id>
    <published>2022-03-28T06:30:37.000Z</published>
    <updated>2022-03-28T06:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直知道Pytorch、numpy之类有好几种变换维度的方法，但是之前了解的不深，今天总结一下。</p><h2 id="Reshape"><a href="#Reshape" class="headerlink" title="Reshape"></a>Reshape</h2><p>Pytorch在reshape的时候，是按照行存储的方式进行的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: x = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: x</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">tensor([[[ <span class="number">0.2921</span>, <span class="number">-0.1806</span>, <span class="number">-1.0838</span>, <span class="number">-0.6770</span>],</span><br><span class="line">         [<span class="number">-0.7797</span>,  <span class="number">0.2614</span>, <span class="number">-0.5380</span>,  <span class="number">1.8941</span>],</span><br><span class="line">         [<span class="number">-0.7261</span>,  <span class="number">0.8209</span>,  <span class="number">0.0286</span>,  <span class="number">0.0997</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">0.5549</span>,  <span class="number">0.9036</span>,  <span class="number">0.8790</span>, <span class="number">-0.5776</span>],</span><br><span class="line">         [ <span class="number">0.3745</span>,  <span class="number">0.6963</span>, <span class="number">-0.3445</span>, <span class="number">-0.0022</span>],</span><br><span class="line">         [<span class="number">-0.5991</span>,  <span class="number">1.4639</span>, <span class="number">-0.5396</span>, <span class="number">-0.1702</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: torch.reshape(x, (<span class="number">-1</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">19</span>]:</span><br><span class="line">tensor([[ <span class="number">0.2921</span>, <span class="number">-0.1806</span>],</span><br><span class="line">        [<span class="number">-1.0838</span>, <span class="number">-0.6770</span>],</span><br><span class="line">        [<span class="number">-0.7797</span>,  <span class="number">0.2614</span>],</span><br><span class="line">        [<span class="number">-0.5380</span>,  <span class="number">1.8941</span>],</span><br><span class="line">        [<span class="number">-0.7261</span>,  <span class="number">0.8209</span>],</span><br><span class="line">        [ <span class="number">0.0286</span>,  <span class="number">0.0997</span>],</span><br><span class="line">        [ <span class="number">0.5549</span>,  <span class="number">0.9036</span>],</span><br><span class="line">        [ <span class="number">0.8790</span>, <span class="number">-0.5776</span>],</span><br><span class="line">        [ <span class="number">0.3745</span>,  <span class="number">0.6963</span>],</span><br><span class="line">        [<span class="number">-0.3445</span>, <span class="number">-0.0022</span>],</span><br><span class="line">        [<span class="number">-0.5991</span>,  <span class="number">1.4639</span>],</span><br><span class="line">        [<span class="number">-0.5396</span>, <span class="number">-0.1702</span>]])</span><br></pre></td></tr></table></figure><h2 id="permute"><a href="#permute" class="headerlink" title="permute"></a>permute</h2><p>permute会将tensor维度进行调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: y = x.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: y</span><br><span class="line">Out[<span class="number">25</span>]:</span><br><span class="line">tensor([[[ <span class="number">0.2921</span>,  <span class="number">0.5549</span>],</span><br><span class="line">         [<span class="number">-0.1806</span>,  <span class="number">0.9036</span>],</span><br><span class="line">         [<span class="number">-1.0838</span>,  <span class="number">0.8790</span>],</span><br><span class="line">         [<span class="number">-0.6770</span>, <span class="number">-0.5776</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">-0.7797</span>,  <span class="number">0.3745</span>],</span><br><span class="line">         [ <span class="number">0.2614</span>,  <span class="number">0.6963</span>],</span><br><span class="line">         [<span class="number">-0.5380</span>, <span class="number">-0.3445</span>],</span><br><span class="line">         [ <span class="number">1.8941</span>, <span class="number">-0.0022</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">-0.7261</span>, <span class="number">-0.5991</span>],</span><br><span class="line">         [ <span class="number">0.8209</span>,  <span class="number">1.4639</span>],</span><br><span class="line">         [ <span class="number">0.0286</span>, <span class="number">-0.5396</span>],</span><br><span class="line">         [ <span class="number">0.0997</span>, <span class="number">-0.1702</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: y.size()</span><br><span class="line">Out[<span class="number">26</span>]: torch.Size([<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: x[:, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">Out[<span class="number">29</span>]: tensor([<span class="number">0.2614</span>, <span class="number">0.6963</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: y[<span class="number">1</span>, <span class="number">1</span>, :]</span><br><span class="line">Out[<span class="number">31</span>]: tensor([<span class="number">0.2614</span>, <span class="number">0.6963</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直知道Pytorch、numpy之类有好几种变换维度的方法，但是之前了解的不深，今天总结一下。&lt;/p&gt;
&lt;h2 id=&quot;Reshape&quot;&gt;&lt;a href=&quot;#Reshape&quot; class=&quot;headerlink&quot; title=&quot;Reshape&quot;&gt;&lt;/a&gt;Reshape&lt;/h2&gt;&lt;p&gt;Pytorch在reshape的时候，是按照行存储的方式进行的。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; torch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;]: x = torch.randn(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;]: x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tensor([[[ &lt;span class=&quot;number&quot;&gt;0.2921&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.1806&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1.0838&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.6770&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         [&lt;span class=&quot;number&quot;&gt;-0.7797&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.2614&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.5380&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;1.8941&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         [&lt;span class=&quot;number&quot;&gt;-0.7261&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.8209&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.0286&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.0997&lt;/span&gt;]],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[ &lt;span class=&quot;number&quot;&gt;0.5549&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.9036&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.8790&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.5776&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         [ &lt;span class=&quot;number&quot;&gt;0.3745&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.6963&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.3445&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.0022&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         [&lt;span class=&quot;number&quot;&gt;-0.5991&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;1.4639&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.5396&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.1702&lt;/span&gt;]]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;]: torch.reshape(x, (&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tensor([[ &lt;span class=&quot;number&quot;&gt;0.2921&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.1806&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;-1.0838&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.6770&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;-0.7797&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.2614&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;-0.5380&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;1.8941&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;-0.7261&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.8209&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [ &lt;span class=&quot;number&quot;&gt;0.0286&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.0997&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [ &lt;span class=&quot;number&quot;&gt;0.5549&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.9036&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [ &lt;span class=&quot;number&quot;&gt;0.8790&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.5776&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [ &lt;span class=&quot;number&quot;&gt;0.3745&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.6963&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;-0.3445&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.0022&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;-0.5991&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;1.4639&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;-0.5396&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.1702&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;permute&quot;&gt;&lt;a href=&quot;#permute&quot; class=&quot;headerlink&quot; title=&quot;permute&quot;&gt;&lt;/a&gt;permute&lt;/h2&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/categories/MLFrameworks/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/tags/Pytorch/"/>
    
      <category term="shape" scheme="https://www.zdaiot.com/tags/shape/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch模型存储研究</title>
    <link href="https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch%E6%A8%A1%E5%9E%8B%E5%AD%98%E5%82%A8%E7%A0%94%E7%A9%B6/"/>
    <id>https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch模型存储研究/</id>
    <published>2022-03-23T11:23:38.000Z</published>
    <updated>2022-03-23T11:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Pytorch的两种保存模型方式"><a href="#Pytorch的两种保存模型方式" class="headerlink" title="Pytorch的两种保存模型方式"></a>Pytorch的两种保存模型方式</h2><p>众所周知，Pytorch存储模型主要有<a href="https://pytorch.org/tutorials/beginner/saving_loading_models.html" target="_blank" rel="noopener">两种方式</a>。</p><p><strong>方式一：Save/Load <code>state_dict</code> (Recommended)</strong></p><p>只保存权重：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), PATH)</span><br></pre></td></tr></table></figure><p>加载模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH))</span><br><span class="line">model.eval()</span><br></pre></td></tr></table></figure><p><strong>方式二：Save/Load Entire Model</strong></p><p>保存模型和权重：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model, PATH)</span><br></pre></td></tr></table></figure><p>加载模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Model class must be defined somewhere</span></span><br><span class="line">model = torch.load(PATH)</span><br><span class="line">model.eval()</span><br></pre></td></tr></table></figure><p>注意到方式二在加载模型的时候，官方有一个提醒：<code># Model class must be defined somewhere</code>，也就是从<code>PATH</code>中读取时需要定义出来<code>TheModelClass</code>，否则的话会直接报错。可能你看到这个地方不是很明白，我们可以做一个实验。</p><h2 id="Save-Load-Entire-Model：缺陷"><a href="#Save-Load-Entire-Model：缺陷" class="headerlink" title="Save/Load Entire Model：缺陷"></a>Save/Load Entire Model：缺陷</h2><p>我们首先定义模型结构，并进行保存，假设下面代码存储在文件<code>E:\Working\torch_save\save_learn.py</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myConv</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_channel, output_chanel)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(input_channel, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(output_chanel, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>)  <span class="comment"># flatten all dimensions except batch</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_conv</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> myConv(input_channel=<span class="number">3</span>, output_chanel=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define Model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheModelClass</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv = get_conv()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = torch.sigmoid(self.fc3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">   </span><br><span class="line">model = TheModelClass()</span><br><span class="line">output = model(torch.ones(<span class="number">1</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line">print(output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里_use_new_zipfile_serialization=False是使用非压缩存储方式，这个之后再进行解释。</span></span><br><span class="line">torch.save(model, <span class="string">'./model_file.pth'</span>, _use_new_zipfile_serialization=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>执行该文件，可以保存模型到<code>./model_file.pth</code>，并且得到输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Out[<span class="number">1</span>]: tensor([[<span class="number">0.5042</span>]], grad_fn=&lt;SigmoidBackward0&gt;)</span><br></pre></td></tr></table></figure><p>此时，新建一个文件<code>E:\Working\torch_save\load_learn.py</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">model = torch.load(<span class="string">'model_file.pth'</span>)</span><br><span class="line">print(model)</span><br></pre></td></tr></table></figure><p>执行该文件，会报错如下，也就是在该文件中，找不到<code>TheModelClass</code>类的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"E:/Working/torch_save/load_learn.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    model = torch.load(<span class="string">'model_file.pth'</span>)</span><br><span class="line">  File <span class="string">"C:\Users\zhaodali\Anaconda3\lib\site-packages\torch\serialization.py"</span>, line <span class="number">713</span>, <span class="keyword">in</span> load</span><br><span class="line">    <span class="keyword">return</span> _legacy_load(opened_file, map_location, pickle_module, **pickle_load_args)</span><br><span class="line">  File <span class="string">"C:\Users\zhaodali\Anaconda3\lib\site-packages\torch\serialization.py"</span>, line <span class="number">930</span>, <span class="keyword">in</span> _legacy_load</span><br><span class="line">    result = unpickler.load()</span><br><span class="line">  File <span class="string">"C:\Users\zhaodali\Anaconda3\lib\site-packages\torch\serialization.py"</span>, line <span class="number">746</span>, <span class="keyword">in</span> find_class</span><br><span class="line">    <span class="keyword">return</span> super().find_class(mod_name, name)</span><br><span class="line">AttributeError: Can<span class="string">'t get attribute '</span>TheModelClass<span class="string">' on &lt;module '</span>__main__<span class="string">' from '</span>E:/Working/torch_save/load_learn.py<span class="string">'&gt;</span></span><br></pre></td></tr></table></figure><p>那么，既然<code>./model_file.pth</code>文件已经保存了模型结构，怎么可以在不知道源代码的情况下，加载进来呢？围绕这个问题，我进行了一系列的探索。</p><h2 id="pickle库"><a href="#pickle库" class="headerlink" title="pickle库"></a>pickle库</h2><p>再看一遍Pytorch的<a href="https://pytorch.org/tutorials/beginner/saving_loading_models.html" target="_blank" rel="noopener">官方文档</a>，有关于为什么在加载模型时，必须要事先定义类的解释说明：</p><blockquote><p>This save/load process uses the most intuitive syntax and involves the least amount of code. Saving a model in this way will save the entire module using Python’s <a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="noopener">pickle</a> module. The disadvantage of this approach is that the serialized data is bound to the specific classes and the exact directory structure used when the model is saved. The reason for this is because pickle does not save the model class itself. Rather, it saves a path to the file containing the class, which is used during load time. Because of this, your code can break in various ways when used in other projects or after refactors.</p></blockquote><p>简单来说，Pytorch保存整个module使用的是pickle库，由于这个库在保存类的时候，并不是保存类本身，而是只保存了类名和类定义的位置，在加载的时候，pickle库会找类定义的位置，去加载类的定义。可以看这句话还是很懵逼，我们可以直接去<a href="https://docs.python.org/zh-cn/3/library/pickle.html#what-can-be-pickled-and-unpickled" target="_blank" rel="noopener">pickle官方库</a>看相应的解释。</p><p>以下来自官方文档，为了方便理解，这里将这些内容全部复制过来了。</p><h3 id="可以被序列化-反序列化的对象"><a href="#可以被序列化-反序列化的对象" class="headerlink" title="可以被序列化/反序列化的对象"></a>可以被序列化/反序列化的对象</h3><p>下列类型可以被封存：</p><ul><li><code>None</code>、<code>True</code> 和 <code>False</code></li><li>整数、浮点数、复数</li><li>str、byte、bytearray</li><li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li><li>定义在模块最外层的函数（使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def" target="_blank" rel="noopener"><code>def</code></a> 定义，<a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a> 函数则不可以）</li><li>定义在模块最外层的内置函数</li><li>定义在模块最外层的类</li><li>某些类实例，这些类的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 属性值或 <code>__getstate__()</code> 函数的返回值可以被封存（详情参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-inst" target="_blank" rel="noopener">封存类实例</a> 这一段）。</li></ul><p>尝试封存不能被封存的对象会抛出 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PicklingError" target="_blank" rel="noopener"><code>PicklingError</code></a> 异常，异常发生时，可能有部分字节已经被写入指定文件中。尝试封存递归层级很深的对象时，可能会超出最大递归层级限制，此时会抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RecursionError" target="_blank" rel="noopener"><code>RecursionError</code></a> 异常，可以通过 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.setrecursionlimit" target="_blank" rel="noopener"><code>sys.setrecursionlimit()</code></a> 调整递归层级，不过请谨慎使用这个函数，因为可能会导致解释器崩溃。</p><p>注意，<strong>函数（内置函数或用户自定义函数）在被封存时，引用的是函数全名。这意味着只有函数所在的模块名，与函数名会被封存，函数体及其属性不会被封存。因此，在解封的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被封存时的名称</strong>，否则会抛出异常。</p><p>同样的，<strong>类也只封存名称，所以在解封环境中也有和函数相同的限制。注意，类体及其数据不会被封存</strong>，所以在下面的例子中类属性 <code>attr</code> 不会存在于解封后的环境中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    attr = <span class="string">'A class attribute'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file.pickle'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    pickle.dump(Foo, handle)</span><br></pre></td></tr></table></figure><p>用Hex Fiend软件（Windows下的WinHex软件）查看<code>file.pickle</code>文件，可以如下所示，可以看到确实只封存了名称。</p><p><img src="/MLFrameworks/Pytorch/Pytorch模型存储研究/image-20220323203426343.png" alt="image-20220323203426343" style="zoom:50%;"></p><p>这些限制决定了为什么必须在一个模块的最外层定义可封存的函数和类。</p><p>类似的，在封存类的实例时，其类体和类数据不会跟着实例一起被封存，只有实例数据会被封存。这样设计是有目的的，在将来修复类中的错误、给类增加方法之后，仍然可以载入原来版本类实例的封存数据来还原该实例。如果你准备长期使用一个对象，可能会同时存在较多版本的类体，可以为对象添加版本号，这样就可以通过类的 <code>__setstate__()</code> 方法将老版本转换成新版本。</p><h3 id="封存类实例"><a href="#封存类实例" class="headerlink" title="封存类实例"></a>封存类实例</h3><p>在本节中，我们描述了可用于定义、自定义和控制如何封存和解封类实例的通用流程。</p><p>通常，使一个实例可被封存不需要附加任何代码。Pickle 默认会通过 Python 的内省机制获得实例的类及属性。而当实例解封时，它的 <code>__init__()</code> 方法通常 <em>不会</em> 被调用。其默认动作是：先创建一个未初始化的实例，然后还原其属性，下面的代码展示了这种行为的实现机制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (obj.__class__, obj.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(cls, attributes)</span>:</span></span><br><span class="line">    obj = cls.__new__(cls)</span><br><span class="line">    obj.__dict__.update(attributes)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>由此可见，确实是pickle本身的机制导致了Pytorch load的异常。</p><h2 id="Hex-Fiend分析"><a href="#Hex-Fiend分析" class="headerlink" title="Hex Fiend分析"></a>Hex Fiend分析</h2><p>那么，真的没有办法去加载保存在<code>./model_file.pth</code>文件中的结构么？我们又从该文件的二进制流中进行分析。用Hex Fiend软件打开<code>./model_file.pth</code>文件，可以在最前面看到一些模型类的定义和类所处的位置，而这些信息跟我们的真实情况一模一样。</p><p><img src="/MLFrameworks/Pytorch/Pytorch模型存储研究/image-20220323223740287.png" alt="image-20220323223740287" style="zoom: 30%;"></p><p>那么就可以想到，既然Pytorch在load的时候找不到类的定义和位置，而这些信息在Hex Fiend软件中又可以看到，那我们建立对应的文件，并把类的定义手动复制过来不就行了么？</p><p>观察Hex Fiend软件中的信息，发现我们类的定义都是在<code>E:/Working/torch_save/save_learn.py</code>，因此，我们只需要新建一个文件<code>load_test.py</code>，将类的定义放到该文件夹中，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheModelClass</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv = get_conv()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = torch.sigmoid(self.fc3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myConv</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_channel, output_chanel)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(input_channel, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(output_chanel, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>)  <span class="comment"># flatten all dimensions except batch</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = torch.load(<span class="string">'model_file.pth'</span>)</span><br><span class="line">print(model)</span><br></pre></td></tr></table></figure><blockquote><p>因为我们这里类的定义都是一个文件中的，所以新建一个文件即可。若类的定义是放在不同的文件中的，则需要建立对应目录的文件，并放对应的类。</p></blockquote><p>运行这个文件，我们发现竟然可以load进来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TheModelClass(</span><br><span class="line">  (conv): myConv(</span><br><span class="line">    (conv1): Conv2d(<span class="number">3</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    (pool): MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, ceil_mode=<span class="literal">False</span>)</span><br><span class="line">    (conv2): Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  )</span><br><span class="line">  (fc1): Linear(in_features=<span class="number">400</span>, out_features=<span class="number">120</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (fc2): Linear(in_features=<span class="number">120</span>, out_features=<span class="number">84</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (fc3): Linear(in_features=<span class="number">84</span>, out_features=<span class="number">1</span>, bias=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>那么能够进行前向推理呢？我们又添加了如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output = model(torch.ones(1, 3, 32, 32))</span><br><span class="line">print(output)</span><br></pre></td></tr></table></figure><p>但是发现会报错：<code>NameError: name &#39;F&#39; is not defined</code>。也就是说<code>forward</code>前向推理中<code>F</code>未定义。我们导入相应的库<code>import torch.nn.functional as F</code>，此时再运行文件，发现可以推理了，输出如下，推理结果与真实结果一致，说明我们加载成功了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">0.5042</span>]], grad_fn=&lt;SigmoidBackward&gt;)</span><br></pre></td></tr></table></figure><p>我们由此还可以得出一个结论：<strong>模型在前向推理时会调用<code>forward</code>函数，也就是<code>forward</code>函数必须与真实的<code>forward</code>函数完全一致，否则会报错。</strong></p><p>另外，我们还可以观察一下，我在模型定义时用了<code>get_conv()</code>函数来声明卷积层，而该函数的定义在<code>./model_file.pth</code>文件中并没有，但是我们仍然还原出了模型，那么是不是类的初始化并不重要呢？我们把类的初始化代码都删除，只保留代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheModelClass</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = torch.sigmoid(self.fc3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myConv</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>)  <span class="comment"># flatten all dimensions except batch</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = torch.load(<span class="string">'model_file.pth'</span>)</span><br><span class="line">print(model)</span><br><span class="line">output = model(torch.ones(<span class="number">1</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line">print(output)</span><br></pre></td></tr></table></figure><p>发现仍然可以推理成功，且结果正确。</p><p>最后，我们在运行时还观察到如下warning，也就是TheModelClass的原定义已经被更改了。</p><blockquote><p>/torch/serialization.py:671: SourceChangeWarning: source code of class ‘<strong>main</strong>.TheModelClass’ has changed. you can retrieve the original source code by accessing the object’s source attribute or set <code>torch.nn.Module.dump_patches = True</code> and use the patch tool to revert the changes.<br>  warnings.warn(msg, SourceChangeWarning)</p></blockquote><p>我们点开该warning提醒的位置，可以发现Pytorch会将保存在<code>./model_file.pth</code>文件中的源码与当前的源码进行对比。值得注意的是，下面有一行代码<code>if container_type.dump_patches:</code>，这个是<code>nn.Module</code>才有的属性，所以在还原类的时候，必须让类继承<code>nn.Module</code>，否则还原的时候会保存。</p><p><img src="/MLFrameworks/Pytorch/Pytorch模型存储研究/截屏2022-03-23 23.13.29.png" alt="截屏2022-03-23 23.13.29" style="zoom: 50%;"></p><p>那么我们就可以得出另一个结论：<strong>类的具体初始化可以没有或者不正确，但是类的位置和名字必须正确，且类必须继承<code>nn.Module</code>。</strong></p><h2 id="压缩存储方式"><a href="#压缩存储方式" class="headerlink" title="压缩存储方式"></a>压缩存储方式</h2><p>在本文的开头，我们在保存模型的时候，使用了参数<code>_use_new_zipfile_serialization=False</code>，这会使用非压缩存储方式。若不使用该参数，存储模型的时候，会采用压缩存储方式。这种存储方式并不会保存像类的定义和位置这些信息，而且会进行压缩（因为我们可以用zip解压模型文件）。</p><p>至于为什么说这种存储方式并不会保存类的定义和位置呢？这不仅仅可以通过Hex Fiend分析得到，而且还可以直接看torch save的源代码，其文件位于<code>torch\serialization.py</code>中。</p><p>如下是非压缩存储方式，在持久化存储时使用的代码（关于持久化存储可以看<a href="https://docs.python.org/zh-cn/3/library/pickle.html#persistence-of-external-objects" target="_blank" rel="noopener">官方的代码</a>）。</p><p><img src="/MLFrameworks/Pytorch/Pytorch模型存储研究/截屏2022-03-23 23.27.02.png" alt="截屏2022-03-23 23.27.02" style="zoom:50%;"></p><p>如下是压缩存储方式，在持久化存储时使用的代码。</p><p><img src="/MLFrameworks/Pytorch/Pytorch模型存储研究/截屏2022-03-23 23.24.34.png" alt="截屏2022-03-23 23.24.34" style="zoom:50%;"></p><p>对比一下可以发现，非压缩存储方式查询相应的源码并进行保存，而压缩存储方式不会。</p><blockquote><p>前面介绍说pickle并不会保存类的实现，而Pytorch在非压缩存储方式却保存了相应的源码，这也跟上述的持久化存储函数有关。</p></blockquote><p>因此像前文介绍的，从Hex Fiend中获取类的定义和位置，然后实现模型的load和推理，并不适合压缩存储方式。而对于压缩存储方式，当同时存储了模型和权重，同时又没有源码的情况下，如何load并推理，目前还没有研究出来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们最后做一下总结：</p><ol><li>Pytorch存储Entire Model的时候，有非压缩（旧）与压缩（新）两种方式。这两种方式都会借助于pickle库实现保存。</li><li>pickle库本身在封存类的时候，只会封装类名，其类体和类数据不会跟着实例一起被封存。这导致了Pytorch恢复Entire Model时，必须要有类的定义。</li><li>在恢复Entire Model时，Model类的具体初始化可以没有或者不正确，但是类的位置和名字必须正确，且类必须继承<code>nn.Module</code>。模型在前向推理时会调用<code>forward</code>函数，也就是<code>forward</code>函数必须与真实的<code>forward</code>函数完全一致，否则会报错。</li><li>非压缩的的方式，会将所有Model Class源代码保存下来，而压缩的方式并不会保存这些信息。因此前者可以通过手动恢复Model Class定义的方式来加载模型，而后者不可以。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Pytorch的两种保存模型方式&quot;&gt;&lt;a href=&quot;#Pytorch的两种保存模型方式&quot; class=&quot;headerlink&quot; title=&quot;Pytorch的两种保存模型方式&quot;&gt;&lt;/a&gt;Pytorch的两种保存模型方式&lt;/h2&gt;&lt;p&gt;众所周知，Pytorch存储模型主要有&lt;a href=&quot;https://pytorch.org/tutorials/beginner/saving_loading_models.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两种方式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式一：Save/Load &lt;code&gt;state_dict&lt;/code&gt; (Recommended)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只保存权重：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;torch.save(model.state_dict(), PATH)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/categories/MLFrameworks/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>brew使用</title>
    <link href="https://www.zdaiot.com/Mac/brew%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.zdaiot.com/Mac/brew使用/</id>
    <published>2022-01-08T14:44:44.000Z</published>
    <updated>2022-01-08T14:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="brew安装历史版本"><a href="#brew安装历史版本" class="headerlink" title="brew安装历史版本"></a>brew安装历史版本</h2><p>由于Mac中使用homebrew安装的库都是最新的，有时需要老版本的软件，就很难办。</p><p>在工作中想用opencv3.3，但是使用brew安装的都是3.4，后来查到个方法，就是指定需要安装的opencv.rb文件</p><p>使用brew info opencv 可以看到：（最新的是3.4，我安装的是3.3）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opencv: stable 3.4.0 (bottled)</span><br><span class="line">Open <span class="built_in">source</span> computer vision library</span><br><span class="line">https://opencv.org/</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/opencv/3.3.0_3 (516 files, 123MB) *</span><br><span class="line"> Poured from bottle on 2018-02-24 at 15:28:54</span><br><span class="line">From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/opencv.rb</span><br></pre></td></tr></table></figure><p>上面可以看到opencv是来自<code>Formula/opencv.rb</code>这个文件，只要找打此文件到对应opencv3.3的commit点应该就ok了</p><p>这里首先clone 下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:Homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure><p>进入<code>homebrew-core</code>目录，用<code>git log ./Formula/opencv.rb | less</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 2e4c2bb04c08074723274e618343301038777663</span><br><span class="line">Author: BrewTestBot &lt;brew-test-bot@googlegroups.com&gt;</span><br><span class="line">Date:  Sat Sep 16 11:10:27 2017 +0000</span><br><span class="line">  opencv: update 3.3.0_3 bottle.</span><br></pre></td></tr></table></figure><p>可以发现在这个commit点时opencv3.3，于是git checkout 到这个点，</p><p>然后使用<code>brew install ./Formula/opencv.rb</code>，安装opencv，那么安装的就是opencv3.3了</p><blockquote><p>或者不git clone，只需要得到opencv3.3对应的<code>opencv.rb</code>文件即可</p></blockquote><p>安装时若报错<code>Invalid bottle tag symbol</code>，则删除掉<code>opencv.rb</code>文件中的<code>bottle do</code> block。</p><p>若遇到报错<code>Cask &#39;opencv&#39; is unreadable: wrong constant name</code>好像不用管。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Homebrew/discussions/discussions/2429" target="_blank" rel="noopener">Need #help with installing rust - Invalid bottle tag symbol #2429</a><br><a href="https://www.cnblogs.com/AlwaySleeping/p/8466084.html" target="_blank" rel="noopener">Mac 使用brew安装低版本的软件，如opencv</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;brew安装历史版本&quot;&gt;&lt;a href=&quot;#brew安装历史版本&quot; class=&quot;headerlink&quot; title=&quot;brew安装历史版本&quot;&gt;&lt;/a&gt;brew安装历史版本&lt;/h2&gt;&lt;p&gt;由于Mac中使用homebrew安装的库都是最新的，有时需要老版本的软件，就很难办。&lt;/p&gt;
&lt;p&gt;在工作中想用opencv3.3，但是使用brew安装的都是3.4，后来查到个方法，就是指定需要安装的opencv.rb文件&lt;/p&gt;
&lt;p&gt;使用brew info opencv 可以看到：（最新的是3.4，我安装的是3.3）&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;opencv: stable 3.4.0 (bottled)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Open &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt; computer vision library&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https://opencv.org/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/Cellar/opencv/3.3.0_3 (516 files, 123MB) *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Poured from bottle on 2018-02-24 at 15:28:54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/opencv.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="https://www.zdaiot.com/categories/Mac/"/>
    
    
      <category term="brew" scheme="https://www.zdaiot.com/tags/brew/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch中的仿射变换 (affine_grid)</title>
    <link href="https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%20(affine_grid)/"/>
    <id>https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/</id>
    <published>2021-11-25T03:11:37.000Z</published>
    <updated>2021-11-25T03:11:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>注意这篇文章来源于<a href="https://www.jianshu.com/p/723af68beb2e" target="_blank" rel="noopener">Pytorch中的仿射变换(affine_grid)</a>，感觉写的很好，所以转运过来了。</p><p>在看 pytorch 的 <a href="https://pytorch.org/tutorials/intermediate/spatial_transformer_tutorial.html" target="_blank" rel="noopener">Spatial Transformer Network 教程</a> 时，在 stn 层中的 <code>affine_grid</code> 与 <code>grid_sample</code> 函数上卡住了，不知道这两个函数该如何使用，经过一些实验终于搞清楚了其作用。</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_39422642/article/details/78870629" target="_blank" rel="noopener">详细解读 Spatial Transformer Networks (STN)</a>，该文章与李宏毅的课程一样，推荐听李老师的 STN 这一课，讲的比较清楚；</p></blockquote><p>假设我们有这么一张图片：</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-5285414fb5239b43-163780950525713.png)</p><p>下面我们将通过分别通过手动编码和 pytorch 方式对该图片进行平移、旋转、转置、缩放等操作，这些操作的数学原理在本文中不会详细讲解。</p><p>实现载入图片 (注意，下面的代码都是在 jupyter 中进行)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">"图片文件路径"</span></span><br><span class="line">img_torch = transforms.ToTensor()(Image.open(img_path))</span><br><span class="line"></span><br><span class="line">plt.imshow(img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-8993db99d0b86235-163780952508414.png)</p><h2 id="平移操作"><a href="#平移操作" class="headerlink" title="平移操作"></a>平移操作</h2><h3 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a>普通方式</h3><p>例如我们需要向右平移 50px，向下平移 100px。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">theta = np.array([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">50</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment"># 变换1：可以实现缩放/旋转，这里为 [[1,0],[0,1]] 保存图片不变</span></span><br><span class="line">t1 = theta[:,[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 变换2：可以实现平移</span></span><br><span class="line">t2 = theta[:,[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">_, h, w = img_torch.size()</span><br><span class="line">new_img_torch = torch.zeros_like(img_torch, dtype=torch.float)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(w):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(h):</span><br><span class="line">        pos = np.array([[x], [y]])</span><br><span class="line">        npos = t1@pos+t2</span><br><span class="line">        nx, ny = npos[<span class="number">0</span>][<span class="number">0</span>], npos[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=nx&lt;w <span class="keyword">and</span> <span class="number">0</span>&lt;=ny&lt;h:</span><br><span class="line">            new_img_torch[:,ny,nx] = img_torch[:,y,x]</span><br><span class="line">plt.imshow(new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图片变为：</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-52725f141110d242.png)</p><h3 id="pytorch-方式"><a href="#pytorch-方式" class="headerlink" title="pytorch 方式"></a>pytorch 方式</h3><p>向右移动 0.2，向下移动 0.4：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">theta = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">-0.2</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">-0.4</span>]</span><br><span class="line">], dtype=torch.float)</span><br><span class="line">grid = F.affine_grid(theta.unsqueeze(<span class="number">0</span>), img_torch.unsqueeze(<span class="number">0</span>).size())</span><br><span class="line">output = F.grid_sample(img_torch.unsqueeze(<span class="number">0</span>), grid)</span><br><span class="line">new_img_torch = output[<span class="number">0</span>]</span><br><span class="line">plt.imshow(new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>得到的图片为：</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-1933576668ffe355.png)</p><p>总结：</p><ul><li>要使用 pytorch 的平移操作，只需要两步：<ul><li>创建 grid：<code>grid = torch.nn.functional.affine_grid(theta, size)</code>，其实我们可以通过调节 <code>size</code> 设置所得到的图像的大小 (相当于 resize)；</li><li>grid_sample 进行重采样：<code>outputs = torch.nn.functional.grid_sample(inputs, grid, mode=&#39;bilinear&#39;)</code></li></ul></li><li>theta 的第三列为平移比例，向右为负，向下为负；</li></ul><p>我们通过设置 <code>size</code> 可以将图像 resize：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">theta = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">-0.2</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">-0.4</span>]</span><br><span class="line">], dtype=torch.float)</span><br><span class="line"><span class="comment"># 修改size</span></span><br><span class="line">N, C, W, H = img_torch.unsqueeze(<span class="number">0</span>).size()</span><br><span class="line">size = torch.Size((N, C, W//<span class="number">2</span>, H//<span class="number">3</span>))</span><br><span class="line">grid = F.affine_grid(theta.unsqueeze(<span class="number">0</span>), size)</span><br><span class="line">output = F.grid_sample(img_torch.unsqueeze(<span class="number">0</span>), grid)</span><br><span class="line">new_img_torch = output[<span class="number">0</span>]</span><br><span class="line">plt.imshow(new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-9cb89845b5fd7f46.png)</p><h2 id="缩放操作"><a href="#缩放操作" class="headerlink" title="缩放操作"></a>缩放操作</h2><h3 id="普通方式-1"><a href="#普通方式-1" class="headerlink" title="普通方式"></a>普通方式</h3><p>放大 1 倍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">theta = np.array([</span><br><span class="line">    [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">])</span><br><span class="line">t1 = theta[:,[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">t2 = theta[:,[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">_, h, w = img_torch.size()</span><br><span class="line">new_img_torch = torch.zeros_like(img_torch, dtype=torch.float)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(w):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(h):</span><br><span class="line">        pos = np.array([[x], [y]])</span><br><span class="line">        npos = t1@pos+t2</span><br><span class="line">        nx, ny = npos[<span class="number">0</span>][<span class="number">0</span>], npos[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=nx&lt;w <span class="keyword">and</span> <span class="number">0</span>&lt;=ny&lt;h:</span><br><span class="line">            new_img_torch[:,ny,nx] = img_torch[:,y,x]</span><br><span class="line">plt.imshow(new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-820530e427101dd6.png)</p><p>由于没有使用插值算法，所以中间有很多部分是黑色的。</p><h3 id="pytorch-方式-1"><a href="#pytorch-方式-1" class="headerlink" title="pytorch 方式"></a>pytorch 方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">theta = torch.tensor([</span><br><span class="line">    [<span class="number">0.5</span>, <span class="number">0</span>  , <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>  , <span class="number">0.5</span>, <span class="number">0</span>]</span><br><span class="line">], dtype=torch.float)</span><br><span class="line">grid = F.affine_grid(theta.unsqueeze(<span class="number">0</span>), img_torch.unsqueeze(<span class="number">0</span>).size())</span><br><span class="line">output = F.grid_sample(img_torch.unsqueeze(<span class="number">0</span>), grid)</span><br><span class="line">new_img_torch = output[<span class="number">0</span>]</span><br><span class="line">plt.imshow(new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果为：  </p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-3abddfdb11c78536.png)</p><p>结论：可以看到，</p><p><code>affine_grid</code></p><p>的放大操作是以图片中心为原点的。</p><h2 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h2><h3 id="普通操作"><a href="#普通操作" class="headerlink" title="普通操作"></a>普通操作</h3><p>将图片旋转 30 度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">angle = <span class="number">30</span>*math.pi/<span class="number">180</span></span><br><span class="line">theta = np.array([</span><br><span class="line">    [math.cos(angle),math.sin(-angle),<span class="number">0</span>],</span><br><span class="line">    [math.sin(angle),math.cos(angle) ,<span class="number">0</span>]</span><br><span class="line">])</span><br><span class="line">t1 = theta[:,[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">t2 = theta[:,[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">_, h, w = img_torch.size()</span><br><span class="line">new_img_torch = torch.zeros_like(img_torch, dtype=torch.float)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(w):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(h):</span><br><span class="line">        pos = np.array([[x], [y]])</span><br><span class="line">        npos = t1@pos+t2</span><br><span class="line">        nx, ny = int(npos[<span class="number">0</span>][<span class="number">0</span>]), int(npos[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=nx&lt;w <span class="keyword">and</span> <span class="number">0</span>&lt;=ny&lt;h:</span><br><span class="line">            new_img_torch[:,ny,nx] = img_torch[:,y,x]</span><br><span class="line">plt.imshow(new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-4265aac391f480f6.png)</p><h3 id="pytorch-操作"><a href="#pytorch-操作" class="headerlink" title="pytorch 操作"></a>pytorch 操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">angle = <span class="number">-30</span>*math.pi/<span class="number">180</span></span><br><span class="line">theta = torch.tensor([</span><br><span class="line">    [math.cos(angle),math.sin(-angle),<span class="number">0</span>],</span><br><span class="line">    [math.sin(angle),math.cos(angle) ,<span class="number">0</span>]</span><br><span class="line">], dtype=torch.float)</span><br><span class="line">grid = F.affine_grid(theta.unsqueeze(<span class="number">0</span>), img_torch.unsqueeze(<span class="number">0</span>).size())</span><br><span class="line">output = F.grid_sample(img_torch.unsqueeze(<span class="number">0</span>), grid)</span><br><span class="line">new_img_torch = output[<span class="number">0</span>]</span><br><span class="line">plt.imshow(new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-79097d85e572b88e.png)</p><p>pytorch 以图片中心为原点进行旋转，并且在旋转过程中会发生图片缩放，如果选择角度变为 90°，图片为：</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-48b991eafba74af0.png)</p><h2 id="转置操作"><a href="#转置操作" class="headerlink" title="转置操作"></a>转置操作</h2><h3 id="普通操作-1"><a href="#普通操作-1" class="headerlink" title="普通操作"></a>普通操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">theta = np.array([</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">])</span><br><span class="line">t1 = theta[:,[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">t2 = theta[:,[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">_, h, w = img_torch.size()</span><br><span class="line">new_img_torch = torch.zeros_like(img_torch, dtype=torch.float)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(w):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(h):</span><br><span class="line">        pos = np.array([[x], [y]])</span><br><span class="line">        npos = t1@pos+t2</span><br><span class="line">        nx, ny = npos[<span class="number">0</span>][<span class="number">0</span>], npos[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=nx&lt;w <span class="keyword">and</span> <span class="number">0</span>&lt;=ny&lt;h:</span><br><span class="line">            new_img_torch[:,ny,nx] = img_torch[:,y,x]</span><br><span class="line">plt.imshow(new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-85420eeeea133f87.png)</p><h3 id="pytorch-操作-1"><a href="#pytorch-操作-1" class="headerlink" title="pytorch 操作"></a>pytorch 操作</h3><p>我们可以通过 size 大小，保存图片不被压缩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">theta = torch.tensor([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">], dtype=torch.float)</span><br><span class="line">N, C, H, W = img_torch.unsqueeze(<span class="number">0</span>).size()</span><br><span class="line">grid = F.affine_grid(theta.unsqueeze(<span class="number">0</span>), torch.Size((N, C, W, H)))</span><br><span class="line">output = F.grid_sample(img_torch.unsqueeze(<span class="number">0</span>), grid)</span><br><span class="line">new_img_torch = output[<span class="number">0</span>]</span><br><span class="line">plt.imshow(new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid" alt>/5798456-8bf31af3f4067add.png)</p><p>上面就是 <code>affine_grid</code> + <code>grid_sample</code> 的大致用法，如果你在看 STN 时有相同的用法，希望可以帮助到你。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>需要注意的是，即使是平移操作，再经过平移之后，也会有损失，例如将全红色图案经过平移变换后，得到的结果如下。</p><p><img src="/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/image-20211221171505853.png" alt="image-20211221171505853" style="zoom:50%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">img_path = <span class="string">"4.png"</span></span><br><span class="line">img_ori = Image.open(img_path)</span><br><span class="line">img_ori_np = np.array(img_ori)</span><br><span class="line">img_torch = transforms.ToTensor()(img_ori)</span><br><span class="line"></span><br><span class="line">theta = torch.tensor([</span><br><span class="line">    [<span class="number">1.0</span>, <span class="number">0</span>  , <span class="number">0.0</span>],</span><br><span class="line">    [<span class="number">0</span>  , <span class="number">1.0</span>, <span class="number">-0.2</span>]</span><br><span class="line">], dtype=torch.float)</span><br><span class="line">grid = F.affine_grid(theta.unsqueeze(<span class="number">0</span>), img_torch.unsqueeze(<span class="number">0</span>).size())</span><br><span class="line">output = F.grid_sample(img_torch.unsqueeze(<span class="number">0</span>), grid)</span><br><span class="line">new_img_torch = output[<span class="number">0</span>]</span><br><span class="line">new_img = new_img_torch.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)*<span class="number">255</span></span><br><span class="line">unique,count = np.unique(new_img, return_counts=<span class="literal">True</span>)</span><br><span class="line">data_count = dict(zip(unique,count))</span><br><span class="line">print(data_count)</span><br><span class="line"></span><br><span class="line">plt.imshow(new_img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0.0: 4352640, 0.0037693689: 1, 0.0037693977: 1919, 254.99805: 972, 255.0: 1865268&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注意这篇文章来源于&lt;a href=&quot;https://www.jianshu.com/p/723af68beb2e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pytorch中的仿射变换(affine_grid)&lt;/a&gt;，感觉写的很好，所以转运过来了。&lt;/p&gt;
&lt;p&gt;在看 pytorch 的 &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/spatial_transformer_tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spatial Transformer Network 教程&lt;/a&gt; 时，在 stn 层中的 &lt;code&gt;affine_grid&lt;/code&gt; 与 &lt;code&gt;grid_sample&lt;/code&gt; 函数上卡住了，不知道这两个函数该如何使用，经过一些实验终于搞清楚了其作用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/qq_39422642/article/details/78870629&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;详细解读 Spatial Transformer Networks (STN)&lt;/a&gt;，该文章与李宏毅的课程一样，推荐听李老师的 STN 这一课，讲的比较清楚；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们有这么一张图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/MLFrameworks/Pytorch/Pytorch中的仿射变换 (affine_grid)/Pytorch中的仿射变换 (affine_grid&quot; alt&gt;/5798456-5285414fb5239b43-163780950525713.png)&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/categories/MLFrameworks/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/tags/Pytorch/"/>
    
      <category term="affine_grid" scheme="https://www.zdaiot.com/tags/affine-grid/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Lab远程环境搭建</title>
    <link href="https://www.zdaiot.com/Python/%E8%B5%B7%E6%AD%A5/Jupyter%20Lab%E8%BF%9C%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://www.zdaiot.com/Python/起步/Jupyter Lab远程环境搭建/</id>
    <published>2021-11-23T08:04:57.000Z</published>
    <updated>2021-11-23T08:04:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2><p>首先配置<code>~/.jupyter/jupyter_lab_config.py</code>，内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c.LabApp.allow_origin = <span class="string">'*'</span></span><br><span class="line">c.ServerApp.ip = <span class="string">'0.0.0.0'</span></span><br><span class="line">c.LabApp.allow_remote_access = True</span><br><span class="line">c.LabApp.allow_root = True</span><br><span class="line">c.LabApp.base_url = <span class="string">'/jupyter'</span></span><br><span class="line">c.LabApp.open_browser = False</span><br><span class="line">c.LabApp.token = <span class="string">"***********************"</span></span><br><span class="line">c.LabApp.port = 80</span><br><span class="line">c.LabApp.terminals_enabled = True</span><br><span class="line">c.LabApp.tornado_settings = &#123;<span class="string">'shell_command'</span>: [<span class="string">'/usr/bin/zsh'</span>]&#125;</span><br></pre></td></tr></table></figure><p>其中将<code>c.LabApp.token</code>为密码，当你登陆Jupyter Lab的时候需要使用。</p><blockquote><p><code>c.LabApp.tornado_settings</code>设置不是必须的，只是方便使用zsh时，可以通过<a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">配置</a>让终端可以好看点。下面的<code>Environment</code>同理。</p></blockquote><p>接着设置<code>/usr/lib/systemd/system/jupyter.service</code>，内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Jupyter Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">WorkDirectory=/data</span><br><span class="line">Environment=<span class="string">"SHELL=/usr/bin/zsh"</span></span><br><span class="line">ExecStart=/dockerdata/anaconda3/bin/jupyter-lab --config=/root/.jupyter/jupyter_lab_config.py</span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>其中<code>WorkDirectory</code>为默认工作路径；<code>ExecStart</code>后面的<code>/dockerdata/anaconda3/bin/jupyter-lab</code>需要替换成自己<code>jupyter-lab</code>的路径。</p><p>设置完毕之后，开启服务并设置为开机自启。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start jupyter.service</span><br><span class="line">systemctl <span class="built_in">enable</span> jupyter.service</span><br></pre></td></tr></table></figure><h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><p>打开浏览器，输入<code>http://yourip/jupyter</code>，即可远程使用<code>jupyter lab</code>。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>若遇到无法访问的情况，可以考虑在服务器端采用如下方式看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status jupyter.service</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dockerdata/anaconda3/bin/jupyter-lab --config=/root/.jupyter/jupyter_lab_config.py</span><br></pre></td></tr></table></figure><p>PS：keyunluo教我的方法，我整理成了文档，方便大家使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务器端配置&quot;&gt;&lt;a href=&quot;#服务器端配置&quot; class=&quot;headerlink&quot; title=&quot;服务器端配置&quot;&gt;&lt;/a&gt;服务器端配置&lt;/h2&gt;&lt;p&gt;首先配置&lt;code&gt;~/.jupyter/jupyter_lab_config.py&lt;/code&gt;，内容为：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c.LabApp.allow_origin = &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.ServerApp.ip = &lt;span class=&quot;string&quot;&gt;&#39;0.0.0.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.LabApp.allow_remote_access = True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.LabApp.allow_root = True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.LabApp.base_url = &lt;span class=&quot;string&quot;&gt;&#39;/jupyter&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.LabApp.open_browser = False&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.LabApp.token = &lt;span class=&quot;string&quot;&gt;&quot;***********************&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.LabApp.port = 80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.LabApp.terminals_enabled = True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.LabApp.tornado_settings = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;shell_command&#39;&lt;/span&gt;: [&lt;span class=&quot;string&quot;&gt;&#39;/usr/bin/zsh&#39;&lt;/span&gt;]&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中将&lt;code&gt;c.LabApp.token&lt;/code&gt;为密码，当你登陆Jupyter Lab的时候需要使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;c.LabApp.tornado_settings&lt;/code&gt;设置不是必须的，只是方便使用zsh时，可以通过&lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;配置&lt;/a&gt;让终端可以好看点。下面的&lt;code&gt;Environment&lt;/code&gt;同理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.zdaiot.com/categories/Python/"/>
    
      <category term="起步" scheme="https://www.zdaiot.com/categories/Python/%E8%B5%B7%E6%AD%A5/"/>
    
    
      <category term="Conda" scheme="https://www.zdaiot.com/tags/Conda/"/>
    
  </entry>
  
  <entry>
    <title>GAN简介</title>
    <link href="https://www.zdaiot.com/MachineLearning/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/GAN%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.zdaiot.com/MachineLearning/神经网络/GAN简介/</id>
    <published>2021-08-09T06:07:16.000Z</published>
    <updated>2021-08-09T06:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>生成对抗网络（GAN）由2个重要的部分构成：</p><ol><li><strong>生成器(Generator</strong>)：通过机器生成数据（大部分情况下是图像），目的是“骗过”判别器</li><li><strong>判别器(Discriminator</strong>)：判断这张图像是真实的还是机器生成的，目的是找出生成器做的“假数据”</li></ol><p><img src="/MachineLearning/神经网络/GAN简介/2019-07-16-2bf-1.png" alt="生成对抗网络GANs由生成器和判别器构成" style="zoom: 50%;"></p><p>要想理解GAN，直接看损失函数是一个特别好的方法。如下所示，D想办法增加V的值，G想办法减小V的值，两者在相互的对抗。关于V的收敛性证明可以在<a href="https://zhuanlan.zhihu.com/p/28853704" target="_blank" rel="noopener">GAN入门理解及公式推导</a>这里找到。</p><p><img src="/MachineLearning/神经网络/GAN简介/v2-c93b874f77316d54f01aa653f8c24a86_b.jpg" alt="img" style="zoom: 80%;"></p><p>下面介绍一下详细过程：</p><p><strong>第一阶段：固定「判别器D」，训练「生成器G」</strong></p><p>使用一个较好的判别器D，让一个「生成器G」不断生成“假数据”，然后给这个「判别器D」去判断。一开始，「生成器G」还很弱，所以很容易被揪出来。但是随着不断的训练，「生成器G」技能不断提升，最终骗过了「判别器D」。到了这个时候，「判别器D」基本属于瞎猜的状态，判断是否为假数据的概率为50%。</p><p><img src="/MachineLearning/神经网络/GAN简介/2019-07-16-g-tg.png" alt="固定判别器，训练生成器" style="zoom:50%;"></p><p>从损失函数的角度理解，固定D训练G ，它是希望V的值越小越好，让D分不开真假数据。如下所示，目标函数的第一项不包含G，是常数，所以可以直接忽略 不受影响。</p><p><img src="/MachineLearning/神经网络/GAN简介/v2-08a48c4e9da837e5f3bf375bef5d8007_b.jpg" alt="img" style="zoom:80%;"></p><p>对于G来说，它希望D在划分它的时候能够越大越好，即希望被D划分1(真实数据)。</p><p><img src="/MachineLearning/神经网络/GAN简介/v2-dfa0c29336f15c4e9f047d8d1dae50f1_b.jpg" alt="img" style="zoom:80%;"></p><p>第二个式子和第一个式子等价。在训练的时候，第二个式子训练效果比较好 常用第二个式子的形式。</p><p><strong>第二阶段：固定「生成器G」，训练「判别器D」</strong></p><p>当通过了第一阶段，继续训练「生成器G」就没有意义了。这个时候我们固定「生成器G」，然后开始训练「判别器D」。「判别器D」通过不断训练，提高了自己的鉴别能力，最终它可以准确的判断出所有的假图片。到了这个时候，「生成器G」已经无法骗过「判别器D」。</p><p><img src="/MachineLearning/神经网络/GAN简介/2019-07-16-d-tg-1.png" alt="固定生成器，训练判别器" style="zoom:50%;"></p><p>从损失函数的角度理解，训练D的目的是希望这个式子的值越大越好。真实数据希望被D分成1，生成数据希望被分成0。</p><p><img src="/MachineLearning/神经网络/GAN简介/v2-474547ca59dd2737f0c4a8833f4ffcde_b.png" alt="img" style="zoom:80%;"></p><p>第一项，如果有一个真实数据被分错，那么log(D(x))&lt;&lt;0,期望会变成负无穷大。</p><p>第二项，如果被分错成1的话，第二项也会是负无穷大。</p><p>很多被分错的话，就会出现很多负无穷，那样可以优化的空间还有很多。可以修正参数，使V的数值增大。</p><p><strong>循环阶段一和阶段二</strong></p><p>通过不断的循环，「生成器G」和「判别器D」的能力都越来越强。最终我们得到了一个效果非常好的「生成器G」，我们就可以用它来生成想要的图片了。</p><p><img src="/MachineLearning/神经网络/GAN简介/2019-07-16-xh.png" alt="循环训练，2遍越来越强" style="zoom:50%;"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>3个优势</strong></p><ol><li>能更好建模数据分布（图像更锐利、清晰）</li><li>理论上，GANs 能训练任何一种生成器网络。其他的框架需要生成器网络有一些特定的函数形式，比如输出层是高斯的。</li><li>无需利用马尔科夫链反复采样，无需在学习过程中进行推断，没有复杂的变分下界，避开近似计算棘手的概率的难题。</li></ol><p><strong>2个缺陷</strong></p><ol><li>难训练，不稳定。生成器和判别器之间需要很好的同步，但是在实际训练中很容易D收敛，G发散。D/G 的训练需要精心的设计。</li><li>模式缺失（Mode Collapse）问题。GANs的学习过程可能出现模式缺失，生成器开始退化，总是生成同样的样本点，无法继续学习。</li></ol><p>扩展阅读：《<a href="https://easyai.tech/blog/gan-why-it-is-so-hard-to-train/" target="_blank" rel="noopener">为什么训练生成对抗网络如此困难？</a>》阅读这篇文章对数学要求很高。</p><h2 id="CycleGAN"><a href="#CycleGAN" class="headerlink" title="CycleGAN"></a>CycleGAN</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通常的GAN的设计思路从信息流的角度出发是单向的，如下图所示：使用Generator从A产生一个假的B，然后使用Determinator判断这个假的B是否属于B集合，并将这个信息反馈至Generator，然后通过逐次分别提高Generator与Discriminator的能力以期达到使Generator能以假乱真的能力，这样的设计思路在一般<strong>有匹配图像的情况</strong>下是合理的，例如Pix2Pix模型的关键是提供了在这两个域中有相同数据的训练样本。</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107202407705.png" alt="img"></p><p>然而若两个域内没有相同数据的训练样本，也就是没有成对样本，则需要借助于CycleGAN。成对样本与非成对样本的示意图如下所示：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107201615878.png" alt="img" style="zoom:67%;"></p><p>可以实现无配对的两个图片集的训练是CycleGAN与Pixel2Pixel相比的一个典型优点，但仍然需要通过训练创建这个映射来确保输入图像和生成图像间存在有意义的关联，即输入输出共享一些特征。</p><p>简而言之，该模型通过从域DA获取输入图像，该输入图像被传递到第一个生成器GeneratorA→B，其任务是将来自域DA的给定图像转换到目标域DB中的图像。然后这个新生成的图像被传递到另一个生成器GeneratorB→A，其任务是在原始域DA转换回图像CyclicA，这里可与自动编码器作对比。这个输出图像必须与原始输入图像相似，用来定义非配对数据集中原来不存在的有意义映射。</p><p>量子位给出的CycleGAN的示意图如下：</p><p><img src="/MachineLearning/神经网络/GAN简介/webp" alt="img" style="zoom: 67%;"></p><p><img src="/MachineLearning/神经网络/GAN简介/webp-162849242832012" alt="img" style="zoom:67%;"></p><blockquote><p>上图中之所以是<code>input_A</code>参与D_A损失函数的计算，可以看具体的损失函数。</p></blockquote><p>论文的设计示意图如下：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107204154215.png" alt="img" style="zoom:67%;"></p><p>李宏毅的一张ppt Slide给出的下面的示意图：</p><p><img src="/MachineLearning/神经网络/GAN简介/20.png" alt="img" style="zoom: 80%;"></p><p>上面的这三个示意图可以结合这一块理解，感觉画的都不错。</p><p>GAN个人感觉还是结合具体的损失函数比较好理解。</p><p>Cycle-GAN的loss总体来说可以分为两部分，一部分是GAN loss，一部分是Cycle loss：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107205953410.png" alt="img" style="zoom:67%;"></p><p>具体每一部分的形式为：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107210307463.png" alt="img" style="zoom:67%;"></p><p>上面这个部分是GAN的损失。从理论上讲，对抗训练可以学习和产生与目标域Y和X相同分布的输出，即映射G和F。然而，在足够大的样本容量下，<strong>网络可以将相同的输入图像集合映射到目标域中图像的任何随机排列</strong>，其中任何学习的映射可以归纳出与目标分布匹配的输出分布。因此，<strong>单独的对抗损失Loss不能保证学习函数可以将单个输入$X_i$​映射到期望的输出$Y_i$​​​。</strong></p><p>因此，作者又定义了一个cycle consistency loss，也就是说把X生成的Y再通过另一个生成器还原到X域，并且我们希望还原的X和原来的输入X尽可能相似。 也就是$G(F(x)) ≈ x$，同理 $F(G(y)) ≈ y$，因此这个循环一致性损失如下：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107210307177.png" alt="img" style="zoom:67%;"></p><p>需要注意的是论文中为了保证训练出的模型具有较强的稳定性，将基于前人的成果将GAN loss变为非负的似然计算改为最小平方loss，也就是上面的公式(1)改为了下面的式子：</p><p><img src="/MachineLearning/神经网络/GAN简介/webp-162849310424419" alt="img" style="zoom:67%;"></p><p>另外，作者在训练过程中，为了保证稳定性，还使用了GAN训练的“记忆”技术，即在更新Discriminator时使用先期存储的数据而非刚刚由Generator产生数据。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>CycleGAN实现的是一类图片到另一类图片的转化，也就是图片域的转变， 对于这类问题pix2pix是一种不错的方法，但是pix2pix训练时需要成对的训练样本，也就是比如你要训练图片风景从白天到黑夜的转变，那么你的训练集就是各种风景图片的白天照片以及其对应的黑夜照片，必须一一对应。那么CycleGAN则不需要， 所以如果用CycleGAN来做这个问题，只需要收集一些白天的风景图片和一些黑夜的风景图片即可，不需要是同一种风景，不需要一一对应。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://easyai.tech/ai-definition/gan/" target="_blank" rel="noopener">生成对抗网络 – Generative Adversarial Networks | GAN</a><br><a href="https://zhuanlan.zhihu.com/p/28853704" target="_blank" rel="noopener">GAN入门理解及公式推导</a><br><a href="https://cryer.github.io/2018/02/cycleGAN/" target="_blank" rel="noopener">CycleGAN介绍</a><br><a href="https://blog.csdn.net/xiaoxifei/article/details/83830842" target="_blank" rel="noopener">Cycle-GAN 模型介绍——原理简介</a><br><a href="https://www.jianshu.com/p/64bf39804c80" target="_blank" rel="noopener">CycleGAN原理及实验（TensorFlow）</a><br><a href="https://zhuanlan.zhihu.com/p/27145954" target="_blank" rel="noopener">带你理解CycleGAN，并用TensorFlow轻松实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GAN&quot;&gt;&lt;a href=&quot;#GAN&quot; class=&quot;headerlink&quot; title=&quot;GAN&quot;&gt;&lt;/a&gt;GAN&lt;/h2&gt;&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;生成对抗网络（GAN）由2个重要的部分构成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;生成器(Generator&lt;/strong&gt;)：通过机器生成数据（大部分情况下是图像），目的是“骗过”判别器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判别器(Discriminator&lt;/strong&gt;)：判断这张图像是真实的还是机器生成的，目的是找出生成器做的“假数据”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/MachineLearning/神经网络/GAN简介/2019-07-16-2bf-1.png&quot; alt=&quot;生成对抗网络GANs由生成器和判别器构成&quot; style=&quot;zoom: 50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://www.zdaiot.com/categories/MachineLearning/"/>
    
      <category term="神经网络" scheme="https://www.zdaiot.com/categories/MachineLearning/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="GAN" scheme="https://www.zdaiot.com/tags/GAN/"/>
    
      <category term="CycleGAN" scheme="https://www.zdaiot.com/tags/CycleGAN/"/>
    
  </entry>
  
  <entry>
    <title>Office365与VisioPro共存</title>
    <link href="https://www.zdaiot.com/Tools/Md&amp;Office/Office365%E4%B8%8EVisioPro%E5%85%B1%E5%AD%98/"/>
    <id>https://www.zdaiot.com/Tools/Md&amp;Office/Office365与VisioPro共存/</id>
    <published>2021-03-09T14:33:36.000Z</published>
    <updated>2021-03-09T14:33:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注意：这种方法会卸载现有的Office365，具体原因未知，所以暂时不可用。</strong></p><p>现在的电脑有的预装office365，但是此时安装visio会报错。可以采用如下方式解决。</p><p>首先从mdsn中下载最新的VisioPro2016的安装镜像，<a href="ed2k://|file|cn_visio_professional_2016_x86_x64_dvd_6970929.iso|2588262400|52A997F3AF4E40B896C8E4677CF10E90|/" target="_blank" rel="noopener">下载地址</a>。</p><p>下载之后第一步要把镜像文件加载至光驱，比如加载到了<code>E:\</code>。正常情况下，点击 setup 会直接进入 Visio 程序的安装，但是现在不能够进行正常的安装，在任务管理器也不会看见进程开启</p><p>第二步 到 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=49117" target="_blank" rel="noopener">Office 2016 Deployment Tool </a>下载文件，打开下载到的部署工具安装文件，选择任意路径解压；解压后路径内有一个 Setup.exe 文件和若干个配置文件；新建配置文件，例如命名为 configuration.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Add</span> <span class="attr">SourcePath</span>=<span class="string">"E:\"</span> <span class="attr">OfficeClientEdition</span>=<span class="string">"64"</span> <span class="attr">Channel</span>=<span class="string">"Current"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- &lt;Product ID="VisioProXVolume" PIDKEY="69WXN-MBYV6-22PQG-3WGHK-RM6XC"&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Product</span> <span class="attr">ID</span>=<span class="string">'VisioProRetail'</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Language</span> <span class="attr">ID</span>=<span class="string">"zh-cn"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">Product</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Add</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在当前路径下运行<code>setup.exe/configure configuration.xml</code>，完成安装。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zchwei.com/post/2019/8/28/office365-proplus-visiopro-install" target="_blank" rel="noopener">Office 365 ProPlus &amp; VisioPro 安装冲突问题解决</a><br><a href="https://blog.iifatree.com/2020/02/17/Office-click-to-run-and-visio-2016/" target="_blank" rel="noopener">即点即用 Office 365 与 Visio 2016 共存问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;注意：这种方法会卸载现有的Office365，具体原因未知，所以暂时不可用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在的电脑有的预装office365，但是此时安装visio会报错。可以采用如下方式解决。&lt;/p&gt;
&lt;p&gt;首先从mdsn中下载最新的VisioPro2016的安装镜像，&lt;a href=&quot;ed2k://|file|cn_visio_professional_2016_x86_x64_dvd_6970929.iso|2588262400|52A997F3AF4E40B896C8E4677CF10E90|/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下载之后第一步要把镜像文件加载至光驱，比如加载到了&lt;code&gt;E:\&lt;/code&gt;。正常情况下，点击 setup 会直接进入 Visio 程序的安装，但是现在不能够进行正常的安装，在任务管理器也不会看见进程开启&lt;/p&gt;
&lt;p&gt;第二步 到 &lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=49117&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Office 2016 Deployment Tool &lt;/a&gt;下载文件，打开下载到的部署工具安装文件，选择任意路径解压；解压后路径内有一个 Setup.exe 文件和若干个配置文件；新建配置文件，例如命名为 configuration.xml，内容如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="Md&amp;Office" scheme="https://www.zdaiot.com/categories/Tools/Md-Office/"/>
    
    
      <category term="Office365" scheme="https://www.zdaiot.com/tags/Office365/"/>
    
      <category term="VisioPro" scheme="https://www.zdaiot.com/tags/VisioPro/"/>
    
  </entry>
  
  <entry>
    <title>git合并多个仓库</title>
    <link href="https://www.zdaiot.com/Tools/GIt/git%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E4%BB%93%E5%BA%93/"/>
    <id>https://www.zdaiot.com/Tools/GIt/git合并多个仓库/</id>
    <published>2020-11-27T09:02:14.000Z</published>
    <updated>2020-11-27T09:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前因为考虑不得当，没有采用分支的方法管理同一个工程。在github上建立了多个仓库，强迫症发作了，想合并这些仓库到同一个git中，并保留所有的git记录。具体来说，假设我们有如下几个仓库：</p><ol><li>OldA：要合并的仓库A</li><li>OldB：要合并的仓库B</li><li>C：将OldA和OldB两个仓库合并到该git中</li></ol><p>具体操作过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mkdir C</span><br><span class="line"><span class="built_in">cd</span> C</span><br><span class="line"><span class="comment"># Assume the current directory is where we want the new repository to be created, Create the new repository</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># Before we do a merge, we have to have an initial commit, so we’ll make a dummy commit</span></span><br><span class="line">dir &gt; deleteme.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"Initial dummy commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a remote for and fetch the old repo</span></span><br><span class="line">git remote add -f old_a &lt;OldA repo URL&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Merge the files from old_a/master into new/master</span></span><br><span class="line">git merge old_a/master</span><br><span class="line"><span class="comment"># if occurs "fatal: refusing to merge unrelated histories"</span></span><br><span class="line">git merge old_a/master --allow-unrelated-histories</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clean up our dummy file because we don’t need it any more</span></span><br><span class="line">git rm .\deleteme.txt</span><br><span class="line">git commit -m <span class="string">"Clean up initial file"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Move the old_a repo files and folders into a subdirectory so they don’t collide with the other repo coming later</span></span><br><span class="line">mkdir old_a</span><br><span class="line">dir -exclude old_a | %&#123;git mv <span class="variable">$_</span>.Name old_a&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commit the move</span></span><br><span class="line">git commit -m <span class="string">"Move old_a files into subdir"</span></span><br></pre></td></tr></table></figure><p>接着合并其余仓库，如OldB</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Do the same thing for old_b</span></span><br><span class="line">git remote add -f old_b &lt;OldB repo URL&gt;</span><br><span class="line">git merge old_b/master</span><br><span class="line"><span class="comment"># if occurs "fatal: refusing to merge unrelated histories"</span></span><br><span class="line">git merge old_b/master --allow-unrelated-histories</span><br><span class="line">mkdir old_b</span><br><span class="line">dir -exclude old_a,old_b | %&#123;git mv <span class="variable">$_</span>.Name old_b&#125;</span><br><span class="line">git commit -m <span class="string">"Move old_b files into subdir"</span></span><br></pre></td></tr></table></figure><p>这个时候仓库A和B都合并到了仓库C中，并且保留了所有的git记录。此时若想查看某个文件的提交记录，需要使用<code>git log --follow old_b/readme.md</code>。</p><p>若<code>old_a</code>仓库有多个分支，则可以采用如下方式继续合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bring over a feature branch from one of the old repos</span></span><br><span class="line">git checkout -b feature-in-progress</span><br><span class="line">git merge -s recursive -Xsubtree=old_a old_a/feature-in-progress</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://saintgimp.org/2013/01/22/merging-two-git-repositories-into-one-repository-without-losing-file-history/" target="_blank" rel="noopener">Merging Two Git Repositories Into One Repository Without Losing File History</a><br><a href="https://medium.com/altcampus/how-to-merge-two-or-multiple-git-repositories-into-one-9f8a5209913f" target="_blank" rel="noopener">How to merge two or multiple git repositories into one</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前因为考虑不得当，没有采用分支的方法管理同一个工程。在github上建立了多个仓库，强迫症发作了，想合并这些仓库到同一个git中，并保留所有的git记录。具体来说，假设我们有如下几个仓库：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OldA：要合并的仓库A&lt;/li&gt;
&lt;li&gt;OldB：要合并的仓库B&lt;/li&gt;
&lt;li&gt;C：将OldA和OldB两个仓库合并到该git中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体操作过程如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Assume the current directory is where we want the new repository to be created, Create the new repository&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Before we do a merge, we have to have an initial commit, so we’ll make a dummy commit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dir &amp;gt; deleteme.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;Initial dummy commit&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Add a remote for and fetch the old repo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote add -f old_a &amp;lt;OldA repo URL&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Merge the files from old_a/master into new/master&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git merge old_a/master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# if occurs &quot;fatal: refusing to merge unrelated histories&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git merge old_a/master --allow-unrelated-histories&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Clean up our dummy file because we don’t need it any more&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rm .\deleteme.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;Clean up initial file&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Move the old_a repo files and folders into a subdirectory so they don’t collide with the other repo coming later&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir old_a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dir -exclude old_a | %&amp;#123;git mv &lt;span class=&quot;variable&quot;&gt;$_&lt;/span&gt;.Name old_a&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Commit the move&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;Move old_a files into subdir&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接着合并其余仓库，如OldB&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="GIt" scheme="https://www.zdaiot.com/categories/Tools/GIt/"/>
    
    
      <category term="github" scheme="https://www.zdaiot.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>VIM入门</title>
    <link href="https://www.zdaiot.com/Tools/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/VIM%E5%85%A5%E9%97%A8/"/>
    <id>https://www.zdaiot.com/Tools/杂七杂八/VIM入门/</id>
    <published>2020-10-17T03:51:16.000Z</published>
    <updated>2020-10-17T03:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Vim大概有如下几个版本：vim、vim-athena、vim-gnome、vim-gtk、vim-gtk3、vim-noxvim-tiny。它们中有编译进最小功能的 Vim 包（vim-tiny），有较全功能的文本界面 Vim 包（vim-nox），有适用于老的 X-Window 界面的版本（vim-athena），有适用于 KDE 环境的 GTK2 版本（vim-gtk），等等。</p><p>对于Ubuntu而言，一般情况下<code>sudo apt install vim-gtk3</code>即可。在 Ubuntu 上，vim 和 gvim 都是指向同一个应用程序的符号链接，且 <code>gvim</code> 的执行效果和 <code>vim -g</code> 相同。所以要启动图像化界面的<code>vim</code>，直接在终端执行<code>gvim</code>即可。</p><p>另外，若使用远程软件连接到Linux机器上，需要注意远程终端软件的远程字符集（如 PuTTY 中的“Windows &gt; Translation &gt; Remote character set”）应当设置成 UTF-8。</p><p>然后，还可以安装中文版本的帮助文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim</span><br><span class="line">mkdir -p pack/my/start</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/yianwillis/vimcdoc.git pack/my/start/vimcdoc</span><br></pre></td></tr></table></figure><p>当然，也可以在这个 <a href="https://github.com/yianwillis/vimcdoc" target="_blank" rel="noopener">Vim 中文文档计划</a> 的<a href="https://github.com/yianwillis/vimcdoc/releases" target="_blank" rel="noopener">下载页面</a>下载 tar 包，然后自行解压到 <code>~/.vim/pack/my/start</code> 目录下（或 Windows 用户目录下的 <code>vimfiles\pack\my\start</code> 目录下）。</p><p>最后，可以使用<code>LANG=zh_CN.UTF-8 vimtutor</code>命令查看Vim教程，可以作为Vim的入门教程。</p><h2 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h2><p>Vim 有以下四种主要模式：</p><ol><li>正常（normal）模式（也称为普通模式），缺省的编辑模式；<strong>如果不加特殊说明，一般提到的命令都直接在正常模式下输入</strong>；在任何其他模式中，都可以通过键盘上的 Esc 键回到正常模式。</li><li>插入（insert）模式，输入文本时使用；比如在正常模式下键入 i（insert）或 a（append）即可进入插入模式。</li><li>可视（visual）模式，用于选定文本块；教程中已经提到可以用键 v（小写）来按字符选定，Vim 里也提供其他不同的选定方法，包括按行和按列块。</li><li>命令行（command-line）模式，用于执行较长、较复杂的命令；在正常模式下键入冒号（:）即可进入该模式；使用斜杠（/）和问号（?）开始搜索也算作命令行模式。命令行模式下的命令要输入回车键（Enter）才算完成。</li></ol><blockquote><p>记住正常模式就是正常情况下你应当处于的模式。</p></blockquote><h2 id="Vim的键描述体例"><a href="#Vim的键描述体例" class="headerlink" title="Vim的键描述体例"></a>Vim的键描述体例</h2><p>下面的教程将会使用Vim中的标准键描述方式来讲解。Vim一般使用尖括号来描述特殊的输入序列。</p><div class="table-container"><table><thead><tr><th style="text-align:center">尖括号</th><th style="text-align:center">表示</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><esc></esc></td><td style="text-align:center">Esc 键</td><td style="text-align:center">⎋</td></tr><tr><td style="text-align:center"><cr></cr></td><td style="text-align:center">回车键</td><td style="text-align:center">↩</td></tr><tr><td style="text-align:center"><space></space></td><td style="text-align:center">空格键</td><td style="text-align:center">␣</td></tr><tr><td style="text-align:center"><tab></tab></td><td style="text-align:center">Tab 键</td><td style="text-align:center">⇥</td></tr><tr><td style="text-align:center"><bs></bs></td><td style="text-align:center">退格键</td><td style="text-align:center">⌫</td></tr><tr><td style="text-align:center"><del></del></td><td style="text-align:center">删除键</td><td style="text-align:center">⌦</td></tr><tr><td style="text-align:center"><lt></lt></td><td style="text-align:center">&lt;</td><td style="text-align:center">&lt;</td></tr><tr><td style="text-align:center"><up></up></td><td style="text-align:center">光标上移键</td><td style="text-align:center">⇡</td></tr><tr><td style="text-align:center"><down></down></td><td style="text-align:center">光标下移键</td><td style="text-align:center">⇣</td></tr><tr><td style="text-align:center"><left></left></td><td style="text-align:center">光标左移键</td><td style="text-align:center">⇠</td></tr><tr><td style="text-align:center"><right></right></td><td style="text-align:center">光标右移键</td><td style="text-align:center">⇢</td></tr><tr><td style="text-align:center"><pageup></pageup></td><td style="text-align:center">Page Up 键</td><td style="text-align:center">⇞</td></tr><tr><td style="text-align:center"><pagedown></pagedown></td><td style="text-align:center">Page Down 键</td><td style="text-align:center">⇟</td></tr><tr><td style="text-align:center"><home></home></td><td style="text-align:center">Home 键</td><td style="text-align:center">↖</td></tr><tr><td style="text-align:center"><end></end></td><td style="text-align:center">End 键</td><td style="text-align:center">↘</td></tr><tr><td style="text-align:center"><f1> - <f12></f12></f1></td><td style="text-align:center">功能键 1 到 12</td><td style="text-align:center">“F1”到“F12”</td></tr><tr><td style="text-align:center"><s-…></s-…></td><td style="text-align:center">Shift 组合键</td><td style="text-align:center">⇧</td></tr><tr><td style="text-align:center"><c-…></c-…></td><td style="text-align:center">Control 组合键</td><td style="text-align:center">⌃</td></tr><tr><td style="text-align:center"><m-…></m-…></td><td style="text-align:center">Alt 组合键</td><td style="text-align:center">⌥</td></tr><tr><td style="text-align:center"><d-…></d-…></td><td style="text-align:center">Command 组合键</td><td style="text-align:center">⌘</td></tr></tbody></table></div><p>例如前面提到的 Esc、Enter、v、V 和 Ctrl-V，按我们现在的描述惯例，以后就会写成 <code>&lt;Esc&gt;、&lt;CR&gt;、v、V 和 &lt;C-V&gt;</code>。</p><p>需要强调的一点是，<strong>对“&lt;”的特殊解释仅在描述输入时生效</strong>。在描述命令行（以<code>:、/、?、$</code>开头）和代码时，写<code>“&lt;CR&gt;”</code>仍表示四个字符，而非回车键。对于命令行详细解释如下：</p><ol><li>若描述的命令行首是<code>“:”</code>，表示这是一个输入 <code>:</code> 开始的 Vim 命令行模式命令（以回车键结束）</li><li>如果行首是<code>“/”</code>或<code>“?”</code>，表示这是一个输入 <code>/</code> 或 <code>?</code> 开始的搜索命令（以回车键结束）</li><li>如果行首是<code>“$”</code>，表示这是一个在linux shell 命令行上输入的命令（以回车键结束），<code>“$”</code>（和后面的空格）不是命令的一部分，通常后续行也不是命令的一部分，除非行尾有<code>“\”</code>或<code>“^”</code>字符，或行首有<code>“$”</code>字符。</li></ol><p>例如<code>“:set ft?&lt;CR&gt;”</code>表示在Vim里面输入<code>:set :ft</code>然后回车；<code>“which vim&lt;CR&gt;”</code>表示在Linux shell中输入<code>which vim</code>然后回车。</p><p>此外，当用<a href="https://yianwillis.github.io/vimcdoc/doc/help.html" target="_blank" rel="noopener"><code>“:help”</code></a>描述帮助命令时，你不仅可以在 Vim 里输入这个命令来得到帮助，也可以点击这个帮助的链接，直接在线查看相应的中文帮助页面。</p><h2 id="Vim常用命令"><a href="#Vim常用命令" class="headerlink" title="Vim常用命令"></a>Vim常用命令</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>Vim 里的基本光标移动是通过 <code>h、j、k、l</code> 四个键实现的。（分别是左移、上移、上移、右移）。不过，标准的光标移动键（键盘上的上下左右键）可以在任何模式下使用，而这四个键并不能在插入模式下使用，因此，它们并不构成完全的替代关系。</p><p>跳转到行首：<code>0</code>；跳转到行尾：<code>$</code>；跳转到行首的第一个非空白字符：<code>^</code>；<code>w/W</code>以单词为单位的跳转，小写和大写命令的区别在于，小写的跟编程语言里的标识符的规则相似，认为一个单词是由字母、数字、下划线组成的（不严格的说法），而大写的命令则认为非空格字符都是单词（例如<code>hello world</code>，当光标停在了<code>h</code>上，按下<code>w</code>键会跳转到<code>w</code>字母上，这是因为空格不属于后面的<code>world</code>单词）。</p><p><code>cw</code>删除一个单词（<code>c5w</code>删除5个单词）；<code>f（find）、t（till）</code>找到下一个（如果在输入它们之前先输入数字 n 的话，那就是下面第 n 个）紧接着输入的字符。两者的区别是，f 会包含这个字符，而 t 不会包含这个字符（例如<code>fi</code>则找到下一个<code>i</code>的位置）；</p><p>写文字时，可以使用<code>(</code> 和 <code>)</code> 移到上一句和下一句；<code>{</code> 和 <code>}</code> 移到上一段和下一段。</p><p><code>gg</code> 和 <code>G</code> 跳转到开头和结尾行（小区别：<code>G</code>是跳转到最后一行的第一个字符，而不是最后一个字符）。</p><h3 id="文本修改"><a href="#文本修改" class="headerlink" title="文本修改"></a>文本修改</h3><p><code>c</code> 和 <code>d</code> 配合方向键，可以对文本进行更改。可以认为 <strong><code>c</code>（修改）的功能就是执行 <code>d</code>（删除）然后 <code>i</code>（插入）</strong>。</p><ul><li><code>d</code> 加动作来进行删除（dd 删除整行）；<code>D</code> 则相当于 <code>d$</code>，删除到行尾。</li><li><code>c</code> 加动作来进行修改（cc 修改整行）；<code>C</code> 则相当于 <code>c$</code>，删除到行尾然后进入插入模式。</li><li><code>s</code> 相当于 <code>cl</code>，删除一个字符然后进入插入模式；<code>S</code> 相当于 <code>cc</code>，替换整行的内容。</li><li><code>i</code> 在当前字符前面进入插入模式；<code>I</code> 则相当于 <code>^i</code>，把光标移到行首非空白字符上然后进入插入模式。</li><li><code>a</code> 在当前字符后面进入插入模式；<code>A</code> 相当于 <code>$a</code>，把光标移到行尾然后进入插入模式。</li><li><code>o</code> 在当前行下方插入一个新行，然后在这行进入插入模式；<code>O</code> 在当前行上方插入一个新行，然后在这行进入插入模式。</li><li><code>r</code> 替换光标下的字符；<code>R</code> 则进入替换模式，每次按键（直到<code>&lt;Esc&gt;</code>）替换一个字符。</li><li><code>u</code> 撤销最近的一个修改动作；<code>U</code> 撤销当前行上的所有修改。</li></ul><h3 id="文本对象选择"><a href="#文本对象选择" class="headerlink" title="文本对象选择"></a>文本对象选择</h3><p>可以使用 <code>c、d</code> 加动作键对这个动作选定的文本块进行操作（如<code>dj</code>就是删除当前行和下一行，相当于<code>2dd</code>），也可以使用 <code>v</code> 加动作键来选定文本块（以便后续进行操作）。</p><p>有几个动作只能在<code>c、d、v、y</code>这样命令之后用，例如基本附加键是 <code>a</code> 和 <code>i</code>。其中，<code>a</code> 可以简单理解为英文单词 <code>a</code>，表示选定后续动作要求的完整内容，而 <code>i</code> 可理解为英文单词 inner，代表后续动作要求的内容的“内部”。</p><p>假设有下面的文本内容：<code>if (message == &quot;sesame open&quot;)</code>。进一步假设光标停在“sesame”的“a”上，那么：</p><ul><li><code>dw</code>（理解为 delete word）会删除 <code>ame␣</code>，结果是 <code>if (message == &quot;sesopen&quot;)</code></li><li><code>diw</code>（理解为 delete inside word）会删除 <code>sesame</code>，结果是 <code>if (message == &quot; open&quot;)</code></li><li><code>daw</code>（理解为 delete a word）会删除 <code>sesame␣</code>，结果是 <code>if (message == &quot;open&quot;)</code></li><li><code>diW</code> 会删除 <code>&quot;sesame</code>，结果是 <code>if (message == open&quot;)</code></li><li><code>daW</code> 会删除 <code>&quot;sesame␣</code>，结果是 <code>if (message == open&quot;)</code></li><li><code>di&quot;</code> 会删除 <code>sesame open</code>，结果是 <code>if (message == &quot;&quot;)</code></li><li><code>da&quot;</code> 会删除 <code>&quot;sesame open&quot;</code>，结果是 <code>if (message ==)</code></li><li><code>di(</code> 或 <code>di)</code> 会删除 <code>message == &quot;sesame open&quot;</code>，结果是 <code>if ()</code></li><li><code>da(</code> 或 <code>da)</code> 会删除 <code>(message == &quot;sesame open&quot;)</code>，结果是 <code>if␣</code></li></ul><h2 id="Vim的选项和配置"><a href="#Vim的选项和配置" class="headerlink" title="Vim的选项和配置"></a>Vim的选项和配置</h2><p>根据 Unix 下的惯例，Vim 的配置文件放在用户的主目录下，文件名通常是<code>.vimrc</code>；而它在 Windows 下名字是 <code>_vimrc</code>，也是放在用户主目录下面。最基本的配置文件是这个样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> enc=utf-8</span><br><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$VIMRUNTIME</span>/vimrc_example.vim</span><br></pre></td></tr></table></figure><p>这三行采用的是shell编程，完成的功能是：</p><ol><li>设置编辑文件的内码是 UTF-8（非所有平台缺省，但为编辑多语言文件所必需）</li><li>设置 Vim 不需要和 vi 兼容（仅为万一起见，目前大部分情况下这是缺省情况）</li><li>导入 Vim 的示例配置（这会打开一些有用的选项，如语法加亮、搜索加亮、命令历史、记住上次的文件位置，等等）</li></ol><p>对于现代 Unix 系统上的 Vim 8，实际上只需要最后一句就足够了。对于现代 Windows 系统上的 Vim 8，中间的这句 set nocompatible 也可以删除。如果你在较老的 Vim 版本上进行配置，那么把这三行全放进去会比较安全。</p><h3 id="备份和撤销文件"><a href="#备份和撤销文件" class="headerlink" title="备份和撤销文件"></a>备份和撤销文件</h3><p>在示例配置里，Vim 自动设置了下面两个选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> backup</span><br><span class="line"><span class="built_in">set</span> undofile</span><br></pre></td></tr></table></figure><p>前一个选项使得每次编辑会保留上一次的备份文件，后一个选项使得 Vim 在重新打开一个文件时，仍然能够撤销之前的编辑（undo），这就会产生一个保留编辑历史的“撤销文件”（undofile）了。所以修改文件时会出现结尾为<code>“~”</code>的文件，有文件名后面直接加<code>“~”</code>的，还有前面加<code>“.”</code>后面加<code>“.un~”</code>的。</p><p>可以不产生备份文件，但保留跨会话撤销编辑的能力；因为有了撤销文件，备份其实也就没有必要了。同时，把撤销文件放在用户个人的特定目录下，既保证了安全，又免去了其他目录下出现不必要文件的麻烦。</p><p>Linux/MacOS下可以在<code>.vimrc</code>文件中写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nobackup</span><br><span class="line"><span class="built_in">set</span> undodir=~/.vim/undodir</span><br></pre></td></tr></table></figure><p>Windows 下可以在<code>_vimrc</code>文件中写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nobackup</span><br><span class="line"><span class="built_in">set</span> undodir=~\vimfiles\undodir</span><br></pre></td></tr></table></figure><p>无论哪个环境都要自动创建该文件夹，所以可以加上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !isdirectory(&amp;undodir)</span><br><span class="line">  call mkdir(&amp;undodir, <span class="string">'p'</span>, 0700)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h3 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h3><p>在windows下，使用vim打开utf-8编码的文件，通常会产生乱码，解决方法为在配置文件<code>_vimrc</code>（用户目录下的）中，添加如下设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> fileencodings=utf-8,ucs-bom,cp936,big5  </span><br><span class="line"><span class="built_in">set</span> fileencoding=utf-8</span><br></pre></td></tr></table></figure><p>vim关于文件编码常用的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> fileencoding    查看文件编码</span><br><span class="line">:<span class="built_in">set</span> fileformat       查看文件格式</span><br><span class="line">:<span class="built_in">set</span> fileencoding=utf-8 转换文件编码为utf-8</span><br></pre></td></tr></table></figure><h3 id="启用backspace"><a href="#启用backspace" class="headerlink" title="启用backspace"></a>启用backspace</h3><p>我在Windows的平台下面遇到了backspace退格键不能向左删除的问题，解决方法为在配置文件<code>_vimrc</code>中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> backspace=indent,eol,start</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://time.geekbang.org/column/article/262520" target="_blank" rel="noopener">01｜各平台下的 Vim 安装方法：上路前准备好你的宝马</a><br><a href="https://time.geekbang.org/column/article/266193" target="_blank" rel="noopener">02｜基本概念和基础命令：应对简单的编辑任务</a><br><a href="https://time.geekbang.org/column/article/266754" target="_blank" rel="noopener">03｜更多常用命令：应对稍复杂的编辑任务</a><br><a href="https://www.jianshu.com/p/4e040835f241" target="_blank" rel="noopener">Windows下，Vim的配置文件（_vimrc）在哪？</a><br><a href="https://blog.csdn.net/u012145252/article/details/82155354" target="_blank" rel="noopener">解决windows下vim中文乱码</a><br><a href="https://stackoverflow.com/questions/11560201/backspace-key-not-working-in-vim-vi" target="_blank" rel="noopener">Backspace key not working in Vim/vi</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;Vim大概有如下几个版本：vim、vim-athena、vim-gnome、vim-gtk、vim-gtk3、vim-noxvim-tiny。它们中有编译进最小功能的 Vim 包（vim-tiny），有较全功能的文本界面 Vim 包（vim-nox），有适用于老的 X-Window 界面的版本（vim-athena），有适用于 KDE 环境的 GTK2 版本（vim-gtk），等等。&lt;/p&gt;
&lt;p&gt;对于Ubuntu而言，一般情况下&lt;code&gt;sudo apt install vim-gtk3&lt;/code&gt;即可。在 Ubuntu 上，vim 和 gvim 都是指向同一个应用程序的符号链接，且 &lt;code&gt;gvim&lt;/code&gt; 的执行效果和 &lt;code&gt;vim -g&lt;/code&gt; 相同。所以要启动图像化界面的&lt;code&gt;vim&lt;/code&gt;，直接在终端执行&lt;code&gt;gvim&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;另外，若使用远程软件连接到Linux机器上，需要注意远程终端软件的远程字符集（如 PuTTY 中的“Windows &amp;gt; Translation &amp;gt; Remote character set”）应当设置成 UTF-8。&lt;/p&gt;
&lt;p&gt;然后，还可以安装中文版本的帮助文件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="杂七杂八" scheme="https://www.zdaiot.com/categories/Tools/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="vim" scheme="https://www.zdaiot.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile指令详解</title>
    <link href="https://www.zdaiot.com/Tools/Docker/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.zdaiot.com/Tools/Docker/Dockerfile指令详解/</id>
    <published>2020-09-25T14:04:55.000Z</published>
    <updated>2020-09-25T14:04:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>dockerfile记载了从一个镜像创建另一个新镜像的步骤。撰写好Dockerfile文件之后，我们就可以轻而易举的使用<code>docker build</code>命令来创建镜像了。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。</p><h3 id="Dockerfile的组成部分"><a href="#Dockerfile的组成部分" class="headerlink" title="Dockerfile的组成部分"></a>Dockerfile的组成部分</h3><div class="table-container"><table><thead><tr><th>部分</th><th>命令</th></tr></thead><tbody><tr><td>基础镜像信息</td><td>FROM</td></tr><tr><td>维护者信息</td><td>MAINTAINER</td></tr><tr><td>镜像操作指令</td><td>RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等</td></tr><tr><td>容器启动时执行指令</td><td>CMD、ENTRYPOINT</td></tr></tbody></table></div><p>下面主要列举出Dockerfile中比较常用的指令及其用法和说明，需要注意的是这些指令都是全部大写。</p><h4 id="FROM："><a href="#FROM：" class="headerlink" title="FROM："></a><strong><code>FROM</code></strong>：</h4><ul><li>说明：指定该镜像的基础镜像</li><li>格式如：<code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code></li><li>示例：<code>FROM centos:7</code></li><li>注意：<code>FROM</code>一般出现在文件头，且每个镜像都需要有一个<code>FROM</code>来指定基础镜像。</li></ul><h4 id="MAINTAINER："><a href="#MAINTAINER：" class="headerlink" title="MAINTAINER："></a><strong><code>MAINTAINER</code></strong>：</h4><ul><li>说明：指定作者信息</li><li>格式如：<code>MAINTAINER &lt;name&gt;</code></li><li>示例：<code>MAINTAINER 知识林 &quot;393156105@qq.com&quot;</code></li></ul><h4 id="RUN："><a href="#RUN：" class="headerlink" title="RUN："></a><strong><code>RUN</code></strong>：</h4><ul><li>说明：在构建镜像时执行脚本</li><li>格式如：<code>RUN &lt;command&gt;</code>、<code>RUN [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code></li><li>示例：<code>RUN ls -l</code>（以详细信息方式列表当前目录下的文件，跟在shell终端运行一样）</li></ul><h4 id="CMD："><a href="#CMD：" class="headerlink" title="CMD："></a><strong><code>CMD</code></strong>：</h4><ul><li>说明：在运行容器时执行脚本</li><li>格式如：<code>CMD &lt;command&gt; &lt;par1&gt; &lt;par2&gt; ...</code>、<code>CMD [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code></li><li>示例：<code>CMD [&quot;ls&quot;, &quot;-l&quot;]</code></li><li>注意：一个Dockerfile中只有一条<code>CMD</code>，如果有多条只执行最后一条；在运行容器时如果用户指定了运行命令则Dockerfile中的CMD将被覆盖。</li></ul><h4 id="Label"><a href="#Label" class="headerlink" title="Label:"></a><code>Label</code>:</h4><ul><li><p>说明：给构建的镜像打标签。</p></li><li><p>格式如：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LABEL <span class="string">"com.example.vendor"</span>=<span class="string">"ACME Incorporated"</span></span><br><span class="line">LABEL com.example.label-with-value=<span class="string">"foo"</span></span><br><span class="line">LABEL version=<span class="string">"1.0"</span></span><br><span class="line">LABEL description=<span class="string">"This text illustrates \</span></span><br><span class="line"><span class="string">that label-values can span multiple lines."</span></span><br></pre></td></tr></table></figure><p>一个镜像可以有多个标签，如果基础镜像也有标签则继承，名字相同的话则会覆盖。如果使用多个标签，建议合并成一个标签指令，如果使用多个标签指令， 则每个标签指令都会生成一个图层，这会导致镜像生成效率低下。举个栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL multi.label1=<span class="string">"value1"</span> multi.label2=<span class="string">"value2"</span> other=<span class="string">"value3"</span></span><br></pre></td></tr></table></figure><p>也可以写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABEL multi.label1=<span class="string">"value1"</span> \</span><br><span class="line">multi.label2=<span class="string">"value2"</span> \</span><br><span class="line">other=<span class="string">"value3"</span></span><br></pre></td></tr></table></figure></li><li><p>注意：标签是键值对格式，要在标签中包含空格则需转义或用引号<code>&quot;</code>括起来。</p></li></ul><h4 id="ENTRYPOINT："><a href="#ENTRYPOINT：" class="headerlink" title="ENTRYPOINT："></a><strong><code>ENTRYPOINT</code></strong>：</h4><ul><li>说明：在运行容器时执行脚本</li><li>格式如：<code>ENTRYPOINT [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code>、<code>ENTRYPOINT command par1 par2</code></li><li>示例：<code>ENTRYPOINT [&quot;catalina.sh&quot;, &quot;run&quot;]</code></li><li>注意：一个Dockerfile中只有一条<code>ENTRYPOINT</code>，如果有多条只执行最后一条；不可以被容器运行时的命令所覆盖。</li></ul><h4 id="EXPOSE："><a href="#EXPOSE：" class="headerlink" title="EXPOSE："></a><strong><code>EXPOSE</code></strong>：</h4><ul><li>说明：让Docker暴露容器的端口号，供其他容器使用，在宿主机以外的网络中是无法使用的</li><li>格式如：<code>EXPOSE &lt;port&gt; ...</code></li><li>示例：<code>EXPOSE 8080</code></li><li>注意：<ul><li>在Docker中有两种暴露端口的概念，一种叫<code>EXPOSE</code>隐式暴露，只供Docker服务内部使用；另一种叫<code>PUBLISH</code>显式暴露，供外部网络使用，<code>PUBLISH</code>只是一个概念在Dockerfile中没有这个指令。</li><li><code>EXPOSE</code> 只在Dockerfile中出现，所暴露的端口只是被其他容器使用</li><li><code>PUBLISH</code> 没有该指令而是通过<code>docker run</code>命令的参数<code>-p</code>、<code>-P</code>或在<code>docker-compose</code>中的<code>ports</code>来体现</li><li><code>-P</code>：大写是属于自动映射，将Dockerfile中<code>EXPOSE</code>所暴露的所有端口分别映射到宿主机的随机端口，每次启动或重启容器时端口都可能有所不同</li><li><code>-p</code>：小写是属于固定映射，格式如：<code>-p 宿主端口:容器端口</code>，宿主端口和容器端口可以是纯数字也可以是一个范围，如：<code>-p 8060-8080:8060-8080</code>，意为将宿主机的<code>8060</code>（含）到<code>8080</code>（含）的端口映射到容器的<code>8060</code>（含）到<code>8080</code>（含）端口，需要注意的是在使用范围时，宿主端口个数应该与容器端口个数匹配；但上面这个例子可以写成：<code>-p 7060-7080:8060-8080</code>，这样宿主的端口就在<code>7060-7080</code>范围内</li></ul></li></ul><h4 id="ENV："><a href="#ENV：" class="headerlink" title="ENV："></a><strong><code>ENV</code></strong>：</h4><ul><li>说明：指定环境变量，在Dockerfile文件中的后续代码中使用，在容器运行时也可以使用</li><li>格式如：<code>ENV &lt;key&gt; &lt;value&gt;</code></li><li>示例：<code>ENV tomcat_home /web/tomcat/</code></li></ul><h4 id="ADD："><a href="#ADD：" class="headerlink" title="ADD："></a><strong><code>ADD</code></strong>：</h4><ul><li>说明：添加文件（夹）到容器</li><li>格式如：<code>ADD &lt;src&gt; &lt;dest&gt;</code></li><li>示例：<code>ADD web.jar /web.jar</code></li><li>注意：复制指定的<code>&lt;src&gt;</code>到容器中的<code>&lt;dest&gt;</code>，<code>&lt;src&gt;</code>可以是Dockerfile所在目录的一个相对路径，也可以是一个URL，也可以是一个<code>tar</code>文件（<code>tar</code>文件将自动解压成文件目录）</li></ul><h4 id="COPY："><a href="#COPY：" class="headerlink" title="COPY："></a><strong><code>COPY</code></strong>：</h4><ul><li>说明：添加文件（夹）到容器</li><li>格式如：<code>COPY &lt;src&gt; &lt;dest&gt;</code></li><li>示例：<code>COPY web.jar /web.jar</code></li><li>注意：与<code>ADD</code>功能相似，只是不能指定URL，使用本地文件（夹）为源文件时，推荐使用<code>COPY</code></li></ul><h4 id="VOLUME："><a href="#VOLUME：" class="headerlink" title="VOLUME："></a><strong><code>VOLUME</code></strong>：</h4><ul><li><p>说明：创建挂载点</p></li><li><p>格式如：<code>VOLUME [path]</code></p></li><li><p>示例：<code>VOLUME [&quot;/datas&quot;]</code></p></li><li><p>注意：</p><ul><li><code>VOLUME</code>在原理和概念上与<code>EXPOSE</code>差不多，都是属于供容器与容器间使用</li><li>通过<code>VOLUME</code>挂载的卷可以供其他容器使用</li></ul></li><li><p>举例说明：</p><ul><li><p>创建一个Dockerfile来构建一个镜像，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [<span class="string">"/web/images"</span>, <span class="string">"/web/files"</span>]</span><br></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t <span class="string">"zsl131/test01"</span> .</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name <span class="built_in">test</span>-root</span><br></pre></td></tr></table></figure></li><li><p>可以使用命令：<code>docker inspect test-root</code>来查看容器详细信息，在<code>Mounts</code>部份可以看到两个挂载点：<code>/web/images</code>和<code>/web/files</code></p></li><li><p>启动另一个容器来共用这两个挂载卷</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name <span class="built_in">test</span>-1 --volumes-from <span class="built_in">test</span>-root centos</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>使用<code>--volumes-from</code>来指定挂载点，这时容器<code>test-root</code>和<code>test-1</code>里面都分别有挂载卷<code>/web/images</code>和<code>/web/files</code>，可以启动任意多个容器使用<code>--volumes-from</code>来共用这些挂载卷，这些容器可以来自不同的镜像。当任何一个容器中的挂载卷中的文件发生变化时其他容器挂载卷中的内容也随之改变。</p><p>容器<code>test-root</code>即使已经停止也可以在启动其他容器时使用<code>--volumes-from test-root</code>来挂载这些卷，只要<code>test-root</code>不被删除，不过如果<code>test-root</code>真被删除还可以使用<code>--volumes-from test-1</code>，因为容器<code>test-1</code>中还存在我们所需要的挂载卷，换句话说这些挂载卷永远存在直到所有使用这些挂载卷的容器都被删除。</p></li><li><p><code>VOLUME</code>与<code>docker run</code>参数<code>-v</code>是有区别的。<code>docker run -v /host/web/images:/web/images -v /host/web/files:/web/files:rw</code>是将容器内的<code>/web/images</code>挂载到宿主机的<code>/host/web/images</code>目录上；将容器内的<code>/web/files</code>挂载到宿主机的<code>/host/web/files</code>目录上，<code>rw</code>表示可读写。</p></li></ul></li></ul><h4 id="WORKDIR："><a href="#WORKDIR：" class="headerlink" title="WORKDIR："></a><strong><code>WORKDIR</code></strong>：</h4><ul><li>说明：设置工作目录</li><li>格式如：<code>WORKDIR /path</code></li><li>示例：<code>WORKDIR /web</code></li><li>注意：可以使用绝对路径，也可以使用相对路径，设置之后的所有操作都将在这个目录下完成</li></ul><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG:"></a><code>ARG</code>:</h4><p>指定用户在<code>docker build --build-arg &lt;varname&gt;=&lt;value&gt;</code>时可以使用的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><p>如果用户指定了未在Dockerfile中定义的构建参数，则构建会输出警告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Warning] One or more build-args [foo] were not consumed.</span><br></pre></td></tr></table></figure><p>构建参数在定义的时候生效而不是在使用的时候。如下面第三行开始的user才是用户构建参数传递过来的user：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line"><span class="comment"># 此处获取不到用户传来的user</span></span><br><span class="line">USER <span class="variable">$&#123;user:-some_user&#125;</span></span><br><span class="line">ARG user</span><br><span class="line">USER <span class="variable">$user</span></span><br></pre></td></tr></table></figure><p>您可以使用<code>ARG</code>或<code>ENV</code>指令指定<code>RUN</code>指令可用的变量。使用<code>ENV</code>指令定义的环境变量始终覆盖同名的<code>ARG</code>指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER v1.0.0</span><br><span class="line"><span class="comment"># 始终是v1.0.0</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span><br></pre></td></tr></table></figure><p>正确的用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER <span class="variable">$&#123;CONT_IMG_VER:-v1.0.0&#125;</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span><br></pre></td></tr></table></figure><p>要在多个阶段中使用arg，每个阶段都必须包含该ARG指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG SETTINGS</span><br><span class="line">RUN ./run/setup <span class="variable">$SETTINGS</span></span><br><span class="line"></span><br><span class="line">FROM busybox</span><br><span class="line">ARG SETTINGS</span><br><span class="line">RUN ./run/other <span class="variable">$SETTINGS</span></span><br></pre></td></tr></table></figure><p>此外docker还内置了一批构建参数，可以不用在Dockerfile中声明：<code>HTTP_PROXY</code>、<code>http_proxy</code>、<code>HTTPS_PROXY</code>、<code>https_proxy</code>、<code>FTP_PROXY</code>、 <code>ftp_proxy</code>、<code>NO_PROXY</code>、<code>no_proxy</code></p><blockquote><p>注意：在使用构建参数(而不是在构建参数定义的时候)的指令中，如果构建参数的值发生了变化，会导致该指令发生变化，会重新寻找缓存。</p></blockquote><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>在上面的描述中可以看到有两组指令在功能上都差不多，但也是有区别的：</p><ul><li><code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>执行脚本的指令<ul><li>三个指令都是执行脚本</li><li><code>RUN</code>是在创建镜像是执行，即使用<code>docker build</code>命令时执行，在一个Dockerfile里面可以有多个<code>RUN</code></li><li><code>CMD</code>和<code>ENTRYPOINT</code>是在运行容器时执行，即使用<code>docker run</code>命令时执行，这两个指令在Dockerfile中都只有最行一条被执行</li><li><code>CMD</code>在使用<code>docker run</code>时可以加参数将Dockerfile中的<code>CMD</code>覆盖</li><li><code>ENTRYPOINT</code>在Dockerfile中出现后就一定会在<code>docker run</code>时被执行，不必担心会被其他参数所覆盖。</li></ul></li><li><code>ADD</code>、<code>COPY</code>拷贝文件（夹）到容器<ul><li><code>ADD</code>拷贝文件（夹）时可以指定本地文件、远程URL地址，如果拷贝的是<code>tar</code>文件时将会被自动解压成文件夹</li><li><code>COPY</code>拷贝文件（夹）时不可以指定远程URL地址，拷贝<code>tar</code>文件也不会被自动解压成文件夹，在拷贝本地文件时建议使用<code>COPY</code></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/6844903878849200142" target="_blank" rel="noopener">Dockerfile指令详解</a><br><a href="https://www.jianshu.com/p/ff301a3ecf17" target="_blank" rel="noopener">12 - Dockerfile指令详解（Docker系列）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dockerfile记载了从一个镜像创建另一个新镜像的步骤。撰写好Dockerfile文件之后，我们就可以轻而易举的使用&lt;code&gt;docker build&lt;/code&gt;命令来创建镜像了。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。&lt;/p&gt;
&lt;h3 id=&quot;Dockerfile的组成部分&quot;&gt;&lt;a href=&quot;#Dockerfile的组成部分&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile的组成部分&quot;&gt;&lt;/a&gt;Dockerfile的组成部分&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;部分&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基础镜像信息&lt;/td&gt;
&lt;td&gt;FROM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;维护者信息&lt;/td&gt;
&lt;td&gt;MAINTAINER&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;镜像操作指令&lt;/td&gt;
&lt;td&gt;RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;容器启动时执行指令&lt;/td&gt;
&lt;td&gt;CMD、ENTRYPOINT&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;下面主要列举出Dockerfile中比较常用的指令及其用法和说明，需要注意的是这些指令都是全部大写。&lt;/p&gt;
&lt;h4 id=&quot;FROM：&quot;&gt;&lt;a href=&quot;#FROM：&quot; class=&quot;headerlink&quot; title=&quot;FROM：&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/strong&gt;：&lt;/h4&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="Docker" scheme="https://www.zdaiot.com/categories/Tools/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.zdaiot.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode总结</title>
    <link href="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode%E6%80%BB%E7%BB%93/"/>
    <id>https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/</id>
    <published>2020-07-24T02:08:47.000Z</published>
    <updated>2020-07-24T02:08:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树遍历模板"><a href="#二叉树遍历模板" class="headerlink" title="二叉树遍历模板"></a>二叉树遍历模板</h3><ol><li><strong>前序遍历</strong>：<strong>先访问根节点</strong>，再前序遍历左子树，再前序遍历右子树</li><li><strong>中序遍历</strong>：先中序遍历左子树，<strong>再访问根节点</strong>，再中序遍历右子树</li><li><strong>后序遍历</strong>：先后序遍历左子树，再后序遍历右子树，<strong>再访问根节点</strong></li></ol><p>注意点：</p><ol><li><p>以根访问顺序决定是什么遍历</p></li><li><p>左子树都是优先右子树</p></li></ol><p>练习：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>递归法三要素：</p><ol><li>确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型；</li><li>确定终止条件；</li><li>确定单层递归逻辑：这里需要假定嵌套问题已经解决了。</li></ol><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>前序遍历（迭代法）不难写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        TreeNode* node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) result.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        st.push(node-&gt;right);  <span class="comment">// 栈是先进后出，访问顺序是根左右，所以先让右节点入栈</span></span><br><span class="line">        st.push(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用迭代法很难写出统一的模板，在迭代过程中，有两个操作，<strong>一个是处理：将元素放进result数组中，一个是访问：遍历节点。</strong>前序遍历的顺序是中左右，要先访问的元素是中间节点，要处理的元素也是中间节点，要访问的元素和要处理的元素顺序是一致的，都是中间节点，所以才能写出相对简洁的代码。</p><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><p>中序遍历，可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;  <span class="comment">// 一层一层的向下访问，直到树左边的底层</span></span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// </span></span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/DataStructureAlgorithm/LeetCode总结/4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image.png" alt="4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image" style="zoom: 50%;"></p><p>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        TreeNode* node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) result.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        st.push(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序</span></span><br><span class="line">        st.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(result.begin(), result.end()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h4><blockquote><p>给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><p>该题目可以使用递归的方法解决，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftD, rightD;</span><br><span class="line">    <span class="keyword">if</span>(isBalancedCore(root-&gt;left, leftD) &amp;&amp; isBalancedCore(root-&gt;right, rightD)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(leftD-rightD) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            depth = <span class="number">1</span> + (leftD &gt; rightD?leftD:rightD);</span><br><span class="line">            <span class="comment">// depth = max(leftD, rightD) + 1;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth;</span><br><span class="line">    <span class="keyword">return</span> isBalancedCore(root, depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/" target="_blank" rel="noopener">彻底吃透前中后序递归法（递归三部曲）和迭代法（不统一写法与统一写法）</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>链表代码经常考察点在于指针的理解，也就是<code>NULL</code>指针的处理，比如说有一个结构体<code>Node</code>，结构体指针为<code>node*</code>，访问结构体成员变量<code>node-&gt;val</code>的时候，要先判断<code>node</code>是否等于<code>NULL</code>。</p><p>常用技巧：</p><ol><li>设置哑点可以简化很多判断和处理</li><li>快慢指针、双指针的使用</li><li>得到链表的中心节点之后翻转链表（可以翻转前半部分，也可以翻转后半部分。翻转前半部分指针代码更加简单）</li></ol><p>这里补充一个常用代码，链表借助双指针，找到中间节点<code>slow</code>，若链表为偶数个元素，则<code>slow</code>节点在前半段的最后一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow, fast = head, head.next</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">fast, slow = fast.next.next, slow.next</span><br></pre></td></tr></table></figure><p>若写成下面形式，则若链表为偶数个元素，则<code>slow</code>节点在后半段的第一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow, fast = head, head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">fast, slow = fast.next.next, slow.next</span><br></pre></td></tr></table></figure><h3 id="常见题目-1"><a href="#常见题目-1" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></h4><blockquote><p>给定一个<strong>排序</strong>链表，删除所有重复的元素，使得每个元素只出现一次。</p></blockquote><p>这个题目需要使用双指针的方法，一个指针记录前一个指针，一个指针记录当前遍历到的指针。若两个指针的元素值相同，则删除当前节点，否则的话，更新两个指针。</p><p>参考代码如下。为了简化代码，这里使用了<code>cur</code>和<code>cur-&gt;next</code>代替双指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">        <span class="comment">// 如果节点值相同</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;   <span class="comment">// 不需要更新cur指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></h4><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p></blockquote><p>这个题目和上一个题目的区别在于，上一个题目重复出现的只保留一个，而这里重复出现的数字则需要全部删除。</p><p>首先，在上一个题目中首节点是不可能被删除的，而在本题目中首节点是有可能被删除的，所以需要借助<strong>哑点</strong>处理。另外需要删除所有重复的数字，刚拿到题目的思路是采用三指针的方法，但是这种方法的容易出错并且代码比较复杂。</p><p>因此可以换一种思路，我们使用双指针法，指针<code>l</code>记录左节点，指针<code>r</code>记录右节点。每次循环的时候，初始化<code>l=r</code>，若<code>l-&gt;val=r-&gt;val</code>则不断向后移动<code>r</code>指针。</p><ol><li>若<code>l-&gt;next==r</code>，则说明<code>l-&gt;val</code>肯定是唯一的，将<code>l</code>指针放到结果中，但此时<code>r-&gt;val</code>不一定是唯一的，所以重新初始化<code>l=r</code>；</li><li>若<code>l-&gt;next!=r</code>，则说明<code>l</code>到<code>r-&gt;pre</code>之间所有的值都是重复的，不更新结果，同样此时<code>r-&gt;val</code>不一定是唯一的，所以重新初始化<code>l=r</code>；</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;        </span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);  <span class="comment">// 哑点</span></span><br><span class="line">    ListNode* node = dummy;</span><br><span class="line">    </span><br><span class="line">    ListNode* r = head;</span><br><span class="line">    <span class="keyword">for</span>(ListNode* l=head; l!=<span class="literal">NULL</span>; l=r) &#123;  <span class="comment">// 不管l节点是不是唯一，r节点是否唯一都不能得到结论，所以更新l=r</span></span><br><span class="line">        <span class="keyword">while</span>(r &amp;&amp; l-&gt;val==r-&gt;val) r = r-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;next == r) &#123;  <span class="comment">// 若满足则说明l节点肯定是唯一的，不能用r-l==1，因为两个都是表示地址</span></span><br><span class="line">            node-&gt;next = l;  <span class="comment">// 将l指针添加到最后结果中</span></span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 不要忘记置为NULL，否则结果会混乱</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h4><blockquote><p>反转一个单链表。</p></blockquote><p>该题是典型的双指针题目，需要用一个<code>pre</code>指针记录前一个节点，一个<code>node</code>指针记录当前节点。这里需要注意的地方是<code>pre</code>指针的初始化特别重要，需要初始化为<code>pre=NULL</code>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pNode = head;</span><br><span class="line">    ListNode* pPre = <span class="literal">NULL</span>;  <span class="comment">// 这个初始化很重要</span></span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">        ListNode* pNext = pNode-&gt;next;  <span class="comment">// 记录下一个节点          </span></span><br><span class="line">        pNode-&gt;next = pPre;</span><br><span class="line">        pPre = pNode;</span><br><span class="line">        pNode = pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pPre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></h4><blockquote><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。<strong>说明:</strong>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。也就是说 <em>m</em> 和 <em>n</em> 的下标都是从1开始的。</p></blockquote><p>这个题目有一个要求就是一趟扫描完成反转。定义两个指针，分别为<code>g</code>（guard）和<code>p</code>（point）。首先根据参数<code>m</code>确定<code>g</code>和<code>p</code>的位置。将<code>g</code>移动到第一个要反转的节点前面，将<code>p</code>移动到第一个要反转的节点位置上。以<code>m=2,n=4</code>为例：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/5389db651086bd4bcd42dd5c4552f180b553a9b204cfc1013523dfe09beac382-1.png" alt="5389db651086bd4bcd42dd5c4552f180b553a9b204cfc1013523dfe09beac382-1"></p><p>然后使用头插法，将<code>p</code>后面的元素删除，然后添加到<code>g</code>的后面，重复该步骤。如下图所示：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/db22bdb60035e45f8c354b3f45f2a844260d6cafcf81528d2c4f1b51e484fb45-2.png" alt="db22bdb60035e45f8c354b3f45f2a844260d6cafcf81528d2c4f1b51e484fb45-2" style="zoom:67%;"></p><p>最后返回<code>dummyHead-&gt;next</code>。</p><p>这里需要注意的是，根据<code>m</code>是否等于1，返回的结果是不一样的。为了避免对这些情况进行分类讨论，可以借助哑点。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    ListNode* g = dummyHead;</span><br><span class="line">    ListNode* p = dummyHead-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>; i++) &#123; <span class="comment">// 将g移动到第一个要反转的节点的前面，将p移动到第一个要反转的节点的位置上</span></span><br><span class="line">        g = g-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-m; i++) &#123;  <span class="comment">// 由上图可得知，并不需要更新g、p指针</span></span><br><span class="line">        ListNode* removed = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        removed-&gt;next = g-&gt;next;  <span class="comment">// 注意这个地方不能直接等于p，画到第二次循环即可明白</span></span><br><span class="line">        g-&gt;next = removed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h4><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></blockquote><p>这个一个很典型的需要借助哑点来简化代码的题目。思想比较简单，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">        cur-&gt;next = l2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur-&gt;next = l1;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></h4><blockquote><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。你应当保留两个分区中每个节点的初始相对位置。</p></blockquote><p>这个题目可以使用双哑点指针解决。</p><p>参考代码如下，这里需要注意的是，因为涉及到节点的拼接，所以要避免陷入死循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* little = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* big = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* node1 = little;</span><br><span class="line">    ListNode* node2 = big;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val &lt; x) &#123;</span><br><span class="line">            node1-&gt;next = head;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node2-&gt;next = head;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node2-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 避免返回结果的时候陷入死循环</span></span><br><span class="line">    node1-&gt;next = big-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> little-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></h4><blockquote><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p></blockquote><p>题目要求时间空间复杂度分别为$O(nlogn)$和$O(1)$，根据时间复杂度我们自然想到二分法，从而联想到归并排序（快速排序平均时间复杂度为$O(nlogn)$ ）；对数组进行归并排序的空间复杂度为$O(n)$，分别由新开辟数组$O(n)$和递归函数调用$O(logn)$组成，而根据链表特性：</p><ol><li>数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间</li><li>递归额外空间：递归调用函数将带来$O(logn)$的空间复杂度，若希望达到$O(1)$空间复杂度，则不能使用递归</li></ol><p>为了方便理解，先阐述一下基于<strong>递归方法</strong>的思路：</p><p><strong>分割环节：</strong>找到当前链表中点，并从中点将链表断开</p><ul><li>使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</li><li>找到中点 slow 后，执行 slow.next = None <strong>将链表切断</strong>。</li><li>递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。</li><li>cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。</li></ul><p><strong>合并环节：</strong>将两个排序链表合并，转化为一个排序链表。</p><ul><li>双指针法合并，建立辅助ListNode h 作为头部。</li><li>设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li><li>返回辅助ListNode h 作为头部的下个节点 h.next。</li><li>时间复杂度 O(l + r)，l, r 分别代表两个链表长度。</li></ul><p><strong>当题目输入的 <code>head == None</code> 时，直接返回None。</strong></p><p>示意图如下：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png" alt="Picture2.png" style="zoom: 50%;"></p><p>接下来阐述一下<strong>基于循环</strong>的方式，也就是<strong>从底至顶直接合并</strong>。需要使用迭代的方式替换上述<strong>分割环节</strong>，该环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。</p><p>每一轮合并merge操作针对的单元都有固定长度intv，例如：</p><ul><li>第一轮合并时intv = 1，即将整个链表切分为多个长度为1的单元，并按顺序两两排序合并，合并完成的已排序单元长度为2。</li><li>第二轮合并时intv = 2，即将整个链表切分为多个长度为2的单元，并按顺序两两排序合并，合并完成已排序单元长度为4。</li><li>以此类推，直到单元长度intv &gt;= 链表长度，代表已经排序完成。</li></ul><p>根据以上推论，我们可以仅根据intv计算每个单元边界，并完成链表的每轮排序合并，例如:</p><ul><li>当intv = 1时，将链表第1和第2节点排序合并，第3和第4节点排序合并，……。</li><li>当intv = 2时，将链表第1-2和第3-4节点排序合并，第5-6和第7-8节点排序合并，……。</li><li>当intv = 4时，将链表第1-4和第5-8节点排序合并，第9-12和第13-16节点排序合并，……。</li></ul><p>此方法时间复杂度$O(nlogn)$，空间复杂度$O(1)$。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png" alt="Picture1.png" style="zoom:50%;"></p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);  <span class="comment">// 设置哑点</span></span><br><span class="line">    res-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前每个组别的长度</span></span><br><span class="line">    <span class="keyword">int</span> intv = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(intv &lt; length) &#123;</span><br><span class="line">        <span class="comment">// h用于遍历，注意这次每次都需要这样的初始化，res每次也会更新，其next指向排序后的第一个指针</span></span><br><span class="line">        ListNode* pre = res;</span><br><span class="line">        ListNode* h = res-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两两一组的遍历各个小块，当h为空的时候，加大intv</span></span><br><span class="line">        <span class="keyword">while</span>(h) &#123;</span><br><span class="line">            <span class="comment">// h1是第一个块的开头，h2是第二个块的开头</span></span><br><span class="line">            ListNode* h1 = h;</span><br><span class="line">            <span class="comment">// 向前移动intv个，得到第二个块的开头h</span></span><br><span class="line">            <span class="keyword">int</span> i = intv;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; h) &#123;</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) </span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 此时第二个块没有值，也就可以删除了</span></span><br><span class="line">        </span><br><span class="line">            i = intv;</span><br><span class="line">            ListNode* h2 = h;</span><br><span class="line">            <span class="comment">// 得到第三个块的开始坐标h，方便接下来的循环</span></span><br><span class="line">            <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; h) &#123;</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始进行合并，注意这里循环的时候不能够使用h1和h2，因为并没有截断</span></span><br><span class="line">            <span class="keyword">int</span> c1 = intv;</span><br><span class="line">            <span class="keyword">int</span> c2 = intv - i; <span class="comment">// c2的长度可能比intv短</span></span><br><span class="line">            <span class="keyword">while</span>(c1&gt;<span class="number">0</span> &amp;&amp; c2&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(h1-&gt;val &lt; h2-&gt;val) &#123;</span><br><span class="line">                    pre-&gt;next = h1;</span><br><span class="line">                    h1 = h1-&gt;next;</span><br><span class="line">                    c1--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre-&gt;next = h2;</span><br><span class="line">                    h2 = h2-&gt;next;</span><br><span class="line">                    c2--;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有一方有剩余</span></span><br><span class="line">            <span class="keyword">if</span>(c1&gt;<span class="number">0</span>) </span><br><span class="line">                pre-&gt;next = h1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c2&gt;<span class="number">0</span>) </span><br><span class="line">                pre-&gt;next = h2;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 排序好的链表末尾指针pre的next指向第三块的开始坐标</span></span><br><span class="line">            <span class="keyword">while</span>(c1&gt;<span class="number">0</span> || c2&gt;<span class="number">0</span>) &#123;  </span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                c1--;</span><br><span class="line">                c2--;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = h;</span><br><span class="line">        &#125;</span><br><span class="line">        intv *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></h4><blockquote><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></blockquote><p>这个题目根据一头一尾取元素的特性。可以分为三个步骤：</p><ol><li>将链表平均分为两半，并从中间截断，防止陷入死循环</li><li>将第二个链表逆序</li><li>依次连接两个链表</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* slow = head;  <span class="comment">// slow指向的是中间元素</span></span><br><span class="line">    ListNode* fast = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* mid = slow-&gt;next;  <span class="comment">// mid指向第二个链表的首元素</span></span><br><span class="line">    slow-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 进行截断，防止陷入死循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 旋转后面的链表，最终pre指向旋转后首元素</span></span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 这个初始化需要注意</span></span><br><span class="line">    <span class="keyword">while</span>(mid) &#123;</span><br><span class="line">        ListNode* third = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = pre;</span><br><span class="line">        pre = mid;</span><br><span class="line">        mid = third;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始进行拼接操作</span></span><br><span class="line">    ListNode* node = head;</span><br><span class="line">    <span class="keyword">while</span>(pre) &#123;</span><br><span class="line">        ListNode* third = node-&gt;next;</span><br><span class="line">        node-&gt;next = pre;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;next = third;</span><br><span class="line">        node = third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h4><blockquote><p>给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。如果链表中存在环，则返回 true 。 否则，返回 false 。请尝试使用 <em>O(1)</em>（即，常量）内存解决此问题。</p></blockquote><p>这个题目可以使用快慢指针的方法，若链表中存在环，则快慢指针肯定存在相等的情况，否则的话肯定不存在环。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head-&gt;next;  <span class="comment">// 访问肯定不会报错，但是不是NULL就不一定了</span></span><br><span class="line">    <span class="keyword">while</span>(fast!=slow) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="comment">// 肯定不存在环了</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h4><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。</p></blockquote><p>这个题目和上一个题目的区别在于本题目不仅要判断是不是有环，而且要得到入环的第一个节点。</p><p>阶段一：判断存在环；阶段二：找到环的入口，下面对第二个阶段进行讨论。</p><p>当环很大的时候，这个过程用示意图表示如下图所示。其实这个结论对于环很小的时候也适用。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/2036dfe7e991f00dfb788a9b84a17bb6fac337e81c09bdf57e683d028a6952bc-未命名文件.png" alt="未命名文件.png"></p><p>为了更加严谨的证明这个结论，我们不对环的大小进行限制进行讨论。</p><ol><li>假设链表共有 <em>a</em>+<em>b</em> 个节点，其中 <strong>链表头部到链表入口</strong> 有 <em>a</em> 个节点（不计链表入口节点）， <strong>链表环</strong> 有 <em>b</em> 个节点。设快慢指针分别走了$f,s$步，则在两个指针<strong>第一次相遇</strong>有：<ul><li>fast指针走的是slow步数的两倍，即$f=2s$</li><li>fast比slow<strong>多走了</strong>$n$个环的长度，即$f=s+nb$；（ 双指针都走过 <em>a</em> 步，然后在环内绕圈直到重合，重合时 <code>fast</code> 比 <code>slow</code> 多走 <strong>环的长度整数倍</strong> ）</li><li>以上两式相减得：$f=2nb,s=nb$，即<code>fast</code>和<code>slow</code> 指针分别走了 2<em>n</em>，<em>n</em> 个 <strong>环的周长</strong> （注意： <em>n</em> 是未知数，不同链表的情况不同）</li></ul></li><li>此时，若让指针从链表头部一直向前走并统计步数$k$，那么所有走到链表入口节点时的步数是：$k=a+nb$（先走 $a$ 步到入口节点，之后每绕 1 圈环（ $b$ 步）都会再次到入口节点）。而目前slow指针已经走了$nb$步了，只需要再走$a$步停下来即为环的入口。但是此时不知道$a$的值，所以仍然使用双指针法，让另外一个指针从链表头部出发，与slow一起向前走$a$步后，两者在入口节点重合。</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre=head, *post=head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(post==<span class="literal">NULL</span> || post-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 肯定不存在环</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        post = post-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(pre == post)  <span class="comment">// 第一次相遇停止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="keyword">while</span>(pre != post) &#123;  <span class="comment">// 再次相遇停止</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        post = post-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></h4><blockquote><p>请判断一个链表是否为回文链表。你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p></blockquote><p>若想使用$O(1)$的空间复杂度解决这个题目，可以使用<strong>快慢指针遍历的同时翻转前半部分，然后与后半部分比较即可。</strong>这个技巧也经常被其他题目使用。</p><p>值得注意的是，这里将<code>fast</code>和<code>slow</code>指针都初始化为了<code>head</code>，若将<code>fast</code>初始化为<code>head-&gt;next</code>，则当链表有偶数个元素的时候，最后一个中位数没办法处理到。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ListNode* prepre=<span class="literal">NULL</span>, *pre=head;  <span class="comment">// pre指针指向前半部分翻转后的首地址</span></span><br><span class="line">    ListNode* slow=head, *fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;  <span class="comment">// 快慢指针遍历的同时翻转前半部分</span></span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        pre-&gt;next = prepre;    </span><br><span class="line">        prepre = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast)  <span class="comment">// 说明链表元素有奇数个，此时slow在中位数上，需要向后移动一位；若链表元素为偶数个，slow在后半段的开头位置</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">NULL</span> &amp;&amp; slow!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;val != slow-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></h4><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的 深拷贝。 </p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><ul><li>val：一个表示 Node.val 的整数。</li><li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li></ul></blockquote><p>该题主要有两个思路。</p><p>第一个思路是不借助外部存储空间，使用三步走的方法。</p><p><strong>第一步</strong>，根据遍历到的原节点创建对应的新节点，每个新创建的节点是在原节点后面，比如下图中原节点<strong>1</strong>不再指向原原节点<strong>2</strong>，而是指向新节点<strong>1</strong></p><p><img src="/DataStructureAlgorithm/LeetCode总结/360dbd3b89c25324287f4cef2c22ba8a20e946891ac887f70703b211893aafa0-5.jpg" alt="5.jpg" style="zoom:67%;"></p><p><strong>第二步</strong>是最关键的一步，用来设置新链表的随机指针</p><p><img src="/DataStructureAlgorithm/LeetCode总结/b531fb496fd478a2db6ba7bc805cda08b825771817dd24cdd616946a89800fbb-6.jpg" alt="6.jpg" style="zoom:67%;"></p><p>此时可以观察到一个规律，原节点<code>i</code>的随机指针(如果有的话)，指向的是原节点<code>j</code>。那么新节点<code>i</code>的随机指针，指向的是原节点<code>j</code>的<strong>next</strong>。</p><p><strong>第三步</strong>就简单了，只要将两个链表分离开，再返回新链表就可以了</p><p><img src="/DataStructureAlgorithm/LeetCode总结/9b5c6e99aa89284c8a7b423bc36fec7af39fac3f8bb709e77483e574e02ef1cd-7.jpg" alt="7.jpg"></p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    Node* node = head;</span><br><span class="line">    <span class="comment">// 开始复制</span></span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        newNode-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = newNode;</span><br><span class="line">        node = newNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始复制随机指针</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;random)</span><br><span class="line">            node-&gt;next-&gt;random = node-&gt;random-&gt;next;</span><br><span class="line">        node = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始拆分链表，借助哑点让newNode在node的前面，可以简化代码，不需要对newNode-&gt;next是否为空进行特殊判断了</span></span><br><span class="line">    Node* newHead = <span class="keyword">new</span> Node(<span class="number">-1</span>);</span><br><span class="line">    Node* newNode = newHead;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        newNode-&gt;next = node-&gt;next;</span><br><span class="line">        newNode = newNode-&gt;next;</span><br><span class="line">        node-&gt;next = newNode-&gt;next;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个解法是借助额外存储空间，也就是借助哈希表来解决这个问题。</p><p>首先创建一个哈希表，再遍历原链表，遍历的同时再不断创建新节点。我们将原节点作为<strong>key</strong>，新节点作为<strong>value</strong>放入哈希表中。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/5b578a2e33a4f87536c7fe50f71ac01904ae689b26ee3e2751dac0144f009d77-8.jpg" alt="8.jpg"></p><p>第二步我们再遍历原链表，这次我们要将新链表的next和random指针给设置上。</p><p>参考代码如下，我这里将next指针的设置放在了第一个循环中，这个位置其实无所谓。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; um;</span><br><span class="line">    Node* newHead = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">    um[head] = newHead;</span><br><span class="line">    Node* pre2 = newHead;</span><br><span class="line">    Node* cur1 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur1) &#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(cur1-&gt;val);</span><br><span class="line">        um[cur1] = newNode;</span><br><span class="line">        pre2-&gt;next = newNode;</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">        pre2 = pre2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur1 = head;</span><br><span class="line">    Node* cur2 = newHead;</span><br><span class="line">    <span class="keyword">while</span>(cur1) &#123;</span><br><span class="line">        cur2-&gt;random = um[cur1-&gt;random];</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/" target="_blank" rel="noopener">Java-双指针-头插法</a><br><a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/" target="_blank" rel="noopener">Sort List （归并排序链表）</a><br><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/xiang-xi-tu-jie-ken-ding-kan-de-ming-bai-by-xixili/" target="_blank" rel="noopener">详细图解(肯定看的明白)</a><br><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/" target="_blank" rel="noopener">环形链表 II（双指针法，清晰图解）</a><br><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-1zhan-2kuai-man-zhi-zhen-fan-zhu/" target="_blank" rel="noopener">回文链表（1.栈，2.快慢指针+翻转）</a><br><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/liang-chong-shi-xian-tu-jie-138-fu-zhi-dai-sui-ji-/" target="_blank" rel="noopener">两种实现+图解 138. 复制带随机指针的链表</a></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h3><ol><li>栈的特点是后入先出。根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 <strong>DFS 深度搜索</strong>。</li><li>队列一般用于<strong>BFS广度搜索</strong>，类似一层一层的搜索。</li></ol><h3 id="栈常见题目"><a href="#栈常见题目" class="headerlink" title="栈常见题目"></a>栈常见题目</h3><h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h4><blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) —— 将元素 x 推入栈中。</li><li>pop() —— 删除栈顶的元素。</li><li>top() —— 获取栈顶元素。</li><li>getMin() —— 检索栈中的最小元素。</li></ul></blockquote><p>这个题目要在常数时间内检索到最小元素，那么可以借助额外的一个栈保存当前最小元素。其中<code>push</code>函数比较特殊，这里给出其实现，其余的均不给出了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;INT_MAX&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s.push(x);</span><br><span class="line">    <span class="comment">// 注意这个必须每次和top比较，不能拿个全局值</span></span><br><span class="line">    vec.push_back(min(vec.back(), x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h4><blockquote><p>根据<a href="https://baike.baidu.com/item/逆波兰式/128437" target="_blank" rel="noopener"> 逆波兰表示法</a>，求表达式的值。有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) <em> ( 3 + 4 ) 。该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) </em> ) 。</p></blockquote><p>我们一般看到的都是中缀表达式，但这对于计算机来说就很不友好了。例如$4+13/5$，计算机从左到右扫描的话，扫到13还要判断13以后是什么运算符，还要比较优先级。是比较麻烦的。但是转换为中缀表达式之后，即为<code>[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</code>，计算机可以按照栈里面的顺序处理，不需要考虑优先级，也不需要后退了。</p><p>对于本题的解决思路为：</p><ol><li>定义一个栈辅助计算；</li><li>当遇到运算符”+”、”-“、”*”、”/“时，从栈中pop出两个数字计算，运算结果入栈；否则将数字入栈。</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokens.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tokens.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> c = tokens[i];</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">"+"</span> || c==<span class="string">"-"</span> || c==<span class="string">"*"</span> || c==<span class="string">"/"</span>) &#123;</span><br><span class="line">            <span class="comment">// 弹出最前面两个元素</span></span><br><span class="line">            <span class="keyword">int</span> first = vec.back();</span><br><span class="line">            vec.pop_back();</span><br><span class="line">            <span class="keyword">int</span> two = vec.back();</span><br><span class="line">            vec.pop_back();</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">"+"</span>) vec.push_back(two+first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">"-"</span>) vec.push_back(two-first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">"*"</span>) vec.push_back(two*first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">"/"</span>) vec.push_back(two/first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vec.push_back(atoi(c.c_str()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></h4><blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p></blockquote><p>本题难点在于括号内嵌套括号，需要<strong>从内向外</strong>生成与拼接字符串，这与栈的<strong>先入后出</strong>特性对应。</p><p>构建辅助栈<code>stack</code>，遍历字符串<code>s</code>中每个字符<code>c</code>：</p><ul><li>当<code>c</code>为数字时，将数字字符转化为数字<code>multi</code>，用于后续倍数计算</li><li>当<code>c</code>为字母时，在<code>res</code>尾部添加<code>c</code></li><li>当 <code>c</code> 为<code>[</code> 时，将当前 multi 和 res 入栈，并分别置空置 0：<ul><li>记录此 <code>[</code> 前的临时结果 res 至栈，用于发现对应 <code>]</code> 后的拼接操作；</li><li>记录此 <code>[</code> 前的倍数 <code>multi</code> 至栈，用于发现对应 <code>]</code> 后，获取 <code>multi × [...]</code>字符串。</li><li>进入到新 <code>[</code> 后，res 和 multi 重新记录</li></ul></li><li>当 <code>c</code> 为 <code>]</code> 时，stack 出栈，拼接字符串 <code>res = last_res + cur_multi * res</code>，其中:<ul><li><code>last_res</code>是上个 <code>[</code> 到当前 <code>[</code> 的字符串，例如 <code>&quot;3[a2[c]]&quot;</code> 中的 <code>c</code>；</li><li><code>cur_multi</code>是当前 <code>[</code> 到 <code>]</code> 内字符串的重复倍数，例如<code>&quot;3[a2[c]]&quot;</code> 中的 2。</li></ul></li></ul><p>返回字符串<code>res</code>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; sta;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            num += c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) &#123;  <span class="comment">//遇到[压栈数字和字符串，置零置空</span></span><br><span class="line">            sta.push(make_pair(num, res));</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            res = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>) &#123;  <span class="comment">//遇到]出栈数字和字符串，组装</span></span><br><span class="line">            <span class="keyword">int</span> n = sta.top().first;  <span class="comment">//n指示的是res的循环次数，不是a的</span></span><br><span class="line">            <span class="built_in">string</span> a = sta.top().second;</span><br><span class="line">            sta.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="comment">// 将a拼接到n次res前面</span></span><br><span class="line">                a = a + res;</span><br><span class="line">            res = a;  <span class="comment">// 更新当前的已有字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></h4><blockquote><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">&gt;     <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这个题目明显是深度优先遍历的题目。深度优先遍历有三个关键点：</p><ol><li>遍历路径：假设目前所在的节点为<code>node</code>，则由该点向此点的邻居节点做深度搜索</li><li>遍历终止条件：若节点<code>node==NULL</code>，则返回<code>NULL</code>；若出现在哈希表中，则已经遍历过了，返回对应的新节点</li><li>如何避免重复遍历：在遍历的同时，使用一个哈希表记录原始节点和新节点的对应关系，这样若访问过了，直接返回对应的新节点即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; mp; <span class="comment">// 声明在外面</span></span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mp.count(node)) <span class="keyword">return</span> mp[node]; <span class="comment">// 如果已经访问过了，则直接从哈希表中取出对应的克隆节点返回</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> new_root = <span class="keyword">new</span> Node(node-&gt;val); <span class="comment">// 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span></span><br><span class="line">    mp[node] = new_root;  <span class="comment">// 哈希表存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp;e : node-&gt;neighbors) &#123; <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">        mp[node]-&gt;neighbors.push_back(cloneGraph(e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p></blockquote><p>该题目也是典型的深度优先遍历题目。</p><p><strong>深度优先遍历</strong>有如下三个关键点：</p><ol><li>遍历路径：假设目前指针在岛屿中的<code>(i,j)</code>点，那么由该点向此点的上下左右 <code>(i+1,j)</code>,<code>(i-1,j)</code>,<code>(i,j+1)</code>,<code>(i,j-1)</code> 做深度搜索。</li><li>遍历终止条件：<code>(i,j)</code>越过矩阵边界；<code>grid[i][j] == &#39;2&#39;</code>代表此分支已经越过岛屿边界</li><li>如何避免重复遍历：搜索岛屿的同时，执行 <code>grid[i][j] = &#39;2&#39;</code>，即将岛屿所有节点删除，以免之后重复搜索相同岛屿。</li></ol><p><strong>主循环（深度优先遍历不一定都对这个分析，因为本题在DFS的时候，会中断掉，所以需要分析）：</strong>遍历整个矩阵，当遇到<code>grid[i][j] == &#39;1&#39;</code> 时，从此点开始做深度优先搜索 dfs，岛屿数 count + 1 且在深度优先搜索中删除此岛屿。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=grid.size() || j&gt;=grid[<span class="number">0</span>].size()|| grid[i][j] != <span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">    infect(grid, i<span class="number">-1</span>, j);</span><br><span class="line">    infect(grid, i+<span class="number">1</span>, j);</span><br><span class="line">    infect(grid, i, j<span class="number">-1</span>);</span><br><span class="line">    infect(grid, i, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                infect(grid, i, j);                </span><br><span class="line">                nums++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4><blockquote><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p></blockquote><p>这个题目是典型的单调栈题目。单调栈分为单调递增栈和单调递减栈：</p><ol><li>单调递增栈，即栈中的元素都是单调不递减的。<ul><li>若新元素大于等于栈顶元素，则入栈</li><li>若新元素小于栈顶元素，则不断弹栈，直到新元素大于等于栈顶元素，将新元素入栈</li></ul></li><li>单调递减栈，即栈中的元素都是单调不递增的。<ul><li>若新元素小于等于栈顶元素，则入栈</li><li>若新元素大于栈顶元素，则不断弹栈，直到新元素小于等于栈顶元素，将新元素入栈</li></ul></li></ol><p>解决本问题需要借助<strong>单调递增栈+哨兵技巧</strong>。具体思路为：</p><p>首先，在栈中记录高度是不可以的，因为计算矩阵还需要计算宽度，而宽度是需要是由下标确定的。记录下标也可以从数组中得到对应的高度。因此应该记录的是下标。</p><p>其次，考虑找到第<code>i</code>个位置最大面积。是以<code>i</code>为中心，向左找第一个小于<code>heights[i]</code>的位置<code>left_i</code>；向右找第一个小于于<code>heights[i]</code>的位置<code>right_i</code>，那么对应的宽度为<code>right_i - left_i -1</code>，即最大面积为<code>heights[i] * (right_i - left_i -1)</code>，如下图所示：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/441ac778821dc26689b31466bced9f61ec241f092bf7e4f0f8699ef4fa3be1b2-1559826097853.png" alt="1559826097853.png"></p><p>这样的一个要求与单调递增栈的性质不谋而合。考虑新元素比栈顶元素严格小的情况，此时需要出栈</p><ol><li>新元素是出栈元素向后找第一个比其小的元素</li><li>新栈顶元素是出栈元素向前找第一个比其小的元素</li></ol><p>最后，这里需要借助哨兵技巧，这是因为：</p><ol><li>若输入是递增的话，则代码无法弹出计算面积，需要在<code>heights</code>数组后面加上一个<code>0</code>，这样就可以强迫栈内元素出栈计算面积了</li><li>考虑首元素计算时需要知道左边第一个小于它的元素位置，所以在<code>heights</code>数组前面加上一个<code>0</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 添加哨兵</span></span><br><span class="line">    heights.insert(heights.begin(), <span class="number">0</span>);</span><br><span class="line">    heights.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;heights.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 注意这个判断要用while，如果要用top必须让sta不等于空</span></span><br><span class="line">        <span class="keyword">while</span>(!sta.empty() &amp;&amp; heights[sta.top()]&gt;heights[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = heights[sta.top()];</span><br><span class="line">            sta.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i表示向后找第一个比其小的元素下标，sta.top()表示向前找第一个比其小的元素</span></span><br><span class="line">            ans = max(ans, (i-sta.top()<span class="number">-1</span>)*num);</span><br><span class="line">        &#125;</span><br><span class="line">        sta.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列常见题目"><a href="#队列常见题目" class="headerlink" title="队列常见题目"></a>队列常见题目</h3><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></h4><blockquote><p>使用栈实现队列的下列操作：</p><ul><li>push(x) — 将一个元素放入队列的尾部。</li><li>pop() — 从队列首部移除元素。</li><li>peek() — 返回队列首部的元素。</li><li>empty() — 返回队列是否为空。</li></ul></blockquote><p>使用两个栈，一个栈（<code>stackPush</code>）用于元素进栈，一个栈（<code>stackPop</code>）用于元素出栈；</p><p><code>push</code>的时候，直接<code>push</code>到<code>stackPush</code>栈中</p><p><code>pop()</code> 或者 <code>peek()</code> 的时候：</p><p>（1）如果 <code>stackPop</code> 里面有元素，直接从 <code>stackPop</code> 里弹出或者 <code>peek</code> 元素；</p><p>（2）如果 <code>stackPop</code> 里面没有元素，一次性将 <code>stackPush</code> 里面的所有元素倒入 <code>stackPop</code>。</p><p>为此，可以写一个 <code>shift</code> 辅助方法，一次性将 <code>stackPush</code> 里的元素倒入 <code>stackPop</code>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackPush;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackPop;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    stackPush.push(x);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackPop.empty()) &#123;  <span class="comment">// 只有当stackPop为空的时候，才会执行下面的转移操作</span></span><br><span class="line">        <span class="keyword">while</span>(!stackPush.empty()) &#123;</span><br><span class="line">            stackPop.push(stackPush.top());</span><br><span class="line">            stackPush.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shift();</span><br><span class="line">    <span class="keyword">int</span> val = stackPop.top();</span><br><span class="line">    stackPop.pop();</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shift();</span><br><span class="line">    <span class="keyword">return</span> stackPop.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stackPop.empty() &amp;&amp; stackPush.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a><a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 矩阵</a></h4><blockquote><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。</p></blockquote><p>广度优先搜索大概可以分为两种：</p><ol><li>对于<strong>「Tree 的 BFS」 （典型的「单源 BFS」）</strong>：首先把 root 节点入队，再一层一层遍历</li><li>对于<strong>「图 的 BFS」 （「多源 BFS」）</strong> 其实也是一样的，不过需要注意以下两点：<ul><li>Tree 只有 1 个 root，而图可以有多个源点，所以首先需要把多个源点都入队；</li><li>Tree 是有向的因此不需要标识是否访问过，而对于无向图来说，必须得标志是否访问过。并且为了防止某个节点多次入队，需要在其入队之前就将其设置成已访问！</li></ul></li></ol><p>那么对于本题而言，可以借助广度优先搜索完成，具体思路是首先将每个源点 0 入队，然后从各个 0 <strong>同时开始</strong>一圈一圈的向 1 扩散（每个 1 都是被离它最近的 0 扩散到的 ）。扩散的时候可以实时更新矩阵元素的值来几记录距离（即扩散的层次）并同时标志是否访问过。这里需要注意的是，需要首先将所有非 0 的元素统一设置为<code>-1</code>这个无效距离值来标记这个位置的<code>1</code>没有访问过。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="comment">// 先将所有的零入列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                q.push(make_pair(i, j));</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                matrix[i][j] = <span class="number">-1</span>; <span class="comment">// 表明没有被访问过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx&#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 开始由零一圈一圈的向外扩散</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front().first;</span><br><span class="line">        <span class="keyword">int</span> y = q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = x + dx[k];</span><br><span class="line">            <span class="keyword">int</span> j = y + dy[k];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;rows &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;cols &amp;&amp; matrix[i][j]==<span class="number">-1</span>) &#123;</span><br><span class="line">                matrix[i][j] = matrix[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.push(make_pair(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/150-ni-bo-lan-biao-da-shi-qiu-zhi-zhan-de-jing-dia/" target="_blank" rel="noopener">150. 逆波兰表达式求值:【栈的经典应用】详解</a><br><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/java-yi-dong-yi-jie-xiao-lu-gao-by-spirit-9-19/" target="_blank" rel="noopener">Java 易懂,易解,效率高</a><br><a href="https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/" target="_blank" rel="noopener">字符串解码（辅助栈法 / 递归法，清晰图解）</a><br><a href="https://leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode-solution/" target="_blank" rel="noopener">克隆图</a><br><a href="https://leetcode-cn.com/problems/number-of-islands/solution/number-of-islands-shen-du-you-xian-bian-li-dfs-or-/" target="_blank" rel="noopener">200. 岛屿数量（DFS / BFS）</a><br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/" target="_blank" rel="noopener">暴力解法、栈（单调栈、哨兵技巧）</a><br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/" target="_blank" rel="noopener">找两边第一个小于它的值</a><br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-by-ikaruga/" target="_blank" rel="noopener">【柱状图中最大的矩形】单调栈入门，使用单调栈快速寻找边界</a><br><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/shi-yong-liang-ge-zhan-yi-ge-zhuan-men-ru-dui-yi-g/" target="_blank" rel="noopener">负负得正，使用两个栈，一个专门入队，一个专门出队</a><br><a href="https://leetcode-cn.com/problems/01-matrix/solution/2chong-bfs-xiang-jie-dp-bi-xu-miao-dong-by-sweetie/" target="_blank" rel="noopener">2种BFS，详解DP， 🤷‍♀️必须秒懂！</a></p><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><h3 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h3><ol><li><p>移除最后一个1：<code>a = n&amp;(n-1);</code></p></li><li><p>获取最右端的一个1：<code>a = n&amp;(-n);</code></p></li><li><p>异或满足交换律且两个相同元素异或结果为0：<code>a=a^b^b=b^a^b;</code></p></li><li><p>整数的二进制编码：</p><ul><li>正数的编码为原码，如8的二进制编码为：00001000</li><li>负数的编码为最高位为1，其余位等于原码取反加1，如-8的二进制编码为：1…1111000</li></ul></li><li><p>两个数交换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b</span><br><span class="line">b = a^b</span><br><span class="line">a = a^b</span><br></pre></td></tr></table></figure></li><li><p><code>^</code>：相当于无进位的求和；<code>&amp;</code>相当于求每位的进位数。</p></li></ol><h3 id="常见题目-2"><a href="#常见题目-2" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h4><blockquote><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p></blockquote><p>这个题目比较简单，使用到了上面的规律3。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        num ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a></h4><blockquote><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p></blockquote><p>最简单的思路是统计数组元素二进制表达中每个位置1出现的次数。若某个位置1出现的次数不能被3整除，则说明目标元素的该位置为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num: nums) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">31</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num&amp;mask == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">        res = res&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        res += dp[i]%<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种思路是使用位运算符的性质。</p><p><strong>XOR异或运算符可以用来检测出现奇数次的位：</strong>0与任何数异或均为该数，而两个相同数异或结果为0。</p><script type="math/tex; mode=display">0 \land x=x \\x \land x = 0</script><p>以此类推，只有某个位置的数字出现奇数次时，该位的掩码才不为 0。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/xor.png" alt="img" style="zoom: 50%;"></p><p>因此，可以检测出出现一次的位和出现三次的位，但是要区分这两种情况。这个时候需要借助AND和NOT运算：为了区分出现一次的数字和出现三次的数字，使用两个位掩码：seen_once 和 seen_twice。思路是：</p><ul><li><p>仅当 seen_twice 未变时，改变 seen_once。</p></li><li><p>仅当 seen_once 未变时，改变seen_twice。</p></li></ul><p>可以看到，位掩码 <code>seen_once</code> 仅保留出现一次的数字，不保留出现三次的数字。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/three.png" alt="img" style="zoom:50%;"></p><p>对应的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seenOnce = <span class="number">0</span>, seenTwice = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">        seenOnce = ~seenTwice &amp; (seenOnce ^ num);</span><br><span class="line">        seenTwice = ~seenOnce &amp; (seenTwice ^ num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seenOnce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a></h4><blockquote><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p></blockquote><p>由异或性质可得，若将所有的数字进行异或，最终结果为只出现一次的那两个元素异或的结果。接下来考察其的某个非0位（比如最低非0位），那么只出现一次的两个数中，在这个位上一个为0，一个为1。由此可以将数组中的元素分成两部分，重新遍历，求两个异或值。参</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">        mask ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = mask &amp; (-mask);   <span class="comment">// 得到最右端的1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num1=<span class="number">0</span>, num2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num&amp;index)</span><br><span class="line">            num1 ^= num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num2 ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;num1, num2&#125;;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></h4><blockquote><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p></blockquote><p>该题考察的是上面的性质1。具体来说，每次都将最后一个1变成0，然后结果加1。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        n = n&amp;(n<span class="number">-1</span>);   <span class="comment">// 将最后一个为1变成0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></h4><blockquote><p>给定一个非负整数 <strong>num</strong>。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p></blockquote><p>这个题目可以使用动态规划来做。对于所有的数字，只有两类：</p><ol><li><p>奇数：二进制表示中，奇数一定比前面的那个偶数多一个1，因为多的就是最低位的 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例： </span><br><span class="line">0 = 0       1 = 1</span><br><span class="line">2 = 10      3 = 11</span><br></pre></td></tr></table></figure></li><li><p>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">2 = 10       4 = 100       8 = 1000</span><br><span class="line">3 = 11       6 = 110       12 = 1100</span><br></pre></td></tr></table></figure></li></ol><p>另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    result.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)   <span class="comment">// 奇数</span></span><br><span class="line">            result.push_back(result[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.push_back(result[i&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></h4><blockquote><p>颠倒给定的 32 位无符号整数的二进制位。比如输入<code>00000010100101000001111010011100</code>，输出<code>00111001011110000010100101000000</code>。</p></blockquote><p>依次颠倒即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--) &#123;</span><br><span class="line">        ans = ans&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        ans += n&amp;<span class="number">1</span>;</span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span>;   <span class="comment">// 右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. 数字范围按位与</a></h4><blockquote><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p></blockquote><p>按位相与的结果可以概括为：两个位的值都为1，按位与的结果才为 1，否则必为 0。可以得到两个结论：</p><ol><li>多个数字按位与，其结果中值为 1 的位绝对不会增加，只有可能减少。</li><li>多个数字按位与，其结果中值为 1 的位，在多个数字中的对应位必然也为 1。</li></ol><p>因题目传参用了有符号整型（实际上都是大于0的），忽略符号位后，还剩31位。从高位到低位依次编号为 0, 1, 2, 3, … 29, 30。首先来寻找一下n和m的二进制最长相同前缀，设这个前缀长度为x。因为<strong>加法只会影响连续的低位</strong>，所以 <code>[n,m]</code> 中的所有数字的长度为 x 的二进制前缀都是相等的。那也就导致，按位与的结果的长度x的二进制前缀也相同。</p><p>因为n和m的最长相同前缀长度为 x，此时 x 有两种情况：</p><ol><li>x = 31。即 n 和 m 完全相等。这种情况没啥好说的，答案就是 n&amp;m。这种情况太简单了，不做讨论。</li><li>0 &lt;= x &lt; 31。因为 n &gt;= m，所以 m 的第 x 位必然为 0，而 n 的第 x 为必然为 1。(不然就成 m &gt;= n 了)</li></ol><p>从 n 的后缀 0abcd… 累加到 m 的后缀 1hijk… 这个过程中，不管abcd…，hijk… 取值如何，必然要经过 10000…。0abcd… 和 10000… 使得答案中长度为 31-x 的后缀必然都为 0。</p><p>例如n 和 m 的二进制及最长前缀如下图所示，后缀 <strong>011 累加到 110 必然经过 100。011 和 100 保证了答案中长度为 3 的后缀必然均为 0。</strong></p><p><img src="/DataStructureAlgorithm/LeetCode总结/1598143339-uPRKJZ-image.png" alt="image.png" style="zoom:50%;"></p><p>所以对应的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 最高位开始</span></span><br><span class="line">    <span class="keyword">int</span> anw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(mask &gt; <span class="number">0</span> &amp;&amp; (m&amp;mask) == (n&amp;mask)) &#123; <span class="comment">//寻找相同前缀</span></span><br><span class="line">        anw |= m&amp;mask;  <span class="comment">// 将该位的结果使用或运算更新到anw的对应位置</span></span><br><span class="line">        mask &gt;&gt;= <span class="number">1</span>;  <span class="comment">// 判断下一个低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></h4><blockquote><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p></blockquote><p>这道题目如果采用暴力方法，肯定能够做出来，但是肯定会超时。如果采用滑窗的方法，那么何时收缩窗口，难以确定。所以该题目其实考察的是前缀和和位运算。</p><p>我们知道，一个数加上偶数不改变奇偶性，例如奇数+偶数=奇数，偶数+偶数=偶数。那么如果子串<code>[0,i]</code>奇偶性和<code>[0,j]</code>相同，那么子串<code>[i+1,j]</code>一定偶数。</p><p>只考虑每个元音的奇偶次数，可以用二进制进行记录：定义<code>aeiou</code> 分别对应二进制 <code>00001，00010，00100，01000，10000</code>。其中 0 表示对应元音出现了偶数次数，1 表示奇数。</p><p>从左到右遍历字符串，不断更新<code>dp</code>：<code>dp[pattern]</code> 的作用是用来记录当前索引值下对应的元音奇偶次数组合特征。例如：如果 pattern 为 10，也就是对应二进制<code>01010</code>，<code>dp[pattern] = 8</code>的意思为，当索引值为 8 的时候，e 和 o 都出现了奇数次，其它元音为偶数次。</p><p>根据异或运算规律，异或本身为 <code>0</code>，所以当重复出现偶数次，对应位变为 <code>0</code>，否则为 <code>1</code>。由这个规律可以断定，当再次出现这个 <code>pattern</code> 的时候，一定出现了偶数次。例如<code>pattern</code> 的值变化为 <code>31--&gt;30--&gt;28--&gt;29--&gt;31</code>，对应的二进制位 <code>[11111]--&gt;[11110]--&gt;[11100]--&gt;[11101]--&gt;[11111]</code>，此时对应的一个合理字符串变化为<code>aeiou</code> —&gt; <code>aeioua</code> —&gt;<code>aeiouae</code>—&gt;<code>aeiouaea</code>—&gt;<code>aeiouaeae</code>。由此可见，从 <code>aeiou</code> 到 <code>aeiouaeae</code> 这个过程中，多余出来的 <code>aeae</code> 为符合条件的字符串。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, pattern = <span class="number">0</span>, n = s.length();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(<span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="number">-1</span>);</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'e'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'i'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'o'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'u'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (~pos[pattern]) &#123;</span><br><span class="line">            ans = max(ans, i + <span class="number">1</span> - pos[pattern]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pos[pattern] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetcode/" target="_blank" rel="noopener">只出现一次的数字 II</a><br><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/ju-hao-li-jie-de-wei-yun-suan-si-lu-by-time-limit/" target="_blank" rel="noopener">巨好理解的位运算思路</a><br><a href="https://blog.csdn.net/a435262767/article/details/104748036/" target="_blank" rel="noopener">【leetcode】5337. 每个元音包含偶数次的最长子字符串( Find the Longest Substring Containing Vowels in Even Counts)</a><br><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/xiang-xi-jie-shi-by-will_never_die/" target="_blank" rel="noopener">小学生解释</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找模板"><a href="#二分查找模板" class="headerlink" title="二分查找模板"></a>二分查找模板</h3><p><strong>适用情况：</strong>给一个有序数组和目标值，找到第一个/最后一个/任何一次出现的索引，如果没有返回-1。时间复杂度$O(logn)$。</p><p>常使用的模板主要有三个，可通过下面几道典型题目进行总结练习：</p><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p><strong>模板一：在排序数组中查找目标元素任何一次出现的位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot, left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        pivot = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[pivot] == target) </span><br><span class="line">            <span class="keyword">return</span> pivot;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[pivot]) </span><br><span class="line">            right = pivot - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            left = pivot + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板二：在排序数组中查找目标元素的第一个位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end-begin)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            begin = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span> || nums[begin] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板三：在排序数组中查找目标元素的第一个位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end-begin+<span class="number">1</span>)/<span class="number">2</span>;  <span class="comment">// 这个地方注意</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            begin = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span> || nums[begin] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用模板的关键点在于：</strong></p><ol><li>确定mid元素和目标元素的关系；进而得到缩小区间的方法</li><li>由缩小区间的方法，判断出来是第几个模板</li><li>如果不是第一个模板，则需要对最终元素进行特殊处理</li><li>对其余特殊情况进行特殊处理</li></ol><h3 id="常见题目-3"><a href="#常见题目-3" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h4><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p></blockquote><p>考虑插入的位置为pos，则成立的条件为：</p><script type="math/tex; mode=display">nums[pos-1] < target <= nums[pos]</script><p>这个条件可以转换为：<strong>在一个有序数组中找第一个大于等于 target 的下标。</strong>套用模板一可以得到下面代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></h4><blockquote><p>编写一个高效的算法来判断 $m \times n$ 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul></blockquote><p>这个问题其实是与<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a>思想一致，只是需要将一维数组的下标转换为二维数字的下标即可。根据模板一参考代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool searchMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int target) &#123;</span><br><span class="line">    int m = matrix.size();</span><br><span class="line">    if (m == 0) return false;</span><br><span class="line">    int n = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    // 二分查找</span><br><span class="line">    int left = 0, right = m * n - 1;</span><br><span class="line">    int pivotIdx, pivotElement;</span><br><span class="line">    while (left &lt;= right) &#123;</span><br><span class="line">        pivotIdx = (left + right) / 2;</span><br><span class="line">        pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">        if (target == pivotElement) </span><br><span class="line">            return true;</span><br><span class="line">        else if (target &lt; pivotElement) </span><br><span class="line">            right = pivotIdx - 1;</span><br><span class="line">        else </span><br><span class="line">            left = pivotIdx + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></h4><blockquote><p> 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p></blockquote><p>这个明显可以使用模板二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 当前版本不是错误的</span></span><br><span class="line">        <span class="keyword">if</span>(!isBadVersion(mid)) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。请找出其中最小的元素。你可以假设数组中不存在重复元素。</p></blockquote><p>旋转数据查找这类题目的解决关键在于：</p><ol><li>通过画图将问题模型抽象为下图：</li></ol><p><img src="/DataStructureAlgorithm/LeetCode总结/33834ed636a0fcd634b0b790cb6a096ac935b3a0d4159e32259638d19c73dd3d-捕获5.PNG" alt="捕获5.PNG" style="zoom:80%;"></p><ol><li>考虑和最后一个元素比较大小</li><li>考虑旋转点在0，也就是没有任何旋转的特殊情况</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end =  nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; nums[end])</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; nums[end])  <span class="comment">// 可以这样写，因为while条件，决定了cur!=end</span></span><br><span class="line">            end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。请找出其中最小的元素。注意数组中可能存在重复的元素。</p></blockquote><p>这个题目是上一道题目的区别在于，该题目的元素是可以重复的。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/4e410caf37485a65a95b6af228b564464099cf430ca695872125f0b13a147b19-捕获6.PNG" alt="捕获6.PNG"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end =  nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; nums[end])</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; nums[end])</span><br><span class="line">            end = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 无法判断mid的位置，可能位于最小值的前面，也可能后面。唯一可以确定的是最小值在end的左边</span></span><br><span class="line">            end--;   <span class="comment">// 跟上一题题解的区别</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 (不包含重复元素)</p></blockquote><p>这个题目和上两个题目不同点在于该题目是搜索特定元素，而前两个题目是找到最小元素值。</p><p>解题思路是：根据<code>arr[mid]</code>与<code>arr[end]</code>的值大小关系，划分出完全有序部分和部分有序部分。接着对于前半段有序的情况，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>；若是后半段有序，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[end]) &#123;  <span class="comment">// mid到end有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[end]) <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 从start到mid有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; target&gt;=nums[start])  <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。(包含重复元素)</p></blockquote><p>这个题目和上一个题目的不同点在于该题目中的元素是可以重复的。</p><p>解题思路是：根据<code>arr[mid]</code>与<code>arr[end]</code>的值大小关系，划分出完全有序部分和部分有序部分。接着对于前半段有序的情况，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>；若是后半段有序，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[end]) &#123;  <span class="comment">// mid到end有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[end]) <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[end]) &#123;  <span class="comment">// 从start到mid有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; target&gt;=nums[start])  <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">// 无法判断哪一个是单调区间，极端情况下，退化为从end到start的遍历查找</span></span><br><span class="line">            end--;  <span class="comment">// 跟上一题题解的区别</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/tong-guo-hua-tu-geng-neng-shen-ke-li-jie-er-fen-fa/" target="_blank" rel="noopener">通过画图来深刻理解二分法</a><br><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/tong-guo-hua-tu-lai-shen-ke-li-jie-er-fen-fa-by-ch/" target="_blank" rel="noopener">通过画图来深刻理解二分法</a></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>原理可以参考<a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a>。</p><p>C++代码可以参考<a href="https://github.com/zdaiot/DataStructure-And-Algorithm" target="_blank" rel="noopener">DataStructure-And-Algorithm</a>。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划：是一种解决问 题的思想，大规模问题的结果，是由小规模问 题的结果运算得来的。动态规划可用递归来实现(Memorization Search)。递归只是一种程序的实现方式。</p><h3 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h3><p><strong>使用场景，需要满足几个条件：</strong></p><ol><li><p>满足以下条件之一：</p><p>求最大/最小值（Maximum/Minimum ）</p><p>求是否可行（Yes/No ）</p><p>求可行个数（Count(*) ）</p></li><li><p>最优子结构（如果不能利用子问题的最优解获得整个问题的最优解，那么这种问题就不具有最优子结构。简单来说后面阶段的状态要能够通过前面阶段的状态推导出来，对应的一定能写出来状态转移方程）</p></li><li><p>重复子问题</p></li><li><p>满足不能排序或者交换（Can not sort / swap ）</p></li></ol><p>如题：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a> 位置可以交换，所以不用动态规划</p><p><strong>四点要素：</strong></p><ol><li>状态 State：灵感，创造力，存储<strong>小规模问题</strong>的结果</li><li>方程 Function：状态之间的联系，怎么通过小的状态，来算大的状态</li><li>初始化 Intialization：最极限的小状态是什么，起点</li><li>答案 Answer：最大的那个状态是什么，终点</li></ol><blockquote><p>动态规划的tabel通常会为长度+1，<code>tabel[0]</code>的初始化很重要，通常可以简化很多操作。但是这样操作的时候记住遍历原数组的时候，下标减1。</p></blockquote><p><strong>常见四种类型：</strong></p><ol><li>矩阵类型（10%）</li><li>序列类型（40%）</li><li>两个序列类型（40%）</li><li>零钱和背包（10%）</li></ol><blockquote><p>贪心算法大多题目靠背答案，所以如果能用动态规划就尽量用动规，不用贪心算法。</p></blockquote><h3 id="矩阵类型（10-）"><a href="#矩阵类型（10-）" class="headerlink" title="矩阵类型（10%）"></a>矩阵类型（10%）</h3><h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h4><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p></blockquote><p>这是一个典型的动态规划问题。</p><ol><li>状态State：用<code>f[i][j]</code>表示从三角顶部走到位置<code>(i,j)</code>的最小路径和。这里的位置<code>(i,j)</code>表示第 i 行第 j 列（下标从0开始）</li><li>方程：若<code>j=0</code>，则<code>f[i][j]=f[i−1][0]+c[i][0]</code>；若<code>j=i</code>，则<code>f[i][j]=f[i−1][i−1]+c[i][i]</code>；<code>f[i][j] = min(f[i−1][j−1], f[i−1][j]) + c[i][j]</code>，<code>c[i][j]</code>表示位置<code>(i,j)</code>对应的元素值。需要注意第 <code>i</code> 行有 <code>i+1</code> 个元素，在计算状态转移的时候注意不要</li><li>初始化：<code>f[0][0]</code></li><li>答案：<code>max(f[n-1][:])</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];   <span class="comment">// j=0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];  <span class="comment">// j=i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *min_element(f[n - <span class="number">1</span>].begin(), f[n - <span class="number">1</span>].end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾方法一中的状态转移方程，可以发现<code>f[i][j]</code>只与<code>f[i-1][..]</code>有关，而与<code>f[i-2][..]</code>及之前的状态无关。可以使用两个长度为$n$的一位数组进行，根据$i$的奇偶性进行转移。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/image-20200910195806939.png" alt="image-20200910195806939"></p><p>优化空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> curr = i % <span class="number">2</span>;   <span class="comment">// 分奇偶性</span></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">1</span> - curr;</span><br><span class="line">        f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];  <span class="comment">// j=0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            f[curr][j] = min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle[i][i];  <span class="comment">// j=i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *min_element(f[(n - <span class="number">1</span>) % <span class="number">2</span>].begin(), f[(n - <span class="number">1</span>) % <span class="number">2</span>].end());  <span class="comment">// 注意这个结尾的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><blockquote><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。</p></blockquote><p>很明显这个题目是求最优解的；存在最优子结构；并且存在重复子问题（若采用回溯法，相同子路径会重复出现）。可以使用动态规划来求解。按照上面所说的四个要素：</p><ol><li>状态State：<code>f[x][y]</code>为从起点走到 x,y 的最短路径</li><li>方程：<code>f[x][y] = min(f[x-1][y], f[x][y-1]) + A[x][y]</code></li><li>初始化：<code>f[0][0] = A[0][0]、f[i][0] = sum(0,0 -&gt; i,0)、 f[0][i] = sum(0,0 -&gt; 0,i)</code></li><li>答案：<code>f[m-1][n-1]</code></li></ol><p>其实，仔细分析状态转移方程，发现<code>f[x][y]</code>只与上一行正上方元素和该行左边元素有关，因此可以省略掉<code>x</code>维，使用一维数组代替二维数组完成动态规划。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(grid[<span class="number">0</span>].size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)</span><br><span class="line">                vec[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                vec[j] = vec[j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                vec[j] = vec[j] + grid[i][j]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                vec[j] = min(vec[j], vec[j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><blockquote><p>一个机器人位于一个 m x n 网格的左上角。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。 问总共有多少条不同的路径？</p></blockquote><p>这个问题可以转换为，最多有多少条不同的路径，所以是一个求最优解的问题；存在最优子结构；假设<code>f[x][y]</code>表示从 x 到 y 最多有多少条路径，那么在求解<code>f[x+1][y]、f[x][y+1]</code>都需要求解<code>f[x][y]</code>，所以存在重复子问题，可以使用动态规划解决。按照上面所说的四个要素：</p><ol><li>定义State：<code>f[x][y]</code>表示从 x 到 y 最多有多少条路径</li><li>方程：<code>f[x][y]=f[x][y-1]+f[x-1][y]</code></li><li>初始化：<code>f[i][0]=f[0][i]=1</code></li><li>答案：<code>f[m-1][n-1]</code></li></ol><p>仔细分析状态转移方程，发现<code>f[x][y]</code>只与上一行正上方元素和该行左边元素有关，因此可以省略掉<code>x</code>维，使用一维数组代替二维数组完成动态规划。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;=<span class="number">0</span> || n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)</span><br><span class="line">                vec[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vec[j] = vec[j] + vec[j<span class="number">-1</span>];</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h4><blockquote><p>一个机器人位于一个 m x n 网格的左上角 。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p></blockquote><p>这个问题和上面问题的区别在于，这里加上了一个障碍物。使用动态规划，按照上面所说的四个要素：</p><ol><li>定义State：<code>f[x][y]</code>表示从 x 到 y 最多有多少条路径。若当前位置为障碍物，则<code>f[x][y]=0</code>，下面讨论没有障碍物时候的状态转移以及初始化</li><li>方程：<code>f[x][y]=f[x][y-1]+f[x-1][y]</code></li><li>初始化：<code>f[0][0]=1、f[i][0]=f[i-1][0]、f[0][i]=f[0][i]</code>，这个初始化因为障碍物存在，不能全部置为1</li><li>答案：<code>f[m-1][n-1]</code></li></ol><p>仔细分析状态转移方程，发现<code>f[x][y]</code>只与上一行正上方元素和该行左边元素有关，因此可以省略掉<code>x</code>维，使用一维数组代替二维数组完成动态规划。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(obstacleGrid[<span class="number">0</span>].size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;obstacleGrid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;obstacleGrid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">                vec[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)</span><br><span class="line">                    vec[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                    vec[j] = vec[j] + vec[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列类型（40-）"><a href="#序列类型（40-）" class="headerlink" title="序列类型（40%）"></a>序列类型（40%）</h3><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h4><blockquote><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><p>这应该是最简单的动态规划问题。按照上面四个要素进行分析：</p><ol><li>状态State：<code>f(x)</code>爬到台阶 x 有多少种方法</li><li>方程：<code>f(x)=f(x-1)+f(x-2)</code></li><li>初始化：<code>f(1)=1、f(2)=2</code></li><li>答案：<code>f(n)</code></li></ol><p>分析状态转移方程，发现<code>f(x)</code>只与前两个状态有关，所以可以用两个变量保存这两个状态即可。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> vec[n<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = vec[<span class="number">0</span>] + vec[<span class="number">1</span>];</span><br><span class="line">        vec[<span class="number">0</span>] = vec[<span class="number">1</span>];</span><br><span class="line">        vec[<span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h4><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。</p></blockquote><p>这个题目有两种解法。</p><p>第一种方法是借助<strong>贪心算法</strong>，使用一个变量<code>k</code>记录能够跳到的<strong>最远元素的下标</strong>（从0开始）。依次遍历数组的元素，若<code>k</code>大于等于当前下标，证明可以跳到该元素，然后看是否需要更新<code>k</code>以及是否已经可以跳到最后一个位置了；若<code>k</code>小于当前下标，则证明无法跳到该元素，返回<code>false</code>。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= i) &#123;</span><br><span class="line">            k = max(k, nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= nums.size()<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法是借助动态规划，该方法求解过程并没有贪心简单。还是按照上面四个要素进行分析：</p><ol><li>状态State：<code>f[i]</code>表示 i 下标能不能到达</li><li>方程：<code>f[i] = OR(f[j],j&lt;i&amp;&amp;j能跳到i)</code> 判断之前所有的点最后一跳是否<strong>存在</strong>能跳到当前点的（<code>OR</code>表示存在）。</li><li>初始化：<code>f(0)=1</code></li><li>答案：<code>f(n-1)</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(n, <span class="literal">false</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; j+nums[j]&gt;=i) &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></h4><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p></blockquote><p>跟上一道题目一样，这也是典型的<strong>贪心算法，每次都是贪心的选择最远距离，通过局部最优解得到全局最优解。</strong>这里的贪心有两种方法。</p><p><strong>第一种方法是反向查找出发位置。</strong>有多个位置通过跳跃可以达到最后一个位置，直观上，可以贪心地选择距离最后一个位置最远的那个位置，可以从左到右遍历数组，选择第一个满足要求的位置。找到最后一步跳跃前所在的位置之后，继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。这种思路需要遍历多遍（时间复杂度为$O(n^2)$），C++会超时，这里给出Java版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> position = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                position = i;</span><br><span class="line">                steps++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种方法是正向查找可达到的最大位置。</strong>假设第一个元素最远可以跳 j 个位置，将从这 j 个位置开始能够跳到的最远距离记做 sum；使用 end 变量（初始化为0）记录第一步可以跳的最远距离；依次遍历所有位置，若当前位置下标大于 end，则证明需要再跳一步，此时需要更新end和step。另外，我们不会遍历到最后一个元素，因为若刚好<code>end=n-1</code>，那么遍历到最后一个元素时，会凭空的多一个step。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++) &#123;  <span class="comment">// 注意没有遍历到最后一个元素</span></span><br><span class="line">        sum = max(sum, i+nums[i]); <span class="comment">// 用于记录该step能跃过的所有节点中，下一个能跳过的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(i == end) &#123;  <span class="comment">// 需要再跳，才有可能到最终元素，注意更新end</span></span><br><span class="line">            end = sum;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><blockquote><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p></blockquote><p>对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。根据这样的思路，可以使用动态规划的方法解决本题。</p><ol><li>状态State：定义<code>dp[i][j]</code>为<code>s[i, j]</code>是否为回文子串</li><li>方程：<code>dp[i][j] = dp[i+1][j-1] and (s[i]==s[j])</code></li><li>初始化：<code>dp[i][i]=1、dp[i][j]=s[i][j] if j-i=1</code></li><li>答案：若<code>dp[i][j]=1</code>，则判断是否需要更新最终的最长回文子串答案</li></ol><p><strong>这道题需要注意的是<code>dp[i][j]</code>的更新次序</strong>，参考代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;n; l++) &#123;  <span class="comment">// j-i的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+l&lt;n; i++) &#123; <span class="comment">// 开始坐标，注意停止条件</span></span><br><span class="line">            <span class="keyword">int</span> j = i+l; <span class="comment">// 结束坐标</span></span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = s[i]==s[j];</span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i]==s[j]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; l+<span class="number">1</span>&gt;ans.size())</span><br><span class="line">                ans = s.substr(i, l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. 分割回文串 II</a></h4><blockquote><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。返回符合要求的最少分割次数。</p></blockquote><ol><li>状态State：<code>dp[i]</code>表示前缀子串 <code>s[0,i]</code> 分割成若干个回文子串所需要最小分割次数</li><li>方程：若<code>s[0,i]</code>本身为回文串，则<code>d[i]=0</code>；否则<code>dp[i] = min([dp[j] + 1 for j in range(i) if s[j+1, i] 是回文])</code></li><li>初始化：<code>dp[0]=0</code></li><li>答案：<code>s[n-1]</code></li></ol><p>可以看到这个问题其实包含了<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a>子问题，与之相似的<a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a>却是一个回溯法解决的题目。该题目的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;n; l++) &#123;    <span class="comment">// j-i的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+l&lt;n; i++) &#123;   <span class="comment">// 开始坐标，注意停止条件</span></span><br><span class="line">            <span class="keyword">int</span> j = i + l;   <span class="comment">// 结束坐标</span></span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = s[i]==s[j];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i]==s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        vec[i] = i;  <span class="comment">// 初始化最大所需切割次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;  <span class="comment">// 若s[o,i]为回文串</span></span><br><span class="line">            vec[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j+<span class="number">1</span>][i] == <span class="number">1</span>)</span><br><span class="line">                vec[i] = min(vec[i], vec[j] + <span class="number">1</span>);  <span class="comment">// 找到最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h4><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。子序列下标可以不连续。</p></blockquote><ol><li>状态State：<code>f[i]</code>表示从0开始到 i 结尾的最长序列长度</li><li>方程：<code>f[i] = max(f[j])+1 ,a[j]&lt;a[i] and j&lt;i</code></li><li>初始化：<code>f[i]=1</code></li><li>答案：<code>max(f[0]...f[n-1])</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 特殊输入测试</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                dp[i] = max(dp[j]+<span class="number">1</span>, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h4><blockquote><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p></blockquote><ol><li>状态State：<code>f[i]</code>表示前 i 个字符是否可以被划分</li><li>方程：<code>f[i] = f[j] &amp;&amp; s[j~i-1] in wordDict, j&lt;i</code>（注意下标）</li><li>初始化：<code>f[0]=true</code></li><li>答案：<code>f[n]</code></li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> wordDictSet = <span class="built_in">unordered_set</span> &lt;<span class="built_in">string</span>&gt; ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word: wordDict) &#123;</span><br><span class="line">        wordDictSet.insert(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dp = <span class="built_in">vector</span> &lt;<span class="keyword">bool</span>&gt; (s.size() + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) &#123;   <span class="comment">// 注意下标</span></span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个序列类型（40-）"><a href="#两个序列类型（40-）" class="headerlink" title="两个序列类型（40%）"></a>两个序列类型（40%）</h3><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h4><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p></blockquote><ol><li>状态State：<code>dp[i][j]</code>为text1前 i 个和text2前 j 个字符最长公共子序列</li><li>方程：若<code>text1[i-1]=text2[j-1]</code>，则<code>dp[i][j]=dp[i-1][j-1]+1</code>；否则<code>dp[i][j]=max(dp[i-1][j], dp[i][j-1])</code></li><li>初始化：<code>dp[0][i]=dp[i][0]=0</code></li><li>答案：<code>dp[m][n]</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = text1.size();</span><br><span class="line">    <span class="keyword">int</span> length2 = text2.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(length1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(length2+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=length2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h4><blockquote><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p></blockquote><ol><li><p>状态State：<code>dp[i][j]</code>为word1前 i 个字符编辑为word2前 j 个字符最少需要多少次操作</p></li><li><p>方程：若<code>word1[i-1]==word2[j-1]</code>，则<code>dp[i][j]=dp[i-1][j-1]</code>；否则<code>dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code>。</p><p>对<code>dp[i-1][j-1]</code>表示替换操作，<code>dp[i-1][j]</code>表示删除操作，<code>dp[i][j-1]</code>表示插入操作的补充理解：以 word1 为 “horse”，word2 为 “ros”，求<code>dp[5][3]</code> 为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：</p><ul><li><code>dp[i-1][j-1]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符<code>word1[4]</code>（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，<code>word2[2]</code>）</li><li><code>dp[i][j-1]</code>，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</li><li><code>dp[i-1][j]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</li></ul></li><li><p>初始化：<code>dp[0][i] = i、dp[i][0] = i;</code></p></li><li>答案：<code>dp[m][n]</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = word1.size();</span><br><span class="line">    <span class="keyword">int</span> length2 = word2.size();</span><br><span class="line">    <span class="keyword">if</span>(length1*length2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> word1.size()+word2.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(length1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(length2+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length2; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=length1; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=length2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> minV = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                minV = min(minV, dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp[i][j] = minV + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零钱和背包（10-）"><a href="#零钱和背包（10-）" class="headerlink" title="零钱和背包（10%）"></a>零钱和背包（10%）</h3><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h4><blockquote><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p></blockquote><ol><li>状态State：<code>dp[i]</code>组成总金额为 i 所需的最少硬币个数</li><li>方程：<code>dp[i]=min(dp[i-coins[j]]+1)</code></li><li>初始化：<code>dp[0]=0、dp[i]=amount+1(i&gt;0)</code></li><li>答案：若<code>dp[amount]==amount+1</code>，则返回<code>-1</code>；否则返回<code>dp[amount]</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>, amount+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;coins.size(); j++)</span><br><span class="line">            <span class="keyword">if</span>(i-coins[j] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i] = min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="92-背包问题"><a href="#92-背包问题" class="headerlink" title="92. 背包问题"></a><a href="https://www.lintcode.com/problem/backpack/description" target="_blank" rel="noopener">92. 背包问题</a></h4><blockquote><p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]。你不可以将物品进行切割。</p></blockquote><ol><li>状态State：<code>dp[i][j]</code>表示前<code>i</code>个物品，能不能填满容量为<code>j</code>的背包。</li><li>方程：<code>dp[i][j] = dp[i-1][j] OR dp[i-1][j-A[i-1]]</code>。注意<code>i</code>表示前<code>i</code>个物品，换算到下标时为<code>i-1</code></li><li>初始化：<code>dp[0][0]=True</code></li><li>答案：<code>j if dp[m-1][j]=1 else -1 for j in range(m, -1, -1)</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j-A[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[n][j])</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，本题所用的存储空间可以优化。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=A[i<span class="number">-1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-A[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[j])</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">01背包问题</a></h4><blockquote><p>有 <em>N</em> 件物品和一个容量是 <em>V</em> 的背包。每件物品只能使用一次。第 <em>i</em> 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输入第一行N、V分别表示物品数量和背包容积；接下来有N行，每行两个整数$v_i,w_i$，分别表示第$i$个物品的体积和价值。输出最大价值。</p></blockquote><p>这个问题是典型的动态规划问题。最大的特点是每一件物品只能使用一次。</p><ol><li>状态State：定义<code>f[i][j]</code>为所有选法集合中，只从前<code>i</code>个物品中选，并且总体积 $\leq j$ 的选法集合，它的值是这个集合中每一个选法的最大值。</li><li>方程：<code>f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i] if j&gt;=v[i])</code>。其中<code>f[i-1][j]</code>表示不选第<code>i</code>个物品的集合中的最大值；<code>f[i-1][j-v[i]]+w[i]</code>表示选第<code>i</code>个物品的集合中的最大值。</li><li>初始化：<code>f[0][0]=0</code></li><li>答案：<code>f[N][V]</code></li></ol><p>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">// n goods</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v)</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化之后的代码实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">// n goods</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=v; j--) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">完全背包问题</a></h4><blockquote><p>有 <em>N</em> 件物品和一个容量是 <em>V</em> 的背包。每件物品都有无限件可用。第 <em>i</em> 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输入第一行N、V分别表示物品数量和背包容积；接下来有N行，每行两个整数$v_i,w_i$，分别表示第$i$个物品的体积和价值。输出最大价值。</p></blockquote><p>该题目和上一个题目区别在于本题的每件物品可以重复使用。同理可以采用动态规划解决该问题。</p><ol><li>状态State：定义<code>f[i][j]</code>为所有选法集合中，只从前<code>i</code>个物品中选，并且总体积 $\leq j$ 的选法集合，它的值是这个集合中每一个选法的最大值。</li><li>方程：<code>f[i][j] = max(f[i-1][j], f[i-1][j-v[i]*k]+w[i]*k if j&gt;=v[i]*k)</code>。其中<code>f[i-1][j]</code>表示不选第 i 个物品的集合中的最大值；<code>f[i-1][j-v[i]*k]+w[i]*k</code>表示选第<code>i</code>个物品<code>k</code>次的集合中的最大值。</li><li>初始化：<code>f[0][0]=0</code></li><li>答案：<code>f[N][V]</code></li></ol><p>上一道题中，逆序遍历体积是为了保证更新当前状态时，用到的状态是上一轮的状态，保证每个物品只有一次或零次；在这里，因为每个物品可以取任意多次，所以不再强求用上一轮的状态，即本轮放过的物品，在后面还可以再放，所以可以顺序遍历体积。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v; j&lt;=m; j++) &#123;</span><br><span class="line">            <span class="comment">//dp[j] = max(dp[j], dp[j-v]+w);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=j/v; k++)</span><br><span class="line">               dp[j] = max(dp[j], dp[j-k*v]+w*k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/lanchunhui/article/details/52480106" target="_blank" rel="noopener">最优子结构（optimal substructure）</a><br><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/dong-tai-gui-hua-by-liweiwei1419-2/" target="_blank" rel="noopener">动态规划（Java、Python）</a><br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">动态规划、中心扩散、Manacher 算法</a><br><a href="https://blog.csdn.net/ZK_J1994/article/details/72809260" target="_blank" rel="noopener">Python列表解析配合if else</a><br><a href="https://www.acwing.com/solution/content/3986/" target="_blank" rel="noopener">AcWing 3. 完全背包问题—一维动态规划转移过程模拟 </a></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法一般用来解决需要 “找到要做某事的最小数量” 或 “找到在某些情况下适合的最大物品数量” 的问题，且提供的是无序的输入。</p><h2 id="递归思维"><a href="#递归思维" class="headerlink" title="递归思维"></a>递归思维</h2><h3 id="理论-3"><a href="#理论-3" class="headerlink" title="理论"></a>理论</h3><p>递归是一种应用非常广泛的算法（或者编程技巧）。递归分为两个步骤：<strong>去的过程叫“递”，回来的过程叫“归”</strong>。</p><p>当问题满足如下三个条件时，则适合使用递归解决：</p><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了<strong>数据规模</strong>不同，求解思路完全一样</li><li>存在递归终止条件。另外，还需要注意的是，要通过几个边界值例子，看终止条件是否足够。</li></ol><p>写递归代码有两个最关键的步骤：</p><ol><li>写出递推公式</li><li>找到终止条件</li></ol><p>理解递归代码需要把握住如下几点：</p><ol><li>如果试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区</li><li>如果一个问题 A 可以分解为若干子问题 B、C、D，<strong>可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，</strong>理解起来就简单多了。</li><li>因此，<strong>编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></li></ol><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。<strong>所有的递归代码都可以改为迭代循环的非递归写法。</strong></p><h3 id="常见题目-4"><a href="#常见题目-4" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h4><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p></blockquote><p>这道题可以采用递归的方式解决。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseStringCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    swap(s[start], s[end]);</span><br><span class="line">    reverseStringCore(s, start+<span class="number">1</span>, end<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    reverseStringCore(s, <span class="number">0</span>, s.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以采用循环以及交换元素的方式解决，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, end=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end) &#123;</span><br><span class="line">        swap(s[start], s[end]);</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h4><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p></blockquote><p>可以采用递归方法解决这个问题，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairsCore</span><span class="params">(ListNode* first, ListNode* two)</span> </span>&#123;</span><br><span class="line">    ListNode* third = two-&gt;next;</span><br><span class="line">    two-&gt;next = first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(third &amp;&amp; third-&gt;next)</span><br><span class="line">        first-&gt;next = swapPairsCore(third, third-&gt;next);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        first-&gt;next = third;</span><br><span class="line">    <span class="keyword">return</span> two;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> swapPairsCore(head, head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II</a></h4><blockquote><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p></blockquote><p>根据二叉树的性质，若根节点的值为$i$，则左子树的范围为$1\sim i-1$，右子树的范围为$i+1 \sim n$，且左子树和右子树也同样为二叉搜索树，因此可以递归的解决这个问题。</p><p>定义<code>generateTrees(start, end)</code>函数表示当前值的集合<code>[start,end]</code>，返回序列<code>[start,end]</code>生成的所有可行的二叉搜索树（使用<code>vector</code>表示，每个值均为可行二叉搜索树的根节点）。考虑枚举<code>[start,end]</code>中的值<code>i</code>为当前二叉搜索树的根，那么序列划分为了<code>[start,i−1]</code>和<code>[i+1,end]</code>两部分。递归调用这两部分，即<code>generateTrees(start, i - 1)</code>和<code>generateTrees(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，那么最后一步只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; generateTreesCore(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">    <span class="comment">// 某棵树终止</span></span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++) &#123;  <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; leftV = generateTreesCore(start, i<span class="number">-1</span>);  <span class="comment">// 获得所有可行的左子树集合（存储根节点）</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; rightV = generateTreesCore(i+<span class="number">1</span>, end);   <span class="comment">// 获得所有可行的右子树集合（存储根节点）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> nodeL:leftV) &#123;   <span class="comment">// 遍历每一个可行左子树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> nodeR:rightV) &#123;  <span class="comment">// 遍历每一个可行右子树</span></span><br><span class="line">                TreeNode* node = <span class="keyword">new</span> TreeNode(i);   <span class="comment">// 接到根节点上，形成一棵树，放到本次迭代的vecotr中</span></span><br><span class="line">                node-&gt;left = nodeL;</span><br><span class="line">                node-&gt;right = nodeR;</span><br><span class="line">                res.push_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是所有可行搜索树的根节点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    res = generateTreesCore(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h4><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p></blockquote><p>这道题其实可以用循环来做，但是一般来说，这是一道很典型的递归问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span> || N==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fib(N<span class="number">-1</span>) + fib(N<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口思想"><a href="#滑动窗口思想" class="headerlink" title="滑动窗口思想"></a>滑动窗口思想</h2><h3 id="理论-4"><a href="#理论-4" class="headerlink" title="理论"></a>理论</h3><p>这类题目更像是双指针的升级版，滑动窗口的核心是维护一个窗口集，根据窗口集来进行处理。核心步骤包括：</p><ol><li>右指针右移，窗口数据更新（注意移动的范围）</li><li>判断窗口是否需要收缩</li><li>左指针右移，窗口数据更新</li><li>根据题意计算结果</li></ol><h3 id="常见题目-5"><a href="#常见题目-5" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><blockquote><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p></blockquote><p>很明显，这个题目需要用滑动窗口去做。在 S 上滑动窗口，通过移动右指针不断扩张窗口。当窗口包含 T 全部所需的字符后，如果能收缩，就收缩窗口得到最小窗口。而判断是否包含 T 所需的全部字符，需要借助哈希表记录所有字符以及出现的位置。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; need, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p:need) &#123;  <span class="comment">// 注意必须是need循环，window可能字符并不全</span></span><br><span class="line">        <span class="keyword">if</span>(window[p.first] &lt; p.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;  <span class="comment">// need 存储 t 每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t.size(); i++)</span><br><span class="line">        need[t[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;  <span class="comment">// 注意这个初始值，是为了使用++right，而不是right++，保证统计windows时下标与need.find一致</span></span><br><span class="line">    <span class="keyword">int</span> ansL=<span class="number">-1</span>, len=INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span>&lt;<span class="keyword">int</span>(s.size())) &#123;  <span class="comment">// 注意这个right的取值</span></span><br><span class="line">        <span class="keyword">if</span>(need.find(s[++right]) != need.end()) &#123;  <span class="comment">// 右移，注意window只存储了t中出现的字符</span></span><br><span class="line">            window[s[right]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(judge(need, window) &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; len) &#123;   <span class="comment">// 记录最小字符子串的开始坐标和长度，上面用的是++right，所以这里要加1</span></span><br><span class="line">                len = right-left+<span class="number">1</span>;</span><br><span class="line">                ansL = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need.find(s[left]) != need.end())   <span class="comment">// 左移，注意window只存储了t中出现的字符</span></span><br><span class="line">                window[s[left]]--;</span><br><span class="line"></span><br><span class="line">            left++;  <span class="comment">// 注意这个left的位置，不要放在上面的if条件里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansL&gt;<span class="number">-1</span>?s.substr(ansL, len):<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的空间复杂度可以优化，使用一个哈希表，哈希表的每个字符对应的值含义为：</p><ol><li>若大于0，则滑动窗口中该字符还应该出现几次</li><li>若等于0，则滑动窗口中该字符次数的次数正好</li><li>若小于0，则滑动窗口中该字符多出现了几次</li></ol><p>对应的若哈希表中的所有值均小于等于0，则应该缩小窗口，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; need)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p:need) &#123;  <span class="comment">// 注意必须是need循环，window可能字符并不全</span></span><br><span class="line">        <span class="keyword">if</span>(p.second &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;  <span class="comment">// need 存储 t 每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t.size(); i++)</span><br><span class="line">        need[t[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;  <span class="comment">// 注意这个初始值，是为了使用++right，而不是right++，保证统计windows时下标与need.find一致</span></span><br><span class="line">    <span class="keyword">int</span> ansL=<span class="number">-1</span>, len=INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span>&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.find(s[++right]) != need.end()) &#123;</span><br><span class="line">            need[s[right]]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(judge(need) &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; len) &#123;   <span class="comment">// 记录最小字符子串的开始坐标和长度</span></span><br><span class="line">                len = right-left+<span class="number">1</span>;</span><br><span class="line">                ansL = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need.find(s[left]) != need.end())   <span class="comment">// 左移</span></span><br><span class="line">                need[s[left]]++;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansL&gt;<span class="number">-1</span>?s.substr(ansL, len):<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></h4><blockquote><p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。</p></blockquote><p>这道题乍一看比上一道题要难，该题要判断是否包含 s1 的排列，而上一道题是判断包含 T 所有字符的最小子串。其实包含 s1 的排列和包含 T 所有字符只是两个说法而已，实际在用的时候都只需要使用一个哈希表记录出现过的字符以及出现的次数即可。</p><p>另外，该题和上一道题的区别在于本题的滑动窗口大小是固定的。有两个思路可以解决这个问题。</p><p>第一个思路是使用上一道题的模板，使用一个match变量记录当前滑动窗口中有多少个字符满足了出现的次数。滑动窗口的缩小条件为当前窗口的大小大于等于 s1 的长度，注意在移动左右指针的时候，更新window窗口以及match变量的值。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; need, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p: need) &#123;  <span class="comment">// 注意必须是need循环，window可能字符并不全</span></span><br><span class="line">        <span class="keyword">if</span>(window[p.first] &lt; p.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: s1)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;  <span class="comment">// 注意这个初始值，是为了使用++right，而不是right++，保证统计windows时下标与need.find一致</span></span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span> &lt; <span class="keyword">int</span>(s2.size())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.find(s2[++right]) != need.end()) &#123;   <span class="comment">// 移动右指针的时候更新 window 和 match的值</span></span><br><span class="line">            window[s2[right]]++;</span><br><span class="line">            <span class="keyword">if</span>(window[s2[right]] == need[s2[right]]) &#123;</span><br><span class="line">                match++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right-left+<span class="number">1</span> &gt;= s1.size()) &#123;  <span class="comment">// 目标框大小固定，当超过时，缩小框</span></span><br><span class="line">            <span class="keyword">if</span>(match == need.size())  <span class="comment">// 包含了 s1 的全排列</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(need.find(s2[left]) != need.end()) &#123;  <span class="comment">// 移动左指针的时候更新 window 和 match的值</span></span><br><span class="line">                <span class="keyword">if</span>(window[s2[left]] == need[s2[left]])</span><br><span class="line">                    match--;</span><br><span class="line">                window[s2[left]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;  <span class="comment">// 注意这个left的位置，不要放在上面的if条件里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个思路是只使用一个哈希表，哈希表的每个字符对应的值含义为：</p><ol><li>若大于0，则滑动窗口中该字符还应该出现几次</li><li>若等于0，则滑动窗口中该字符次数的次数正好</li><li>若小于0，则滑动窗口中该字符多出现了几次</li></ol><p>对应的代码为（该代码是比较标准的固定窗口大小的模板）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: s1)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s2[right++];</span><br><span class="line">        need[c]--;</span><br><span class="line">        <span class="keyword">while</span>(need[c]&lt;<span class="number">0</span> &amp;&amp; left&lt;=right) &#123;  <span class="comment">// 该字符多出现了，收缩窗口</span></span><br><span class="line">            need[s2[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right-left == s1.size())  <span class="comment">// 注意上面的right++了，所以这里不需要加1了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 当满足此条件是，一定是need中所有的值均为0，否则的话一定会有小于0的值，执行上述while循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><blockquote><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序</li></ul></blockquote><p>该题目可以使用滑动窗口的思想解决，并且由题意可知这是一个固定大小窗口的题目。因此窗口收缩的判断条件为当前窗口的大小大于等于 p 的长度。另外，在收缩窗口的时候，注意判断当前窗口是否满足要求。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: p)</span><br><span class="line">        need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span>&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.find(s[++right]) != need.end()) &#123;</span><br><span class="line">            window[s[right]]++;</span><br><span class="line">            <span class="keyword">if</span>(window[s[right]] == need[s[right]])</span><br><span class="line">                match++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left+<span class="number">1</span> &gt;= p.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(match == need.size()) &#123;</span><br><span class="line">                result.push_back(left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(need.find(s[left]) != need.end()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(need[s[left]] == window[s[left]])</span><br><span class="line">                    match--;</span><br><span class="line">                window[s[left]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考上一个题目，可以简化为使用一个哈希表解决。另外，上一题目是比较标准的固定窗口大小的模板，套用之后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: p)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">while</span>(right&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        need[c]--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(need[c]&lt;<span class="number">0</span> &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            need[s[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left == p.size())</span><br><span class="line">            result.push_back(left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p></blockquote><p>这个题目明显可以使用滑窗思想解决。使用一个哈希表记录每个字符出现了多少次，窗口收缩条件为若当前字符出现了多次，则收缩左指针直到当前字符出现一次。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        record[c]++;</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span>(record[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            record[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = max(result, right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>滑动窗口的模板可以分为两个：</p><ol><li>一般模板</li><li>固定滑窗大小的模板</li></ol><p>第二个模板代码更加简洁，并且空间时间复杂度较低。若遇到固定窗口大小的题目，优先使用第二个模板。</p><h3 id="参考-6"><a href="#参考-6" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/" target="_blank" rel="noopener">不同的二叉搜索树 II</a><br><a href="https://leetcode-cn.com/problems/permutation-in-string/solution/hua-dong-chuang-kou-by-muyids-4/" target="_blank" rel="noopener">滑动窗口(十行代码)</a></p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="理论-5"><a href="#理论-5" class="headerlink" title="理论"></a>理论</h3><ol><li><p>定义：</p><ul><li>每个节点中的值必须大于（或等于）存储在其左侧子树中的<strong>任何值。</strong></li><li>每个节点中的值必须小于（或等于）存储在其右子树中的<strong>任何值。</strong></li></ul></li><li><p>二叉搜索树的<strong>中序遍历是递增序列</strong>，这个性质经常能够使用到。</p></li><li><p>二叉搜索树经常使用<strong>递归</strong>方法实现。</p></li><li>在平均情况下，能够在 $\mathcal{O}(\log N)$ 的时间内完成搜索和插入元素。</li></ol><h3 id="常见题目-6"><a href="#常见题目-6" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p></blockquote><p>这个题目的难点在于，一个节点的左子树节点值必须都小于该节点，而该节点的右子树节点值必须大于该节点。因此递归过程中需要使用两个变量在递归的时候记录端点值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBSTCore</span><span class="params">(TreeNode* node, <span class="keyword">long</span> <span class="keyword">long</span> minV, <span class="keyword">long</span> <span class="keyword">long</span> maxV)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;val&lt;=minV || node-&gt;val&gt;=maxV) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValidBSTCore(node-&gt;left, minV, node-&gt;val) &amp;&amp; isValidBSTCore(node-&gt;right, node-&gt;val, maxV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> minV = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxV = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBSTCore(root, minV, maxV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h4><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p></blockquote><p>考虑最简单的插入方式。将插入的节点作为叶子节点插入。插入到哪个叶节点可以遵循如下原则：</p><ol><li>若<code>val &gt; node.val</code>，且右子树为空，则插入到右子树</li><li>若<code>val &lt; node.val</code>，且左子树为空，则插入到左子树</li></ol><p>基于循环方式的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    TreeNode* newNode = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    </span><br><span class="line">    TreeNode* node = root;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &lt; val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;right = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;left = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java版本的基于递归的方式参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert into the right subtree</span></span><br><span class="line">    <span class="keyword">if</span> (val &gt; root.val) root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="comment">// insert into the left subtree</span></span><br><span class="line">    <span class="keyword">else</span> root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h4><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p></blockquote><p>该题的考察点在于二叉搜索树的定义。</p><p>首先介绍一下二叉搜索树前驱节点、后继节点的概念：</p><ol><li>前驱节点：比当前节点小的最大节点，即中序遍历序列的下一个节点。</li><li>后继节点：比当前节点大的最小节点，即中序遍历序列的前一个节点。</li></ol><p>然后，还需要注意几个关键点：</p><pre><code>1. 对于删除节点，只需要更改当前节点的值即可，不需要调整左右指针   2. 删除节点的时候只需要让当前节点值等于NULL即可   3. C++在函数内部会更改形参的值，对于实际调用或者递归的时候，要考虑形参和实参的关系</code></pre><p>解决问题的思路为：</p><ol><li>若删除的是叶子节点，直接删除即可</li><li>如果含有右节点，则将后继节点的值赋值给当前节点，递归删除后继节点</li><li>如果含有左节点，则将前驱节点的值赋值给当前节点，递归删除前驱节点</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到前驱节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">findPre</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    node = node-&gt;left;</span><br><span class="line">    <span class="keyword">while</span>(node-&gt;right) <span class="comment">// 注意这个判断条件，可以返回不为NULL的结果</span></span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到后驱节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">findPost</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    node = node-&gt;right;</span><br><span class="line">    <span class="keyword">while</span>(node-&gt;left)</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; key) </span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);  <span class="comment">// 注意调用递归的时候更新递归子函数的更改的结果</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; key)</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) &#123;  <span class="comment">// 删除的是叶子节点</span></span><br><span class="line">            <span class="comment">//delete root;  // new对应delete，new[]对应delete[]</span></span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) &#123;  <span class="comment">// 如果含有右子树</span></span><br><span class="line">            TreeNode* post = findPost(root);</span><br><span class="line">            root-&gt;val = post-&gt;val;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, root-&gt;val); <span class="comment">// 必须采用递归的方式，不能直接置post=NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode* pre = findPre(root);</span><br><span class="line">            root-&gt;val = pre-&gt;val;</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下为什么第32行需要采用递归的方式删除。</p><p>首先，从特殊例子来看，如下图所示，节点33的前驱节点为25，后继节点为34，这两个节点均不是叶子节点，所以需要递归删除。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/309271bd1f94c57fd4e19f5eee624dd2ad3ef8e4d5a3b6eca5556e9f2e43a3bc-file_1576477912310" alt="在这里插入图片描述" style="zoom:40%;"></p><p>其次，从语法上来看：</p><ol><li>函数内部若直接将<code>post=NULL</code>，则只是局部指针变量指向了<code>NULL</code>，并没有对整个树进行更改</li><li>若在函数内部<code>*post=NULL</code>，则<code>*post</code>是一个<code>TreeNode</code>对象，将该对象置为<code>NULL</code>，会隐式的调用构造函数，而<code>NULL</code>会隐式的转换为0，调用构造函数的结果会将该节点的<code>val</code>置为0，而不是将该块区域置为<code>NULL</code>。</li><li>若采用递归的方式调用，极端情况下，考虑调用的结果<code>root-&gt;right=NULL</code>，<code>root-&gt;right</code>是一个<code>TreeNode</code>指针，可以置为<code>NULL</code>。然后该次调用会将root的结果返回，直到更新整个树。</li></ol><h3 id="参考-7"><a href="#参考-7" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-2/" target="_blank" rel="noopener">二叉搜索树中的插入操作</a></p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="理论-6"><a href="#理论-6" class="headerlink" title="理论"></a>理论</h3><p>回溯法（backtrack）常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于全排列，穷尽所有可能，遍历的过程实际上是一个决策树的遍历过程。时间复杂度一般 $O(N!)$，它不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</p><p>常用模板如下，核心就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">func backtrack(选择列表,路径):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(选择列表,路径)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>在这个模板中需要注意的有：</p><ol><li>路径：也就是已经做出的选择</li><li>选择列表：也就是当前可以做的选择（可以使用<code>可以遍历的下标范围</code>或者<code>标记是否访问过的数组</code>来得到选择列表并避免回溯重复。若访问某一个元素的时候，前面的元素不在选择列表中，则可以使用前者，否则的话可以使用后者）</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件</li></ol><h3 id="常见题目-7"><a href="#常见题目-7" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h4><blockquote><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。<strong>说明：</strong>解集不能包含重复的子集。</p></blockquote><p>这道题明显是需要用回溯法解决的，因为要遍历所有可能的子集。因为不含重复元素，所以参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsetsCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">    result.push_back(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        subsetsCore(result, tmp, nums, i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    subsetsCore(result, tmp, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h4><blockquote><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。<strong>说明：</strong>解集不能包含重复的子集。</p></blockquote><p>该题和上一个题目的区别在于，本题的 nums 中是可能包含重复元素的。若还采用上一题的思路，会出现重复的子集。相比上一个题目，主要多了两个步骤：</p><ol><li>将 nums 中的元素从小到大排序，这样可以保证相同的数字挨在一起</li><li>若<code>i&gt;begin &amp;&amp; nums[i]==nums[i-1]</code>则说明该次循环还在这一级，且出现了重复元素，直接跳过。其中<code>i&gt;begin</code>保证只跳过同级的相同元素，而不同级的相同元素不会跳过</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsetsWithDupCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">    res.push_back(tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 只跳过同级的相同元素，而不同级的相同元素不会跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;begin &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        subsetsWithDupCore(res, tmp, nums, i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());  <span class="comment">// 将元素从小到大排序，方便之后跳过重复元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    subsetsWithDupCore(res, tmp, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h4><blockquote><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p></blockquote><p>因为这是一个全排列问题，在以后面数字作为首字母的时候，前面的数字也要遍历到，因此不能使用下标的变换去更新下一次的回溯范围，而只能使用标记是否访问过的数组。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuteCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flag, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size() == nums.size()) &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        flag[i] = <span class="number">1</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        permuteCore(res, tmp, flag, nums);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(nums.size(), <span class="number">0</span>);</span><br><span class="line">    permuteCore(res, tmp, flag, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h4><blockquote><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p></blockquote><p>该题和上一题的区别在于该题的序列可能包含重复数字。按照 <a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a> 的解题思路，并结合上一题的解法：</p><ol><li>将序列从小到大进行排序，这样可以让重复数字放在一块</li><li><code>i&gt;0 &amp;&amp; !flag[i-1] &amp;&amp; nums[i]==nums[i-1]</code>保证若处于不同层次的循环，且相邻两个元素相等，则不需要进行回溯了。</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuteUniqueCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flag, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size() == nums.size()) &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">/* 需要跳过的有几种情况</span></span><br><span class="line"><span class="comment">        1. flag[i] 表示当前回溯路径第i个元素已经访问了</span></span><br><span class="line"><span class="comment">        2. !flag[i-1]表示已经处于上一层回溯了，此时需要判断是否与前一个元素值相等，相等的话就不用回溯了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(flag[i] || (i&gt;<span class="number">0</span> &amp;&amp; !flag[i<span class="number">-1</span>] &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        flag[i] = <span class="number">1</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        permuteUniqueCore(res, tmp, flag, nums);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end()); <span class="comment">// 一定要排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(nums.size(), <span class="number">0</span>); <span class="comment">// 注意大小，与nums元素一一对应</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    permuteUniqueCore(res, tmp, flag, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h4><blockquote><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的数字可以<strong>无限制重复被选取。</strong></p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul></blockquote><p>这个题目有两个地方需要注意：数组 <code>candidates</code>无重复元素、每个元素可以使用多次。使用一个变量<code>sum</code>记录当前<strong>路径</strong>的累加和，若累加和等于<code>target</code>则停止并添加到最终结果中，若累加和大于<code>target</code>则<strong>停止</strong>。因为遍历到后面的元素后，前面的元素不在回溯路径中了，所以可以使用下标范围来得到<strong>选择列表</strong>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combinationSumCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;candidates.size(); i++) &#123;</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        tmp.push_back(candidates[i]);</span><br><span class="line">        combinationSumCore(res, tmp, candidates, i, target, sum);  <span class="comment">// 注意这里的index传参为i，因为数字可以无限制重复选取</span></span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    combinationSumCore(res, tmp, candidates, <span class="number">0</span>, target, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h4><blockquote><p>给定一个数组 <code>candidates</code>  和一个目标数 <code>target</code> ，找出 <code>candidates</code>  中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code>  中的每个数字在每个组合中<strong>只能使用一次。</strong></p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul></blockquote><p>这个题目和上一个题目的区别在于：数组<code>candidates</code>可能含有重复元素、每个元素只能使用一次。根据前面的经验，处理重复元素的方法：</p><ol><li>将 <code>candidates</code> 中的元素从小到大排序，这样可以保证相同的数字挨在一起</li><li>若<code>i&gt;index &amp;&amp; candidates[i]==candidates[i-1]</code>则说明该次循环还在这一级，且出现了重复元素，直接跳过。其中<code>i&gt;index</code>保证只跳过同级的相同元素，而不同级的相同元素不会跳过</li></ol><p>另外，因为每个元素只能使用一次，因此在进行下一次回溯的时候，下标需要加1。最终参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combinationSumCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;candidates.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;index &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        tmp.push_back(candidates[i]);</span><br><span class="line">        combinationSumCore(res, tmp, candidates, i+<span class="number">1</span>, target, sum);  <span class="comment">// 注意这里的index传参为i+1，因为数字可以只能选取一次</span></span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    sort(candidates.begin(), candidates.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    combinationSumCore(res, tmp, candidates, <span class="number">0</span>, target, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h4><blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/17_telephone_keypad.png" alt="img" style="zoom: 50%;"></p></blockquote><p>这个题目明显要使用回溯去解决，因为要从各个按键里面找到一个字母，然后组成结果，不存在优化的可能。</p><ol><li>路径：使用<code>vector</code>记录</li><li>选择列表：当前按下数字对应的所有字母</li><li>结束条件：若当前路径的长度等于<code>digits</code>的长度，则将路径添加到最终路径，终止本次回溯</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">letterCombinationsCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span>&amp; digits, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;&amp; m, <span class="built_in">string</span>&amp; tmpS, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == digits.size()) &#123;</span><br><span class="line">        res.push_back(tmpS);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到当前数字对应的字母</span></span><br><span class="line">    <span class="built_in">string</span> s = m[digits[index]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++) &#123;</span><br><span class="line">        tmpS.push_back(s[i]);</span><br><span class="line">        letterCombinationsCore(res, digits, m, tmpS, index+<span class="number">1</span>);</span><br><span class="line">        tmpS.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(digits.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m&#123;</span><br><span class="line">        &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> tmpS;</span><br><span class="line">    letterCombinationsCore(res, digits, m, tmpS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></h4><blockquote><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。返回 <em>s</em> 所有可能的分割方案。</p></blockquote><p>这道题可以使用回溯法解决。</p><ol><li>路径：使用<code>vector&lt;string&gt;</code>记录当前所有回文子串</li><li>选择列表：从当前索引到 <code>s.size()-1</code> 均可以当做子串的结尾；若当前子串为回文子串，则继续进行回溯</li><li>结束条件：当前索引已经等于<code>s.size()</code>了，则将当前路径添加到最终结果中</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;  <span class="comment">// 使用递归+双指针的方式判断是否为回文子串，代码更加简洁</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[i++] == s[j--]) <span class="keyword">return</span> judge(s, i, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; result, <span class="keyword">int</span> begin, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp, <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin == s.size()) &#123;</span><br><span class="line">        result.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;s.size(); i++) &#123;  <span class="comment">// 每一个索引都可以作为当前子串的结尾索引</span></span><br><span class="line">        <span class="keyword">if</span>(judge(s, begin, i)) &#123;  <span class="comment">// 若为回文子串，则继续进行回溯；否则进行下一个循环</span></span><br><span class="line">            tmp.push_back(s.substr(begin, i-begin+<span class="number">1</span>));;</span><br><span class="line">            partitionCore(result, i+<span class="number">1</span>, tmp, s);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">    partitionCore(result, <span class="number">0</span>, tmp, s);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></h4><blockquote><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。</p></blockquote><p>这个题目比较复杂，借助这道题和大佬的讲解。这里详细讲解一下回溯算法的分析步骤。</p><p>回溯算法事实上就是在一个树形问题上做深度优先遍历，因此 <strong>首先需要把问题转换为树形问题</strong>。在画树形图的过程中，一定会发现有些枝叶是没有必要的，把没有必要的枝叶剪去的操作就是<strong>剪枝</strong>，在代码中一般通过 <code>break</code> 或者 <code>contine</code> 和 <code>return</code> （表示递归终止）实现。画出本题的树形图如下图所示：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/b581bdde1cef982f0af3182af17fc3c41960c76a7445af0dcfd445c89b4c2eaa-「力扣」第 93 题：复原 IP 地址-1.png" alt="「力扣」第 93 题：复原 IP 地址-1.png" style="zoom: 43%;"></p><ol><li>路径：这个题目麻烦的地方是IP地址之间要用<code>.</code>进行分割，若用<code>string</code>存储路径，则比较麻烦，不如直接使用<code>vector&lt;string&gt;</code>进行记录，记录完毕之后若满足条件，则再拼接到一块</li><li>选择列表：因为已经遍历过的元素，以后不会在出现了，因为可以使用下标记录下一次访问的位置。每次回溯的时候，可遍历的子串长度在<code>[1,3]</code>之间。并且需要排除如下几种情况<ul><li>若<code>子串长度+当前下标-1&gt;=.size()</code></li><li><code>0x、0xx</code>都是非法的</li><li>子串的数值不能大于255</li></ul></li><li>结束条件：<ul><li>若遍历完所有的<code>s</code>，并且已经有四段合法字符串了，则记为有效结果，结束</li><li>若没有遍历完<code>s</code>，并且已经有四段合法字符串了，则记为无效结果，结束</li></ul></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp, <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start==s.size() &amp;&amp; tmp.size()==<span class="number">4</span>) &#123; <span class="comment">// tmp有四段，并且遍历完s了</span></span><br><span class="line">        <span class="built_in">string</span> str = tmp[<span class="number">0</span>];  <span class="comment">// 这样写可以保证最后不会多一个 .</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;tmp.size(); i++)</span><br><span class="line">            str = str + <span class="string">'.'</span> + tmp[i];</span><br><span class="line">        res.push_back(str); <span class="comment">// 其中一种可行方案</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(start&lt;s.size() &amp;&amp; tmp.size()==<span class="number">4</span>)  <span class="comment">// tmp有四段，并且没有遍历完s</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len&lt;=<span class="number">3</span>; len++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(len+start<span class="number">-1</span> &gt;= s.size())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(len!=<span class="number">1</span> &amp;&amp; s[start]==<span class="string">'0'</span>)  <span class="comment">// 0x，00x非法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">string</span> str = s.substr(start, len);</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">3</span> &amp;&amp; atoi(str.c_str())&gt;<span class="number">255</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        tmp.push_back(str);</span><br><span class="line">        DFS(res, tmp, s, start+len);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">    DFS(res, tmp, s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-8"><a href="#参考-8" class="headerlink" title="参考"></a>参考</h3><p><a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">回溯算法解题套路框架</a><br><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/c-shuang-bai-hui-su-xie-fa-by-jiang-ly/" target="_blank" rel="noopener">C++ 双百回溯写法</a><br><a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/" target="_blank" rel="noopener">回溯算法（画图分析剪枝条件）</a><br><a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/" target="_blank" rel="noopener">『手画图解』DFS 回溯 细节</a></p><h2 id="参考-9"><a href="#参考-9" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/" target="_blank" rel="noopener">Sort List （归并排序链表）</a><br><a href="https://blog.csdn.net/fuxuemingzhu/article/details/101900729" target="_blank" rel="noopener">【LeetCode】代码模板，刷题必会</a><br><a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">labuladong的算法小抄</a><br><a href="https://greyireland.gitbook.io/algorithm-pattern/" target="_blank" rel="noopener">algorithm-pattern</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;二叉树遍历模板&quot;&gt;&lt;a href=&quot;#二叉树遍历模板&quot; class=&quot;headerlink&quot; title=&quot;二叉树遍历模板&quot;&gt;&lt;/a&gt;二叉树遍历模板&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;前序遍历&lt;/strong&gt;：&lt;strong&gt;先访问根节点&lt;/strong&gt;，再前序遍历左子树，再前序遍历右子树&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中序遍历&lt;/strong&gt;：先中序遍历左子树，&lt;strong&gt;再访问根节点&lt;/strong&gt;，再中序遍历右子树&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后序遍历&lt;/strong&gt;：先后序遍历左子树，再后序遍历右子树，&lt;strong&gt;再访问根节点&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以根访问顺序决定是什么遍历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;左子树都是优先右子树&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="DataStructureAlgorithm" scheme="https://www.zdaiot.com/categories/DataStructureAlgorithm/"/>
    
    
      <category term="数据结构" scheme="https://www.zdaiot.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://www.zdaiot.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Few-Shot Learning with Global Class Representations</title>
    <link href="https://www.zdaiot.com/DeepLearningApplications/Few-shot%20Learning/Few-Shot%20Learning%20with%20Global%20Class%20Representations/"/>
    <id>https://www.zdaiot.com/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/</id>
    <published>2020-07-19T12:05:05.000Z</published>
    <updated>2020-07-19T12:05:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul><li>标题：Few-Shot Learning with Global Class Representations</li><li>年份：2019</li><li>期刊：ICCV</li><li>标签：global class representations,  few-shot learning</li><li>数据：miniImageNet，Omniglot</li></ul><h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><ol><li>通过<strong>在训练阶段引入新类的数据</strong>，同时对基类和新类学习<strong>全局类别表征</strong>，并利用样本生成策略解决类别不均衡问题，有效防止模型在基类数据中出现过拟合的现象，从而提高了模型泛化到新类的能力。</li><li>方法可以很容易的扩展到广义小样本学习（相比标准小样本学习，广义小样本学习中测试样本不仅包含新类，还包含了基类）。</li><li>所提的方法在标准小样本学习与广义小样本学习的benchmark上均取得了很好的效果。并且在广义小样本学习上，性能的提升更大。</li></ol><h2 id="创新点来源"><a href="#创新点来源" class="headerlink" title="创新点来源"></a>创新点来源</h2><p>首先，先了解几个知识点：</p><ol><li>对于FSL问题，base classes每类均有足够的训练样本，而novel classes每类只有少量的标记样本。</li><li>现有的FSL方法都是基于元学习的。在元学习阶段，在base classes上采样来模拟Few-Shot Learning的条件。学习到的迁移知识通常以good initial conditions、embeddings、optimization strategies形式存储。元学习阶段之后，目标Few-Shot Learning问题通常有两种途径解决：一使用the learned<br>optimization strategy进行fine-tuning；二在不更新网络权重的情况下进行前向计算。</li></ol><p>但是基于元学习的方法有一个根本性的问题：通常只使用基类数据训练模型（initial condition, embedding or optimization strategy），无法保证模型在目标数据上进行有效的泛化，即使在fine-tuning步骤之后。由于基类和新类之间<strong>存在严重的样本不均衡问题</strong>，导致容易过拟合到基类数据，这一点在广义小样本问题中尤为突出。通过<strong>在训练阶段引入新类的数据</strong>，同时对基类和新类学习全局类别表征，并利用样本生成策略解决类别不均衡问题，有效防止训练模型在基类数据中出现过拟合的现象，从而提高了模型泛化到新类的能力。</p><p>跟原型网络相比，本文主要有如下几个不同点：</p><ol><li>本文学习的是全局类别表征，而不是episodic one；</li><li>base class和novel class训练样本都用来学习表征。这保证学习到的类表征是具有全局一致性的，而不是local的；</li><li>本文引入了feature hallucination based方法，可以用来合成新的样本，解决类不平衡性问题。</li></ol><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>然而，这种全局类别表征最大的障碍是base与novel class训练样本之间的不均衡。作者使用了如下两种方式解决的这个问题：</p><ol><li>通过合成数据增加novel class的类内多样性，通过在类样本子空间中随机抽样数据点，作者所提的合成样本策略可以有效地增加类内方差；</li><li>引入元训练去平衡base与novel class。具体来说就是representation registration，这部分内容比较复杂，在下面会详细展开。</li></ol><h3 id="Registration-Module"><a href="#Registration-Module" class="headerlink" title="Registration Module"></a>Registration Module</h3><p>假设样本集合为$C_{total}=\{c_1,\dots,c_N\}$，其中$N$表示类别总数。给定训练集集合$D_{train}$和测试集集合$D_{test}$，其中$D_{train}$的类别空间为$C_{total}$。registration module的主要作用为：将训练样本和全局类别表征进行比较，并选择出对应的全局类别表征。registration loss定义为全局表征和registration module的联合优化。下面进行具体介绍。</p><p>首先将训练集合中的一个训练样本$x_i$输入到特征提取器$F$中，获得其视觉特征，定义为$f_i=F(x_i)$。然后将该样本的视觉特征与全局类别特征表达$G=\{g_{c_j},c_i \in C_{total}\}$输入到registration module $R$中。对于每一个视觉特征$f_i$，registration module $R$都会产生一个向量$V_i=[v_i^{c_1},\cdots,v_i^{c_N}]^T$，其中第$j$个元素表示$f_i$与第$c_j$类全局类别表征$g_{c_j}$之间的相似性。在本文中，相似性得分的定义如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200719222836379.png" alt="image-20200719222836379" style="zoom:80%;"></p><p>其中，$\theta(\cdot)$和$\phi(\cdot)$分别是样本视觉特征与全局类别表征的嵌入。</p><p>对于样本$x_i$（类别为$y_i$），定义registration loss $L_{reg}$，使得该样本与它对应的全局类别表征最接近，其中$CE$表示交叉熵损失：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200719223827007.png" alt="image-20200719223827007" style="zoom:80%;"></p><p>通过将样本与所有全局类别表征（$C_{total}$）进行比较，<strong>registration module使得每个全局类别表征接近其类内的样本，而远离类外的样本。</strong>值得注意的是，representation和特征提取网络都是可以端到端训练的，并且联合优化的。具体地说，利用训练好的全局类别表征，特征提取器被优化以将样本聚集在这些全局类表征周围；给定特征提取器，每个全局类别表征被优化为更接近同类样本而远离异类样本。</p><h3 id="Sample-Synthesis-Module"><a href="#Sample-Synthesis-Module" class="headerlink" title="Sample Synthesis Module"></a>Sample Synthesis Module</h3><p>为了解决novel classes样本过少引起的类别不平衡问题，本文提出了一个样本合成策略为novel classes合成样本。主要分为两个步骤：</p><ol><li><p>使用原始样本产生新样本。具体来说，输入原始图像，使用随机裁剪、随机翻转和data hallucination策略合成样本。使用该方法后，每个novel class都可以获得总数为$k_t$的样本总数。</p></li><li><p>对于每一个新类$c_j$，首先从$k_t$个样本中随机选择出$k_r$个样本，从这$k_r$ 个特征$\{f_1,\cdots,f_{k_r}\}$组成的特征空间中，随机采样一个点合成一个样本。具体来说，在0~1均匀分布中采样出$k_r$个值$\{v_1,\cdots,v_{k_r}\}$；然后以这$k_r$ 个值作为权重对这些特征进行加权求和，得到了$c_j$类新的样本$r_{c_j}$，具体方程如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200719231102918.png" alt="image-20200719231102918" style="zoom:80%;"></p></li></ol><p>通过上述的策略，类内的样本多样性会增加，样本过少的问题也得到了减轻。上述这两个步骤可以概括为下面这副图：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200719232056995.png" alt="image-20200719232056995"></p><h3 id="Few-Shot-Learning-By-Registration"><a href="#Few-Shot-Learning-By-Registration" class="headerlink" title="Few Shot Learning By Registration"></a>Few Shot Learning By Registration</h3><p>除了上述的样本合成策略外，本文还使用了元训练策略。在FSL中，类标集合$C_{total}$分为两个不相交的子集$C_{base}$和$C_{novel}$。</p><p>在元训练阶段，首先从$C_{total}$个类别中抽取$n_{train}$个类别组成训练集合$C_{train}$；$C_{train}$每个类别均随机抽取$n_s$个样本组成支撑集$S=\{(x_i,y_i),i=1,2,\cdots,n_s\times n_{train}\}$；$C_{train}$每个类别随机抽取$n_q$个样本组成查询集$Q=\{(x_k,y_k),k=1,\cdots,n_q\times n_{train}\}$。值得注意的是，在训练集合中的novel class只有少量的$n_{few}$个样本，这通常远远少于$n_s+n_q$。所以，作者首先使用上一小节提到的数据合成的方法，合成$n_s+n_q$个样本，然后将他们划分为$n_s$和$n_q$，分别放到支撑集与查询集里面。</p><p>在元测试阶段，主要和元训练阶段有如下几个方面的不同：</p><ol><li>$C_{test}$仅由从novel classes中随机选择的$n_{test}$个类别组成；</li><li>使用这$n_{test}$个novel class在训练集合中的标记样本作为支撑集</li><li>查询集从$D_{test}$集合中选取，而不是$D_{train}$集合。</li></ol><p>如果在元训练阶段，每个novel class有$n_{few}$的标记样本，那么FSL问题称为$n_{few}$-shot FSL；如果模型在测试阶段，从$n_{test}$的候选类别中预测结果，那么FSL问题称为$n_{test}$-way FSL。</p><p>接下来就开始进行整个FSL框架的描述。整个FSL框架示意图如下图所示：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720115533701.png" alt="image-20200720115533701" style="zoom:80%;"></p><p><strong>第一步</strong>，利用元学习策略将所提的样本合成模块加入到FSL框架中。也就是说，在每一次训练迭代过程中，<strong>支撑集$S$</strong>中的样本$S=\{x_i,i=1,2,\cdots,n_s\times n_{train}\}$首先被送入到特征提取器$F$中获得对应的视觉特征$\{f_i=F(x_i),i=1,\cdots,n_s \times n_{train}\}$。然后<strong>支撑集中的每一个类别建立episodic表征</strong>，记为$\{r_{c_i},c_i \in C_{train}\}$。该episodic表征$r_{c_i}$集成了当前mini-batch的支持集合$S$中的类$C_i$的信息；因此它是局部类别表征而不是全局类别表征。具体操作为：对于base classes，跟原型网络相似，平均同一类的视觉特征来获得episodic类别表征；对于novel class，将支撑集某类的特征作为输入，利用上述样本合成策略，为该类合成新的样本，从而得到的episodic novel类别表征更加多样化。</p><p><strong>第二步，</strong>将registration module融入到FSL框架中，根据其episodic表征选择全局类别表征，选中的全局类别表征被用来对查询图片进行分类。特别的，将支撑集的episodic类别表征$\{r_{c_j},c_j \in C_{train} \}$和全局类别表征$G=\{g_{c_j},c_j \in C_{total}\}$输入到registration module $R$中，计算每一个episodic类别表征与全局类别表征之间的相似度，方程见上述方程1。</p><p>相似度得分被用来为查询数据集选择全局类标表征。为了使得全局类别表征更具有分离性，registration module定义了一个registration loss，使得episodic类别表征与对应类别全局类别表征之间的相似度得分更高。全局类别表征的分离性更强，识别未标记样本的能力越强。根据上面的方程2，每一个类别episodic表征$r_{c_i}$的registration损失定义如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720094226942.png" alt="image-20200720094226942" style="zoom:80%;"></p><p>其中$V_i=[v_i^{c_1},\cdots,v_i^{c_N}]^T$表示$C_{train}$中类别$c_i$的episodic类别表征$r_{c_i}$与所有全局类别表征$\{g_{c_j},c_j\in C_{total}\}$的相似性得分。</p><p><strong>第三步，</strong>利用得到的相似度得分，为$C_{train}$中的每一个类选择一个全局类别表征作为其类表征，并以选出的全局类别表征为参考进行最近邻搜索来识别查询图像。但是，当选择使用的是argmax操作时，它是不可微的。因此，以soft manner的形式选择类别表征。具体就是以概率分布$V_i$为权重，将所有类别的全局类标表征加权求和，得到$C_{train}$中第$i$类的类别表征$\varepsilon_i$，记做$\varepsilon_i=V_iG$。这样就获得了$C_{train}$中所有类别对应的全局类别特征$\{\varepsilon_i,i=1,\cdots,n_{train}\}$。查询样本$\{x_k,y_k  \} \in Q$的分类损失定义如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720101436396.png" alt="image-20200720101436396" style="zoom:80%;"></p><p>其中，$F$为特征提取模块，$W_k=[w_k^1,\cdots,w_k^{n_{train} }]^T$表示查询样本$x_k$与选中的全局类别表征$\varepsilon_i$之间的相似性。</p><p>将registration loss与分类损失结合到一块，就可以得到训练过程中的总损失函数，方程如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720101832702.png" alt="image-20200720101832702" style="zoom:80%;"></p><p>元训练的整个过程如下，值得注意的事项我均以下划线表示出来了。</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720103144949.png" alt="image-20200720103144949"></p><p>在元测试集阶段，使用相同的流程去预测未标记样本的类标。也就是说，首先将<strong>支撑集</strong>输入到特征提取器中，得到每一个类别的episodic类别表征。然后，通过registration module与episodic类别表征得到对应的全局类别表征。然后，通过计算测试样本的特征向量与选出的全局类别表征之间的欧几里德距离来执行最近邻搜索。</p><h3 id="Extension-to-Generalized-FSL"><a href="#Extension-to-Generalized-FSL" class="headerlink" title="Extension to Generalized FSL"></a>Extension to Generalized FSL</h3><p>虽然本文方法初始是用来设计标准FSL过程的，但是它能够很容易的扩展到广义FSL问题：<strong>唯一的区别在于测试样本同时从基类和新类抽取</strong>，预测时需要预测查询样本属于$C_{total}$个类别的类标。<strong>而标准FSL的测试数据只来源于novel classses</strong>。registration module不仅优化novel类别表征，还更新了base类别表征。通过将每个查询样本与base和novel的全局类标表征进行比较，registration module可以直接预测查询样本属于$C_{total}$中每个类的概率。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>本文的实验主要是在miniImageNet和Omniglot两个数据集上展开的。关于这两个数据集的说明这里就不详细展开了，可以看之前的文章。</p><h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><p><strong>网络结构：</strong>特征提取器由四个残差block组成，每个block由64个$3 \times 3$卷积核、BN层、RELU激活函数和一个$2 \times 2$的最大池化层组成。registration module中的两个嵌入模块$\theta$和$\phi$均使用的是全连接层，全连接层的输出维度为512。</p><p><strong>训练过程：</strong>首先，借助分类任务，使用所有的base classes训练特征提取器。然后，通过首先使用预先训练好的$F$其类中提取图像的视觉特征，然后对这些视觉特征进行平均来初始化每个全局类别表征。data hallucinator用预先训练的$F$作为特征提取器进行预训练。registration module采用的是高斯初始化，并从零开始训练。初始化特征提取器、全局类别表征、data hallucinator、registration module之后，将他们放到一块进行端到端的训练。</p><h3 id="Results-on-Omniglot"><a href="#Results-on-Omniglot" class="headerlink" title="Results on Omniglot"></a>Results on Omniglot</h3><p>5way 1-shot/5-shot，20way 1-shot/5-shot。其中，<strong>way表示测试集合中类别的个数，而shot表示每类支撑集的个数</strong>。不管是1-shot还是5-shot，每个类别均有五个查询样本。在元测试阶段，支持集中的图像是从训练集中随机选择的，而查询集中的图像是从测试集中随机选择的。可以观察到，本文的方法取得了新的最先进的性能。这验证了该方法的有效性，因为它采用了独特的全局类别表征学习策略。</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720113100233.png" alt="image-20200720113100233" style="zoom:80%;"></p><h3 id="Results-on-miniImageNet"><a href="#Results-on-miniImageNet" class="headerlink" title="Results on miniImageNet"></a>Results on miniImageNet</h3><p>我们可以看到，我们的方法在5-way 5-shot设置上的性能明显优于其他FSL方案，并且在5-way 1-shot设置下达到了最好的效果。</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720113539560.png" alt="image-20200720113539560" style="zoom:80%;"></p><h3 id="Generalized-Few-Shot-Learning"><a href="#Generalized-Few-Shot-Learning" class="headerlink" title="Generalized Few-Shot Learning"></a>Generalized Few-Shot Learning</h3><p>使用的是miniImageNet数据集，类别划分方式相同（64//16/20），采用的新的数据划分方式，对于base classes，从600张图片中随机选择500张图片，novel classes中随机选取少量样本作为训练数据集。从剩下的数据中，每个base/novel类别，从中选取100张图片作为测试集。</p><p>定义广义FSL问题的评价指标为：</p><ol><li>$acc_a$：将所有类别的测试样本识别正确的概率</li><li>$acc_b$：将base classes的测试样本识别正确的概率</li><li>$accu_a$：将novel classes的测试样本识别正确的概率</li></ol><blockquote><p>值得注意的是，计算上述指标的时候，均需要将测试样本映射到$C_{total}$的标记空间。</p></blockquote><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720114953770.png" alt="image-20200720114953770" style="zoom:80%;"></p><p>实验结果如上表所示，可以观察到：</p><ol><li>本文的方法在所有的评价指标上都取得了最好的结果，比标准设置下的结果有更大的差距。这表明在这种更具挑战性的环境下，本文的模型具有最强的泛化能力。</li><li>本文方法优于PN和RN，因为这里学习每个类的全局类别表征，而它们估计episodic类别表征。</li><li>MN的结果比本文的方法低得多。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先分析基于元学习的方法有一个根本性的问题：通常只使用基类数据训练模型（initial condition, embedding or optimization strategy），无法保证模型在目标数据上进行有效的泛化，即使在fine-tuning步骤之后。由于基类和新类之间<strong>存在严重的样本不均衡问题</strong>，导致容易过拟合到基类数据，这一点在广义小样本问题中尤为突出。</p><p>针对这个根本性问题，作者通过<strong>在训练阶段引入新类的数据</strong>，同时对基类和新类学习<strong>全局类别表征</strong>，并利用样本生成策略解决类别不均衡问题，有效防止训练模型在基类数据中出现过拟合的现象，从而提高了模型泛化到新类的能力。</p><p>本文值得借鉴的地方是episodic类别表征与全局类别表征之间的关系是通过registration module进行的。也就是每次会使用registration module模块，对每个episodic类别特征与所有全局类标表征做相似性度量，选择出该类别对应的全局类标特征。然后由选出的全局类标特征与查询样本进行比较，得到查询样本的类标。不过，关于样本扩充的方式不太适用于非图像领域。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/78743300" target="_blank" rel="noopener">ICCV 2019 | 基于全局类别表征的小样本学习 GCR（附代码）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;标题：Few-Shot Learning with Global Class Representations&lt;/li&gt;
&lt;li&gt;年份：2019&lt;/li&gt;
&lt;li&gt;期刊：ICCV&lt;/li&gt;
&lt;li&gt;标签：global class representations,  few-shot learning&lt;/li&gt;
&lt;li&gt;数据：miniImageNet，Omniglot&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;创新点&quot;&gt;&lt;a href=&quot;#创新点&quot; class=&quot;headerlink&quot; title=&quot;创新点&quot;&gt;&lt;/a&gt;创新点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;通过&lt;strong&gt;在训练阶段引入新类的数据&lt;/strong&gt;，同时对基类和新类学习&lt;strong&gt;全局类别表征&lt;/strong&gt;，并利用样本生成策略解决类别不均衡问题，有效防止模型在基类数据中出现过拟合的现象，从而提高了模型泛化到新类的能力。&lt;/li&gt;
&lt;li&gt;方法可以很容易的扩展到广义小样本学习（相比标准小样本学习，广义小样本学习中测试样本不仅包含新类，还包含了基类）。&lt;/li&gt;
&lt;li&gt;所提的方法在标准小样本学习与广义小样本学习的benchmark上均取得了很好的效果。并且在广义小样本学习上，性能的提升更大。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;创新点来源&quot;&gt;&lt;a href=&quot;#创新点来源&quot; class=&quot;headerlink&quot; title=&quot;创新点来源&quot;&gt;&lt;/a&gt;创新点来源&lt;/h2&gt;
    
    </summary>
    
    
      <category term="DeepLearningApplications" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/"/>
    
      <category term="Few-shot Learning" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/Few-shot-Learning/"/>
    
    
      <category term="Few Shot Learning" scheme="https://www.zdaiot.com/tags/Few-Shot-Learning/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer总结</title>
    <link href="https://www.zdaiot.com/DataStructureAlgorithm/%E5%89%91%E6%8C%87Offer%E6%80%BB%E7%BB%93/"/>
    <id>https://www.zdaiot.com/DataStructureAlgorithm/剑指Offer总结/</id>
    <published>2020-07-09T01:14:14.000Z</published>
    <updated>2020-07-09T01:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近快要面试了，再刷一遍剑指Offer，看大家分享刷LeetCode和剑指Offer的时候都是有模板的，如果按照随机顺序刷，很容易忘记而且不容易总结刷题思路。所以常常把一类题放到一块一起刷。</p><p>《剑指Offer》有如下优点：</p><ul><li>很可能在面试中出现原题（至少在微软面试经常能遇到原题）</li><li>题量少，但是涵盖的内容较全，性价比较高</li><li>能培养一个良好的刷题习惯</li></ul><p>缺点是：</p><ul><li>题目较少，<strong>刷着容易过拟合</strong></li><li>动态规划的题比较少，因此需要在力扣上专项训练。</li></ul><h2 id="数据结构类题目"><a href="#数据结构类题目" class="headerlink" title="数据结构类题目"></a>数据结构类题目</h2><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06-从尾到头打印链表</a>：stack（想到并写出了利用栈的方法，但是没想到递归的方法，但实际上两者需要内存大致相同）</p><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18-删除链表的节点</a>：双指针，头结点处理时可以使用哑点或者特殊处理</p><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22-链表中倒数第k个结点</a>：双指针（没想起思路）</p><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24-反转链表</a>：三个指针。注意<code>pre</code>指针的初始化，另外最终返回的是<code>pre</code>指针</p><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25-合并两个排序的链表</a>：双指针，哑点的使用（要注意基于递归的写法，建议练习）</p><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">面试题35-复杂链表的复制</a>：（想到并写出了利用map的方法，但是没想到节省空间的方法）</p><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">面试题52-两个链表的第一个公共节点</a>（想到并写出了利用栈的方法，但是没想到双指针法）</p><p><strong>链表测试用例：</strong></p><ol><li>特殊输入测试（输入的链表头结点指针为NULL）</li><li>普通链表（输入的链表有多个节点；输入的链表只有一个节点）</li></ol><p><strong>套路：</strong></p><ol><li>哑点的使用</li><li>双指针、三指针等用法</li></ol><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题07-重建二叉树</a>：递归（想到递归，终止判断条件和递归时子函数传参有误，根源在于对于迭代器和重建二叉树过程理解不到位）</p><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26-树的子结构</a>：两个递归（有大概思路，但是代码没想到是两个递归，需注意递归终止条件）</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27-二叉树的镜像</a>：递归（掌握，建议练习）</p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32-1 -从上往下打印二叉树</a>：队列（掌握）</p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32-2 -从上往下打印二叉树 2</a>：队列（掌握）</p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32-3 -从上往下打印二叉树 3</a>：两个栈（想到了使用<code>&lt;algorithm&gt;</code>中<code>reverse</code>方法，但是没想到使用两个栈或者双边队列）</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">面试题33-二叉搜索树的后序遍历序列</a>：后序遍历特点（未想起思路，代码需要这是一个递归过程）</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题34-二叉树中和为某一值的路径</a>：深度优先遍历，前序、中序、后序，这里用到了前序（想到了思路，但是不会写代码）</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36-二叉搜索树与双向链表</a>：递归（没想到思路，第二遍仍然没有写出来代码，建议练习）</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">面试题55-1-二叉树的深度</a>：递归（写的代码比较复杂）</p><p><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题55-2-平衡二叉树</a>：后序遍历（只想到了递归的方法，莫名其妙写成了后序遍历，建议练习）</p><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28-对称的二叉树</a>：递归（有大致思路，但写不出具体代码）</p><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37-序列化二叉树</a>：递归（有大致思路，但写不出具体代码，第二遍对于str库还不是很了解）</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">面试题54-二叉搜索树的第k大节点</a>：中序遍历，右根左（掌握）</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - I-二叉搜索树的最近公共祖先</a>：遍历（没有想到简单思路，第二遍代码写的复杂了，可以使用非递归的形式）</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - II-二叉树的最近公共祖先</a>：遍历（没有想到思路，第二遍仍然没有想到简单思路）</p><p><strong>二叉树测试用例：</strong></p><ol><li>普通二叉树（完全二叉树、非完全二叉树）</li><li>特殊二叉树（所有节点都没有右子节点的二叉树、所有节点都没有左子节点的二叉树、只有一个节点的二叉树）</li><li>特殊输入测试（二叉树的根节点指针为NULL；输入不满足题意）</li></ol><blockquote><p>看到二叉搜索树，就要想到前序、中序、后序遍历方式。其中中序遍历是按照从小到大的顺序排列的。</p></blockquote><p>套路：</p><ul><li>尝试将递归语句放到<code>if</code>条件中，可以</li></ul><h3 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h3><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09-用两个栈实现队列</a>：栈（想出来的思路不是最优解）</p><p><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">面试题30-包含min函数的栈</a>：辅助栈（push函数有点小问题）</p><p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">面试题31-栈的压入、弹出序列</a>：辅助栈（没有想到思路，第二遍仍没有写出来最优解，建议练习）</p><p><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">面试题58-1-翻转单词顺序</a>：<code>istringstream</code>的使用（没有想到最优解，第二遍仍然不会用这个库，建议记忆）</p><p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59-1-滑动窗口的最大值</a>：双边队列（没有想到，第二遍仍然没有想到）</p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40-最小的K个数</a>：最小堆，<code>priority_queue</code>的使用（没有想起来思路，第二遍对于该库还不是很熟悉）</p><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41-数据流中的中位数</a>：最大堆最小堆（没有想到思路，第二遍对库还不是很熟悉）</p><h3 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h3><p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">面试题50-第一个只出现一次的字符</a>：哈希表（想到了思路，但不会写代码。第二遍没有想出来是两遍遍历）</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题12-矩阵中的路径(BFS)</a>：回溯（能想到思路，代码不是很熟，第二遍代码仍然有问题，建议练习）</p><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">面试题13-机器人的运动范围(DFS)</a>：回溯（代码不是很熟练）</p><h2 id="具体算法类题目"><a href="#具体算法类题目" class="headerlink" title="具体算法类题目"></a>具体算法类题目</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof" target="_blank" rel="noopener">面试题10-1-斐波拉契数列</a>：循环、递归（没有想到数字溢出的情况，第二遍仍然没有考虑到）</p><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">面试题10-2-青蛙跳台阶问题</a>：循环、递归（掌握）</p><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">面试题04-二维数组中的查找</a>：右上角开始（能想到思路，但是代码不太会写）</p><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">面试题11-旋转数组的最小数字</a>：二分查找（思路也不是最优解，写出来的代码未完全覆盖所有测试用例）</p><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">面试题53-1-在排序数组中查找数字 I</a>：二分查找（能想到思路，建议练习，注意）</p><p><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题53-II-0～n-1中缺失的数字</a>：二分查找（能想到思路，但是没有注意到缺失数字在数组末尾的情况，第二遍仍然没有注意到，建议练习）</p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">面试题38-字符串的排列</a>：递归（能想到思路，建议练习）</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">面试题42-连续子数组的最大和</a>：DP（掌握，但不知道方法是DP）</p><p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">面试题19-正则表达式匹配</a>：递归（未想到思路，第二遍思路仍然不清晰，建议练习）</p><p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">面试题47-礼物的最大价值</a>：DP（没写出来递推公式）</p><p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题48-最长不含重复字符的子字符串</a>：DP（有思路但没想到转换为公式）</p><p><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">面试题60-n个骰子的点数</a>：DP（没想出来状态表达式，且代码容易写错）</p><h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">面试题14-I-剪绳子</a>：贪婪算法（没有想到思路）</p><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">面试题14-II-剪绳子</a>：贪婪算法（没有想到思路，第二遍不会解决大数问题，建议练习）</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题12-矩阵中的路径(BFS)</a>：回溯（能想到思路，代码不是很熟）</p><p><a href>面试题13-机器人的运动范围(DFS)</a>：回溯（代码不是很熟练）</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51-数组中的逆序对</a>：归并排序（只想到了暴力求解的方法，经典建议练习）</p><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">面试题53-I-在排序数组中查找数字 I</a>：二分查找</p><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40-最小的K个数</a>：最小堆（没有想起来思路）</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">面试题15-二进制中1的个数</a>：位运算（没有考虑到n&amp;n-1）</p><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof" target="_blank" rel="noopener">面试题16-数值的整数次方</a>：位运算（没有想到最优解，且测试用例想的不齐全，第二遍没有想到递归）</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56-1-数组中数字出现的次数</a>：异或性质（没有想到最优解）</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">面试题56-2-数组中数字出现的次数 II</a>：位运算（没有想到这个思路，第二遍仍然没有想出来解法）</p><p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">面试题65-不用加减乘除做加法</a>：位运算（没有想到思路，且没有考虑到负数的情况，第二遍仍然没有考虑到）</p><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题03-数组中重复的数字</a>：元素交换（只想到基于map的思路，不是最优解）</p><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05-替换空格</a>：从后向前移位（有思路，但是代码写的有问题）</p><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">面试题17-打印从1到最大的n位数</a>：大数问题（代码写的有问题，第二遍代码仍然不熟悉）</p><p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题20-表示数值的字符串</a>：主要考察代码的完整性（思路不是很清晰）</p><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">面试题21-调整数组顺序使奇数位于偶数前面</a>：（有思路，但是写出来的代码不是最优的）</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39-数组中出现次数超过一半的数字</a>：（只想到基于map的思路，不是最优解）</p><p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题43- 1～n整数中1出现的次数</a>：一位一位的按照当前值为<code>0,1,其他</code>计算1出现次数（没有想到最优解，第二遍仍然没有想到最优解）</p><p><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题44-数字序列中某一位的数字</a>：找规律（能想到思路，但是无法正确转换为代码，第二遍仍是，建议练习）</p><p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof" target="_blank" rel="noopener">面试题45-把数组排成最小的数</a>：自定义排序（思路有，但无法转换为具体的公式，第二遍不会使用C++自定义排序）</p><p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题46-把数字翻译成字符串</a>：循环（思路和官方思路稍有不同）</p><p><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">面试题49-丑数</a>：空间换时间（没有理解题意，第二遍仍然没有写出来代码）</p><p><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">面试题57-1-和为s的两个数字</a>：双指针（掌握）</p><p><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">面试题57-2-和为S的连续正数序列</a>：前后指针（没有写出来最优解，第二遍没有写出来简便代码，建议练习）</p><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题58-2-左旋转字符串</a>：字符翻转（使用C++ string字符串切割拼接更简单，第二遍仍然没有写出来简单代码）</p><p><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">面试题61-扑克牌中的顺子</a>：0的个数与中间元素的个数（没有抽象出具体问题，第二遍没有注意到相等的情况）</p><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62-圆圈中最后剩下的数</a>：约瑟夫环（没有推出递推公式，第二遍仍然没有思路，建议练习）</p><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">面试题63-股票的最大利润</a>：抽象建模（掌握）</p><p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">面试题64-求1+2+…+n</a>：发散思维（没有想法方法，第二遍仍然没有想到思路）</p><p><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">面试题66-构建乘积数组</a>：矩阵（没有想到简便方法，建议练习）</p><p><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">面试题67-把字符串转换成整数</a>：考虑问题的全面性、<code>isdigit</code>的使用（没有想到简洁代码的写法，第二遍没有想到函数库的使用）</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>每道题都要知道<strong>最优思路</strong></li><li>要会写<strong>结构体的定义和主函数</strong></li><li>每个算法都要<strong>分析时间、空间复杂度；想到所有的测试用例</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近快要面试了，再刷一遍剑指Offer，看大家分享刷LeetCode和剑指Offer的时候都是有模板的，如果按照随机顺序刷，很容易忘记而且不容易总结刷题思路。所以常常把一类题放到一块一起刷。&lt;/p&gt;
&lt;p&gt;《剑指Offer》有如下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很可能在面试中出现原题（至少在微软面试经常能遇到原题）&lt;/li&gt;
&lt;li&gt;题量少，但是涵盖的内容较全，性价比较高&lt;/li&gt;
&lt;li&gt;能培养一个良好的刷题习惯&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题目较少，&lt;strong&gt;刷着容易过拟合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;动态规划的题比较少，因此需要在力扣上专项训练。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="DataStructureAlgorithm" scheme="https://www.zdaiot.com/categories/DataStructureAlgorithm/"/>
    
    
      <category term="数据结构" scheme="https://www.zdaiot.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://www.zdaiot.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库常见用法</title>
    <link href="https://www.zdaiot.com/C/%E8%AF%AD%E6%B3%95/C++%E6%A0%87%E5%87%86%E5%BA%93%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    <id>https://www.zdaiot.com/C/语法/C++标准库常见用法/</id>
    <published>2020-07-08T09:20:17.000Z</published>
    <updated>2020-07-08T09:20:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在刷leetcode的时候，经常要用到标准库，这里总结一下标准库的常见用法，用于查询使用。</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>queue模板类的定义在<code>&lt;queue&gt;</code>头文件中。只能在容器的末尾添加新元素，只能从头部移除元素。</p><p>与stack模板类很相似，queue模板类也需要两个模板参数，一个是元素类型，一个容器类型，元素类型是必要的，容器类型是可选的，默认为deque类型。</p><p>定义queue对象的示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">double</span>&gt; q2;</span><br></pre></td></tr></table></figure><p>queue的基本操作有：</p><ol><li>入队，如<code>q.push(x);</code> 将x接到队列的末端</li><li>出队，如<code>q.pop();</code> 弹出队列的第一个元素，注意，并不会返回被弹出元素的值</li><li>访问队首元素，如<code>q.front();</code> 即最早被压入队列的元素</li><li>访问队尾元素，如<code>q.back();</code> 即最后被压入队列的元素</li><li>判断队列空，如<code>q.empty();</code> 当队列空时，返回true</li><li>访问队列中的元素个数，如<code>q.size();</code></li></ol><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector模板类的定义在<code>&lt;vector&gt;</code>头文件中。</p><p>定义vector对象的示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v2;</span><br><span class="line"><span class="comment">//初始化size,但每个元素值为默认值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; abc(<span class="number">10</span>);    <span class="comment">//初始化了10个默认值为0的元素</span></span><br><span class="line"><span class="comment">//初始化size,并且设置初始值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cde(<span class="number">10</span>，<span class="number">1</span>);    <span class="comment">//初始化了10个值为1的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>vector的基本操作有：</p><ol><li><p>尾部插入数字：<code>vec.push_back(a);</code></p></li><li><p>使用下标访问元素：<code>cout&lt;&lt;vec[0]&lt;&lt;endl;</code> 记住下标是从0开始的。</p></li><li><p>使用迭代器访问元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>插入元素：<code>vec.insert(vec.begin()+i,a);</code> 在第<code>i</code>个元素后面插入<code>a</code>;</p></li><li><p>删除元素：</p><p><code>vec.erase(vec.begin()+2);</code> 删除第3个元素；</p><p><code>vec.erase(vec.begin()+i,vec.end()+j);</code> 删除区间<code>[i,j-1];</code>区间从0开始</p><p><code>vec.pop_back();</code> 删除最后一个元素</p></li><li><p>向量大小：<code>vec.size();</code></p></li><li><p>得到首元素：<code>vec[0];</code> 或者<code>vec.front();</code></p></li><li><p>得到最后一个元素：<code>vec[vec.size() - 1];</code> 或者<code>vec.back();</code></p></li><li><p>清空：<code>vec.clear()</code>　　　//清空之后，<code>vec.size()</code>为０</p></li><li><p>反转：<code>reverse(vec.begin(), vec.end());</code></p></li></ol><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack模板类的定义在<code>&lt;stack&gt;</code>头文件中。</p><p>定义stack对象的示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; s2;</span><br></pre></td></tr></table></figure><p>stack的基本操作有：</p><ol><li><code>top()</code>：返回一个栈顶元素的引用，类型为 <code>T&amp;</code>。如果栈为空，返回值未定义。</li><li><code>push(const T&amp; obj)</code>：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</li><li><code>push(T&amp;&amp; obj)</code>：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</li><li><code>pop()</code>：弹出栈顶元素。</li><li><code>size()</code>：返回栈中元素的个数。</li><li><code>empty()</code>：在栈中没有元素的情况下返回 true。</li><li><code>emplace()</code>：用传入的参数调用构造函数，在栈顶生成对象。</li><li><code>swap(stack&lt;T&gt; &amp; other_stack)</code>：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。</li></ol><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是一类关联式容器。提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力。</p><p>它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。对于迭代器来说，可以修改实值，而不能修改key。</p><p>map定义在<code>&lt;map&gt;</code>头文件中。注意，STL头文件没有扩展名<code>.h</code></p><p>定义map示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;mapstring;         <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span> &gt;mapint;</span><br><span class="line"><span class="built_in">map</span>&lt;sring, <span class="keyword">char</span>&gt;mapstring;         <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;mapchar;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mapchar;            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;mapint；</span><br></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; maplive;  </span><br><span class="line">maplive.insert(pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;(<span class="number">102</span>,<span class="string">"aclive"</span>));</span><br><span class="line">maplive.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::value_type(<span class="number">321</span>,<span class="string">"hai"</span>));</span><br><span class="line">maplive[<span class="number">112</span>]=<span class="string">"April"</span>;<span class="comment">//map中最简单最常用的插入添加！</span></span><br></pre></td></tr></table></figure><p>map中元素的查找： find()函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span> &gt;::iterator l_it;; </span><br><span class="line">l_it = maplive.find(<span class="number">112</span>);</span><br><span class="line"><span class="keyword">if</span>(l_it==maplive.end())</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"we do not find 112"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">l_it-&gt;second;   <span class="comment">// 注意这个地方使用的是-&gt;second</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"wo find 112"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map中元素的查找：count()函数，返回值为0或1，表示是否包含。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m.count(key)&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> null;</span><br></pre></td></tr></table></figure><p>map中元素的删除：如果删除112；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span> &gt;::iterator l_it;;   </span><br><span class="line">l_it = maplive.find(<span class="number">112</span>);</span><br><span class="line"><span class="keyword">if</span>(l_it == maplive.end())</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"we do not find 112"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">maplive.erase(l_it);  <span class="comment">//delete 112;</span></span><br></pre></td></tr></table></figure><p>map的基本操作函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">C++ Maps是一种关联式容器，包含“关键字/值”对</span><br><span class="line">begin()     返回指向<span class="built_in">map</span>头部的迭代器</span><br><span class="line">clear(）     删除所有元素</span><br><span class="line">count()     返回指定元素出现的次数</span><br><span class="line">empty()     如果<span class="built_in">map</span>为空则返回<span class="literal">true</span></span><br><span class="line">end()      返回指向<span class="built_in">map</span>末尾的迭代器</span><br><span class="line">equal_range()  返回特殊条目的迭代器对</span><br><span class="line">erase()     删除一个元素</span><br><span class="line">find()      查找一个元素</span><br><span class="line">get_allocator() 返回<span class="built_in">map</span>的配置器</span><br><span class="line">insert()     插入元素</span><br><span class="line">key_comp()    返回比较元素key的函数</span><br><span class="line">lower_bound()  返回键值&gt;=给定元素的第一个位置</span><br><span class="line">max_size()    返回可以容纳的最大元素个数</span><br><span class="line">rbegin()     返回一个指向<span class="built_in">map</span>尾部的逆向迭代器</span><br><span class="line">rend()      返回一个指向<span class="built_in">map</span>头部的逆向迭代器</span><br><span class="line">size()      返回<span class="built_in">map</span>中元素的个数</span><br><span class="line">swap()      交换两个<span class="built_in">map</span></span><br><span class="line">upper_bound()   返回键值&gt;给定元素的第一个位置</span><br><span class="line">value_comp()   返回比较元素value的函数</span><br></pre></td></tr></table></figure><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque（双端队列）是由一段一段的定量连续空间构成，可以向两端发展，因此<strong>不论在尾部或头部安插元素都十分迅速。 在中间部分安插元素则比较费时，因为必须移动其它元素。</strong></p><p>deque定义在头文件<code>deque</code>中。</p><p>定义deque如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a; <span class="comment">// 定义一个int类型的双端队列a</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>); <span class="comment">// 定义一个int类型的双端队列a，并设置初始大小为10</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>, <span class="number">1</span>); <span class="comment">// 定义一个int类型的双端队列a，并设置初始大小为10且初始值都为1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; b(a); <span class="comment">// 定义并用双端队列a初始化双端队列b</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; b(a.begin(), a.begin()+<span class="number">3</span>); <span class="comment">// 将双端队列a中从第0个到第2个(共3个)作为双端队列b的初始值</span></span><br></pre></td></tr></table></figure><p>容量函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器大小：deq.size();</span><br><span class="line">容器最大容量：deq.max_size();</span><br><span class="line">更改容器大小：deq.resize();</span><br><span class="line">容器判空：deq.empty();</span><br><span class="line">减少容器大小到满足元素所占存储空间的大小：deq.shrink_to_fit();</span><br></pre></td></tr></table></figure><p>添加函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">头部添加元素：deq.push_front(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">末尾添加元素：deq.push_back(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">任意位置插入一个元素：deq.insert(iterator it, <span class="keyword">const</span> T&amp; x);</span><br><span class="line">任意位置插入 n 个相同元素：deq.insert(iterator it, <span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; x);</span><br><span class="line">插入另一个向量的 [forst,last] 间的数据：deq.insert(iterator it, iterator first, iterator last);</span><br></pre></td></tr></table></figure><p>删除函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">头部删除元素：deq.pop_front();</span><br><span class="line">末尾删除元素：deq.pop_back();</span><br><span class="line">任意位置删除一个元素：deq.erase(iterator it);</span><br><span class="line">删除 [first,last] 之间的元素：deq.erase(iterator first, iterator last);</span><br><span class="line">清空所有元素：deq.clear();</span><br><span class="line"></span><br><span class="line">删除键为bfff指向的元素</span><br><span class="line">cmap.erase(<span class="string">"bfff"</span>);</span><br><span class="line"> </span><br><span class="line">删除迭代器 key所指向的元素</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator key = cmap.find(<span class="string">"mykey"</span>);</span><br><span class="line"><span class="keyword">if</span>(key!=cmap.end()) &#123;</span><br><span class="line">cmap.erase(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除所有元素</span><br><span class="line">cmap.erase(cmap.begin(),cmap.end())</span><br></pre></td></tr></table></figure><p>访问函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下标访问：deq[<span class="number">1</span>]; <span class="comment">// 并不会检查是否越界</span></span><br><span class="line">at 方法访问：deq.at(<span class="number">1</span>); <span class="comment">// 以上两者的区别就是 at 会检查是否越界，是则抛出 out of range 异常</span></span><br><span class="line">访问第一个元素：deq.front();</span><br><span class="line">访问最后一个元素：deq.back();</span><br></pre></td></tr></table></figure><p>可以看到，deque 与 vector 的用法基本一致，除了以下几处不同：</p><ul><li>deque 没有 capacity() 函数，而 vector 有；</li><li>deque 有 push_front() 和 pop_front() 函数，而 vector 没有；</li><li>deque 没有 data() 函数，而 vector 有。</li></ul><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>priority_queue 容器适配器定义了一个<strong>元素有序排列</strong>的队列。默认队列头部的元素优先级最高。因为它是一个队列，所以<strong>只能访问第一个元素</strong>，这也意味着优先级最高的元素总是第一个被处理。</p><p>priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它定义了一个用来决定元素顺序的断言。因此模板类型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="keyword">typename</span> Compare=<span class="built_in">std</span>::less&lt;T&gt;&gt; class priority_queue</span><br></pre></td></tr></table></figure><p>priority_queue 实例默认有一个 vector 容器。<strong>函数对象类型 <code>less&lt;T&gt;</code> 是一个默认的排序断言（最大堆），最大的元素排在队列前面，出队的时候会出最大的元素，而入队的时候会重排</strong>，定义在头文件 function 中，决定了容器中最大的元素会排在队列前面。fonction 中定义了 <code>greater&lt;T&gt;</code>，用来作为模板的最后一个参数对元素排序，<strong>最小元素会排在队列前面，出队的时候最小的元素先出队，而入队的时候会重排</strong>。当然，如果指定模板的最巵一个参数，就必须提供另外的两个模板类型参数。</p><p>可以如下所示生成一个空的优先级队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; words; </span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; lo;  <span class="comment">// 大顶堆</span></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; hi; <span class="comment">// 小顶堆</span></span><br></pre></td></tr></table></figure><p>可以用适当类型的对象初始化一个优先级队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> wrds[] &#123; <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; words &#123; <span class="built_in">std</span>::begin(wrds), <span class="built_in">std</span>::end(wrds)&#125;; <span class="comment">// "two" "three" "one" "four"</span></span><br></pre></td></tr></table></figure><p>对 priority_queue 进行操作有一些限制：</p><ul><li><code>push(const T&amp; obj)</code>：将obj的副本放到容器的适当位置，这通常会包含一个<strong>排序</strong>操作。</li><li><code>push(T&amp;&amp; obj)</code>：将obj放到容器的适当位置，这通常会包含一个<strong>排序</strong>操作。</li><li><code>emplace(T constructor a rgs...)</code>：通过调用传入参数的构造函数，在序列的适当位置构造一个T对象。为了维持优先顺序，通常需要一个<strong>排序</strong>操作。</li><li><code>top()</code>：返回优先级队列中第一个元素的引用。</li><li><code>pop()</code>：移除第一个元素。</li><li><code>size()</code>：返回队列中元素的个数。</li><li><code>empty()</code>：如果队列为空的话，返回true。</li><li><code>swap(priority_queue&lt;T&gt;&amp; other)</code>：和参数的元素进行交换，所包含对象的类型必须相同。</li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。应该注意的是set中数元素的值不能直接被改变。</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>下面是一个使用 insert() 的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt;&gt; words &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> pr1 = words.insert(<span class="string">"four"</span>);</span><br><span class="line"><span class="keyword">auto</span> pr2 = words.insert (<span class="string">"two"</span>) ;</span><br><span class="line"><span class="keyword">auto</span> iter3 = words.insert(pr.first, <span class="string">"seven"</span>);</span><br><span class="line">words.insert (&#123; <span class="string">"five"</span>,<span class="string">"six"</span>&#125;) ;</span><br><span class="line"><span class="built_in">string</span> wrds[] &#123;<span class="string">"eight"</span>, <span class="string">"nine"</span>, <span class="string">"ten"</span>&#125;;</span><br><span class="line">words.insert(<span class="built_in">std</span>::begin(wrds) , <span class="built_in">std</span>::end(wrds));</span><br></pre></td></tr></table></figure><p>插入单个元素会返回一个 <code>pair&lt;iterator，bool&gt;</code> 对象。插入单个元素和一个标识，会返回一个迭代器。插入一段元素或一个初始化列表就不会有返回值。当 insert() 的参数是初始化列表时，会用列表中的字符串创建 string 对象。下面是两个在 set 容器中创建元素的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&gt; names;</span><br><span class="line"><span class="keyword">auto</span> pr = names.emplace(<span class="string">"Lisa"</span>, <span class="string">"Carr"</span>);</span><br><span class="line"><span class="keyword">auto</span> iter = names.emplace_hint(pr.first, <span class="string">"Joe"</span>, <span class="string">"King"</span>);</span><br></pre></td></tr></table></figure><p>这和 map 一样。成员函数 emplace() 会返回一个 pair<iterator,bool> 对象，而 emplace_hint() 只返回一个迭代器。前者的参数被直接传入元素的构造函数，用来创建元素。emplace_hint() 的第一个参数是一个迭代器，它指出了元素可能的插入位置，随后的参数会被传入元素的构造函数。</iterator,bool></p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>成员函数 clear() 会删除 set 的所有元素。成员函数 erase() 会删除迭代器指定位置的元素或与对象匹配的元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; numbers &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = numbers.erase(++<span class="built_in">std</span>::begin(numbers));</span><br><span class="line"><span class="keyword">auto</span> n = numbers.erase(<span class="number">12</span>);</span><br><span class="line">n = numbers.erase(<span class="number">13</span>);</span><br><span class="line">numbers.clear();</span><br></pre></td></tr></table></figure><p>成员函数 erase() 可以删除一段元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; numbers &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter1 = <span class="built_in">std</span>::begin(numbers); <span class="comment">// iter1 points to 1st element</span></span><br><span class="line">advance(iterl, <span class="number">5</span>); <span class="comment">// Points to 6th element-12</span></span><br><span class="line"><span class="keyword">auto</span> iter = numbers.erase(++<span class="built_in">std</span>:rbegin(numbers), iter1);<span class="comment">// Remove 2nd to 5th inclusive. iter points to 12</span></span><br></pre></td></tr></table></figure><p>如果 set 没有元素，成员函数 empty() 返回 true，成员函数 size() 返回它所包含的元素个数。如果担心无法在 set 中存储尽可能多的元素，可以调用成员函数 max_size() 来得到可存储的最大元素个数，这显然会是一个很大的值。</p><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>set 的成员函数 find() 会返回一个和参数匹配的元素的迭代器。如果对象不在 set 中，会返回一个结束迭代器。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; words &#123;<span class="string">"one"</span>, <span class="string">"two"</span>,<span class="string">"three"</span>, <span class="string">"four"</span>,<span class="string">"five"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = words.find (<span class="string">"one"</span>) ; <span class="comment">// iter points to "one"</span></span><br><span class="line">iter = words.find(<span class="built_in">string</span>&#123;<span class="string">"two"</span>&#125;);   <span class="comment">// iter points to "two"</span></span><br><span class="line">iter = words.find (<span class="string">"six"</span>);   <span class="comment">// iter is std:: end (words)</span></span><br></pre></td></tr></table></figure><p>调用成员函数 <code>count()</code> 可以返回指定键所对应的元素个数，返回值通常是 0 或 1，因为 set 容器中的元素是唯一的。set 容器模板定义了成员函数 equal_range()、lower_bound()、 upper_bound()，这和 multiset 容器在很大程度上是一致的。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>这个知识点不应该放在这里，但是我想把这篇文章当成是刷LeetCode时的查阅语法的地方，所以就姑且放在这里吧。</p><p>要访问<strong>顺序容器和关联容器</strong>中的元素，需要通过“迭代器（iterator）”进行。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，<strong>迭代器和指针类似。</strong></p><p>迭代器按照定义方式分成以下四种。</p><p>1) 正向迭代器，定义方法：<code>容器类名::iterator 迭代器名;</code></p><p>2) 常量正向迭代器，定义方法：<code>容器类名::const_iterator 迭代器名;</code></p><p>3) 反向迭代器，定义方法：<code>容器类名::reverse_iterator 迭代器名;</code></p><p>4) 常量反向迭代器，定义方法：<code>容器类名::const_reverse_iterator 迭代器名;</code></p><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li></ul><p>以下是不同容器对应的迭代器功能。</p><div class="table-container"><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set / multiset</td><td>双向</td></tr><tr><td>map / multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table></div><p>值得注意的有如下几点：</p><ol><li>双向迭代器不支持用“&lt;”进行比较</li><li>不支持随机访问的迭代器不能使用下标访问元素</li><li><code>.end()</code>得到的迭代器指向最后一个元素的下一个元素</li><li>判断一个容器是不是为空，若想用迭代器的用法，建议使用<code>vec.begin() == vec.end()</code>，不要使用<code>*vec.begin() == NULL</code>，会报错</li></ol><p>例如，vector 的迭代器是随机迭代器，因此遍历 vector 容器有以下几种做法。下面的程序中，每个循环演示了一种做法。</p><p>【实例】遍历 vector 容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">100</span>); <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size() ; ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i != v.end (); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i &lt; v.end ();++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    i = v.begin();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v.end()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 "+= 整数"  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i!=v.end(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i&lt;v.end(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p><strong>因为双向迭代器不支持用“&lt;”进行比较。以下代码也不合法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><p><strong>因为 list 不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</strong></p><p>在 C++中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string定义在头文件<code>string</code>中。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>string可以采用如下方式<strong>定义</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">()</span></span>;  <span class="comment">// si = ""</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;  <span class="comment">// s2 = "Hello"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">4</span>, <span class="string">'K'</span>)</span></span>;  <span class="comment">// s3 = "KKKK"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">"12345"</span>, <span class="number">1</span>, <span class="number">3</span>)</span></span>;  <span class="comment">//s4 = "234"，即 "12345" 的从下标 1 开始，长度为 3 的子串</span></span><br></pre></td></tr></table></figure><p>以下将从字符串下标 n 开始、长度为 m 的字符串称为<code>子串(n, m)</code>。</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>对 string 对象<strong>赋值</strong>：</p><ol><li><p>可以用 <code>char*</code> 类型的变量、常量，以及 char 类型的变量、常量对 string 对象进行赋值。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line">s1 = <span class="string">"Hello"</span>;  <span class="comment">// s1 = "Hello"</span></span><br><span class="line">s2 = <span class="string">'K'</span>;  <span class="comment">// s2 = "K”</span></span><br></pre></td></tr></table></figure></li><li><p>string 类还有 assign 成员函数，可以用来对 string 对象赋值。assign 成员函数返回对象自身的引用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1("12345"), s2;</span><br><span class="line">s3.assign(s1);  <span class="comment">// s3 = s1</span></span><br><span class="line">s2.assign(s1, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s2 = "23"，即 s1 的子串(1, 2)</span></span><br><span class="line">s2.assign(<span class="number">4</span>, <span class="string">'K'</span>);  <span class="comment">// s2 = "KKKK"</span></span><br><span class="line">s2.assign(<span class="string">"abcde"</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s2 = "cde"，即 "abcde" 的子串(2, 3)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> c = s[<span class="number">0</span>]; <span class="comment">// 按下标访问得到的char</span></span><br><span class="line"><span class="keyword">char</span> *cc = s.c_str(); <span class="comment">// string转为char*</span></span><br></pre></td></tr></table></figure><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>求字符串的<strong>长度</strong>：length 成员函数返回字符串的长度。size 成员函数可以实现同样的功能。</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>string对象中字符串的<strong>连接</strong>：除了可以<strong>使用<code>+</code>和<code>+=</code>运算符</strong>对 string 对象执行字符串的连接操作外，string 类还有 append 成员函数，可以用来向字符串后面添加内容。append 成员函数返回对象自身的引用。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1("123"), s2("abc");</span><br><span class="line">s1.append(s2);  <span class="comment">// s1 = "123abc"</span></span><br><span class="line">s1.append(s2, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s1 = "123abcbc"</span></span><br><span class="line">s1.append(<span class="number">3</span>, <span class="string">'K'</span>);  <span class="comment">// s1 = "123abcbcKKK"</span></span><br><span class="line">s1.append(<span class="string">"ABCDE"</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s1 = "123abcbcKKKCDE"，添加 "ABCDE" 的子串(2, 3)</span></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>除了可以用 &lt;、&lt;=、==、!=、&gt;=、&gt; 运算符比较 string 对象外，string 类还有 compare 成员函数，可用于比较字符串。compare 成员函数有以下返回值：</p><ul><li>小于 0 表示当前的字符串小；</li><li>等于 0 表示两个字符串相等；</li><li>大于 0 表示另一个字符串小。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s1("hello"), s2("hello, world");</span><br><span class="line"><span class="keyword">int</span> n = s1.compare(s2);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, s2, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">//比较s1的子串 (1,2) 和s2的子串 (0,3)</span></span><br><span class="line">n = s1.compare(<span class="number">0</span>, <span class="number">2</span>, s2);  <span class="comment">// 比较s1的子串 (0,2) 和 s2</span></span><br><span class="line">n = s1.compare(<span class="string">"Hello"</span>);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"Hello"</span>);  <span class="comment">//比较 s1 的子串(1,2)和"Hello”</span></span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"Hello"</span>, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//比较 s1 的子串(1,2)和 "Hello" 的子串(1,2)</span></span><br></pre></td></tr></table></figure><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>swap 成员函数可以交换两个 string 对象的内容。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"West”), s2("</span>East<span class="string">");</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">s1.swap(s2);  // s1 = "</span>East<span class="string">"，s2 = "</span>West<span class="string">"</span></span></span></span><br></pre></td></tr></table></figure><h3 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h3><p>substr 成员函数可以用于求子串 (n, m)，原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="built_in">string</span>::npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>调用时，如果省略 m 或 m 超过了字符串的长度，则求出来的子串就是从下标 n 开始一直到字符串结束的部分。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"this is ok"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1.substr(<span class="number">2</span>, <span class="number">4</span>);  <span class="comment">// s2 = "is i"</span></span><br><span class="line">s2 = s1.substr(<span class="number">2</span>);  <span class="comment">// s2 = "is is ok"</span></span><br></pre></td></tr></table></figure><h3 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h3><p>insert 成员函数可以在 string 对象中插入另一个字符串，返回值为对象自身的引用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1("Limitless"), s2("00");</span><br><span class="line">s1.insert(<span class="number">2</span>, <span class="string">"123"</span>);  <span class="comment">//在下标 2 处插入字符串"123"，s1 = "Li123mitless"</span></span><br><span class="line">s1.insert(<span class="number">3</span>, s2);  <span class="comment">//在下标 2 处插入 s2 , s1 = "Li10023mitless"</span></span><br><span class="line">s1.insert(<span class="number">3</span>, <span class="number">5</span>, <span class="string">'X'</span>);  <span class="comment">//在下标 3 处插入 5 个 'X'，s1 = "Li1XXXXX0023mitless"</span></span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">s.push_back(<span class="string">'w'</span>);</span><br><span class="line">s.resize(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="格式互转"><a href="#格式互转" class="headerlink" title="格式互转"></a>格式互转</h2><h3 id="转int"><a href="#转int" class="headerlink" title="转int"></a>转int</h3><p>C语言转换形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> i = atoi(str.c_str()); <span class="comment">// 不做范围检查，超出上界，则输出上界，超出下界，则输出下界；</span></span><br></pre></td></tr></table></figure><p>C++转换形式(C++11)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">std</span>::stoi(str); <span class="comment">//会做范围检查，超过范围会报错</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/msdnwolaile/article/details/52708144" target="_blank" rel="noopener">C++ vector用法（详解！！函数，实现）</a><br><a href="https://blog.csdn.net/wangshihui512/article/details/8930652" target="_blank" rel="noopener">C++ 标准模板库STL 队列 queue 使用方法与应用介绍（一）</a><br><a href="http://c.biancheng.net/view/478.html" target="_blank" rel="noopener">C++ stack(STL stack)用法详解</a><br><a href="https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html" target="_blank" rel="noopener">C++ map用法</a><br><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html" target="_blank" rel="noopener">C++中的STL中map用法详解</a><br><a href="http://c.biancheng.net/view/338.html" target="_blank" rel="noopener">C++迭代器（STL迭代器）iterator详解</a><br><a href="http://c.biancheng.net/view/479.html" target="_blank" rel="noopener">C++ queue(STL queue)用法详解</a><br><a href="https://www.cnblogs.com/linuxAndMcu/p/10260124.html" target="_blank" rel="noopener">[C++ STL] deque使用详解</a><br><a href="https://blog.csdn.net/dongyanxia1000/article/details/52838922" target="_blank" rel="noopener">vector删除元素之pop_back(),erase(),remove()</a><br><a href="http://c.biancheng.net/view/480.html" target="_blank" rel="noopener">C++ priority_queue(STL priority_queue)用法详解</a><br><a href="https://blog.csdn.net/tengfei461807914/article/details/52203202" target="_blank" rel="noopener">C++ string的用法和例子</a><br><a href="http://c.biancheng.net/view/400.html" target="_blank" rel="noopener">C++ string类（C++字符串）完全攻略</a><br><a href="http://c.biancheng.net/view/538.html" target="_blank" rel="noopener">C++ set添加、删除和访问(STL set添加、删除和访问)元素详解</a><br><a href="https://blog.csdn.net/weixin_36888577/article/details/79937886" target="_blank" rel="noopener">c++优先队列(priority_queue)用法详解</a><br><a href="https://blog.csdn.net/qq_33221533/article/details/82119031" target="_blank" rel="noopener">c++中的atoi()和stoi()函数的用法和区别</a><br><a href="https://blog.csdn.net/caroline_wendy/article/details/29390573" target="_blank" rel="noopener">C++ - string类型转换int类型</a><br><a href="https://blog.csdn.net/wangjingqi930330/article/details/81938998" target="_blank" rel="noopener">c++ map查找key</a><br><a href="https://blog.csdn.net/yjunyu/article/details/77728410" target="_blank" rel="noopener">vector的几种初始化及赋值方式</a><br><a href="https://blog.csdn.net/zvall/article/details/52267007" target="_blank" rel="noopener">c++ map删除元素的三种方式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在刷leetcode的时候，经常要用到标准库，这里总结一下标准库的常见用法，用于查询使用。&lt;/p&gt;
&lt;h2 id=&quot;queue&quot;&gt;&lt;a href=&quot;#queue&quot; class=&quot;headerlink&quot; title=&quot;queue&quot;&gt;&lt;/a&gt;queue&lt;/h2&gt;&lt;p&gt;queue模板类的定义在&lt;code&gt;&amp;lt;queue&amp;gt;&lt;/code&gt;头文件中。只能在容器的末尾添加新元素，只能从头部移除元素。&lt;/p&gt;
&lt;p&gt;与stack模板类很相似，queue模板类也需要两个模板参数，一个是元素类型，一个容器类型，元素类型是必要的，容器类型是可选的，默认为deque类型。&lt;/p&gt;
&lt;p&gt;定义queue对象的示例代码如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.zdaiot.com/categories/C/"/>
    
      <category term="语法" scheme="https://www.zdaiot.com/categories/C/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="C++" scheme="https://www.zdaiot.com/tags/C/"/>
    
      <category term="queue" scheme="https://www.zdaiot.com/tags/queue/"/>
    
      <category term="vector" scheme="https://www.zdaiot.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>目标检测评价指标</title>
    <link href="https://www.zdaiot.com/DeepLearningApplications/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>https://www.zdaiot.com/DeepLearningApplications/目标检测/目标检测评价指标/</id>
    <published>2020-07-07T06:54:08.000Z</published>
    <updated>2020-07-07T06:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>mAP: mean Average Precision，即各类别AP的平均值</p><p>AP: PR曲线下面积，后文会详细讲解</p><p>PR曲线: Precision-Recall曲线</p><p>Precision: TP / (TP + FP)</p><p>Recall: TP / (TP + FN)</p><p>TP: IoU&gt;0.5的检测框数量（同一Ground Truth只计算一次）</p><p>FP: IoU&lt;=0.5的检测框，或者是检测到同一个GT的多余检测框的数量</p><p>FN: 没有检测到的GT的数量</p><blockquote><p>其实Precision和Recall就是分母不同，一个分母是预测为正的样本数，另一个是原来样本中所有的正样本数。</p></blockquote><p>注意：<strong>一般来说mAP针对整个数据集而言的；AP针对数据集中某一个类别而言的；而percision和recall针对单张图片某一类别的。</strong></p><h2 id="mAP的具体计算"><a href="#mAP的具体计算" class="headerlink" title="mAP的具体计算"></a>mAP的具体计算</h2><p>由前面定义，我们可以知道，要计算mAP必须先绘出各类别PR曲线，计算出AP。而如何采样PR曲线，VOC采用过两种不同方法。参见：<a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/htmldoc/devkit_doc.html#SECTION00044000000000000000" target="_blank" rel="noopener">The PASCAL Visual Object Classes Challenge 2012 (VOC2012) Development Kit</a></p><ol><li><p>在VOC2010以前，只需要选取当Recall &gt;= 0, 0.1, 0.2, …, 1共11个点时的Precision最大值，然后AP就是这11个Precision的平均值。</p></li><li><p>在VOC2010及以后，需要针对每一个不同的Recall值（包括0和1），选取其大于等于这些Recall值时的Precision最大值，然后计算PR曲线下面积作为AP值。</p></li><li>COCO数据集，设定多个IOU阈值（0.5-0.95,0.05为步长），在每一个IOU阈值下都有某一类别的AP值，然后求不同IOU阈值下的AP平均，就是所求的最终的某类别的AP值。</li></ol><p>下面给出<strong>某一个类别</strong>AP的计算示例：</p><p>对于多类别目标检测，首先选定一个类别，比如说<code>Aeroplane</code>类别，从检测器中筛选出<strong>这种类别的检测框（其他类别的先不管，并且这里是所有图片的结果）</strong>。假设网络有以下输出(BB表示BoundingBox序号，IoU&gt;0.5时GT=1)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BB  | confidence | GT</span><br><span class="line">----------------------</span><br><span class="line">BB1 |  0.9       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB2 |  0.9       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB1 |  0.8       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB3 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB4 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB5 |  0.7       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB6 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB7 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB8 |  0.7       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB9 |  0.7       | 1</span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure><p>这里需要注意的有如下几点：</p><ol><li>这里的confidence一般指的是分类得分，也就是预测框中物体属于<code>Aeroplane</code>类别的概率</li><li>上面各行是按照confidence进行排序的，跟后面计算时的rank对应；另外这样排序后也方便将检测到同一个GT的多余检测框去掉</li><li>这里有两个BB1，这两个并不是同一个bbox，指的是同一个GT匹配上了不同的bbox</li><li>因为percision和recall针对单张图片某一类别的。而在实际计算的时候，是将所有图片该类别的检测结果和GT放到一块计算的。</li></ol><p>因此，我们有 TP=5 (第一个BB1, BB2, BB5, BB8, BB9), FP=5 (重复检测到的BB1也算FP)。除了表里检测到的5个GT以外，我们还有2个GT没被检测到，因此: FN = 2. 这时我们就可以按照Confidence的顺序给出各处的PR值，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rank=1  precision=1.00 and recall=0.14</span><br><span class="line">----------</span><br><span class="line">rank=2  precision=1.00 and recall=0.29</span><br><span class="line">----------</span><br><span class="line">rank=3  precision=0.66 and recall=0.29</span><br><span class="line">----------</span><br><span class="line">rank=4  precision=0.50 and recall=0.29</span><br><span class="line">----------</span><br><span class="line">rank=5  precision=0.40 and recall=0.29</span><br><span class="line">----------</span><br><span class="line">rank=6  precision=0.50 and recall=0.43</span><br><span class="line">----------</span><br><span class="line">rank=7  precision=0.43 and recall=0.43</span><br><span class="line">----------</span><br><span class="line">rank=8  precision=0.38 and recall=0.43</span><br><span class="line">----------</span><br><span class="line">rank=9  precision=0.44 and recall=0.57</span><br><span class="line">----------</span><br><span class="line">rank=10 precision=0.50 and recall=0.71</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><p>对于上述PR值，如果我们采用：</p><ol><li>VOC2010之前的方法，选取$Recall &gt;= 0, 0.1, …, 1$的11处Percision的最大值：$1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, 0, 0$。此时<code>Aeroplane</code>类别的 $AP = 5.5 / 11 = 0.5$</li><li>VOC2010及以后的方法，对于$Recall &gt;= 0, 0.14, 0.29, 0.43, 0.57, 0.71, 1$，选取此时Percision的最大值：$1, 1, 1, 0.5, 0.5, 0.5, 0$。此时<code>Aeroplane</code>类别的 $AP = (0.14-0)<em>1 + (0.29-0.14)</em>1 + (0.43-0.29)<em>0.5 + (0.57-0.43)</em>0.5 + (0.71-0.57)<em>0.5 + (1-0.71)</em>0 = 0.5$</li><li>COCO数据集，设定多个IOU阈值（0.5-0.95,0.05为步长），在每一个IOU阈值下都有某一类别的AP值，然后求不同IOU阈值下的AP平均，就是所求的最终的某类别的AP值。</li></ol><p><strong>mAP就是对每一个类别都计算出AP然后再计算AP平均值就好了</strong>。</p><p>建议参考GluonCV库里面的voc_detection.py实现了两种mAP计算方式，思路清晰：<a href="https://github.com/dmlc/gluon-cv/blob/master/gluoncv/utils/metrics/voc_detection.py" target="_blank" rel="noopener">https://github.com/dmlc/gluon-cv/blob/master/gluoncv/utils/metrics/voc_detection.py</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/53405779/answer/419532990" target="_blank" rel="noopener">目标检测中的mAP是什么含义？ - Wentao的回答 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/70306015" target="_blank" rel="noopener">目标检测的性能评价指标</a><br><a href="https://www.zhihu.com/question/19645541/answer/91694636" target="_blank" rel="noopener">如何解释召回率与精确率？ - Charles Xiao的回答 - 知乎</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;mAP: mean Average Precision，即各类别AP的平均值&lt;/p&gt;
&lt;p&gt;AP: PR曲线下面积，后文会详细讲解&lt;/p&gt;
&lt;p&gt;PR曲线: Precision-Recall曲线&lt;/p&gt;
&lt;p&gt;Precision: TP / (TP + FP)&lt;/p&gt;
    
    </summary>
    
    
      <category term="DeepLearningApplications" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/"/>
    
      <category term="目标检测" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="评价指标" scheme="https://www.zdaiot.com/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
      <category term="目标检测" scheme="https://www.zdaiot.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="mAP" scheme="https://www.zdaiot.com/tags/mAP/"/>
    
  </entry>
  
  <entry>
    <title>TensorRT INT8量化原理</title>
    <link href="https://www.zdaiot.com/MLFrameworks/TensorRT/TensorRT%20INT8%E9%87%8F%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    <id>https://www.zdaiot.com/MLFrameworks/TensorRT/TensorRT INT8量化原理/</id>
    <published>2020-07-07T01:02:31.000Z</published>
    <updated>2020-07-07T01:02:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要参考了<a href="https://arleyzhang.github.io/articles/923e2c40/" target="_blank" rel="noopener">TensorRT(5)-INT8校准原理</a>，并添加了一些自己的见解。</p><h2 id="Low-Precision-Inference"><a href="#Low-Precision-Inference" class="headerlink" title="Low Precision Inference"></a>Low Precision Inference</h2><p>现有的深度学习框架，如Pytorch、Tensorflow在训练一个深度神经网络时，往往都会使用 <strong>float 32（Full Precise ，简称FP32）</strong>的数据精度来表示，权值、偏置、激活值等。若一个网络很深的话，比如像VGG，ResNet这种，网络参数是极其多的，计算量就更多了（比如VGG 19.6 billion FLOPS, ResNet-152 11.3 billion FLOPS）。如果多的计算量，如果都采用FP32进行推理，对于嵌入式设备来说计算量是不能接受的。解决此问题主要有两种方案：</p><ol><li>模型压缩、剪枝。在这里不做讨论。</li><li>在部署推理时（inference）使用低精度数据，比如INT8。当然训练的时候仍然采取FP32的精度。</li></ol><p><strong>下面从经验上分析低精度推理的可行性。</strong></p><p>实际上有些人认为，即便在推理时使用低精度的数据（比如INT8），在提升速度的同时，也并不会造成太大的精度损失，比如 <a href="https://petewarden.com/2015/05/23/why-are-eight-bits-enough-for-deep-neural-networks/" target="_blank" rel="noopener">Why are Eight Bits Enough for Deep Neural Networks?</a> 以及<a href="https://towardsdatascience.com/low-precision-inference-with-tensorrt-6eb3cda0730b" target="_blank" rel="noopener">Low Precision Inference with TensorRT</a> 这两篇博文。</p><p>文章的作者认为网络在训练的过程中学习到了数据样本的模式可分性，同时由于数据中存在的噪声，使得网络具有较强的鲁棒性，也就是说在输入样本中做轻微的变动并不会过多的影响性能。与图像上目标间的位置、姿态、角度等变化相比，这些噪声引进的变动只是很少的一部分。但实际上这些噪声引进的变动同样会使各个层的激活值输出发生变动，然而却对结果影响不大，也就是说<strong>训练好的网络对这些噪声具有一定的容忍度（tolerance ）。</strong></p><p>正是由于在训练过程中使用高精度（FP32）的数值表示，才使得网络具有一定的容忍度。训练时使用高精度的数值表示，可以使得网络在每一步训练都会对参数进行少量的修正，这在网络最后收敛的时候是很重要的，因为收敛的时候要求修正量很小很小（一般训练初始 阶段学习率稍大，越往后学习率越小）。</p><p>那么<strong>如果使用低精度的数据来表示网络参数以及中间值的话，势必会存在误差，这个误差某种程度上可以认为是一种噪声</strong>。那也就是说，<strong>使用低精度数据引进的差异是在网络的容忍度之内的</strong>，所以对结果不会产生太大影响。</p><p>以上分析都是基于经验的，理论上的分析比较少，不过文章提到了两篇 paper，如下：</p><ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/37631.pdf" target="_blank" rel="noopener">Improving the speed of neural networks on CPUs</a></li><li><a href="https://arxiv.org/abs/1412.7024" target="_blank" rel="noopener">Training deep neural networks with low precision multiplications</a></li></ul><p>感兴趣的同学可以自行研究。</p><p>TensorRT 的INT8模式只支持计算能力为6.1的GPU（Compute Capability 6.1 ），比如： GP102 (Tesla P40 and NVIDIA Titan X), GP104 (<a href="https://devblogs.nvidia.com/parallelforall/new-pascal-gpus-accelerate-inference-in-the-data-center/" target="_blank" rel="noopener">Tesla P4</a>), and GP106 GPUs，主要根源是这些<strong>GPU支持 DP4A硬件指令</strong>。DP4A下面会稍微介绍一下。</p><h2 id="TensorRT-INT8-Inference"><a href="#TensorRT-INT8-Inference" class="headerlink" title="TensorRT INT8 Inference"></a>TensorRT INT8 Inference</h2><p>首先看一下不同精度的动态范围：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">动态范围</th><th style="text-align:left">最小正数</th></tr></thead><tbody><tr><td style="text-align:left">FP32</td><td style="text-align:left">$−3.4×10^{38} +3.4×10^{38}$</td><td style="text-align:left">$1.4×10^{−45}$</td></tr><tr><td style="text-align:left">FP16</td><td style="text-align:left">$−65504 +65504$</td><td style="text-align:left">$5.96×10^{−8}$</td></tr><tr><td style="text-align:left">INT8</td><td style="text-align:left">$−128 +127$</td><td style="text-align:left">1</td></tr></tbody></table></div><p>实际上将FP32的精度降为INT8还是比较具有挑战性的。</p><h3 id="Quantization"><a href="#Quantization" class="headerlink" title="Quantization"></a>Quantization</h3><p>将FP32降为INT8的过程相当于<strong>信息再编码</strong>（re-encoding information ），就是原来使用32bit来表示一个tensor，现在使用8bit来表示一个tensor，还要求精度不能下降太多。将FP32转换为 INT8的操作需要针对<strong>每一层的输入张量（tensor）和 网络学习到的参数（learned parameters）</strong>进行。</p><p>首先能想到的最简单的映射方式就是线性映射（或称线性量化，linear quantization）, 就是说映射前后的关系满足下式：</p><script type="math/tex; mode=display">\text{FP32 Tensor (T) = scale_factor(sf) * 8-bit Tensor(t) + FP32_bias (b)}</script><p>试验证明，偏置实际上是不需要的，因此去掉偏置，也就是</p><script type="math/tex; mode=display">T = sf * t</script><p>$sf$是<strong>每一层上每一个tensor</strong>的换算系数或称比例因子（scaling factor），因此现在的问题就变成了如何确定比例因子。然后最简单的方法是下图这样的：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/no_satuation_int8_quantization.png" alt="no_satuation_int8_quantization"></p><ul><li>简单的将一个tensor 中的 $-|max|$ 和 $|max|$ FP32 value 映射为 -127 和 127 ，中间值按照线性关系进行映射。</li><li>称这种映射关系为不饱和的（No saturation，$max$很大实际模型的激活值可能取不到），对称的。</li></ul><p>但是试验结果显示这样做会导致比较大的精度损失。</p><p>下面这张图展示的是不同网络结构的不同layer的激活值分布，有卷积层，有池化层，他们之间的分布很不一样，因此<strong>合理的量化方式应该适用于不同的激活值分布，并且减小信息损失。</strong>因为从FP32到INT8其实就是一种信息再编码的过程。</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/distribution-of-different-layers.png.png" alt="1535654439553"></p><p>上图的解释有思考如下：</p><ul><li>上图是一些网络模型中间层的激活值统计，横坐标是激活值，纵坐标是统计数量的归一化表示，这里是归一化表示，不是绝对数值统计；</li><li>这个激活值统计针对的是<strong>一批图片</strong>，不同的图片输出的激活值不完全相同。所以图上并不是一条曲线而是多条曲线（一张图片对应一条曲线，或者称为散点图更好一点），只不过前面一部分重复在一块了（红色虚线圈起来的部分），说明对于<strong>不同图片生成的大部分激活值其分布是相似的</strong>；但是在激活值比较大时（红色实线圈起来的部分），曲线不重复了，一个激活值对应多个不同的统计量，这时的激活值分布就比较乱了。</li><li>后面这一部分在整个层中是占少数的（占比很小，比如10^-9, 10^-7, 10^-3），因此<strong>后面这一段完全可以不考虑到映射关系中去，保留激活值分布的主要部分</strong>。开始以为网络之所以能把不同类别的图片分开是由于后面实线部分的差异导致的，后来想了一下：这个并不包含Tensor空间位置的分布，只是数值上的分布，所以后面的应该对结果影响不大。</li></ul><p>因此TensorRT的做法是：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/satuation_int8_quantization.png" alt="satuation_int8_quantization"></p><ul><li>这种做法不是将 $±|max|$ 映射为 $±127$，而是存在一个 阈值 $|T|$ ，将 $±|T|$ 映射为±127，显然这里 $|T|&lt;|max|$。</li><li>超出 阈值 $±|T|$ 外的直接映射为阈值 $±127$。比如上图中的三个红色点，直接映射为$-127$。</li><li>称这种映射关系为<strong>饱和的（Saturate ），不对称的。</strong></li><li><strong>只要阈值选取得当，就能将分布散乱的较大的激活值舍弃掉，也就有可能使精度损失不至于降低太多。</strong></li></ul><p>网络的前向计算涉及到两部分数值：权值和激活值（weights 和activation，二者要做乘法运算，可以将激活值看作是某层的输出要和下一层的权重做乘法运算），Szymon Migacz也提到他们曾经做过实验，说对weights 做saturation变换没有什么变化，因此<strong>对于weights的INT8量化就使用的是不饱和的方式</strong>（饱和方式需要确定$|T|$，比较麻烦）；而对activation做saturation变换就有比较显著的性能提升，因此<strong>对activation使用的是饱和的量化方式</strong>。</p><p>那现在的问题是如何确定$|T|$？假设有一个FP32的tensor，FP32肯定是能够表达这个tensor的最佳分布。现在我们要用一个不同的分布（INT8）来表达这个tensor，这个INT8 分布不是一个最佳的分布。<strong>饱和的INT8分布由于阈值|T|的取值会有很多种情况（$128 \sim |max|$），其中肯定有一种情况是相对其他最接近FP32的，我们就是要把这种情况找出来。</strong></p><p>那么就<strong>需要一个衡量指标来衡量不同的INT8 分布与原来的FP3F2分布之间的差异程度。</strong>这个衡量指标就是<strong>相对熵</strong>（relative entropy），又称为<strong>KL散度</strong>（<strong>Kullback–Leibler divergence</strong>，简称<strong>KLD</strong>），信息散度（information divergence），信息增益（information gain）。叫法实在太多了，最常见的就是相对熵，跟交叉熵也是有关系的。</p><ul><li><p>假设我们要给一个信息进行完美编码，那么最短平均编码长度就是信息熵。</p></li><li><p>如果编码方案不一定完美（由于对概率分布的估计不一定正确），这时的平均编码长度就是交叉熵。</p><p>平均编码长度 = 最短平均编码长度 + 一个增量</p><p>交叉熵在深度学习中广泛使用，衡量了测试集标签分布和模型预测分布之间的差异程度。</p></li><li><p><strong>编码方法不一定完美时，平均编码长度相对于最小值的增加量（即上面那个增量）是相对熵。</strong></p></li></ul><p>即 <strong>交叉熵=信息熵+相对熵</strong></p><p>通俗的理解 信息熵，交叉熵，相对熵，参考：<a href="https://www.zhihu.com/question/41252833" target="_blank" rel="noopener">知乎：如何通俗的解释交叉熵与相对熵?</a></p><p>如何理解信息熵用来表示最短平均编码长度，参考： <a href="http://blog.csdn.net/hearthougan/article/details/77774948" target="_blank" rel="noopener">如何理解用信息熵来表示最短的平均编码长度</a></p><p>在这里，FP32的tensor就是要表达的信息量，FP32也是最佳分布（可以认为最短编码长度32bit），现在要做的是使用INT8 来编码FP32的信息，同时要求INT8编码后差异尽可能最小。考虑两个分布 P（FP32）、Q（INT8）KL散度计算如下：</p><script type="math/tex; mode=display">\text{KL_divergence(P,Q):= SUM(P[i] * log(P[i] / Q[i] ), i)}</script><p>$P，Q$分别称为reference_distribution、quantize _distribution，$i$表示第$i$层。实际上这里也说明了<strong>每一层的tensor 的$|T|$值都是不一样的。确定每一层的$|T|$值的过程称为校准（Calibration ）。</strong></p><h3 id="Calibration"><a href="#Calibration" class="headerlink" title="Calibration"></a>Calibration</h3><p>上面已经说了 <strong>KL散度越小代表INT8编码后的信息损失越少</strong>。接下来来看看如何根据KL散度寻找最佳INT8分布。其实前面也已经提到了，如果要让最后的精度损失不大，是要考虑一些先验知识的，这个先验知识就是每一层在 FP32精度下的激活值分布，只有根据这个才能找到更加合理的阈值$|T|$。也就是说首先得有一个以FP32精度训练好的模型。基本上现有的深度学习框架都是默认FP32精度的，有些模型还支持FP16精度训练。所以基本上只要没有特别设定，训练出来的模型肯定是 FP32 的。</p><p>那激活值分布如何得到？这里的做法是<strong>从验证集</strong>选取一个子集作为校准集（Calibration Dataset），校准集应该具有代表性，多样性，最好是验证集的一个子集，不应该只是分类类别的一小部分。激活值分布就是从校准集中得到的。</p><p>按照<a href="http://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#calibrationset" target="_blank" rel="noopener">NVIDIA 官方的说法</a>：</p><blockquote><p>Note: The calibration set must be representative of the input provided to TensorRT at runtime; for example, for image classification networks, it should not consist of images from just a small subset of categories. For ImageNet networks, around 500 calibration images is adequate.</p></blockquote><p>对于ImageNet 数据集来说 校准集大小一般500张图片就够了（Szymon Migacz的演讲说用1000张），这里有点怀疑也有点震惊，没想到 ImageNet 1000个分类，100多万张图片，500张就够了，不过从2.5节的图表中的结果可以看出500张确实够了。</p><p>然后要做的是：</p><ul><li>首先在校准集上进行 FP32 inference 推理；</li><li>对于<strong>网络的每一层</strong>（遍历）：<ul><li>收集这一层的激活值，并做<strong>直方图</strong>（histograms ），分成几个组别（bins）（官方给的一个说明使用的是2048组），分组是为了下面遍历|T| 时，减少遍历次数；</li><li>对于不同的阈值|T|进行遍历，因为这里|T|的取值肯定在第128-2047组之间，所以就选取每组的中间值进行遍历；<ul><li>选取使得 KL_divergence(ref_distr, quant_distr) 取得最小值的 |T|。</li></ul></li></ul></li><li>返回一系列|T|值，每一层都有一个|T|。创建 <strong>CalibrationTable</strong> 。</li></ul><p>解释一下：假设最后使得KL散度最小的|T|值是第200组的中间值，那么就把原来第0-200组的数值线性映射到0-128之间，超出范围的直接映射到128。</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/Calibration-process.png" alt="1516636471289"></p><p>校准的过程可以参考一下这个：<a href="https://www.jianshu.com/p/43318a3dc715，" target="_blank" rel="noopener">https://www.jianshu.com/p/43318a3dc715，</a> 这篇文章提供了一个详细的根据KL散度来将原始信息进行编码的例子，包括直方图的使用。跟这里的校准过程极为相像。</p><p>下面是一个官方 <a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf" target="_blank" rel="noopener">GTC2017 PPT</a> 中给的校准的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先分成 2048个组，每组包含多个数值（基本都是小数）</span></span><br><span class="line">Input: FP32 histogram H with <span class="number">2048</span> bins: bin[ <span class="number">0</span> ], …, bin[ <span class="number">2047</span> ] </span><br><span class="line">  </span><br><span class="line">For i in range( 128 , 2048 ): // |T|的取值肯定在 第128-2047 组之间,取每组的中点</span><br><span class="line">reference_distribution_P = [ bin[ <span class="number">0</span> ] , ..., bin[ i<span class="number">-1</span> ] ] <span class="comment">// 选取前 i 组构成P，i&gt;=128</span></span><br><span class="line">outliers_count = sum( bin[ i ] , bin[ i+<span class="number">1</span> ] , … , bin[ <span class="number">2047</span> ] ) <span class="comment">//边界外的组</span></span><br><span class="line">reference_distribution_P[ i<span class="number">-1</span> ] += outliers_count <span class="comment">//边界外的组加到边界P[i-1]上，没有直接丢掉</span></span><br><span class="line">P /= sum(P) <span class="comment">// 归一化</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 将前面的P（包含i个组，i&gt;=128），映射到 0-128 上，映射后的称为Q，Q包含128个组，</span></span><br><span class="line">    <span class="comment">// 一个整数是一组</span></span><br><span class="line">candidate_distribution_Q = quantize [ bin[ <span class="number">0</span> ], …, bin[ i<span class="number">-1</span> ] ] into <span class="number">128</span> levels</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时的P（包含i个组，i&gt;=128）和Q向量（包含128个组）的大小是不一样的，无法直接计算二者的KL散度</span></span><br><span class="line"><span class="comment">//因此需要将Q扩展为 i 个组，以保证跟P大小一样</span></span><br><span class="line">expand candidate_distribution_Q to ‘ i ’ bins </span><br><span class="line"></span><br><span class="line">Q /= sum(Q) <span class="comment">// 归一化</span></span><br><span class="line"><span class="comment">//计算P和Q的KL散度</span></span><br><span class="line">divergence[ i ] = KL_divergence( reference_distribution_P, candidate_distribution_Q)</span><br><span class="line">End For</span><br><span class="line"><span class="comment">//找出 divergence[ i ] 最小的数值，假设 divergence[m] 最小，</span></span><br><span class="line"><span class="comment">//那么|T|=( m + 0.5 ) * ( width of a bin )</span></span><br><span class="line">Find index ‘m’ <span class="keyword">for</span> which divergence[ m ] is minimal</span><br><span class="line">threshold = ( m + <span class="number">0.5</span> ) * ( width of a bin )</span><br></pre></td></tr></table></figure><p>解释一下第16行：</p><ul><li>计算KL散度 KL_divergence(P, Q) 时，要求序列P和Q的长度一致，即 len(P) == len(Q)；</li><li>Candidate_distribution_Q 是将 P 线性映射到 128个bins得到的，长度为128。而reference_distribution_P 包含 i （i&gt;=128）个 bins （bin[0] - bin[i-1] ），二者长度不等；</li><li>需要将 candidate_distribution_Q 扩展回 i 个bins 然后才能与 i个bins 的 reference_distribution_P计算KL散度。</li></ul><p>举个简单的例子：</p><ul><li><p>假设reference_distribution_P 包含 8 个bins（这里一个bin就只包含一个数据）:</p><p>P = [ 1, 0, 2, 3, 5, 3, 1, 7]</p></li><li><p>我们想把它映射为 2 个bins，于是 4个一组合并：</p><p>[1 + 0 + 2 + 3 , 5 + 3 + 1 + 7] = [6, 16]</p></li><li><p>然后要成比例的 扩展回到 8个组，保留原来是0的组：</p><p>Q = [ 6/3, 0, 6/3, 6/3, 16/4, 16/4, 16/4, 16/4] = [ 2, 0, 2, 2, 4, 4, 4, 4]</p></li><li><p>然后对 P和Q进行标准化：</p><p>P /= sum(P) 、Q /= sum(Q)</p></li><li><p>最后计算散度：</p><p>result = KL_divergence(P, Q)</p></li></ul><p>我们来看看 ResNet-152中 res4b30层校准前后的结果对比，图中那个白线就是|T|的取值（可能小于128，因为分成2048组是最前面的128组其值不一定大于128）：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/satuation-before-and-after.png" alt="1516638878836"></p><p>再看看其他几种网络的校准情况：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/Calibration-result1.jpg" alt="result_1"></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/Calibration-result2.jpg" alt="result_2"></p><h3 id="DP4A-Dot-Product-of-4-8-bits-Accumulated-to-a-32-bit"><a href="#DP4A-Dot-Product-of-4-8-bits-Accumulated-to-a-32-bit" class="headerlink" title="DP4A(Dot Product of 4 8-bits Accumulated to a 32-bit)"></a>DP4A(<strong>D</strong>ot <strong>P</strong>roduct of <strong>4</strong> 8-bits <strong>A</strong>ccumulated to a 32-bit)</h3><p>TensorRT 进行优化的方式是 DP4A (<strong>D</strong>ot <strong>P</strong>roduct of <strong>4</strong> 8-bits <strong>A</strong>ccumulated to a 32-bit)，如下图：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/DP4A.png" alt="1516642345023"></p><p>这是PASCAL 系列GPU的硬件指令，INT8卷积就是使用这种方式进行的卷积计算。这个没搞太明白是怎么回事，参考这篇博客获取详细信息<a href="https://devblogs.nvidia.com/mixed-precision-programming-cuda-8/" target="_blank" rel="noopener">Mixed-Precision Programming with CUDA 8</a>。下面是 官方 <a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf" target="_blank" rel="noopener">GTC2017 PPT</a> 中给的INT8卷积计算的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I8 input tensors: I8_input, I8_weights, INT8输入tensor</span></span><br><span class="line"><span class="comment">// I8 output tensors: I8_output， INT8输出tensor</span></span><br><span class="line"><span class="comment">// F32 bias (original bias from the F32 model),FP32的偏置</span></span><br><span class="line"><span class="comment">// F32 scaling factors: input_scale, output_scale, weights_scale[K], 这个是前面说的缩放因子sf</span></span><br><span class="line">I32_gemm_out = I8_input * I8_weights <span class="comment">// Compute INT8 GEMM (DP4A)，卷积计算，INT32输出</span></span><br><span class="line">F32_gemm_out = (<span class="keyword">float</span>)I32_gemm_out <span class="comment">// Cast I32 GEMM output to F32 float，强制转换为FP32</span></span><br><span class="line"><span class="comment">//前面计算I8_input * I8_weights时，总的缩放系数为 input_scale * weights_scale[K]</span></span><br><span class="line"><span class="comment">//但是输出的缩放系数为output_scale，所以为了保证缩放程度匹配，要将F32_gemm_out乘以 </span></span><br><span class="line"><span class="comment">//output_scale / (input_scale * weights_scale[ i ] )</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// At this point we have F32_gemm_out which is scaled by ( input_scale * weights_scale[K] ),</span></span><br><span class="line"><span class="comment">// but to store the final result in int8 we need to have scale equal to "output_scale", so we have to rescale:</span></span><br><span class="line"><span class="comment">// (this multiplication is done in F32, *_gemm_out arrays are in NCHW format)</span></span><br><span class="line">For i in <span class="number">0</span>, ... K<span class="number">-1</span>:</span><br><span class="line">rescaled_F32_gemm_out[ :, i, :, :] = F32_gemm_out[ :, i, :, :] * [ output_scale /(input_scale * weights_scale[ i ] ) ]</span><br><span class="line">  </span><br><span class="line"><span class="comment">//将FP32精度的偏置 乘上缩放因子，加到前面的计算结果中</span></span><br><span class="line"><span class="comment">// Add bias, to perform addition we have to rescale original F32 bias so that it's scaled with "output_scale"</span></span><br><span class="line">rescaled_F32_gemm_out _with_bias = rescaled_F32_gemm_out + output_scale * bias</span><br><span class="line"><span class="comment">//ReLU 激活</span></span><br><span class="line"><span class="comment">// Perform ReLU (in F32)</span></span><br><span class="line">F32_result = ReLU(rescaled_F32_gemm_out _with_bias)</span><br><span class="line"><span class="comment">//重新转换为 INT8</span></span><br><span class="line"><span class="comment">// Convert to INT8 and save to global</span></span><br><span class="line">I8_output = Saturate( Round_to_nearest_integer( F32_result ) )</span><br></pre></td></tr></table></figure><p>它这个INT8卷积的计算是这样的，虽然输入的tensor已经降为 INT8，但是在卷积计算的时候用了DP4A的计算模式，卷积计算完之后是INT32的，然后又要转成 FP32，然后激活，最后再将FP32的转为INT8.</p><p>只知道这么计算会快很多，但不知道为什么，详情还是看<a href="https://devblogs.nvidia.com/mixed-precision-programming-cuda-8/" target="_blank" rel="noopener">Mixed-Precision Programming with CUDA 8</a> 这个吧，我看的也是糊里糊涂的。</p><p>不过这个对于tensorRT的使用没啥影响，这个是很底层的东西，涉及到硬件优化。</p><h3 id="Typical-workflow-in-TensorRT"><a href="#Typical-workflow-in-TensorRT" class="headerlink" title="Typical workflow in TensorRT"></a>Typical workflow in TensorRT</h3><p>典型的工作流还是直接使用 <a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf" target="_blank" rel="noopener">GTC2017 PPT</a> 原文说法吧：</p><ul><li>You will need:<ul><li>Model trained in FP32.</li><li>Calibration dataset.</li></ul></li><li>TensorRT will:<ul><li>Run inference in FP32 on calibration dataset.</li><li>Collect required statistics.</li><li>Run calibration algorithm → optimal scaling factors.</li><li>Quantize FP32 weights → INT8.</li><li>Generate “CalibrationTable” and INT8 execution engine.</li></ul></li></ul><h3 id="Results-Accuracy-amp-Performance"><a href="#Results-Accuracy-amp-Performance" class="headerlink" title="Results - Accuracy &amp; Performance"></a>Results - Accuracy &amp; Performance</h3><p><strong>精度并没有损失太多</strong></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/performance-auccary.png" alt="1516641328187"></p><p><strong>速度提升还蛮多的，尤其是当 batch_size 大于1时，提升更明显</strong></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/performance-speed.png" alt="1516641398718"></p><p><strong>TITAN X GPU优化效果</strong></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/performance-titanx.png" alt="1516642501791"></p><p><strong>DRIVE PX 2, dGPU 优化效果</strong></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/performance-dgpu.png" alt="1516642517725"></p><h3 id="Open-challenges-improvements"><a href="#Open-challenges-improvements" class="headerlink" title="Open challenges / improvements"></a>Open challenges / improvements</h3><p>一些开放式的提升和挑战：</p><ul><li>Unsigned int8 for activations after ReLU. 无符号 INT8 的映射。</li><li>RNNs → open research problem. TensorRT 3.0开始已经支持RNN了。</li><li>Fine tuning of saturation thresholds. 对阈值 |T|的 微调方法。</li><li>Expose API for accepting custom, user provided scale factors. 开放API，使用户可以自定义 换算系数（比例因子）</li></ul><p>这几个开放问题还是很值得研究的。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul><li>介绍了一种自动化，无参数的 FP32 到 INT8 的转换方法；</li><li>对称的，不饱和的线性量化，会导致精度损失较大；</li><li>通过最小化 KL散度来选择 饱和量化中的 阈值 |T|;</li><li>FP32完全可以降低为INT8推理，精度几乎持平，速度有很大提升。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://arleyzhang.github.io/articles/923e2c40/" target="_blank" rel="noopener">TensorRT(5)-INT8校准原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要参考了&lt;a href=&quot;https://arleyzhang.github.io/articles/923e2c40/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TensorRT(5)-INT8校准原理&lt;/a&gt;，并添加了一些自己的见解。&lt;/p&gt;
&lt;h2 id=&quot;Low-Precision-Inference&quot;&gt;&lt;a href=&quot;#Low-Precision-Inference&quot; class=&quot;headerlink&quot; title=&quot;Low Precision Inference&quot;&gt;&lt;/a&gt;Low Precision Inference&lt;/h2&gt;&lt;p&gt;现有的深度学习框架，如Pytorch、Tensorflow在训练一个深度神经网络时，往往都会使用 &lt;strong&gt;float 32（Full Precise ，简称FP32）&lt;/strong&gt;的数据精度来表示，权值、偏置、激活值等。若一个网络很深的话，比如像VGG，ResNet这种，网络参数是极其多的，计算量就更多了（比如VGG 19.6 billion FLOPS, ResNet-152 11.3 billion FLOPS）。如果多的计算量，如果都采用FP32进行推理，对于嵌入式设备来说计算量是不能接受的。解决此问题主要有两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模型压缩、剪枝。在这里不做讨论。&lt;/li&gt;
&lt;li&gt;在部署推理时（inference）使用低精度数据，比如INT8。当然训练的时候仍然采取FP32的精度。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;下面从经验上分析低精度推理的可行性。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/categories/MLFrameworks/TensorRT/"/>
    
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/tags/TensorRT/"/>
    
      <category term="INT8" scheme="https://www.zdaiot.com/tags/INT8/"/>
    
  </entry>
  
</feed>
