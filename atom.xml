<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zdaiot</title>
  
  <subtitle>404NotFound</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zdaiot.com/"/>
  <updated>2021-08-09T06:07:16.000Z</updated>
  <id>https://www.zdaiot.com/</id>
  
  <author>
    <name>zdaiot</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GAN简介</title>
    <link href="https://www.zdaiot.com/MachineLearning/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/GAN%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.zdaiot.com/MachineLearning/神经网络/GAN简介/</id>
    <published>2021-08-09T06:07:16.000Z</published>
    <updated>2021-08-09T06:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>生成对抗网络（GAN）由2个重要的部分构成：</p><ol><li><strong>生成器(Generator</strong>)：通过机器生成数据（大部分情况下是图像），目的是“骗过”判别器</li><li><strong>判别器(Discriminator</strong>)：判断这张图像是真实的还是机器生成的，目的是找出生成器做的“假数据”</li></ol><p><img src="/MachineLearning/神经网络/GAN简介/2019-07-16-2bf-1.png" alt="生成对抗网络GANs由生成器和判别器构成" style="zoom: 50%;"></p><p>要想理解GAN，直接看损失函数是一个特别好的方法。如下所示，D想办法增加V的值，G想办法减小V的值，两者在相互的对抗。关于V的收敛性证明可以在<a href="https://zhuanlan.zhihu.com/p/28853704" target="_blank" rel="noopener">GAN入门理解及公式推导</a>这里找到。</p><p><img src="/MachineLearning/神经网络/GAN简介/v2-c93b874f77316d54f01aa653f8c24a86_b.jpg" alt="img" style="zoom: 80%;"></p><p>下面介绍一下详细过程：</p><p><strong>第一阶段：固定「判别器D」，训练「生成器G」</strong></p><p>使用一个较好的判别器D，让一个「生成器G」不断生成“假数据”，然后给这个「判别器D」去判断。一开始，「生成器G」还很弱，所以很容易被揪出来。但是随着不断的训练，「生成器G」技能不断提升，最终骗过了「判别器D」。到了这个时候，「判别器D」基本属于瞎猜的状态，判断是否为假数据的概率为50%。</p><p><img src="/MachineLearning/神经网络/GAN简介/2019-07-16-g-tg.png" alt="固定判别器，训练生成器" style="zoom:50%;"></p><p>从损失函数的角度理解，固定D训练G ，它是希望V的值越小越好，让D分不开真假数据。如下所示，目标函数的第一项不包含G，是常数，所以可以直接忽略 不受影响。</p><p><img src="/MachineLearning/神经网络/GAN简介/v2-08a48c4e9da837e5f3bf375bef5d8007_b.jpg" alt="img" style="zoom:80%;"></p><p>对于G来说，它希望D在划分它的时候能够越大越好，即希望被D划分1(真实数据)。</p><p><img src="/MachineLearning/神经网络/GAN简介/v2-dfa0c29336f15c4e9f047d8d1dae50f1_b.jpg" alt="img" style="zoom:80%;"></p><p>第二个式子和第一个式子等价。在训练的时候，第二个式子训练效果比较好 常用第二个式子的形式。</p><p><strong>第二阶段：固定「生成器G」，训练「判别器D」</strong></p><p>当通过了第一阶段，继续训练「生成器G」就没有意义了。这个时候我们固定「生成器G」，然后开始训练「判别器D」。「判别器D」通过不断训练，提高了自己的鉴别能力，最终它可以准确的判断出所有的假图片。到了这个时候，「生成器G」已经无法骗过「判别器D」。</p><p><img src="/MachineLearning/神经网络/GAN简介/2019-07-16-d-tg-1.png" alt="固定生成器，训练判别器" style="zoom:50%;"></p><p>从损失函数的角度理解，训练D的目的是希望这个式子的值越大越好。真实数据希望被D分成1，生成数据希望被分成0。</p><p><img src="/MachineLearning/神经网络/GAN简介/v2-474547ca59dd2737f0c4a8833f4ffcde_b.png" alt="img" style="zoom:80%;"></p><p>第一项，如果有一个真实数据被分错，那么log(D(x))&lt;&lt;0,期望会变成负无穷大。</p><p>第二项，如果被分错成1的话，第二项也会是负无穷大。</p><p>很多被分错的话，就会出现很多负无穷，那样可以优化的空间还有很多。可以修正参数，使V的数值增大。</p><p><strong>循环阶段一和阶段二</strong></p><p>通过不断的循环，「生成器G」和「判别器D」的能力都越来越强。最终我们得到了一个效果非常好的「生成器G」，我们就可以用它来生成想要的图片了。</p><p><img src="/MachineLearning/神经网络/GAN简介/2019-07-16-xh.png" alt="循环训练，2遍越来越强" style="zoom:50%;"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>3个优势</strong></p><ol><li>能更好建模数据分布（图像更锐利、清晰）</li><li>理论上，GANs 能训练任何一种生成器网络。其他的框架需要生成器网络有一些特定的函数形式，比如输出层是高斯的。</li><li>无需利用马尔科夫链反复采样，无需在学习过程中进行推断，没有复杂的变分下界，避开近似计算棘手的概率的难题。</li></ol><p><strong>2个缺陷</strong></p><ol><li>难训练，不稳定。生成器和判别器之间需要很好的同步，但是在实际训练中很容易D收敛，G发散。D/G 的训练需要精心的设计。</li><li>模式缺失（Mode Collapse）问题。GANs的学习过程可能出现模式缺失，生成器开始退化，总是生成同样的样本点，无法继续学习。</li></ol><p>扩展阅读：《<a href="https://easyai.tech/blog/gan-why-it-is-so-hard-to-train/" target="_blank" rel="noopener">为什么训练生成对抗网络如此困难？</a>》阅读这篇文章对数学要求很高。</p><h2 id="CycleGAN"><a href="#CycleGAN" class="headerlink" title="CycleGAN"></a>CycleGAN</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通常的GAN的设计思路从信息流的角度出发是单向的，如下图所示：使用Generator从A产生一个假的B，然后使用Determinator判断这个假的B是否属于B集合，并将这个信息反馈至Generator，然后通过逐次分别提高Generator与Discriminator的能力以期达到使Generator能以假乱真的能力，这样的设计思路在一般<strong>有匹配图像的情况</strong>下是合理的，例如Pix2Pix模型的关键是提供了在这两个域中有相同数据的训练样本。</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107202407705.png" alt="img"></p><p>然而若两个域内没有相同数据的训练样本，也就是没有成对样本，则需要借助于CycleGAN。成对样本与非成对样本的示意图如下所示：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107201615878.png" alt="img" style="zoom:67%;"></p><p>可以实现无配对的两个图片集的训练是CycleGAN与Pixel2Pixel相比的一个典型优点，但仍然需要通过训练创建这个映射来确保输入图像和生成图像间存在有意义的关联，即输入输出共享一些特征。</p><p>简而言之，该模型通过从域DA获取输入图像，该输入图像被传递到第一个生成器GeneratorA→B，其任务是将来自域DA的给定图像转换到目标域DB中的图像。然后这个新生成的图像被传递到另一个生成器GeneratorB→A，其任务是在原始域DA转换回图像CyclicA，这里可与自动编码器作对比。这个输出图像必须与原始输入图像相似，用来定义非配对数据集中原来不存在的有意义映射。</p><p>量子位给出的CycleGAN的示意图如下：</p><p><img src="/MachineLearning/神经网络/GAN简介/webp" alt="img" style="zoom: 67%;"></p><p><img src="/MachineLearning/神经网络/GAN简介/webp-162849242832012" alt="img" style="zoom:67%;"></p><blockquote><p>上图中之所以是<code>input_A</code>参与D_A损失函数的计算，可以看具体的损失函数。</p></blockquote><p>论文的设计示意图如下：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107204154215.png" alt="img" style="zoom:67%;"></p><p>李宏毅的一张ppt Slide给出的下面的示意图：</p><p><img src="/MachineLearning/神经网络/GAN简介/20.png" alt="img" style="zoom: 80%;"></p><p>上面的这三个示意图可以结合这一块理解，感觉画的都不错。</p><p>GAN个人感觉还是结合具体的损失函数比较好理解。</p><p>Cycle-GAN的loss总体来说可以分为两部分，一部分是GAN loss，一部分是Cycle loss：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107205953410.png" alt="img" style="zoom:67%;"></p><p>具体每一部分的形式为：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107210307463.png" alt="img" style="zoom:67%;"></p><p>上面这个部分是GAN的损失。从理论上讲，对抗训练可以学习和产生与目标域Y和X相同分布的输出，即映射G和F。然而，在足够大的样本容量下，<strong>网络可以将相同的输入图像集合映射到目标域中图像的任何随机排列</strong>，其中任何学习的映射可以归纳出与目标分布匹配的输出分布。因此，<strong>单独的对抗损失Loss不能保证学习函数可以将单个输入$X_i$​映射到期望的输出$Y_i$​​​。</strong></p><p>因此，作者又定义了一个cycle consistency loss，也就是说把X生成的Y再通过另一个生成器还原到X域，并且我们希望还原的X和原来的输入X尽可能相似。 也就是$G(F(x)) ≈ x$，同理 $F(G(y)) ≈ y$，因此这个循环一致性损失如下：</p><p><img src="/MachineLearning/神经网络/GAN简介/20181107210307177.png" alt="img" style="zoom:67%;"></p><p>需要注意的是论文中为了保证训练出的模型具有较强的稳定性，将基于前人的成果将GAN loss变为非负的似然计算改为最小平方loss，也就是上面的公式(1)改为了下面的式子：</p><p><img src="/MachineLearning/神经网络/GAN简介/webp-162849310424419" alt="img" style="zoom:67%;"></p><p>另外，作者在训练过程中，为了保证稳定性，还使用了GAN训练的“记忆”技术，即在更新Discriminator时使用先期存储的数据而非刚刚由Generator产生数据。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>CycleGAN实现的是一类图片到另一类图片的转化，也就是图片域的转变， 对于这类问题pix2pix是一种不错的方法，但是pix2pix训练时需要成对的训练样本，也就是比如你要训练图片风景从白天到黑夜的转变，那么你的训练集就是各种风景图片的白天照片以及其对应的黑夜照片，必须一一对应。那么CycleGAN则不需要， 所以如果用CycleGAN来做这个问题，只需要收集一些白天的风景图片和一些黑夜的风景图片即可，不需要是同一种风景，不需要一一对应。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://easyai.tech/ai-definition/gan/" target="_blank" rel="noopener">生成对抗网络 – Generative Adversarial Networks | GAN</a><br><a href="https://zhuanlan.zhihu.com/p/28853704" target="_blank" rel="noopener">GAN入门理解及公式推导</a><br><a href="https://cryer.github.io/2018/02/cycleGAN/" target="_blank" rel="noopener">CycleGAN介绍</a><br><a href="https://blog.csdn.net/xiaoxifei/article/details/83830842" target="_blank" rel="noopener">Cycle-GAN 模型介绍——原理简介</a><br><a href="https://www.jianshu.com/p/64bf39804c80" target="_blank" rel="noopener">CycleGAN原理及实验（TensorFlow）</a><br><a href="https://zhuanlan.zhihu.com/p/27145954" target="_blank" rel="noopener">带你理解CycleGAN，并用TensorFlow轻松实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GAN&quot;&gt;&lt;a href=&quot;#GAN&quot; class=&quot;headerlink&quot; title=&quot;GAN&quot;&gt;&lt;/a&gt;GAN&lt;/h2&gt;&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;生成对抗网络（GAN）由2个重要的部分构成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;生成器(Generator&lt;/strong&gt;)：通过机器生成数据（大部分情况下是图像），目的是“骗过”判别器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判别器(Discriminator&lt;/strong&gt;)：判断这张图像是真实的还是机器生成的，目的是找出生成器做的“假数据”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/MachineLearning/神经网络/GAN简介/2019-07-16-2bf-1.png&quot; alt=&quot;生成对抗网络GANs由生成器和判别器构成&quot; style=&quot;zoom: 50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://www.zdaiot.com/categories/MachineLearning/"/>
    
      <category term="神经网络" scheme="https://www.zdaiot.com/categories/MachineLearning/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="GAN" scheme="https://www.zdaiot.com/tags/GAN/"/>
    
      <category term="CycleGAN" scheme="https://www.zdaiot.com/tags/CycleGAN/"/>
    
  </entry>
  
  <entry>
    <title>Office365与VisioPro共存</title>
    <link href="https://www.zdaiot.com/Tools/Md&amp;Office/Office365%E4%B8%8EVisioPro%E5%85%B1%E5%AD%98/"/>
    <id>https://www.zdaiot.com/Tools/Md&amp;Office/Office365与VisioPro共存/</id>
    <published>2021-03-09T14:33:36.000Z</published>
    <updated>2021-03-09T14:33:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注意：这种方法会卸载现有的Office365，具体原因未知，所以暂时不可用。</strong></p><p>现在的电脑有的预装office365，但是此时安装visio会报错。可以采用如下方式解决。</p><p>首先从mdsn中下载最新的VisioPro2016的安装镜像，<a href="ed2k://|file|cn_visio_professional_2016_x86_x64_dvd_6970929.iso|2588262400|52A997F3AF4E40B896C8E4677CF10E90|/" target="_blank" rel="noopener">下载地址</a>。</p><p>下载之后第一步要把镜像文件加载至光驱，比如加载到了<code>E:\</code>。正常情况下，点击 setup 会直接进入 Visio 程序的安装，但是现在不能够进行正常的安装，在任务管理器也不会看见进程开启</p><p>第二步 到 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=49117" target="_blank" rel="noopener">Office 2016 Deployment Tool </a>下载文件，打开下载到的部署工具安装文件，选择任意路径解压；解压后路径内有一个 Setup.exe 文件和若干个配置文件；新建配置文件，例如命名为 configuration.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Add</span> <span class="attr">SourcePath</span>=<span class="string">"E:\"</span> <span class="attr">OfficeClientEdition</span>=<span class="string">"64"</span> <span class="attr">Channel</span>=<span class="string">"Current"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- &lt;Product ID="VisioProXVolume" PIDKEY="69WXN-MBYV6-22PQG-3WGHK-RM6XC"&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Product</span> <span class="attr">ID</span>=<span class="string">'VisioProRetail'</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Language</span> <span class="attr">ID</span>=<span class="string">"zh-cn"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">Product</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Add</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在当前路径下运行<code>setup.exe/configure configuration.xml</code>，完成安装。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zchwei.com/post/2019/8/28/office365-proplus-visiopro-install" target="_blank" rel="noopener">Office 365 ProPlus &amp; VisioPro 安装冲突问题解决</a><br><a href="https://blog.iifatree.com/2020/02/17/Office-click-to-run-and-visio-2016/" target="_blank" rel="noopener">即点即用 Office 365 与 Visio 2016 共存问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;注意：这种方法会卸载现有的Office365，具体原因未知，所以暂时不可用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在的电脑有的预装office365，但是此时安装visio会报错。可以采用如下方式解决。&lt;/p&gt;
&lt;p&gt;首先从mdsn中下载最新的VisioPro2016的安装镜像，&lt;a href=&quot;ed2k://|file|cn_visio_professional_2016_x86_x64_dvd_6970929.iso|2588262400|52A997F3AF4E40B896C8E4677CF10E90|/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下载之后第一步要把镜像文件加载至光驱，比如加载到了&lt;code&gt;E:\&lt;/code&gt;。正常情况下，点击 setup 会直接进入 Visio 程序的安装，但是现在不能够进行正常的安装，在任务管理器也不会看见进程开启&lt;/p&gt;
&lt;p&gt;第二步 到 &lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=49117&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Office 2016 Deployment Tool &lt;/a&gt;下载文件，打开下载到的部署工具安装文件，选择任意路径解压；解压后路径内有一个 Setup.exe 文件和若干个配置文件；新建配置文件，例如命名为 configuration.xml，内容如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="Md&amp;Office" scheme="https://www.zdaiot.com/categories/Tools/Md-Office/"/>
    
    
      <category term="Office365" scheme="https://www.zdaiot.com/tags/Office365/"/>
    
      <category term="VisioPro" scheme="https://www.zdaiot.com/tags/VisioPro/"/>
    
  </entry>
  
  <entry>
    <title>git合并多个仓库</title>
    <link href="https://www.zdaiot.com/Tools/GIt/git%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E4%BB%93%E5%BA%93/"/>
    <id>https://www.zdaiot.com/Tools/GIt/git合并多个仓库/</id>
    <published>2020-11-27T09:02:14.000Z</published>
    <updated>2020-11-27T09:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前因为考虑不得当，没有采用分支的方法管理同一个工程。在github上建立了多个仓库，强迫症发作了，想合并这些仓库到同一个git中，并保留所有的git记录。具体来说，假设我们有如下几个仓库：</p><ol><li>OldA：要合并的仓库A</li><li>OldB：要合并的仓库B</li><li>C：将OldA和OldB两个仓库合并到该git中</li></ol><p>具体操作过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mkdir C</span><br><span class="line"><span class="built_in">cd</span> C</span><br><span class="line"><span class="comment"># Assume the current directory is where we want the new repository to be created, Create the new repository</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># Before we do a merge, we have to have an initial commit, so we’ll make a dummy commit</span></span><br><span class="line">dir &gt; deleteme.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"Initial dummy commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a remote for and fetch the old repo</span></span><br><span class="line">git remote add -f old_a &lt;OldA repo URL&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Merge the files from old_a/master into new/master</span></span><br><span class="line">git merge old_a/master</span><br><span class="line"><span class="comment"># if occurs "fatal: refusing to merge unrelated histories"</span></span><br><span class="line">git merge old_a/master --allow-unrelated-histories</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clean up our dummy file because we don’t need it any more</span></span><br><span class="line">git rm .\deleteme.txt</span><br><span class="line">git commit -m <span class="string">"Clean up initial file"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Move the old_a repo files and folders into a subdirectory so they don’t collide with the other repo coming later</span></span><br><span class="line">mkdir old_a</span><br><span class="line">dir -exclude old_a | %&#123;git mv <span class="variable">$_</span>.Name old_a&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commit the move</span></span><br><span class="line">git commit -m <span class="string">"Move old_a files into subdir"</span></span><br></pre></td></tr></table></figure><p>接着合并其余仓库，如OldB</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Do the same thing for old_b</span></span><br><span class="line">git remote add -f old_b &lt;OldB repo URL&gt;</span><br><span class="line">git merge old_b/master</span><br><span class="line"><span class="comment"># if occurs "fatal: refusing to merge unrelated histories"</span></span><br><span class="line">git merge old_b/master --allow-unrelated-histories</span><br><span class="line">mkdir old_b</span><br><span class="line">dir -exclude old_a,old_b | %&#123;git mv <span class="variable">$_</span>.Name old_b&#125;</span><br><span class="line">git commit -m <span class="string">"Move old_b files into subdir"</span></span><br></pre></td></tr></table></figure><p>这个时候仓库A和B都合并到了仓库C中，并且保留了所有的git记录。此时若想查看某个文件的提交记录，需要使用<code>git log --follow old_b/readme.md</code>。</p><p>若<code>old_a</code>仓库有多个分支，则可以采用如下方式继续合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bring over a feature branch from one of the old repos</span></span><br><span class="line">git checkout -b feature-in-progress</span><br><span class="line">git merge -s recursive -Xsubtree=old_a old_a/feature-in-progress</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://saintgimp.org/2013/01/22/merging-two-git-repositories-into-one-repository-without-losing-file-history/" target="_blank" rel="noopener">Merging Two Git Repositories Into One Repository Without Losing File History</a><br><a href="https://medium.com/altcampus/how-to-merge-two-or-multiple-git-repositories-into-one-9f8a5209913f" target="_blank" rel="noopener">How to merge two or multiple git repositories into one</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前因为考虑不得当，没有采用分支的方法管理同一个工程。在github上建立了多个仓库，强迫症发作了，想合并这些仓库到同一个git中，并保留所有的git记录。具体来说，假设我们有如下几个仓库：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OldA：要合并的仓库A&lt;/li&gt;
&lt;li&gt;OldB：要合并的仓库B&lt;/li&gt;
&lt;li&gt;C：将OldA和OldB两个仓库合并到该git中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体操作过程如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Assume the current directory is where we want the new repository to be created, Create the new repository&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Before we do a merge, we have to have an initial commit, so we’ll make a dummy commit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dir &amp;gt; deleteme.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;Initial dummy commit&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Add a remote for and fetch the old repo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote add -f old_a &amp;lt;OldA repo URL&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Merge the files from old_a/master into new/master&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git merge old_a/master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# if occurs &quot;fatal: refusing to merge unrelated histories&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git merge old_a/master --allow-unrelated-histories&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Clean up our dummy file because we don’t need it any more&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rm .\deleteme.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;Clean up initial file&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Move the old_a repo files and folders into a subdirectory so they don’t collide with the other repo coming later&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir old_a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dir -exclude old_a | %&amp;#123;git mv &lt;span class=&quot;variable&quot;&gt;$_&lt;/span&gt;.Name old_a&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Commit the move&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;Move old_a files into subdir&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接着合并其余仓库，如OldB&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="GIt" scheme="https://www.zdaiot.com/categories/Tools/GIt/"/>
    
    
      <category term="github" scheme="https://www.zdaiot.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>VIM入门</title>
    <link href="https://www.zdaiot.com/Tools/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/VIM%E5%85%A5%E9%97%A8/"/>
    <id>https://www.zdaiot.com/Tools/杂七杂八/VIM入门/</id>
    <published>2020-10-17T03:51:16.000Z</published>
    <updated>2020-10-17T03:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Vim大概有如下几个版本：vim、vim-athena、vim-gnome、vim-gtk、vim-gtk3、vim-noxvim-tiny。它们中有编译进最小功能的 Vim 包（vim-tiny），有较全功能的文本界面 Vim 包（vim-nox），有适用于老的 X-Window 界面的版本（vim-athena），有适用于 KDE 环境的 GTK2 版本（vim-gtk），等等。</p><p>对于Ubuntu而言，一般情况下<code>sudo apt install vim-gtk3</code>即可。在 Ubuntu 上，vim 和 gvim 都是指向同一个应用程序的符号链接，且 <code>gvim</code> 的执行效果和 <code>vim -g</code> 相同。所以要启动图像化界面的<code>vim</code>，直接在终端执行<code>gvim</code>即可。</p><p>另外，若使用远程软件连接到Linux机器上，需要注意远程终端软件的远程字符集（如 PuTTY 中的“Windows &gt; Translation &gt; Remote character set”）应当设置成 UTF-8。</p><p>然后，还可以安装中文版本的帮助文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim</span><br><span class="line">mkdir -p pack/my/start</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/yianwillis/vimcdoc.git pack/my/start/vimcdoc</span><br></pre></td></tr></table></figure><p>当然，也可以在这个 <a href="https://github.com/yianwillis/vimcdoc" target="_blank" rel="noopener">Vim 中文文档计划</a> 的<a href="https://github.com/yianwillis/vimcdoc/releases" target="_blank" rel="noopener">下载页面</a>下载 tar 包，然后自行解压到 <code>~/.vim/pack/my/start</code> 目录下（或 Windows 用户目录下的 <code>vimfiles\pack\my\start</code> 目录下）。</p><p>最后，可以使用<code>LANG=zh_CN.UTF-8 vimtutor</code>命令查看Vim教程，可以作为Vim的入门教程。</p><h2 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h2><p>Vim 有以下四种主要模式：</p><ol><li>正常（normal）模式（也称为普通模式），缺省的编辑模式；<strong>如果不加特殊说明，一般提到的命令都直接在正常模式下输入</strong>；在任何其他模式中，都可以通过键盘上的 Esc 键回到正常模式。</li><li>插入（insert）模式，输入文本时使用；比如在正常模式下键入 i（insert）或 a（append）即可进入插入模式。</li><li>可视（visual）模式，用于选定文本块；教程中已经提到可以用键 v（小写）来按字符选定，Vim 里也提供其他不同的选定方法，包括按行和按列块。</li><li>命令行（command-line）模式，用于执行较长、较复杂的命令；在正常模式下键入冒号（:）即可进入该模式；使用斜杠（/）和问号（?）开始搜索也算作命令行模式。命令行模式下的命令要输入回车键（Enter）才算完成。</li></ol><blockquote><p>记住正常模式就是正常情况下你应当处于的模式。</p></blockquote><h2 id="Vim的键描述体例"><a href="#Vim的键描述体例" class="headerlink" title="Vim的键描述体例"></a>Vim的键描述体例</h2><p>下面的教程将会使用Vim中的标准键描述方式来讲解。Vim一般使用尖括号来描述特殊的输入序列。</p><div class="table-container"><table><thead><tr><th style="text-align:center">尖括号</th><th style="text-align:center">表示</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><esc></esc></td><td style="text-align:center">Esc 键</td><td style="text-align:center">⎋</td></tr><tr><td style="text-align:center"><cr></cr></td><td style="text-align:center">回车键</td><td style="text-align:center">↩</td></tr><tr><td style="text-align:center"><space></space></td><td style="text-align:center">空格键</td><td style="text-align:center">␣</td></tr><tr><td style="text-align:center"><tab></tab></td><td style="text-align:center">Tab 键</td><td style="text-align:center">⇥</td></tr><tr><td style="text-align:center"><bs></bs></td><td style="text-align:center">退格键</td><td style="text-align:center">⌫</td></tr><tr><td style="text-align:center"><del></del></td><td style="text-align:center">删除键</td><td style="text-align:center">⌦</td></tr><tr><td style="text-align:center"><lt></lt></td><td style="text-align:center">&lt;</td><td style="text-align:center">&lt;</td></tr><tr><td style="text-align:center"><up></up></td><td style="text-align:center">光标上移键</td><td style="text-align:center">⇡</td></tr><tr><td style="text-align:center"><down></down></td><td style="text-align:center">光标下移键</td><td style="text-align:center">⇣</td></tr><tr><td style="text-align:center"><left></left></td><td style="text-align:center">光标左移键</td><td style="text-align:center">⇠</td></tr><tr><td style="text-align:center"><right></right></td><td style="text-align:center">光标右移键</td><td style="text-align:center">⇢</td></tr><tr><td style="text-align:center"><pageup></pageup></td><td style="text-align:center">Page Up 键</td><td style="text-align:center">⇞</td></tr><tr><td style="text-align:center"><pagedown></pagedown></td><td style="text-align:center">Page Down 键</td><td style="text-align:center">⇟</td></tr><tr><td style="text-align:center"><home></home></td><td style="text-align:center">Home 键</td><td style="text-align:center">↖</td></tr><tr><td style="text-align:center"><end></end></td><td style="text-align:center">End 键</td><td style="text-align:center">↘</td></tr><tr><td style="text-align:center"><f1> - <f12></f12></f1></td><td style="text-align:center">功能键 1 到 12</td><td style="text-align:center">“F1”到“F12”</td></tr><tr><td style="text-align:center"><s-…></s-…></td><td style="text-align:center">Shift 组合键</td><td style="text-align:center">⇧</td></tr><tr><td style="text-align:center"><c-…></c-…></td><td style="text-align:center">Control 组合键</td><td style="text-align:center">⌃</td></tr><tr><td style="text-align:center"><m-…></m-…></td><td style="text-align:center">Alt 组合键</td><td style="text-align:center">⌥</td></tr><tr><td style="text-align:center"><d-…></d-…></td><td style="text-align:center">Command 组合键</td><td style="text-align:center">⌘</td></tr></tbody></table></div><p>例如前面提到的 Esc、Enter、v、V 和 Ctrl-V，按我们现在的描述惯例，以后就会写成 <code>&lt;Esc&gt;、&lt;CR&gt;、v、V 和 &lt;C-V&gt;</code>。</p><p>需要强调的一点是，<strong>对“&lt;”的特殊解释仅在描述输入时生效</strong>。在描述命令行（以<code>:、/、?、$</code>开头）和代码时，写<code>“&lt;CR&gt;”</code>仍表示四个字符，而非回车键。对于命令行详细解释如下：</p><ol><li>若描述的命令行首是<code>“:”</code>，表示这是一个输入 <code>:</code> 开始的 Vim 命令行模式命令（以回车键结束）</li><li>如果行首是<code>“/”</code>或<code>“?”</code>，表示这是一个输入 <code>/</code> 或 <code>?</code> 开始的搜索命令（以回车键结束）</li><li>如果行首是<code>“$”</code>，表示这是一个在linux shell 命令行上输入的命令（以回车键结束），<code>“$”</code>（和后面的空格）不是命令的一部分，通常后续行也不是命令的一部分，除非行尾有<code>“\”</code>或<code>“^”</code>字符，或行首有<code>“$”</code>字符。</li></ol><p>例如<code>“:set ft?&lt;CR&gt;”</code>表示在Vim里面输入<code>:set :ft</code>然后回车；<code>“which vim&lt;CR&gt;”</code>表示在Linux shell中输入<code>which vim</code>然后回车。</p><p>此外，当用<a href="https://yianwillis.github.io/vimcdoc/doc/help.html" target="_blank" rel="noopener"><code>“:help”</code></a>描述帮助命令时，你不仅可以在 Vim 里输入这个命令来得到帮助，也可以点击这个帮助的链接，直接在线查看相应的中文帮助页面。</p><h2 id="Vim常用命令"><a href="#Vim常用命令" class="headerlink" title="Vim常用命令"></a>Vim常用命令</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>Vim 里的基本光标移动是通过 <code>h、j、k、l</code> 四个键实现的。（分别是左移、上移、上移、右移）。不过，标准的光标移动键（键盘上的上下左右键）可以在任何模式下使用，而这四个键并不能在插入模式下使用，因此，它们并不构成完全的替代关系。</p><p>跳转到行首：<code>0</code>；跳转到行尾：<code>$</code>；跳转到行首的第一个非空白字符：<code>^</code>；<code>w/W</code>以单词为单位的跳转，小写和大写命令的区别在于，小写的跟编程语言里的标识符的规则相似，认为一个单词是由字母、数字、下划线组成的（不严格的说法），而大写的命令则认为非空格字符都是单词（例如<code>hello world</code>，当光标停在了<code>h</code>上，按下<code>w</code>键会跳转到<code>w</code>字母上，这是因为空格不属于后面的<code>world</code>单词）。</p><p><code>cw</code>删除一个单词（<code>c5w</code>删除5个单词）；<code>f（find）、t（till）</code>找到下一个（如果在输入它们之前先输入数字 n 的话，那就是下面第 n 个）紧接着输入的字符。两者的区别是，f 会包含这个字符，而 t 不会包含这个字符（例如<code>fi</code>则找到下一个<code>i</code>的位置）；</p><p>写文字时，可以使用<code>(</code> 和 <code>)</code> 移到上一句和下一句；<code>{</code> 和 <code>}</code> 移到上一段和下一段。</p><p><code>gg</code> 和 <code>G</code> 跳转到开头和结尾行（小区别：<code>G</code>是跳转到最后一行的第一个字符，而不是最后一个字符）。</p><h3 id="文本修改"><a href="#文本修改" class="headerlink" title="文本修改"></a>文本修改</h3><p><code>c</code> 和 <code>d</code> 配合方向键，可以对文本进行更改。可以认为 <strong><code>c</code>（修改）的功能就是执行 <code>d</code>（删除）然后 <code>i</code>（插入）</strong>。</p><ul><li><code>d</code> 加动作来进行删除（dd 删除整行）；<code>D</code> 则相当于 <code>d$</code>，删除到行尾。</li><li><code>c</code> 加动作来进行修改（cc 修改整行）；<code>C</code> 则相当于 <code>c$</code>，删除到行尾然后进入插入模式。</li><li><code>s</code> 相当于 <code>cl</code>，删除一个字符然后进入插入模式；<code>S</code> 相当于 <code>cc</code>，替换整行的内容。</li><li><code>i</code> 在当前字符前面进入插入模式；<code>I</code> 则相当于 <code>^i</code>，把光标移到行首非空白字符上然后进入插入模式。</li><li><code>a</code> 在当前字符后面进入插入模式；<code>A</code> 相当于 <code>$a</code>，把光标移到行尾然后进入插入模式。</li><li><code>o</code> 在当前行下方插入一个新行，然后在这行进入插入模式；<code>O</code> 在当前行上方插入一个新行，然后在这行进入插入模式。</li><li><code>r</code> 替换光标下的字符；<code>R</code> 则进入替换模式，每次按键（直到<code>&lt;Esc&gt;</code>）替换一个字符。</li><li><code>u</code> 撤销最近的一个修改动作；<code>U</code> 撤销当前行上的所有修改。</li></ul><h3 id="文本对象选择"><a href="#文本对象选择" class="headerlink" title="文本对象选择"></a>文本对象选择</h3><p>可以使用 <code>c、d</code> 加动作键对这个动作选定的文本块进行操作（如<code>dj</code>就是删除当前行和下一行，相当于<code>2dd</code>），也可以使用 <code>v</code> 加动作键来选定文本块（以便后续进行操作）。</p><p>有几个动作只能在<code>c、d、v、y</code>这样命令之后用，例如基本附加键是 <code>a</code> 和 <code>i</code>。其中，<code>a</code> 可以简单理解为英文单词 <code>a</code>，表示选定后续动作要求的完整内容，而 <code>i</code> 可理解为英文单词 inner，代表后续动作要求的内容的“内部”。</p><p>假设有下面的文本内容：<code>if (message == &quot;sesame open&quot;)</code>。进一步假设光标停在“sesame”的“a”上，那么：</p><ul><li><code>dw</code>（理解为 delete word）会删除 <code>ame␣</code>，结果是 <code>if (message == &quot;sesopen&quot;)</code></li><li><code>diw</code>（理解为 delete inside word）会删除 <code>sesame</code>，结果是 <code>if (message == &quot; open&quot;)</code></li><li><code>daw</code>（理解为 delete a word）会删除 <code>sesame␣</code>，结果是 <code>if (message == &quot;open&quot;)</code></li><li><code>diW</code> 会删除 <code>&quot;sesame</code>，结果是 <code>if (message == open&quot;)</code></li><li><code>daW</code> 会删除 <code>&quot;sesame␣</code>，结果是 <code>if (message == open&quot;)</code></li><li><code>di&quot;</code> 会删除 <code>sesame open</code>，结果是 <code>if (message == &quot;&quot;)</code></li><li><code>da&quot;</code> 会删除 <code>&quot;sesame open&quot;</code>，结果是 <code>if (message ==)</code></li><li><code>di(</code> 或 <code>di)</code> 会删除 <code>message == &quot;sesame open&quot;</code>，结果是 <code>if ()</code></li><li><code>da(</code> 或 <code>da)</code> 会删除 <code>(message == &quot;sesame open&quot;)</code>，结果是 <code>if␣</code></li></ul><h2 id="Vim的选项和配置"><a href="#Vim的选项和配置" class="headerlink" title="Vim的选项和配置"></a>Vim的选项和配置</h2><p>根据 Unix 下的惯例，Vim 的配置文件放在用户的主目录下，文件名通常是<code>.vimrc</code>；而它在 Windows 下名字是 <code>_vimrc</code>，也是放在用户主目录下面。最基本的配置文件是这个样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> enc=utf-8</span><br><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$VIMRUNTIME</span>/vimrc_example.vim</span><br></pre></td></tr></table></figure><p>这三行采用的是shell编程，完成的功能是：</p><ol><li>设置编辑文件的内码是 UTF-8（非所有平台缺省，但为编辑多语言文件所必需）</li><li>设置 Vim 不需要和 vi 兼容（仅为万一起见，目前大部分情况下这是缺省情况）</li><li>导入 Vim 的示例配置（这会打开一些有用的选项，如语法加亮、搜索加亮、命令历史、记住上次的文件位置，等等）</li></ol><p>对于现代 Unix 系统上的 Vim 8，实际上只需要最后一句就足够了。对于现代 Windows 系统上的 Vim 8，中间的这句 set nocompatible 也可以删除。如果你在较老的 Vim 版本上进行配置，那么把这三行全放进去会比较安全。</p><h3 id="备份和撤销文件"><a href="#备份和撤销文件" class="headerlink" title="备份和撤销文件"></a>备份和撤销文件</h3><p>在示例配置里，Vim 自动设置了下面两个选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> backup</span><br><span class="line"><span class="built_in">set</span> undofile</span><br></pre></td></tr></table></figure><p>前一个选项使得每次编辑会保留上一次的备份文件，后一个选项使得 Vim 在重新打开一个文件时，仍然能够撤销之前的编辑（undo），这就会产生一个保留编辑历史的“撤销文件”（undofile）了。所以修改文件时会出现结尾为<code>“~”</code>的文件，有文件名后面直接加<code>“~”</code>的，还有前面加<code>“.”</code>后面加<code>“.un~”</code>的。</p><p>可以不产生备份文件，但保留跨会话撤销编辑的能力；因为有了撤销文件，备份其实也就没有必要了。同时，把撤销文件放在用户个人的特定目录下，既保证了安全，又免去了其他目录下出现不必要文件的麻烦。</p><p>Linux/MacOS下可以在<code>.vimrc</code>文件中写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nobackup</span><br><span class="line"><span class="built_in">set</span> undodir=~/.vim/undodir</span><br></pre></td></tr></table></figure><p>Windows 下可以在<code>_vimrc</code>文件中写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nobackup</span><br><span class="line"><span class="built_in">set</span> undodir=~\vimfiles\undodir</span><br></pre></td></tr></table></figure><p>无论哪个环境都要自动创建该文件夹，所以可以加上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !isdirectory(&amp;undodir)</span><br><span class="line">  call mkdir(&amp;undodir, <span class="string">'p'</span>, 0700)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h3 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h3><p>在windows下，使用vim打开utf-8编码的文件，通常会产生乱码，解决方法为在配置文件<code>_vimrc</code>（用户目录下的）中，添加如下设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> fileencodings=utf-8,ucs-bom,cp936,big5  </span><br><span class="line"><span class="built_in">set</span> fileencoding=utf-8</span><br></pre></td></tr></table></figure><p>vim关于文件编码常用的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> fileencoding    查看文件编码</span><br><span class="line">:<span class="built_in">set</span> fileformat       查看文件格式</span><br><span class="line">:<span class="built_in">set</span> fileencoding=utf-8 转换文件编码为utf-8</span><br></pre></td></tr></table></figure><h3 id="启用backspace"><a href="#启用backspace" class="headerlink" title="启用backspace"></a>启用backspace</h3><p>我在Windows的平台下面遇到了backspace退格键不能向左删除的问题，解决方法为在配置文件<code>_vimrc</code>中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> backspace=indent,eol,start</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://time.geekbang.org/column/article/262520" target="_blank" rel="noopener">01｜各平台下的 Vim 安装方法：上路前准备好你的宝马</a><br><a href="https://time.geekbang.org/column/article/266193" target="_blank" rel="noopener">02｜基本概念和基础命令：应对简单的编辑任务</a><br><a href="https://time.geekbang.org/column/article/266754" target="_blank" rel="noopener">03｜更多常用命令：应对稍复杂的编辑任务</a><br><a href="https://www.jianshu.com/p/4e040835f241" target="_blank" rel="noopener">Windows下，Vim的配置文件（_vimrc）在哪？</a><br><a href="https://blog.csdn.net/u012145252/article/details/82155354" target="_blank" rel="noopener">解决windows下vim中文乱码</a><br><a href="https://stackoverflow.com/questions/11560201/backspace-key-not-working-in-vim-vi" target="_blank" rel="noopener">Backspace key not working in Vim/vi</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;Vim大概有如下几个版本：vim、vim-athena、vim-gnome、vim-gtk、vim-gtk3、vim-noxvim-tiny。它们中有编译进最小功能的 Vim 包（vim-tiny），有较全功能的文本界面 Vim 包（vim-nox），有适用于老的 X-Window 界面的版本（vim-athena），有适用于 KDE 环境的 GTK2 版本（vim-gtk），等等。&lt;/p&gt;
&lt;p&gt;对于Ubuntu而言，一般情况下&lt;code&gt;sudo apt install vim-gtk3&lt;/code&gt;即可。在 Ubuntu 上，vim 和 gvim 都是指向同一个应用程序的符号链接，且 &lt;code&gt;gvim&lt;/code&gt; 的执行效果和 &lt;code&gt;vim -g&lt;/code&gt; 相同。所以要启动图像化界面的&lt;code&gt;vim&lt;/code&gt;，直接在终端执行&lt;code&gt;gvim&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;另外，若使用远程软件连接到Linux机器上，需要注意远程终端软件的远程字符集（如 PuTTY 中的“Windows &amp;gt; Translation &amp;gt; Remote character set”）应当设置成 UTF-8。&lt;/p&gt;
&lt;p&gt;然后，还可以安装中文版本的帮助文件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="杂七杂八" scheme="https://www.zdaiot.com/categories/Tools/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="vim" scheme="https://www.zdaiot.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile指令详解</title>
    <link href="https://www.zdaiot.com/Tools/Docker/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.zdaiot.com/Tools/Docker/Dockerfile指令详解/</id>
    <published>2020-09-25T14:04:55.000Z</published>
    <updated>2020-09-25T14:04:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>dockerfile记载了从一个镜像创建另一个新镜像的步骤。撰写好Dockerfile文件之后，我们就可以轻而易举的使用<code>docker build</code>命令来创建镜像了。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。</p><h3 id="Dockerfile的组成部分"><a href="#Dockerfile的组成部分" class="headerlink" title="Dockerfile的组成部分"></a>Dockerfile的组成部分</h3><div class="table-container"><table><thead><tr><th>部分</th><th>命令</th></tr></thead><tbody><tr><td>基础镜像信息</td><td>FROM</td></tr><tr><td>维护者信息</td><td>MAINTAINER</td></tr><tr><td>镜像操作指令</td><td>RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等</td></tr><tr><td>容器启动时执行指令</td><td>CMD、ENTRYPOINT</td></tr></tbody></table></div><p>下面主要列举出Dockerfile中比较常用的指令及其用法和说明，需要注意的是这些指令都是全部大写。</p><h4 id="FROM："><a href="#FROM：" class="headerlink" title="FROM："></a><strong><code>FROM</code></strong>：</h4><ul><li>说明：指定该镜像的基础镜像</li><li>格式如：<code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code></li><li>示例：<code>FROM centos:7</code></li><li>注意：<code>FROM</code>一般出现在文件头，且每个镜像都需要有一个<code>FROM</code>来指定基础镜像。</li></ul><h4 id="MAINTAINER："><a href="#MAINTAINER：" class="headerlink" title="MAINTAINER："></a><strong><code>MAINTAINER</code></strong>：</h4><ul><li>说明：指定作者信息</li><li>格式如：<code>MAINTAINER &lt;name&gt;</code></li><li>示例：<code>MAINTAINER 知识林 &quot;393156105@qq.com&quot;</code></li></ul><h4 id="RUN："><a href="#RUN：" class="headerlink" title="RUN："></a><strong><code>RUN</code></strong>：</h4><ul><li>说明：在构建镜像时执行脚本</li><li>格式如：<code>RUN &lt;command&gt;</code>、<code>RUN [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code></li><li>示例：<code>RUN ls -l</code>（以详细信息方式列表当前目录下的文件，跟在shell终端运行一样）</li></ul><h4 id="CMD："><a href="#CMD：" class="headerlink" title="CMD："></a><strong><code>CMD</code></strong>：</h4><ul><li>说明：在运行容器时执行脚本</li><li>格式如：<code>CMD &lt;command&gt; &lt;par1&gt; &lt;par2&gt; ...</code>、<code>CMD [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code></li><li>示例：<code>CMD [&quot;ls&quot;, &quot;-l&quot;]</code></li><li>注意：一个Dockerfile中只有一条<code>CMD</code>，如果有多条只执行最后一条；在运行容器时如果用户指定了运行命令则Dockerfile中的CMD将被覆盖。</li></ul><h4 id="Label"><a href="#Label" class="headerlink" title="Label:"></a><code>Label</code>:</h4><ul><li><p>说明：给构建的镜像打标签。</p></li><li><p>格式如：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LABEL <span class="string">"com.example.vendor"</span>=<span class="string">"ACME Incorporated"</span></span><br><span class="line">LABEL com.example.label-with-value=<span class="string">"foo"</span></span><br><span class="line">LABEL version=<span class="string">"1.0"</span></span><br><span class="line">LABEL description=<span class="string">"This text illustrates \</span></span><br><span class="line"><span class="string">that label-values can span multiple lines."</span></span><br></pre></td></tr></table></figure><p>一个镜像可以有多个标签，如果基础镜像也有标签则继承，名字相同的话则会覆盖。如果使用多个标签，建议合并成一个标签指令，如果使用多个标签指令， 则每个标签指令都会生成一个图层，这会导致镜像生成效率低下。举个栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL multi.label1=<span class="string">"value1"</span> multi.label2=<span class="string">"value2"</span> other=<span class="string">"value3"</span></span><br></pre></td></tr></table></figure><p>也可以写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABEL multi.label1=<span class="string">"value1"</span> \</span><br><span class="line">multi.label2=<span class="string">"value2"</span> \</span><br><span class="line">other=<span class="string">"value3"</span></span><br></pre></td></tr></table></figure></li><li><p>注意：标签是键值对格式，要在标签中包含空格则需转义或用引号<code>&quot;</code>括起来。</p></li></ul><h4 id="ENTRYPOINT："><a href="#ENTRYPOINT：" class="headerlink" title="ENTRYPOINT："></a><strong><code>ENTRYPOINT</code></strong>：</h4><ul><li>说明：在运行容器时执行脚本</li><li>格式如：<code>ENTRYPOINT [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code>、<code>ENTRYPOINT command par1 par2</code></li><li>示例：<code>ENTRYPOINT [&quot;catalina.sh&quot;, &quot;run&quot;]</code></li><li>注意：一个Dockerfile中只有一条<code>ENTRYPOINT</code>，如果有多条只执行最后一条；不可以被容器运行时的命令所覆盖。</li></ul><h4 id="EXPOSE："><a href="#EXPOSE：" class="headerlink" title="EXPOSE："></a><strong><code>EXPOSE</code></strong>：</h4><ul><li>说明：让Docker暴露容器的端口号，供其他容器使用，在宿主机以外的网络中是无法使用的</li><li>格式如：<code>EXPOSE &lt;port&gt; ...</code></li><li>示例：<code>EXPOSE 8080</code></li><li>注意：<ul><li>在Docker中有两种暴露端口的概念，一种叫<code>EXPOSE</code>隐式暴露，只供Docker服务内部使用；另一种叫<code>PUBLISH</code>显式暴露，供外部网络使用，<code>PUBLISH</code>只是一个概念在Dockerfile中没有这个指令。</li><li><code>EXPOSE</code> 只在Dockerfile中出现，所暴露的端口只是被其他容器使用</li><li><code>PUBLISH</code> 没有该指令而是通过<code>docker run</code>命令的参数<code>-p</code>、<code>-P</code>或在<code>docker-compose</code>中的<code>ports</code>来体现</li><li><code>-P</code>：大写是属于自动映射，将Dockerfile中<code>EXPOSE</code>所暴露的所有端口分别映射到宿主机的随机端口，每次启动或重启容器时端口都可能有所不同</li><li><code>-p</code>：小写是属于固定映射，格式如：<code>-p 宿主端口:容器端口</code>，宿主端口和容器端口可以是纯数字也可以是一个范围，如：<code>-p 8060-8080:8060-8080</code>，意为将宿主机的<code>8060</code>（含）到<code>8080</code>（含）的端口映射到容器的<code>8060</code>（含）到<code>8080</code>（含）端口，需要注意的是在使用范围时，宿主端口个数应该与容器端口个数匹配；但上面这个例子可以写成：<code>-p 7060-7080:8060-8080</code>，这样宿主的端口就在<code>7060-7080</code>范围内</li></ul></li></ul><h4 id="ENV："><a href="#ENV：" class="headerlink" title="ENV："></a><strong><code>ENV</code></strong>：</h4><ul><li>说明：指定环境变量，在Dockerfile文件中的后续代码中使用，在容器运行时也可以使用</li><li>格式如：<code>ENV &lt;key&gt; &lt;value&gt;</code></li><li>示例：<code>ENV tomcat_home /web/tomcat/</code></li></ul><h4 id="ADD："><a href="#ADD：" class="headerlink" title="ADD："></a><strong><code>ADD</code></strong>：</h4><ul><li>说明：添加文件（夹）到容器</li><li>格式如：<code>ADD &lt;src&gt; &lt;dest&gt;</code></li><li>示例：<code>ADD web.jar /web.jar</code></li><li>注意：复制指定的<code>&lt;src&gt;</code>到容器中的<code>&lt;dest&gt;</code>，<code>&lt;src&gt;</code>可以是Dockerfile所在目录的一个相对路径，也可以是一个URL，也可以是一个<code>tar</code>文件（<code>tar</code>文件将自动解压成文件目录）</li></ul><h4 id="COPY："><a href="#COPY：" class="headerlink" title="COPY："></a><strong><code>COPY</code></strong>：</h4><ul><li>说明：添加文件（夹）到容器</li><li>格式如：<code>COPY &lt;src&gt; &lt;dest&gt;</code></li><li>示例：<code>COPY web.jar /web.jar</code></li><li>注意：与<code>ADD</code>功能相似，只是不能指定URL，使用本地文件（夹）为源文件时，推荐使用<code>COPY</code></li></ul><h4 id="VOLUME："><a href="#VOLUME：" class="headerlink" title="VOLUME："></a><strong><code>VOLUME</code></strong>：</h4><ul><li><p>说明：创建挂载点</p></li><li><p>格式如：<code>VOLUME [path]</code></p></li><li><p>示例：<code>VOLUME [&quot;/datas&quot;]</code></p></li><li><p>注意：</p><ul><li><code>VOLUME</code>在原理和概念上与<code>EXPOSE</code>差不多，都是属于供容器与容器间使用</li><li>通过<code>VOLUME</code>挂载的卷可以供其他容器使用</li></ul></li><li><p>举例说明：</p><ul><li><p>创建一个Dockerfile来构建一个镜像，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [<span class="string">"/web/images"</span>, <span class="string">"/web/files"</span>]</span><br></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t <span class="string">"zsl131/test01"</span> .</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name <span class="built_in">test</span>-root</span><br></pre></td></tr></table></figure></li><li><p>可以使用命令：<code>docker inspect test-root</code>来查看容器详细信息，在<code>Mounts</code>部份可以看到两个挂载点：<code>/web/images</code>和<code>/web/files</code></p></li><li><p>启动另一个容器来共用这两个挂载卷</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name <span class="built_in">test</span>-1 --volumes-from <span class="built_in">test</span>-root centos</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>使用<code>--volumes-from</code>来指定挂载点，这时容器<code>test-root</code>和<code>test-1</code>里面都分别有挂载卷<code>/web/images</code>和<code>/web/files</code>，可以启动任意多个容器使用<code>--volumes-from</code>来共用这些挂载卷，这些容器可以来自不同的镜像。当任何一个容器中的挂载卷中的文件发生变化时其他容器挂载卷中的内容也随之改变。</p><p>容器<code>test-root</code>即使已经停止也可以在启动其他容器时使用<code>--volumes-from test-root</code>来挂载这些卷，只要<code>test-root</code>不被删除，不过如果<code>test-root</code>真被删除还可以使用<code>--volumes-from test-1</code>，因为容器<code>test-1</code>中还存在我们所需要的挂载卷，换句话说这些挂载卷永远存在直到所有使用这些挂载卷的容器都被删除。</p></li><li><p><code>VOLUME</code>与<code>docker run</code>参数<code>-v</code>是有区别的。<code>docker run -v /host/web/images:/web/images -v /host/web/files:/web/files:rw</code>是将容器内的<code>/web/images</code>挂载到宿主机的<code>/host/web/images</code>目录上；将容器内的<code>/web/files</code>挂载到宿主机的<code>/host/web/files</code>目录上，<code>rw</code>表示可读写。</p></li></ul></li></ul><h4 id="WORKDIR："><a href="#WORKDIR：" class="headerlink" title="WORKDIR："></a><strong><code>WORKDIR</code></strong>：</h4><ul><li>说明：设置工作目录</li><li>格式如：<code>WORKDIR /path</code></li><li>示例：<code>WORKDIR /web</code></li><li>注意：可以使用绝对路径，也可以使用相对路径，设置之后的所有操作都将在这个目录下完成</li></ul><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG:"></a><code>ARG</code>:</h4><p>指定用户在<code>docker build --build-arg &lt;varname&gt;=&lt;value&gt;</code>时可以使用的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><p>如果用户指定了未在Dockerfile中定义的构建参数，则构建会输出警告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Warning] One or more build-args [foo] were not consumed.</span><br></pre></td></tr></table></figure><p>构建参数在定义的时候生效而不是在使用的时候。如下面第三行开始的user才是用户构建参数传递过来的user：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line"><span class="comment"># 此处获取不到用户传来的user</span></span><br><span class="line">USER <span class="variable">$&#123;user:-some_user&#125;</span></span><br><span class="line">ARG user</span><br><span class="line">USER <span class="variable">$user</span></span><br></pre></td></tr></table></figure><p>您可以使用<code>ARG</code>或<code>ENV</code>指令指定<code>RUN</code>指令可用的变量。使用<code>ENV</code>指令定义的环境变量始终覆盖同名的<code>ARG</code>指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER v1.0.0</span><br><span class="line"><span class="comment"># 始终是v1.0.0</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span><br></pre></td></tr></table></figure><p>正确的用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER <span class="variable">$&#123;CONT_IMG_VER:-v1.0.0&#125;</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span><br></pre></td></tr></table></figure><p>要在多个阶段中使用arg，每个阶段都必须包含该ARG指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG SETTINGS</span><br><span class="line">RUN ./run/setup <span class="variable">$SETTINGS</span></span><br><span class="line"></span><br><span class="line">FROM busybox</span><br><span class="line">ARG SETTINGS</span><br><span class="line">RUN ./run/other <span class="variable">$SETTINGS</span></span><br></pre></td></tr></table></figure><p>此外docker还内置了一批构建参数，可以不用在Dockerfile中声明：<code>HTTP_PROXY</code>、<code>http_proxy</code>、<code>HTTPS_PROXY</code>、<code>https_proxy</code>、<code>FTP_PROXY</code>、 <code>ftp_proxy</code>、<code>NO_PROXY</code>、<code>no_proxy</code></p><blockquote><p>注意：在使用构建参数(而不是在构建参数定义的时候)的指令中，如果构建参数的值发生了变化，会导致该指令发生变化，会重新寻找缓存。</p></blockquote><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>在上面的描述中可以看到有两组指令在功能上都差不多，但也是有区别的：</p><ul><li><code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>执行脚本的指令<ul><li>三个指令都是执行脚本</li><li><code>RUN</code>是在创建镜像是执行，即使用<code>docker build</code>命令时执行，在一个Dockerfile里面可以有多个<code>RUN</code></li><li><code>CMD</code>和<code>ENTRYPOINT</code>是在运行容器时执行，即使用<code>docker run</code>命令时执行，这两个指令在Dockerfile中都只有最行一条被执行</li><li><code>CMD</code>在使用<code>docker run</code>时可以加参数将Dockerfile中的<code>CMD</code>覆盖</li><li><code>ENTRYPOINT</code>在Dockerfile中出现后就一定会在<code>docker run</code>时被执行，不必担心会被其他参数所覆盖。</li></ul></li><li><code>ADD</code>、<code>COPY</code>拷贝文件（夹）到容器<ul><li><code>ADD</code>拷贝文件（夹）时可以指定本地文件、远程URL地址，如果拷贝的是<code>tar</code>文件时将会被自动解压成文件夹</li><li><code>COPY</code>拷贝文件（夹）时不可以指定远程URL地址，拷贝<code>tar</code>文件也不会被自动解压成文件夹，在拷贝本地文件时建议使用<code>COPY</code></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/6844903878849200142" target="_blank" rel="noopener">Dockerfile指令详解</a><br><a href="https://www.jianshu.com/p/ff301a3ecf17" target="_blank" rel="noopener">12 - Dockerfile指令详解（Docker系列）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dockerfile记载了从一个镜像创建另一个新镜像的步骤。撰写好Dockerfile文件之后，我们就可以轻而易举的使用&lt;code&gt;docker build&lt;/code&gt;命令来创建镜像了。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。&lt;/p&gt;
&lt;h3 id=&quot;Dockerfile的组成部分&quot;&gt;&lt;a href=&quot;#Dockerfile的组成部分&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile的组成部分&quot;&gt;&lt;/a&gt;Dockerfile的组成部分&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;部分&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基础镜像信息&lt;/td&gt;
&lt;td&gt;FROM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;维护者信息&lt;/td&gt;
&lt;td&gt;MAINTAINER&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;镜像操作指令&lt;/td&gt;
&lt;td&gt;RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;容器启动时执行指令&lt;/td&gt;
&lt;td&gt;CMD、ENTRYPOINT&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;下面主要列举出Dockerfile中比较常用的指令及其用法和说明，需要注意的是这些指令都是全部大写。&lt;/p&gt;
&lt;h4 id=&quot;FROM：&quot;&gt;&lt;a href=&quot;#FROM：&quot; class=&quot;headerlink&quot; title=&quot;FROM：&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/strong&gt;：&lt;/h4&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.zdaiot.com/categories/Tools/"/>
    
      <category term="Docker" scheme="https://www.zdaiot.com/categories/Tools/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.zdaiot.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode总结</title>
    <link href="https://www.zdaiot.com/DataStructureAlgorithm/LeetCode%E6%80%BB%E7%BB%93/"/>
    <id>https://www.zdaiot.com/DataStructureAlgorithm/LeetCode总结/</id>
    <published>2020-07-24T02:08:47.000Z</published>
    <updated>2020-07-24T02:08:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树遍历模板"><a href="#二叉树遍历模板" class="headerlink" title="二叉树遍历模板"></a>二叉树遍历模板</h3><ol><li><strong>前序遍历</strong>：<strong>先访问根节点</strong>，再前序遍历左子树，再前序遍历右子树</li><li><strong>中序遍历</strong>：先中序遍历左子树，<strong>再访问根节点</strong>，再中序遍历右子树</li><li><strong>后序遍历</strong>：先后序遍历左子树，再后序遍历右子树，<strong>再访问根节点</strong></li></ol><p>注意点：</p><ol><li><p>以根访问顺序决定是什么遍历</p></li><li><p>左子树都是优先右子树</p></li></ol><p>练习：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>递归法三要素：</p><ol><li>确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型；</li><li>确定终止条件；</li><li>确定单层递归逻辑：这里需要假定嵌套问题已经解决了。</li></ol><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>前序遍历（迭代法）不难写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        TreeNode* node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) result.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        st.push(node-&gt;right);  <span class="comment">// 栈是先进后出，访问顺序是根左右，所以先让右节点入栈</span></span><br><span class="line">        st.push(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用迭代法很难写出统一的模板，在迭代过程中，有两个操作，<strong>一个是处理：将元素放进result数组中，一个是访问：遍历节点。</strong>前序遍历的顺序是中左右，要先访问的元素是中间节点，要处理的元素也是中间节点，要访问的元素和要处理的元素顺序是一致的，都是中间节点，所以才能写出相对简洁的代码。</p><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><p>中序遍历，可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;  <span class="comment">// 一层一层的向下访问，直到树左边的底层</span></span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// </span></span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/DataStructureAlgorithm/LeetCode总结/4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image.png" alt="4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image" style="zoom: 50%;"></p><p>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        TreeNode* node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) result.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        st.push(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序</span></span><br><span class="line">        st.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(result.begin(), result.end()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h4><blockquote><p>给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><p>该题目可以使用递归的方法解决，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftD, rightD;</span><br><span class="line">    <span class="keyword">if</span>(isBalancedCore(root-&gt;left, leftD) &amp;&amp; isBalancedCore(root-&gt;right, rightD)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(leftD-rightD) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            depth = <span class="number">1</span> + (leftD &gt; rightD?leftD:rightD);</span><br><span class="line">            <span class="comment">// depth = max(leftD, rightD) + 1;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth;</span><br><span class="line">    <span class="keyword">return</span> isBalancedCore(root, depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/" target="_blank" rel="noopener">彻底吃透前中后序递归法（递归三部曲）和迭代法（不统一写法与统一写法）</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>链表代码经常考察点在于指针的理解，也就是<code>NULL</code>指针的处理，比如说有一个结构体<code>Node</code>，结构体指针为<code>node*</code>，访问结构体成员变量<code>node-&gt;val</code>的时候，要先判断<code>node</code>是否等于<code>NULL</code>。</p><p>常用技巧：</p><ol><li>设置哑点可以简化很多判断和处理</li><li>快慢指针、双指针的使用</li><li>得到链表的中心节点之后翻转链表（可以翻转前半部分，也可以翻转后半部分。翻转前半部分指针代码更加简单）</li></ol><p>这里补充一个常用代码，链表借助双指针，找到中间节点<code>slow</code>，若链表为偶数个元素，则<code>slow</code>节点在前半段的最后一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow, fast = head, head.next</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">fast, slow = fast.next.next, slow.next</span><br></pre></td></tr></table></figure><p>若写成下面形式，则若链表为偶数个元素，则<code>slow</code>节点在后半段的第一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow, fast = head, head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">fast, slow = fast.next.next, slow.next</span><br></pre></td></tr></table></figure><h3 id="常见题目-1"><a href="#常见题目-1" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></h4><blockquote><p>给定一个<strong>排序</strong>链表，删除所有重复的元素，使得每个元素只出现一次。</p></blockquote><p>这个题目需要使用双指针的方法，一个指针记录前一个指针，一个指针记录当前遍历到的指针。若两个指针的元素值相同，则删除当前节点，否则的话，更新两个指针。</p><p>参考代码如下。为了简化代码，这里使用了<code>cur</code>和<code>cur-&gt;next</code>代替双指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">        <span class="comment">// 如果节点值相同</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;   <span class="comment">// 不需要更新cur指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></h4><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p></blockquote><p>这个题目和上一个题目的区别在于，上一个题目重复出现的只保留一个，而这里重复出现的数字则需要全部删除。</p><p>首先，在上一个题目中首节点是不可能被删除的，而在本题目中首节点是有可能被删除的，所以需要借助<strong>哑点</strong>处理。另外需要删除所有重复的数字，刚拿到题目的思路是采用三指针的方法，但是这种方法的容易出错并且代码比较复杂。</p><p>因此可以换一种思路，我们使用双指针法，指针<code>l</code>记录左节点，指针<code>r</code>记录右节点。每次循环的时候，初始化<code>l=r</code>，若<code>l-&gt;val=r-&gt;val</code>则不断向后移动<code>r</code>指针。</p><ol><li>若<code>l-&gt;next==r</code>，则说明<code>l-&gt;val</code>肯定是唯一的，将<code>l</code>指针放到结果中，但此时<code>r-&gt;val</code>不一定是唯一的，所以重新初始化<code>l=r</code>；</li><li>若<code>l-&gt;next!=r</code>，则说明<code>l</code>到<code>r-&gt;pre</code>之间所有的值都是重复的，不更新结果，同样此时<code>r-&gt;val</code>不一定是唯一的，所以重新初始化<code>l=r</code>；</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;        </span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);  <span class="comment">// 哑点</span></span><br><span class="line">    ListNode* node = dummy;</span><br><span class="line">    </span><br><span class="line">    ListNode* r = head;</span><br><span class="line">    <span class="keyword">for</span>(ListNode* l=head; l!=<span class="literal">NULL</span>; l=r) &#123;  <span class="comment">// 不管l节点是不是唯一，r节点是否唯一都不能得到结论，所以更新l=r</span></span><br><span class="line">        <span class="keyword">while</span>(r &amp;&amp; l-&gt;val==r-&gt;val) r = r-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;next == r) &#123;  <span class="comment">// 若满足则说明l节点肯定是唯一的，不能用r-l==1，因为两个都是表示地址</span></span><br><span class="line">            node-&gt;next = l;  <span class="comment">// 将l指针添加到最后结果中</span></span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 不要忘记置为NULL，否则结果会混乱</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h4><blockquote><p>反转一个单链表。</p></blockquote><p>该题是典型的双指针题目，需要用一个<code>pre</code>指针记录前一个节点，一个<code>node</code>指针记录当前节点。这里需要注意的地方是<code>pre</code>指针的初始化特别重要，需要初始化为<code>pre=NULL</code>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pNode = head;</span><br><span class="line">    ListNode* pPre = <span class="literal">NULL</span>;  <span class="comment">// 这个初始化很重要</span></span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">        ListNode* pNext = pNode-&gt;next;  <span class="comment">// 记录下一个节点          </span></span><br><span class="line">        pNode-&gt;next = pPre;</span><br><span class="line">        pPre = pNode;</span><br><span class="line">        pNode = pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pPre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></h4><blockquote><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。<strong>说明:</strong>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。也就是说 <em>m</em> 和 <em>n</em> 的下标都是从1开始的。</p></blockquote><p>这个题目有一个要求就是一趟扫描完成反转。定义两个指针，分别为<code>g</code>（guard）和<code>p</code>（point）。首先根据参数<code>m</code>确定<code>g</code>和<code>p</code>的位置。将<code>g</code>移动到第一个要反转的节点前面，将<code>p</code>移动到第一个要反转的节点位置上。以<code>m=2,n=4</code>为例：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/5389db651086bd4bcd42dd5c4552f180b553a9b204cfc1013523dfe09beac382-1.png" alt="5389db651086bd4bcd42dd5c4552f180b553a9b204cfc1013523dfe09beac382-1"></p><p>然后使用头插法，将<code>p</code>后面的元素删除，然后添加到<code>g</code>的后面，重复该步骤。如下图所示：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/db22bdb60035e45f8c354b3f45f2a844260d6cafcf81528d2c4f1b51e484fb45-2.png" alt="db22bdb60035e45f8c354b3f45f2a844260d6cafcf81528d2c4f1b51e484fb45-2" style="zoom:67%;"></p><p>最后返回<code>dummyHead-&gt;next</code>。</p><p>这里需要注意的是，根据<code>m</code>是否等于1，返回的结果是不一样的。为了避免对这些情况进行分类讨论，可以借助哑点。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    ListNode* g = dummyHead;</span><br><span class="line">    ListNode* p = dummyHead-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>; i++) &#123; <span class="comment">// 将g移动到第一个要反转的节点的前面，将p移动到第一个要反转的节点的位置上</span></span><br><span class="line">        g = g-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-m; i++) &#123;  <span class="comment">// 由上图可得知，并不需要更新g、p指针</span></span><br><span class="line">        ListNode* removed = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        removed-&gt;next = g-&gt;next;  <span class="comment">// 注意这个地方不能直接等于p，画到第二次循环即可明白</span></span><br><span class="line">        g-&gt;next = removed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h4><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></blockquote><p>这个一个很典型的需要借助哑点来简化代码的题目。思想比较简单，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">        cur-&gt;next = l2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur-&gt;next = l1;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></h4><blockquote><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。你应当保留两个分区中每个节点的初始相对位置。</p></blockquote><p>这个题目可以使用双哑点指针解决。</p><p>参考代码如下，这里需要注意的是，因为涉及到节点的拼接，所以要避免陷入死循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* little = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* big = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* node1 = little;</span><br><span class="line">    ListNode* node2 = big;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val &lt; x) &#123;</span><br><span class="line">            node1-&gt;next = head;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node2-&gt;next = head;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node2-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 避免返回结果的时候陷入死循环</span></span><br><span class="line">    node1-&gt;next = big-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> little-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></h4><blockquote><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p></blockquote><p>题目要求时间空间复杂度分别为$O(nlogn)$和$O(1)$，根据时间复杂度我们自然想到二分法，从而联想到归并排序（快速排序平均时间复杂度为$O(nlogn)$ ）；对数组进行归并排序的空间复杂度为$O(n)$，分别由新开辟数组$O(n)$和递归函数调用$O(logn)$组成，而根据链表特性：</p><ol><li>数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间</li><li>递归额外空间：递归调用函数将带来$O(logn)$的空间复杂度，若希望达到$O(1)$空间复杂度，则不能使用递归</li></ol><p>为了方便理解，先阐述一下基于<strong>递归方法</strong>的思路：</p><p><strong>分割环节：</strong>找到当前链表中点，并从中点将链表断开</p><ul><li>使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</li><li>找到中点 slow 后，执行 slow.next = None <strong>将链表切断</strong>。</li><li>递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。</li><li>cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。</li></ul><p><strong>合并环节：</strong>将两个排序链表合并，转化为一个排序链表。</p><ul><li>双指针法合并，建立辅助ListNode h 作为头部。</li><li>设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li><li>返回辅助ListNode h 作为头部的下个节点 h.next。</li><li>时间复杂度 O(l + r)，l, r 分别代表两个链表长度。</li></ul><p><strong>当题目输入的 <code>head == None</code> 时，直接返回None。</strong></p><p>示意图如下：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png" alt="Picture2.png" style="zoom: 50%;"></p><p>接下来阐述一下<strong>基于循环</strong>的方式，也就是<strong>从底至顶直接合并</strong>。需要使用迭代的方式替换上述<strong>分割环节</strong>，该环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。</p><p>每一轮合并merge操作针对的单元都有固定长度intv，例如：</p><ul><li>第一轮合并时intv = 1，即将整个链表切分为多个长度为1的单元，并按顺序两两排序合并，合并完成的已排序单元长度为2。</li><li>第二轮合并时intv = 2，即将整个链表切分为多个长度为2的单元，并按顺序两两排序合并，合并完成已排序单元长度为4。</li><li>以此类推，直到单元长度intv &gt;= 链表长度，代表已经排序完成。</li></ul><p>根据以上推论，我们可以仅根据intv计算每个单元边界，并完成链表的每轮排序合并，例如:</p><ul><li>当intv = 1时，将链表第1和第2节点排序合并，第3和第4节点排序合并，……。</li><li>当intv = 2时，将链表第1-2和第3-4节点排序合并，第5-6和第7-8节点排序合并，……。</li><li>当intv = 4时，将链表第1-4和第5-8节点排序合并，第9-12和第13-16节点排序合并，……。</li></ul><p>此方法时间复杂度$O(nlogn)$，空间复杂度$O(1)$。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png" alt="Picture1.png" style="zoom:50%;"></p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);  <span class="comment">// 设置哑点</span></span><br><span class="line">    res-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前每个组别的长度</span></span><br><span class="line">    <span class="keyword">int</span> intv = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(intv &lt; length) &#123;</span><br><span class="line">        <span class="comment">// h用于遍历，注意这次每次都需要这样的初始化，res每次也会更新，其next指向排序后的第一个指针</span></span><br><span class="line">        ListNode* pre = res;</span><br><span class="line">        ListNode* h = res-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两两一组的遍历各个小块，当h为空的时候，加大intv</span></span><br><span class="line">        <span class="keyword">while</span>(h) &#123;</span><br><span class="line">            <span class="comment">// h1是第一个块的开头，h2是第二个块的开头</span></span><br><span class="line">            ListNode* h1 = h;</span><br><span class="line">            <span class="comment">// 向前移动intv个，得到第二个块的开头h</span></span><br><span class="line">            <span class="keyword">int</span> i = intv;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; h) &#123;</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) </span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 此时第二个块没有值，也就可以删除了</span></span><br><span class="line">        </span><br><span class="line">            i = intv;</span><br><span class="line">            ListNode* h2 = h;</span><br><span class="line">            <span class="comment">// 得到第三个块的开始坐标h，方便接下来的循环</span></span><br><span class="line">            <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; h) &#123;</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始进行合并，注意这里循环的时候不能够使用h1和h2，因为并没有截断</span></span><br><span class="line">            <span class="keyword">int</span> c1 = intv;</span><br><span class="line">            <span class="keyword">int</span> c2 = intv - i; <span class="comment">// c2的长度可能比intv短</span></span><br><span class="line">            <span class="keyword">while</span>(c1&gt;<span class="number">0</span> &amp;&amp; c2&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(h1-&gt;val &lt; h2-&gt;val) &#123;</span><br><span class="line">                    pre-&gt;next = h1;</span><br><span class="line">                    h1 = h1-&gt;next;</span><br><span class="line">                    c1--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre-&gt;next = h2;</span><br><span class="line">                    h2 = h2-&gt;next;</span><br><span class="line">                    c2--;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有一方有剩余</span></span><br><span class="line">            <span class="keyword">if</span>(c1&gt;<span class="number">0</span>) </span><br><span class="line">                pre-&gt;next = h1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c2&gt;<span class="number">0</span>) </span><br><span class="line">                pre-&gt;next = h2;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 排序好的链表末尾指针pre的next指向第三块的开始坐标</span></span><br><span class="line">            <span class="keyword">while</span>(c1&gt;<span class="number">0</span> || c2&gt;<span class="number">0</span>) &#123;  </span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                c1--;</span><br><span class="line">                c2--;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = h;</span><br><span class="line">        &#125;</span><br><span class="line">        intv *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></h4><blockquote><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></blockquote><p>这个题目根据一头一尾取元素的特性。可以分为三个步骤：</p><ol><li>将链表平均分为两半，并从中间截断，防止陷入死循环</li><li>将第二个链表逆序</li><li>依次连接两个链表</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* slow = head;  <span class="comment">// slow指向的是中间元素</span></span><br><span class="line">    ListNode* fast = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* mid = slow-&gt;next;  <span class="comment">// mid指向第二个链表的首元素</span></span><br><span class="line">    slow-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 进行截断，防止陷入死循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 旋转后面的链表，最终pre指向旋转后首元素</span></span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 这个初始化需要注意</span></span><br><span class="line">    <span class="keyword">while</span>(mid) &#123;</span><br><span class="line">        ListNode* third = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = pre;</span><br><span class="line">        pre = mid;</span><br><span class="line">        mid = third;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始进行拼接操作</span></span><br><span class="line">    ListNode* node = head;</span><br><span class="line">    <span class="keyword">while</span>(pre) &#123;</span><br><span class="line">        ListNode* third = node-&gt;next;</span><br><span class="line">        node-&gt;next = pre;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;next = third;</span><br><span class="line">        node = third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h4><blockquote><p>给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。如果链表中存在环，则返回 true 。 否则，返回 false 。请尝试使用 <em>O(1)</em>（即，常量）内存解决此问题。</p></blockquote><p>这个题目可以使用快慢指针的方法，若链表中存在环，则快慢指针肯定存在相等的情况，否则的话肯定不存在环。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head-&gt;next;  <span class="comment">// 访问肯定不会报错，但是不是NULL就不一定了</span></span><br><span class="line">    <span class="keyword">while</span>(fast!=slow) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="comment">// 肯定不存在环了</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h4><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。</p></blockquote><p>这个题目和上一个题目的区别在于本题目不仅要判断是不是有环，而且要得到入环的第一个节点。</p><p>阶段一：判断存在环；阶段二：找到环的入口，下面对第二个阶段进行讨论。</p><p>当环很大的时候，这个过程用示意图表示如下图所示。其实这个结论对于环很小的时候也适用。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/2036dfe7e991f00dfb788a9b84a17bb6fac337e81c09bdf57e683d028a6952bc-未命名文件.png" alt="未命名文件.png"></p><p>为了更加严谨的证明这个结论，我们不对环的大小进行限制进行讨论。</p><ol><li>假设链表共有 <em>a</em>+<em>b</em> 个节点，其中 <strong>链表头部到链表入口</strong> 有 <em>a</em> 个节点（不计链表入口节点）， <strong>链表环</strong> 有 <em>b</em> 个节点。设快慢指针分别走了$f,s$步，则在两个指针<strong>第一次相遇</strong>有：<ul><li>fast指针走的是slow步数的两倍，即$f=2s$</li><li>fast比slow<strong>多走了</strong>$n$个环的长度，即$f=s+nb$；（ 双指针都走过 <em>a</em> 步，然后在环内绕圈直到重合，重合时 <code>fast</code> 比 <code>slow</code> 多走 <strong>环的长度整数倍</strong> ）</li><li>以上两式相减得：$f=2nb,s=nb$，即<code>fast</code>和<code>slow</code> 指针分别走了 2<em>n</em>，<em>n</em> 个 <strong>环的周长</strong> （注意： <em>n</em> 是未知数，不同链表的情况不同）</li></ul></li><li>此时，若让指针从链表头部一直向前走并统计步数$k$，那么所有走到链表入口节点时的步数是：$k=a+nb$（先走 $a$ 步到入口节点，之后每绕 1 圈环（ $b$ 步）都会再次到入口节点）。而目前slow指针已经走了$nb$步了，只需要再走$a$步停下来即为环的入口。但是此时不知道$a$的值，所以仍然使用双指针法，让另外一个指针从链表头部出发，与slow一起向前走$a$步后，两者在入口节点重合。</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre=head, *post=head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(post==<span class="literal">NULL</span> || post-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 肯定不存在环</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        post = post-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(pre == post)  <span class="comment">// 第一次相遇停止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="keyword">while</span>(pre != post) &#123;  <span class="comment">// 再次相遇停止</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        post = post-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></h4><blockquote><p>请判断一个链表是否为回文链表。你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p></blockquote><p>若想使用$O(1)$的空间复杂度解决这个题目，可以使用<strong>快慢指针遍历的同时翻转前半部分，然后与后半部分比较即可。</strong>这个技巧也经常被其他题目使用。</p><p>值得注意的是，这里将<code>fast</code>和<code>slow</code>指针都初始化为了<code>head</code>，若将<code>fast</code>初始化为<code>head-&gt;next</code>，则当链表有偶数个元素的时候，最后一个中位数没办法处理到。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ListNode* prepre=<span class="literal">NULL</span>, *pre=head;  <span class="comment">// pre指针指向前半部分翻转后的首地址</span></span><br><span class="line">    ListNode* slow=head, *fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;  <span class="comment">// 快慢指针遍历的同时翻转前半部分</span></span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        pre-&gt;next = prepre;    </span><br><span class="line">        prepre = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast)  <span class="comment">// 说明链表元素有奇数个，此时slow在中位数上，需要向后移动一位；若链表元素为偶数个，slow在后半段的开头位置</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">NULL</span> &amp;&amp; slow!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;val != slow-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></h4><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的 深拷贝。 </p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><ul><li>val：一个表示 Node.val 的整数。</li><li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li></ul></blockquote><p>该题主要有两个思路。</p><p>第一个思路是不借助外部存储空间，使用三步走的方法。</p><p><strong>第一步</strong>，根据遍历到的原节点创建对应的新节点，每个新创建的节点是在原节点后面，比如下图中原节点<strong>1</strong>不再指向原原节点<strong>2</strong>，而是指向新节点<strong>1</strong></p><p><img src="/DataStructureAlgorithm/LeetCode总结/360dbd3b89c25324287f4cef2c22ba8a20e946891ac887f70703b211893aafa0-5.jpg" alt="5.jpg" style="zoom:67%;"></p><p><strong>第二步</strong>是最关键的一步，用来设置新链表的随机指针</p><p><img src="/DataStructureAlgorithm/LeetCode总结/b531fb496fd478a2db6ba7bc805cda08b825771817dd24cdd616946a89800fbb-6.jpg" alt="6.jpg" style="zoom:67%;"></p><p>此时可以观察到一个规律，原节点<code>i</code>的随机指针(如果有的话)，指向的是原节点<code>j</code>。那么新节点<code>i</code>的随机指针，指向的是原节点<code>j</code>的<strong>next</strong>。</p><p><strong>第三步</strong>就简单了，只要将两个链表分离开，再返回新链表就可以了</p><p><img src="/DataStructureAlgorithm/LeetCode总结/9b5c6e99aa89284c8a7b423bc36fec7af39fac3f8bb709e77483e574e02ef1cd-7.jpg" alt="7.jpg"></p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    Node* node = head;</span><br><span class="line">    <span class="comment">// 开始复制</span></span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        newNode-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = newNode;</span><br><span class="line">        node = newNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始复制随机指针</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;random)</span><br><span class="line">            node-&gt;next-&gt;random = node-&gt;random-&gt;next;</span><br><span class="line">        node = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始拆分链表，借助哑点让newNode在node的前面，可以简化代码，不需要对newNode-&gt;next是否为空进行特殊判断了</span></span><br><span class="line">    Node* newHead = <span class="keyword">new</span> Node(<span class="number">-1</span>);</span><br><span class="line">    Node* newNode = newHead;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        newNode-&gt;next = node-&gt;next;</span><br><span class="line">        newNode = newNode-&gt;next;</span><br><span class="line">        node-&gt;next = newNode-&gt;next;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个解法是借助额外存储空间，也就是借助哈希表来解决这个问题。</p><p>首先创建一个哈希表，再遍历原链表，遍历的同时再不断创建新节点。我们将原节点作为<strong>key</strong>，新节点作为<strong>value</strong>放入哈希表中。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/5b578a2e33a4f87536c7fe50f71ac01904ae689b26ee3e2751dac0144f009d77-8.jpg" alt="8.jpg"></p><p>第二步我们再遍历原链表，这次我们要将新链表的next和random指针给设置上。</p><p>参考代码如下，我这里将next指针的设置放在了第一个循环中，这个位置其实无所谓。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; um;</span><br><span class="line">    Node* newHead = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">    um[head] = newHead;</span><br><span class="line">    Node* pre2 = newHead;</span><br><span class="line">    Node* cur1 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur1) &#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(cur1-&gt;val);</span><br><span class="line">        um[cur1] = newNode;</span><br><span class="line">        pre2-&gt;next = newNode;</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">        pre2 = pre2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur1 = head;</span><br><span class="line">    Node* cur2 = newHead;</span><br><span class="line">    <span class="keyword">while</span>(cur1) &#123;</span><br><span class="line">        cur2-&gt;random = um[cur1-&gt;random];</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/" target="_blank" rel="noopener">Java-双指针-头插法</a><br><a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/" target="_blank" rel="noopener">Sort List （归并排序链表）</a><br><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/xiang-xi-tu-jie-ken-ding-kan-de-ming-bai-by-xixili/" target="_blank" rel="noopener">详细图解(肯定看的明白)</a><br><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/" target="_blank" rel="noopener">环形链表 II（双指针法，清晰图解）</a><br><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-1zhan-2kuai-man-zhi-zhen-fan-zhu/" target="_blank" rel="noopener">回文链表（1.栈，2.快慢指针+翻转）</a><br><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/liang-chong-shi-xian-tu-jie-138-fu-zhi-dai-sui-ji-/" target="_blank" rel="noopener">两种实现+图解 138. 复制带随机指针的链表</a></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h3><ol><li>栈的特点是后入先出。根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 <strong>DFS 深度搜索</strong>。</li><li>队列一般用于<strong>BFS广度搜索</strong>，类似一层一层的搜索。</li></ol><h3 id="栈常见题目"><a href="#栈常见题目" class="headerlink" title="栈常见题目"></a>栈常见题目</h3><h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h4><blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) —— 将元素 x 推入栈中。</li><li>pop() —— 删除栈顶的元素。</li><li>top() —— 获取栈顶元素。</li><li>getMin() —— 检索栈中的最小元素。</li></ul></blockquote><p>这个题目要在常数时间内检索到最小元素，那么可以借助额外的一个栈保存当前最小元素。其中<code>push</code>函数比较特殊，这里给出其实现，其余的均不给出了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;INT_MAX&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s.push(x);</span><br><span class="line">    <span class="comment">// 注意这个必须每次和top比较，不能拿个全局值</span></span><br><span class="line">    vec.push_back(min(vec.back(), x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h4><blockquote><p>根据<a href="https://baike.baidu.com/item/逆波兰式/128437" target="_blank" rel="noopener"> 逆波兰表示法</a>，求表达式的值。有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) <em> ( 3 + 4 ) 。该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) </em> ) 。</p></blockquote><p>我们一般看到的都是中缀表达式，但这对于计算机来说就很不友好了。例如$4+13/5$，计算机从左到右扫描的话，扫到13还要判断13以后是什么运算符，还要比较优先级。是比较麻烦的。但是转换为中缀表达式之后，即为<code>[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</code>，计算机可以按照栈里面的顺序处理，不需要考虑优先级，也不需要后退了。</p><p>对于本题的解决思路为：</p><ol><li>定义一个栈辅助计算；</li><li>当遇到运算符”+”、”-“、”*”、”/“时，从栈中pop出两个数字计算，运算结果入栈；否则将数字入栈。</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokens.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tokens.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> c = tokens[i];</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">"+"</span> || c==<span class="string">"-"</span> || c==<span class="string">"*"</span> || c==<span class="string">"/"</span>) &#123;</span><br><span class="line">            <span class="comment">// 弹出最前面两个元素</span></span><br><span class="line">            <span class="keyword">int</span> first = vec.back();</span><br><span class="line">            vec.pop_back();</span><br><span class="line">            <span class="keyword">int</span> two = vec.back();</span><br><span class="line">            vec.pop_back();</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">"+"</span>) vec.push_back(two+first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">"-"</span>) vec.push_back(two-first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">"*"</span>) vec.push_back(two*first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">"/"</span>) vec.push_back(two/first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vec.push_back(atoi(c.c_str()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></h4><blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p></blockquote><p>本题难点在于括号内嵌套括号，需要<strong>从内向外</strong>生成与拼接字符串，这与栈的<strong>先入后出</strong>特性对应。</p><p>构建辅助栈<code>stack</code>，遍历字符串<code>s</code>中每个字符<code>c</code>：</p><ul><li>当<code>c</code>为数字时，将数字字符转化为数字<code>multi</code>，用于后续倍数计算</li><li>当<code>c</code>为字母时，在<code>res</code>尾部添加<code>c</code></li><li>当 <code>c</code> 为<code>[</code> 时，将当前 multi 和 res 入栈，并分别置空置 0：<ul><li>记录此 <code>[</code> 前的临时结果 res 至栈，用于发现对应 <code>]</code> 后的拼接操作；</li><li>记录此 <code>[</code> 前的倍数 <code>multi</code> 至栈，用于发现对应 <code>]</code> 后，获取 <code>multi × [...]</code>字符串。</li><li>进入到新 <code>[</code> 后，res 和 multi 重新记录</li></ul></li><li>当 <code>c</code> 为 <code>]</code> 时，stack 出栈，拼接字符串 <code>res = last_res + cur_multi * res</code>，其中:<ul><li><code>last_res</code>是上个 <code>[</code> 到当前 <code>[</code> 的字符串，例如 <code>&quot;3[a2[c]]&quot;</code> 中的 <code>c</code>；</li><li><code>cur_multi</code>是当前 <code>[</code> 到 <code>]</code> 内字符串的重复倍数，例如<code>&quot;3[a2[c]]&quot;</code> 中的 2。</li></ul></li></ul><p>返回字符串<code>res</code>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; sta;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            num += c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) &#123;  <span class="comment">//遇到[压栈数字和字符串，置零置空</span></span><br><span class="line">            sta.push(make_pair(num, res));</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            res = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>) &#123;  <span class="comment">//遇到]出栈数字和字符串，组装</span></span><br><span class="line">            <span class="keyword">int</span> n = sta.top().first;  <span class="comment">//n指示的是res的循环次数，不是a的</span></span><br><span class="line">            <span class="built_in">string</span> a = sta.top().second;</span><br><span class="line">            sta.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="comment">// 将a拼接到n次res前面</span></span><br><span class="line">                a = a + res;</span><br><span class="line">            res = a;  <span class="comment">// 更新当前的已有字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></h4><blockquote><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">&gt;     <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这个题目明显是深度优先遍历的题目。深度优先遍历有三个关键点：</p><ol><li>遍历路径：假设目前所在的节点为<code>node</code>，则由该点向此点的邻居节点做深度搜索</li><li>遍历终止条件：若节点<code>node==NULL</code>，则返回<code>NULL</code>；若出现在哈希表中，则已经遍历过了，返回对应的新节点</li><li>如何避免重复遍历：在遍历的同时，使用一个哈希表记录原始节点和新节点的对应关系，这样若访问过了，直接返回对应的新节点即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; mp; <span class="comment">// 声明在外面</span></span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mp.count(node)) <span class="keyword">return</span> mp[node]; <span class="comment">// 如果已经访问过了，则直接从哈希表中取出对应的克隆节点返回</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> new_root = <span class="keyword">new</span> Node(node-&gt;val); <span class="comment">// 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span></span><br><span class="line">    mp[node] = new_root;  <span class="comment">// 哈希表存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp;e : node-&gt;neighbors) &#123; <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">        mp[node]-&gt;neighbors.push_back(cloneGraph(e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p></blockquote><p>该题目也是典型的深度优先遍历题目。</p><p><strong>深度优先遍历</strong>有如下三个关键点：</p><ol><li>遍历路径：假设目前指针在岛屿中的<code>(i,j)</code>点，那么由该点向此点的上下左右 <code>(i+1,j)</code>,<code>(i-1,j)</code>,<code>(i,j+1)</code>,<code>(i,j-1)</code> 做深度搜索。</li><li>遍历终止条件：<code>(i,j)</code>越过矩阵边界；<code>grid[i][j] == &#39;2&#39;</code>代表此分支已经越过岛屿边界</li><li>如何避免重复遍历：搜索岛屿的同时，执行 <code>grid[i][j] = &#39;2&#39;</code>，即将岛屿所有节点删除，以免之后重复搜索相同岛屿。</li></ol><p><strong>主循环（深度优先遍历不一定都对这个分析，因为本题在DFS的时候，会中断掉，所以需要分析）：</strong>遍历整个矩阵，当遇到<code>grid[i][j] == &#39;1&#39;</code> 时，从此点开始做深度优先搜索 dfs，岛屿数 count + 1 且在深度优先搜索中删除此岛屿。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=grid.size() || j&gt;=grid[<span class="number">0</span>].size()|| grid[i][j] != <span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">    infect(grid, i<span class="number">-1</span>, j);</span><br><span class="line">    infect(grid, i+<span class="number">1</span>, j);</span><br><span class="line">    infect(grid, i, j<span class="number">-1</span>);</span><br><span class="line">    infect(grid, i, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                infect(grid, i, j);                </span><br><span class="line">                nums++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4><blockquote><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p></blockquote><p>这个题目是典型的单调栈题目。单调栈分为单调递增栈和单调递减栈：</p><ol><li>单调递增栈，即栈中的元素都是单调不递减的。<ul><li>若新元素大于等于栈顶元素，则入栈</li><li>若新元素小于栈顶元素，则不断弹栈，直到新元素大于等于栈顶元素，将新元素入栈</li></ul></li><li>单调递减栈，即栈中的元素都是单调不递增的。<ul><li>若新元素小于等于栈顶元素，则入栈</li><li>若新元素大于栈顶元素，则不断弹栈，直到新元素小于等于栈顶元素，将新元素入栈</li></ul></li></ol><p>解决本问题需要借助<strong>单调递增栈+哨兵技巧</strong>。具体思路为：</p><p>首先，在栈中记录高度是不可以的，因为计算矩阵还需要计算宽度，而宽度是需要是由下标确定的。记录下标也可以从数组中得到对应的高度。因此应该记录的是下标。</p><p>其次，考虑找到第<code>i</code>个位置最大面积。是以<code>i</code>为中心，向左找第一个小于<code>heights[i]</code>的位置<code>left_i</code>；向右找第一个小于于<code>heights[i]</code>的位置<code>right_i</code>，那么对应的宽度为<code>right_i - left_i -1</code>，即最大面积为<code>heights[i] * (right_i - left_i -1)</code>，如下图所示：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/441ac778821dc26689b31466bced9f61ec241f092bf7e4f0f8699ef4fa3be1b2-1559826097853.png" alt="1559826097853.png"></p><p>这样的一个要求与单调递增栈的性质不谋而合。考虑新元素比栈顶元素严格小的情况，此时需要出栈</p><ol><li>新元素是出栈元素向后找第一个比其小的元素</li><li>新栈顶元素是出栈元素向前找第一个比其小的元素</li></ol><p>最后，这里需要借助哨兵技巧，这是因为：</p><ol><li>若输入是递增的话，则代码无法弹出计算面积，需要在<code>heights</code>数组后面加上一个<code>0</code>，这样就可以强迫栈内元素出栈计算面积了</li><li>考虑首元素计算时需要知道左边第一个小于它的元素位置，所以在<code>heights</code>数组前面加上一个<code>0</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 添加哨兵</span></span><br><span class="line">    heights.insert(heights.begin(), <span class="number">0</span>);</span><br><span class="line">    heights.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;heights.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 注意这个判断要用while，如果要用top必须让sta不等于空</span></span><br><span class="line">        <span class="keyword">while</span>(!sta.empty() &amp;&amp; heights[sta.top()]&gt;heights[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = heights[sta.top()];</span><br><span class="line">            sta.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i表示向后找第一个比其小的元素下标，sta.top()表示向前找第一个比其小的元素</span></span><br><span class="line">            ans = max(ans, (i-sta.top()<span class="number">-1</span>)*num);</span><br><span class="line">        &#125;</span><br><span class="line">        sta.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列常见题目"><a href="#队列常见题目" class="headerlink" title="队列常见题目"></a>队列常见题目</h3><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></h4><blockquote><p>使用栈实现队列的下列操作：</p><ul><li>push(x) — 将一个元素放入队列的尾部。</li><li>pop() — 从队列首部移除元素。</li><li>peek() — 返回队列首部的元素。</li><li>empty() — 返回队列是否为空。</li></ul></blockquote><p>使用两个栈，一个栈（<code>stackPush</code>）用于元素进栈，一个栈（<code>stackPop</code>）用于元素出栈；</p><p><code>push</code>的时候，直接<code>push</code>到<code>stackPush</code>栈中</p><p><code>pop()</code> 或者 <code>peek()</code> 的时候：</p><p>（1）如果 <code>stackPop</code> 里面有元素，直接从 <code>stackPop</code> 里弹出或者 <code>peek</code> 元素；</p><p>（2）如果 <code>stackPop</code> 里面没有元素，一次性将 <code>stackPush</code> 里面的所有元素倒入 <code>stackPop</code>。</p><p>为此，可以写一个 <code>shift</code> 辅助方法，一次性将 <code>stackPush</code> 里的元素倒入 <code>stackPop</code>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackPush;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackPop;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    stackPush.push(x);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackPop.empty()) &#123;  <span class="comment">// 只有当stackPop为空的时候，才会执行下面的转移操作</span></span><br><span class="line">        <span class="keyword">while</span>(!stackPush.empty()) &#123;</span><br><span class="line">            stackPop.push(stackPush.top());</span><br><span class="line">            stackPush.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shift();</span><br><span class="line">    <span class="keyword">int</span> val = stackPop.top();</span><br><span class="line">    stackPop.pop();</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shift();</span><br><span class="line">    <span class="keyword">return</span> stackPop.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stackPop.empty() &amp;&amp; stackPush.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a><a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 矩阵</a></h4><blockquote><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。</p></blockquote><p>广度优先搜索大概可以分为两种：</p><ol><li>对于<strong>「Tree 的 BFS」 （典型的「单源 BFS」）</strong>：首先把 root 节点入队，再一层一层遍历</li><li>对于<strong>「图 的 BFS」 （「多源 BFS」）</strong> 其实也是一样的，不过需要注意以下两点：<ul><li>Tree 只有 1 个 root，而图可以有多个源点，所以首先需要把多个源点都入队；</li><li>Tree 是有向的因此不需要标识是否访问过，而对于无向图来说，必须得标志是否访问过。并且为了防止某个节点多次入队，需要在其入队之前就将其设置成已访问！</li></ul></li></ol><p>那么对于本题而言，可以借助广度优先搜索完成，具体思路是首先将每个源点 0 入队，然后从各个 0 <strong>同时开始</strong>一圈一圈的向 1 扩散（每个 1 都是被离它最近的 0 扩散到的 ）。扩散的时候可以实时更新矩阵元素的值来几记录距离（即扩散的层次）并同时标志是否访问过。这里需要注意的是，需要首先将所有非 0 的元素统一设置为<code>-1</code>这个无效距离值来标记这个位置的<code>1</code>没有访问过。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="comment">// 先将所有的零入列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                q.push(make_pair(i, j));</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                matrix[i][j] = <span class="number">-1</span>; <span class="comment">// 表明没有被访问过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx&#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 开始由零一圈一圈的向外扩散</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front().first;</span><br><span class="line">        <span class="keyword">int</span> y = q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = x + dx[k];</span><br><span class="line">            <span class="keyword">int</span> j = y + dy[k];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;rows &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;cols &amp;&amp; matrix[i][j]==<span class="number">-1</span>) &#123;</span><br><span class="line">                matrix[i][j] = matrix[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.push(make_pair(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/150-ni-bo-lan-biao-da-shi-qiu-zhi-zhan-de-jing-dia/" target="_blank" rel="noopener">150. 逆波兰表达式求值:【栈的经典应用】详解</a><br><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/java-yi-dong-yi-jie-xiao-lu-gao-by-spirit-9-19/" target="_blank" rel="noopener">Java 易懂,易解,效率高</a><br><a href="https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/" target="_blank" rel="noopener">字符串解码（辅助栈法 / 递归法，清晰图解）</a><br><a href="https://leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode-solution/" target="_blank" rel="noopener">克隆图</a><br><a href="https://leetcode-cn.com/problems/number-of-islands/solution/number-of-islands-shen-du-you-xian-bian-li-dfs-or-/" target="_blank" rel="noopener">200. 岛屿数量（DFS / BFS）</a><br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/" target="_blank" rel="noopener">暴力解法、栈（单调栈、哨兵技巧）</a><br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/" target="_blank" rel="noopener">找两边第一个小于它的值</a><br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-by-ikaruga/" target="_blank" rel="noopener">【柱状图中最大的矩形】单调栈入门，使用单调栈快速寻找边界</a><br><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/shi-yong-liang-ge-zhan-yi-ge-zhuan-men-ru-dui-yi-g/" target="_blank" rel="noopener">负负得正，使用两个栈，一个专门入队，一个专门出队</a><br><a href="https://leetcode-cn.com/problems/01-matrix/solution/2chong-bfs-xiang-jie-dp-bi-xu-miao-dong-by-sweetie/" target="_blank" rel="noopener">2种BFS，详解DP， 🤷‍♀️必须秒懂！</a></p><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><h3 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h3><ol><li><p>移除最后一个1：<code>a = n&amp;(n-1);</code></p></li><li><p>获取最右端的一个1：<code>a = n&amp;(-n);</code></p></li><li><p>异或满足交换律且两个相同元素异或结果为0：<code>a=a^b^b=b^a^b;</code></p></li><li><p>整数的二进制编码：</p><ul><li>正数的编码为原码，如8的二进制编码为：00001000</li><li>负数的编码为最高位为1，其余位等于原码取反加1，如-8的二进制编码为：1…1111000</li></ul></li><li><p>两个数交换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b</span><br><span class="line">b = a^b</span><br><span class="line">a = a^b</span><br></pre></td></tr></table></figure></li><li><p><code>^</code>：相当于无进位的求和；<code>&amp;</code>相当于求每位的进位数。</p></li></ol><h3 id="常见题目-2"><a href="#常见题目-2" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h4><blockquote><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p></blockquote><p>这个题目比较简单，使用到了上面的规律3。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        num ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a></h4><blockquote><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p></blockquote><p>最简单的思路是统计数组元素二进制表达中每个位置1出现的次数。若某个位置1出现的次数不能被3整除，则说明目标元素的该位置为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num: nums) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">31</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num&amp;mask == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">        res = res&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        res += dp[i]%<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种思路是使用位运算符的性质。</p><p><strong>XOR异或运算符可以用来检测出现奇数次的位：</strong>0与任何数异或均为该数，而两个相同数异或结果为0。</p><script type="math/tex; mode=display">0 \land x=x \\x \land x = 0</script><p>以此类推，只有某个位置的数字出现奇数次时，该位的掩码才不为 0。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/xor.png" alt="img" style="zoom: 50%;"></p><p>因此，可以检测出出现一次的位和出现三次的位，但是要区分这两种情况。这个时候需要借助AND和NOT运算：为了区分出现一次的数字和出现三次的数字，使用两个位掩码：seen_once 和 seen_twice。思路是：</p><ul><li><p>仅当 seen_twice 未变时，改变 seen_once。</p></li><li><p>仅当 seen_once 未变时，改变seen_twice。</p></li></ul><p>可以看到，位掩码 <code>seen_once</code> 仅保留出现一次的数字，不保留出现三次的数字。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/three.png" alt="img" style="zoom:50%;"></p><p>对应的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seenOnce = <span class="number">0</span>, seenTwice = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">        seenOnce = ~seenTwice &amp; (seenOnce ^ num);</span><br><span class="line">        seenTwice = ~seenOnce &amp; (seenTwice ^ num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seenOnce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a></h4><blockquote><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p></blockquote><p>由异或性质可得，若将所有的数字进行异或，最终结果为只出现一次的那两个元素异或的结果。接下来考察其的某个非0位（比如最低非0位），那么只出现一次的两个数中，在这个位上一个为0，一个为1。由此可以将数组中的元素分成两部分，重新遍历，求两个异或值。参</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">        mask ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = mask &amp; (-mask);   <span class="comment">// 得到最右端的1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num1=<span class="number">0</span>, num2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num&amp;index)</span><br><span class="line">            num1 ^= num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num2 ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;num1, num2&#125;;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></h4><blockquote><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p></blockquote><p>该题考察的是上面的性质1。具体来说，每次都将最后一个1变成0，然后结果加1。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        n = n&amp;(n<span class="number">-1</span>);   <span class="comment">// 将最后一个为1变成0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></h4><blockquote><p>给定一个非负整数 <strong>num</strong>。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p></blockquote><p>这个题目可以使用动态规划来做。对于所有的数字，只有两类：</p><ol><li><p>奇数：二进制表示中，奇数一定比前面的那个偶数多一个1，因为多的就是最低位的 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例： </span><br><span class="line">0 = 0       1 = 1</span><br><span class="line">2 = 10      3 = 11</span><br></pre></td></tr></table></figure></li><li><p>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">2 = 10       4 = 100       8 = 1000</span><br><span class="line">3 = 11       6 = 110       12 = 1100</span><br></pre></td></tr></table></figure></li></ol><p>另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    result.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)   <span class="comment">// 奇数</span></span><br><span class="line">            result.push_back(result[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.push_back(result[i&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></h4><blockquote><p>颠倒给定的 32 位无符号整数的二进制位。比如输入<code>00000010100101000001111010011100</code>，输出<code>00111001011110000010100101000000</code>。</p></blockquote><p>依次颠倒即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--) &#123;</span><br><span class="line">        ans = ans&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        ans += n&amp;<span class="number">1</span>;</span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span>;   <span class="comment">// 右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. 数字范围按位与</a></h4><blockquote><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p></blockquote><p>按位相与的结果可以概括为：两个位的值都为1，按位与的结果才为 1，否则必为 0。可以得到两个结论：</p><ol><li>多个数字按位与，其结果中值为 1 的位绝对不会增加，只有可能减少。</li><li>多个数字按位与，其结果中值为 1 的位，在多个数字中的对应位必然也为 1。</li></ol><p>因题目传参用了有符号整型（实际上都是大于0的），忽略符号位后，还剩31位。从高位到低位依次编号为 0, 1, 2, 3, … 29, 30。首先来寻找一下n和m的二进制最长相同前缀，设这个前缀长度为x。因为<strong>加法只会影响连续的低位</strong>，所以 <code>[n,m]</code> 中的所有数字的长度为 x 的二进制前缀都是相等的。那也就导致，按位与的结果的长度x的二进制前缀也相同。</p><p>因为n和m的最长相同前缀长度为 x，此时 x 有两种情况：</p><ol><li>x = 31。即 n 和 m 完全相等。这种情况没啥好说的，答案就是 n&amp;m。这种情况太简单了，不做讨论。</li><li>0 &lt;= x &lt; 31。因为 n &gt;= m，所以 m 的第 x 位必然为 0，而 n 的第 x 为必然为 1。(不然就成 m &gt;= n 了)</li></ol><p>从 n 的后缀 0abcd… 累加到 m 的后缀 1hijk… 这个过程中，不管abcd…，hijk… 取值如何，必然要经过 10000…。0abcd… 和 10000… 使得答案中长度为 31-x 的后缀必然都为 0。</p><p>例如n 和 m 的二进制及最长前缀如下图所示，后缀 <strong>011 累加到 110 必然经过 100。011 和 100 保证了答案中长度为 3 的后缀必然均为 0。</strong></p><p><img src="/DataStructureAlgorithm/LeetCode总结/1598143339-uPRKJZ-image.png" alt="image.png" style="zoom:50%;"></p><p>所以对应的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 最高位开始</span></span><br><span class="line">    <span class="keyword">int</span> anw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(mask &gt; <span class="number">0</span> &amp;&amp; (m&amp;mask) == (n&amp;mask)) &#123; <span class="comment">//寻找相同前缀</span></span><br><span class="line">        anw |= m&amp;mask;  <span class="comment">// 将该位的结果使用或运算更新到anw的对应位置</span></span><br><span class="line">        mask &gt;&gt;= <span class="number">1</span>;  <span class="comment">// 判断下一个低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></h4><blockquote><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p></blockquote><p>这道题目如果采用暴力方法，肯定能够做出来，但是肯定会超时。如果采用滑窗的方法，那么何时收缩窗口，难以确定。所以该题目其实考察的是前缀和和位运算。</p><p>我们知道，一个数加上偶数不改变奇偶性，例如奇数+偶数=奇数，偶数+偶数=偶数。那么如果子串<code>[0,i]</code>奇偶性和<code>[0,j]</code>相同，那么子串<code>[i+1,j]</code>一定偶数。</p><p>只考虑每个元音的奇偶次数，可以用二进制进行记录：定义<code>aeiou</code> 分别对应二进制 <code>00001，00010，00100，01000，10000</code>。其中 0 表示对应元音出现了偶数次数，1 表示奇数。</p><p>从左到右遍历字符串，不断更新<code>dp</code>：<code>dp[pattern]</code> 的作用是用来记录当前索引值下对应的元音奇偶次数组合特征。例如：如果 pattern 为 10，也就是对应二进制<code>01010</code>，<code>dp[pattern] = 8</code>的意思为，当索引值为 8 的时候，e 和 o 都出现了奇数次，其它元音为偶数次。</p><p>根据异或运算规律，异或本身为 <code>0</code>，所以当重复出现偶数次，对应位变为 <code>0</code>，否则为 <code>1</code>。由这个规律可以断定，当再次出现这个 <code>pattern</code> 的时候，一定出现了偶数次。例如<code>pattern</code> 的值变化为 <code>31--&gt;30--&gt;28--&gt;29--&gt;31</code>，对应的二进制位 <code>[11111]--&gt;[11110]--&gt;[11100]--&gt;[11101]--&gt;[11111]</code>，此时对应的一个合理字符串变化为<code>aeiou</code> —&gt; <code>aeioua</code> —&gt;<code>aeiouae</code>—&gt;<code>aeiouaea</code>—&gt;<code>aeiouaeae</code>。由此可见，从 <code>aeiou</code> 到 <code>aeiouaeae</code> 这个过程中，多余出来的 <code>aeae</code> 为符合条件的字符串。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, pattern = <span class="number">0</span>, n = s.length();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(<span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="number">-1</span>);</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'e'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'i'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'o'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'u'</span>) &#123;</span><br><span class="line">            pattern ^= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (~pos[pattern]) &#123;</span><br><span class="line">            ans = max(ans, i + <span class="number">1</span> - pos[pattern]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pos[pattern] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetcode/" target="_blank" rel="noopener">只出现一次的数字 II</a><br><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/ju-hao-li-jie-de-wei-yun-suan-si-lu-by-time-limit/" target="_blank" rel="noopener">巨好理解的位运算思路</a><br><a href="https://blog.csdn.net/a435262767/article/details/104748036/" target="_blank" rel="noopener">【leetcode】5337. 每个元音包含偶数次的最长子字符串( Find the Longest Substring Containing Vowels in Even Counts)</a><br><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/xiang-xi-jie-shi-by-will_never_die/" target="_blank" rel="noopener">小学生解释</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找模板"><a href="#二分查找模板" class="headerlink" title="二分查找模板"></a>二分查找模板</h3><p><strong>适用情况：</strong>给一个有序数组和目标值，找到第一个/最后一个/任何一次出现的索引，如果没有返回-1。时间复杂度$O(logn)$。</p><p>常使用的模板主要有三个，可通过下面几道典型题目进行总结练习：</p><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p><strong>模板一：在排序数组中查找目标元素任何一次出现的位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot, left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        pivot = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[pivot] == target) </span><br><span class="line">            <span class="keyword">return</span> pivot;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[pivot]) </span><br><span class="line">            right = pivot - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            left = pivot + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板二：在排序数组中查找目标元素的第一个位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end-begin)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            begin = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span> || nums[begin] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板三：在排序数组中查找目标元素的第一个位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end-begin+<span class="number">1</span>)/<span class="number">2</span>;  <span class="comment">// 这个地方注意</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            begin = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span> || nums[begin] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用模板的关键点在于：</strong></p><ol><li>确定mid元素和目标元素的关系；进而得到缩小区间的方法</li><li>由缩小区间的方法，判断出来是第几个模板</li><li>如果不是第一个模板，则需要对最终元素进行特殊处理</li><li>对其余特殊情况进行特殊处理</li></ol><h3 id="常见题目-3"><a href="#常见题目-3" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h4><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p></blockquote><p>考虑插入的位置为pos，则成立的条件为：</p><script type="math/tex; mode=display">nums[pos-1] < target <= nums[pos]</script><p>这个条件可以转换为：<strong>在一个有序数组中找第一个大于等于 target 的下标。</strong>套用模板一可以得到下面代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></h4><blockquote><p>编写一个高效的算法来判断 $m \times n$ 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul></blockquote><p>这个问题其实是与<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a>思想一致，只是需要将一维数组的下标转换为二维数字的下标即可。根据模板一参考代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool searchMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int target) &#123;</span><br><span class="line">    int m = matrix.size();</span><br><span class="line">    if (m == 0) return false;</span><br><span class="line">    int n = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    // 二分查找</span><br><span class="line">    int left = 0, right = m * n - 1;</span><br><span class="line">    int pivotIdx, pivotElement;</span><br><span class="line">    while (left &lt;= right) &#123;</span><br><span class="line">        pivotIdx = (left + right) / 2;</span><br><span class="line">        pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">        if (target == pivotElement) </span><br><span class="line">            return true;</span><br><span class="line">        else if (target &lt; pivotElement) </span><br><span class="line">            right = pivotIdx - 1;</span><br><span class="line">        else </span><br><span class="line">            left = pivotIdx + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></h4><blockquote><p> 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p></blockquote><p>这个明显可以使用模板二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 当前版本不是错误的</span></span><br><span class="line">        <span class="keyword">if</span>(!isBadVersion(mid)) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。请找出其中最小的元素。你可以假设数组中不存在重复元素。</p></blockquote><p>旋转数据查找这类题目的解决关键在于：</p><ol><li>通过画图将问题模型抽象为下图：</li></ol><p><img src="/DataStructureAlgorithm/LeetCode总结/33834ed636a0fcd634b0b790cb6a096ac935b3a0d4159e32259638d19c73dd3d-捕获5.PNG" alt="捕获5.PNG" style="zoom:80%;"></p><ol><li>考虑和最后一个元素比较大小</li><li>考虑旋转点在0，也就是没有任何旋转的特殊情况</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end =  nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; nums[end])</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; nums[end])  <span class="comment">// 可以这样写，因为while条件，决定了cur!=end</span></span><br><span class="line">            end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。请找出其中最小的元素。注意数组中可能存在重复的元素。</p></blockquote><p>这个题目是上一道题目的区别在于，该题目的元素是可以重复的。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/4e410caf37485a65a95b6af228b564464099cf430ca695872125f0b13a147b19-捕获6.PNG" alt="捕获6.PNG"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end =  nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; nums[end])</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; nums[end])</span><br><span class="line">            end = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 无法判断mid的位置，可能位于最小值的前面，也可能后面。唯一可以确定的是最小值在end的左边</span></span><br><span class="line">            end--;   <span class="comment">// 跟上一题题解的区别</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 (不包含重复元素)</p></blockquote><p>这个题目和上两个题目不同点在于该题目是搜索特定元素，而前两个题目是找到最小元素值。</p><p>解题思路是：根据<code>arr[mid]</code>与<code>arr[end]</code>的值大小关系，划分出完全有序部分和部分有序部分。接着对于前半段有序的情况，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>；若是后半段有序，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[end]) &#123;  <span class="comment">// mid到end有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[end]) <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 从start到mid有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; target&gt;=nums[start])  <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h4><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。(包含重复元素)</p></blockquote><p>这个题目和上一个题目的不同点在于该题目中的元素是可以重复的。</p><p>解题思路是：根据<code>arr[mid]</code>与<code>arr[end]</code>的值大小关系，划分出完全有序部分和部分有序部分。接着对于前半段有序的情况，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>；若是后半段有序，判断出目标值是否在该有序的区间内，更新<code>start</code>和<code>end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[end]) &#123;  <span class="comment">// mid到end有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[end]) <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[end]) &#123;  <span class="comment">// 从start到mid有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; target&gt;=nums[start])  <span class="comment">// 目标值是否在有序区间内</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">// 无法判断哪一个是单调区间，极端情况下，退化为从end到start的遍历查找</span></span><br><span class="line">            end--;  <span class="comment">// 跟上一题题解的区别</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/tong-guo-hua-tu-geng-neng-shen-ke-li-jie-er-fen-fa/" target="_blank" rel="noopener">通过画图来深刻理解二分法</a><br><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/tong-guo-hua-tu-lai-shen-ke-li-jie-er-fen-fa-by-ch/" target="_blank" rel="noopener">通过画图来深刻理解二分法</a></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>原理可以参考<a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a>。</p><p>C++代码可以参考<a href="https://github.com/zdaiot/DataStructure-And-Algorithm" target="_blank" rel="noopener">DataStructure-And-Algorithm</a>。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划：是一种解决问 题的思想，大规模问题的结果，是由小规模问 题的结果运算得来的。动态规划可用递归来实现(Memorization Search)。递归只是一种程序的实现方式。</p><h3 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h3><p><strong>使用场景，需要满足几个条件：</strong></p><ol><li><p>满足以下条件之一：</p><p>求最大/最小值（Maximum/Minimum ）</p><p>求是否可行（Yes/No ）</p><p>求可行个数（Count(*) ）</p></li><li><p>最优子结构（如果不能利用子问题的最优解获得整个问题的最优解，那么这种问题就不具有最优子结构。简单来说后面阶段的状态要能够通过前面阶段的状态推导出来，对应的一定能写出来状态转移方程）</p></li><li><p>重复子问题</p></li><li><p>满足不能排序或者交换（Can not sort / swap ）</p></li></ol><p>如题：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a> 位置可以交换，所以不用动态规划</p><p><strong>四点要素：</strong></p><ol><li>状态 State：灵感，创造力，存储<strong>小规模问题</strong>的结果</li><li>方程 Function：状态之间的联系，怎么通过小的状态，来算大的状态</li><li>初始化 Intialization：最极限的小状态是什么，起点</li><li>答案 Answer：最大的那个状态是什么，终点</li></ol><blockquote><p>动态规划的tabel通常会为长度+1，<code>tabel[0]</code>的初始化很重要，通常可以简化很多操作。但是这样操作的时候记住遍历原数组的时候，下标减1。</p></blockquote><p><strong>常见四种类型：</strong></p><ol><li>矩阵类型（10%）</li><li>序列类型（40%）</li><li>两个序列类型（40%）</li><li>零钱和背包（10%）</li></ol><blockquote><p>贪心算法大多题目靠背答案，所以如果能用动态规划就尽量用动规，不用贪心算法。</p></blockquote><h3 id="矩阵类型（10-）"><a href="#矩阵类型（10-）" class="headerlink" title="矩阵类型（10%）"></a>矩阵类型（10%）</h3><h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h4><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p></blockquote><p>这是一个典型的动态规划问题。</p><ol><li>状态State：用<code>f[i][j]</code>表示从三角顶部走到位置<code>(i,j)</code>的最小路径和。这里的位置<code>(i,j)</code>表示第 i 行第 j 列（下标从0开始）</li><li>方程：若<code>j=0</code>，则<code>f[i][j]=f[i−1][0]+c[i][0]</code>；若<code>j=i</code>，则<code>f[i][j]=f[i−1][i−1]+c[i][i]</code>；<code>f[i][j] = min(f[i−1][j−1], f[i−1][j]) + c[i][j]</code>，<code>c[i][j]</code>表示位置<code>(i,j)</code>对应的元素值。需要注意第 <code>i</code> 行有 <code>i+1</code> 个元素，在计算状态转移的时候注意不要</li><li>初始化：<code>f[0][0]</code></li><li>答案：<code>max(f[n-1][:])</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];   <span class="comment">// j=0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];  <span class="comment">// j=i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *min_element(f[n - <span class="number">1</span>].begin(), f[n - <span class="number">1</span>].end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾方法一中的状态转移方程，可以发现<code>f[i][j]</code>只与<code>f[i-1][..]</code>有关，而与<code>f[i-2][..]</code>及之前的状态无关。可以使用两个长度为$n$的一位数组进行，根据$i$的奇偶性进行转移。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/image-20200910195806939.png" alt="image-20200910195806939"></p><p>优化空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> curr = i % <span class="number">2</span>;   <span class="comment">// 分奇偶性</span></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">1</span> - curr;</span><br><span class="line">        f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];  <span class="comment">// j=0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            f[curr][j] = min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle[i][i];  <span class="comment">// j=i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *min_element(f[(n - <span class="number">1</span>) % <span class="number">2</span>].begin(), f[(n - <span class="number">1</span>) % <span class="number">2</span>].end());  <span class="comment">// 注意这个结尾的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><blockquote><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。</p></blockquote><p>很明显这个题目是求最优解的；存在最优子结构；并且存在重复子问题（若采用回溯法，相同子路径会重复出现）。可以使用动态规划来求解。按照上面所说的四个要素：</p><ol><li>状态State：<code>f[x][y]</code>为从起点走到 x,y 的最短路径</li><li>方程：<code>f[x][y] = min(f[x-1][y], f[x][y-1]) + A[x][y]</code></li><li>初始化：<code>f[0][0] = A[0][0]、f[i][0] = sum(0,0 -&gt; i,0)、 f[0][i] = sum(0,0 -&gt; 0,i)</code></li><li>答案：<code>f[m-1][n-1]</code></li></ol><p>其实，仔细分析状态转移方程，发现<code>f[x][y]</code>只与上一行正上方元素和该行左边元素有关，因此可以省略掉<code>x</code>维，使用一维数组代替二维数组完成动态规划。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(grid[<span class="number">0</span>].size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)</span><br><span class="line">                vec[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                vec[j] = vec[j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                vec[j] = vec[j] + grid[i][j]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                vec[j] = min(vec[j], vec[j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><blockquote><p>一个机器人位于一个 m x n 网格的左上角。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。 问总共有多少条不同的路径？</p></blockquote><p>这个问题可以转换为，最多有多少条不同的路径，所以是一个求最优解的问题；存在最优子结构；假设<code>f[x][y]</code>表示从 x 到 y 最多有多少条路径，那么在求解<code>f[x+1][y]、f[x][y+1]</code>都需要求解<code>f[x][y]</code>，所以存在重复子问题，可以使用动态规划解决。按照上面所说的四个要素：</p><ol><li>定义State：<code>f[x][y]</code>表示从 x 到 y 最多有多少条路径</li><li>方程：<code>f[x][y]=f[x][y-1]+f[x-1][y]</code></li><li>初始化：<code>f[i][0]=f[0][i]=1</code></li><li>答案：<code>f[m-1][n-1]</code></li></ol><p>仔细分析状态转移方程，发现<code>f[x][y]</code>只与上一行正上方元素和该行左边元素有关，因此可以省略掉<code>x</code>维，使用一维数组代替二维数组完成动态规划。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;=<span class="number">0</span> || n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)</span><br><span class="line">                vec[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vec[j] = vec[j] + vec[j<span class="number">-1</span>];</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h4><blockquote><p>一个机器人位于一个 m x n 网格的左上角 。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p></blockquote><p>这个问题和上面问题的区别在于，这里加上了一个障碍物。使用动态规划，按照上面所说的四个要素：</p><ol><li>定义State：<code>f[x][y]</code>表示从 x 到 y 最多有多少条路径。若当前位置为障碍物，则<code>f[x][y]=0</code>，下面讨论没有障碍物时候的状态转移以及初始化</li><li>方程：<code>f[x][y]=f[x][y-1]+f[x-1][y]</code></li><li>初始化：<code>f[0][0]=1、f[i][0]=f[i-1][0]、f[0][i]=f[0][i]</code>，这个初始化因为障碍物存在，不能全部置为1</li><li>答案：<code>f[m-1][n-1]</code></li></ol><p>仔细分析状态转移方程，发现<code>f[x][y]</code>只与上一行正上方元素和该行左边元素有关，因此可以省略掉<code>x</code>维，使用一维数组代替二维数组完成动态规划。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(obstacleGrid[<span class="number">0</span>].size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;obstacleGrid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;obstacleGrid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">                vec[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)</span><br><span class="line">                    vec[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                    vec[j] = vec[j] + vec[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列类型（40-）"><a href="#序列类型（40-）" class="headerlink" title="序列类型（40%）"></a>序列类型（40%）</h3><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h4><blockquote><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><p>这应该是最简单的动态规划问题。按照上面四个要素进行分析：</p><ol><li>状态State：<code>f(x)</code>爬到台阶 x 有多少种方法</li><li>方程：<code>f(x)=f(x-1)+f(x-2)</code></li><li>初始化：<code>f(1)=1、f(2)=2</code></li><li>答案：<code>f(n)</code></li></ol><p>分析状态转移方程，发现<code>f(x)</code>只与前两个状态有关，所以可以用两个变量保存这两个状态即可。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> vec[n<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = vec[<span class="number">0</span>] + vec[<span class="number">1</span>];</span><br><span class="line">        vec[<span class="number">0</span>] = vec[<span class="number">1</span>];</span><br><span class="line">        vec[<span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h4><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。</p></blockquote><p>这个题目有两种解法。</p><p>第一种方法是借助<strong>贪心算法</strong>，使用一个变量<code>k</code>记录能够跳到的<strong>最远元素的下标</strong>（从0开始）。依次遍历数组的元素，若<code>k</code>大于等于当前下标，证明可以跳到该元素，然后看是否需要更新<code>k</code>以及是否已经可以跳到最后一个位置了；若<code>k</code>小于当前下标，则证明无法跳到该元素，返回<code>false</code>。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= i) &#123;</span><br><span class="line">            k = max(k, nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= nums.size()<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法是借助动态规划，该方法求解过程并没有贪心简单。还是按照上面四个要素进行分析：</p><ol><li>状态State：<code>f[i]</code>表示 i 下标能不能到达</li><li>方程：<code>f[i] = OR(f[j],j&lt;i&amp;&amp;j能跳到i)</code> 判断之前所有的点最后一跳是否<strong>存在</strong>能跳到当前点的（<code>OR</code>表示存在）。</li><li>初始化：<code>f(0)=1</code></li><li>答案：<code>f(n-1)</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(n, <span class="literal">false</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; j+nums[j]&gt;=i) &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></h4><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p></blockquote><p>跟上一道题目一样，这也是典型的<strong>贪心算法，每次都是贪心的选择最远距离，通过局部最优解得到全局最优解。</strong>这里的贪心有两种方法。</p><p><strong>第一种方法是反向查找出发位置。</strong>有多个位置通过跳跃可以达到最后一个位置，直观上，可以贪心地选择距离最后一个位置最远的那个位置，可以从左到右遍历数组，选择第一个满足要求的位置。找到最后一步跳跃前所在的位置之后，继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。这种思路需要遍历多遍（时间复杂度为$O(n^2)$），C++会超时，这里给出Java版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> position = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                position = i;</span><br><span class="line">                steps++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种方法是正向查找可达到的最大位置。</strong>假设第一个元素最远可以跳 j 个位置，将从这 j 个位置开始能够跳到的最远距离记做 sum；使用 end 变量（初始化为0）记录第一步可以跳的最远距离；依次遍历所有位置，若当前位置下标大于 end，则证明需要再跳一步，此时需要更新end和step。另外，我们不会遍历到最后一个元素，因为若刚好<code>end=n-1</code>，那么遍历到最后一个元素时，会凭空的多一个step。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++) &#123;  <span class="comment">// 注意没有遍历到最后一个元素</span></span><br><span class="line">        sum = max(sum, i+nums[i]); <span class="comment">// 用于记录该step能跃过的所有节点中，下一个能跳过的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(i == end) &#123;  <span class="comment">// 需要再跳，才有可能到最终元素，注意更新end</span></span><br><span class="line">            end = sum;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><blockquote><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p></blockquote><p>对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。根据这样的思路，可以使用动态规划的方法解决本题。</p><ol><li>状态State：定义<code>dp[i][j]</code>为<code>s[i, j]</code>是否为回文子串</li><li>方程：<code>dp[i][j] = dp[i+1][j-1] and (s[i]==s[j])</code></li><li>初始化：<code>dp[i][i]=1、dp[i][j]=s[i][j] if j-i=1</code></li><li>答案：若<code>dp[i][j]=1</code>，则判断是否需要更新最终的最长回文子串答案</li></ol><p><strong>这道题需要注意的是<code>dp[i][j]</code>的更新次序</strong>，参考代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;n; l++) &#123;  <span class="comment">// j-i的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+l&lt;n; i++) &#123; <span class="comment">// 开始坐标，注意停止条件</span></span><br><span class="line">            <span class="keyword">int</span> j = i+l; <span class="comment">// 结束坐标</span></span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = s[i]==s[j];</span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i]==s[j]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; l+<span class="number">1</span>&gt;ans.size())</span><br><span class="line">                ans = s.substr(i, l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. 分割回文串 II</a></h4><blockquote><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。返回符合要求的最少分割次数。</p></blockquote><ol><li>状态State：<code>dp[i]</code>表示前缀子串 <code>s[0,i]</code> 分割成若干个回文子串所需要最小分割次数</li><li>方程：若<code>s[0,i]</code>本身为回文串，则<code>d[i]=0</code>；否则<code>dp[i] = min([dp[j] + 1 for j in range(i) if s[j+1, i] 是回文])</code></li><li>初始化：<code>dp[0]=0</code></li><li>答案：<code>s[n-1]</code></li></ol><p>可以看到这个问题其实包含了<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a>子问题，与之相似的<a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a>却是一个回溯法解决的题目。该题目的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;n; l++) &#123;    <span class="comment">// j-i的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+l&lt;n; i++) &#123;   <span class="comment">// 开始坐标，注意停止条件</span></span><br><span class="line">            <span class="keyword">int</span> j = i + l;   <span class="comment">// 结束坐标</span></span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = s[i]==s[j];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i]==s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        vec[i] = i;  <span class="comment">// 初始化最大所需切割次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;  <span class="comment">// 若s[o,i]为回文串</span></span><br><span class="line">            vec[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j+<span class="number">1</span>][i] == <span class="number">1</span>)</span><br><span class="line">                vec[i] = min(vec[i], vec[j] + <span class="number">1</span>);  <span class="comment">// 找到最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h4><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。子序列下标可以不连续。</p></blockquote><ol><li>状态State：<code>f[i]</code>表示从0开始到 i 结尾的最长序列长度</li><li>方程：<code>f[i] = max(f[j])+1 ,a[j]&lt;a[i] and j&lt;i</code></li><li>初始化：<code>f[i]=1</code></li><li>答案：<code>max(f[0]...f[n-1])</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 特殊输入测试</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                dp[i] = max(dp[j]+<span class="number">1</span>, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h4><blockquote><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p></blockquote><ol><li>状态State：<code>f[i]</code>表示前 i 个字符是否可以被划分</li><li>方程：<code>f[i] = f[j] &amp;&amp; s[j~i-1] in wordDict, j&lt;i</code>（注意下标）</li><li>初始化：<code>f[0]=true</code></li><li>答案：<code>f[n]</code></li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> wordDictSet = <span class="built_in">unordered_set</span> &lt;<span class="built_in">string</span>&gt; ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word: wordDict) &#123;</span><br><span class="line">        wordDictSet.insert(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dp = <span class="built_in">vector</span> &lt;<span class="keyword">bool</span>&gt; (s.size() + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) &#123;   <span class="comment">// 注意下标</span></span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个序列类型（40-）"><a href="#两个序列类型（40-）" class="headerlink" title="两个序列类型（40%）"></a>两个序列类型（40%）</h3><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h4><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p></blockquote><ol><li>状态State：<code>dp[i][j]</code>为text1前 i 个和text2前 j 个字符最长公共子序列</li><li>方程：若<code>text1[i-1]=text2[j-1]</code>，则<code>dp[i][j]=dp[i-1][j-1]+1</code>；否则<code>dp[i][j]=max(dp[i-1][j], dp[i][j-1])</code></li><li>初始化：<code>dp[0][i]=dp[i][0]=0</code></li><li>答案：<code>dp[m][n]</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = text1.size();</span><br><span class="line">    <span class="keyword">int</span> length2 = text2.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(length1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(length2+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=length2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h4><blockquote><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p></blockquote><ol><li><p>状态State：<code>dp[i][j]</code>为word1前 i 个字符编辑为word2前 j 个字符最少需要多少次操作</p></li><li><p>方程：若<code>word1[i-1]==word2[j-1]</code>，则<code>dp[i][j]=dp[i-1][j-1]</code>；否则<code>dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code>。</p><p>对<code>dp[i-1][j-1]</code>表示替换操作，<code>dp[i-1][j]</code>表示删除操作，<code>dp[i][j-1]</code>表示插入操作的补充理解：以 word1 为 “horse”，word2 为 “ros”，求<code>dp[5][3]</code> 为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：</p><ul><li><code>dp[i-1][j-1]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符<code>word1[4]</code>（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，<code>word2[2]</code>）</li><li><code>dp[i][j-1]</code>，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</li><li><code>dp[i-1][j]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</li></ul></li><li><p>初始化：<code>dp[0][i] = i、dp[i][0] = i;</code></p></li><li>答案：<code>dp[m][n]</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = word1.size();</span><br><span class="line">    <span class="keyword">int</span> length2 = word2.size();</span><br><span class="line">    <span class="keyword">if</span>(length1*length2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> word1.size()+word2.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(length1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(length2+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length2; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=length1; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=length2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> minV = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                minV = min(minV, dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp[i][j] = minV + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零钱和背包（10-）"><a href="#零钱和背包（10-）" class="headerlink" title="零钱和背包（10%）"></a>零钱和背包（10%）</h3><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h4><blockquote><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p></blockquote><ol><li>状态State：<code>dp[i]</code>组成总金额为 i 所需的最少硬币个数</li><li>方程：<code>dp[i]=min(dp[i-coins[j]]+1)</code></li><li>初始化：<code>dp[0]=0、dp[i]=amount+1(i&gt;0)</code></li><li>答案：若<code>dp[amount]==amount+1</code>，则返回<code>-1</code>；否则返回<code>dp[amount]</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>, amount+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;coins.size(); j++)</span><br><span class="line">            <span class="keyword">if</span>(i-coins[j] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i] = min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="92-背包问题"><a href="#92-背包问题" class="headerlink" title="92. 背包问题"></a><a href="https://www.lintcode.com/problem/backpack/description" target="_blank" rel="noopener">92. 背包问题</a></h4><blockquote><p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]。你不可以将物品进行切割。</p></blockquote><ol><li>状态State：<code>dp[i][j]</code>表示前<code>i</code>个物品，能不能填满容量为<code>j</code>的背包。</li><li>方程：<code>dp[i][j] = dp[i-1][j] OR dp[i-1][j-A[i-1]]</code>。注意<code>i</code>表示前<code>i</code>个物品，换算到下标时为<code>i-1</code></li><li>初始化：<code>dp[0][0]=True</code></li><li>答案：<code>j if dp[m-1][j]=1 else -1 for j in range(m, -1, -1)</code></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j-A[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[n][j])</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，本题所用的存储空间可以优化。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=A[i<span class="number">-1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-A[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[j])</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">01背包问题</a></h4><blockquote><p>有 <em>N</em> 件物品和一个容量是 <em>V</em> 的背包。每件物品只能使用一次。第 <em>i</em> 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输入第一行N、V分别表示物品数量和背包容积；接下来有N行，每行两个整数$v_i,w_i$，分别表示第$i$个物品的体积和价值。输出最大价值。</p></blockquote><p>这个问题是典型的动态规划问题。最大的特点是每一件物品只能使用一次。</p><ol><li>状态State：定义<code>f[i][j]</code>为所有选法集合中，只从前<code>i</code>个物品中选，并且总体积 $\leq j$ 的选法集合，它的值是这个集合中每一个选法的最大值。</li><li>方程：<code>f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i] if j&gt;=v[i])</code>。其中<code>f[i-1][j]</code>表示不选第<code>i</code>个物品的集合中的最大值；<code>f[i-1][j-v[i]]+w[i]</code>表示选第<code>i</code>个物品的集合中的最大值。</li><li>初始化：<code>f[0][0]=0</code></li><li>答案：<code>f[N][V]</code></li></ol><p>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">// n goods</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v)</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化之后的代码实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">// n goods</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=v; j--) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">完全背包问题</a></h4><blockquote><p>有 <em>N</em> 件物品和一个容量是 <em>V</em> 的背包。每件物品都有无限件可用。第 <em>i</em> 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输入第一行N、V分别表示物品数量和背包容积；接下来有N行，每行两个整数$v_i,w_i$，分别表示第$i$个物品的体积和价值。输出最大价值。</p></blockquote><p>该题目和上一个题目区别在于本题的每件物品可以重复使用。同理可以采用动态规划解决该问题。</p><ol><li>状态State：定义<code>f[i][j]</code>为所有选法集合中，只从前<code>i</code>个物品中选，并且总体积 $\leq j$ 的选法集合，它的值是这个集合中每一个选法的最大值。</li><li>方程：<code>f[i][j] = max(f[i-1][j], f[i-1][j-v[i]*k]+w[i]*k if j&gt;=v[i]*k)</code>。其中<code>f[i-1][j]</code>表示不选第 i 个物品的集合中的最大值；<code>f[i-1][j-v[i]*k]+w[i]*k</code>表示选第<code>i</code>个物品<code>k</code>次的集合中的最大值。</li><li>初始化：<code>f[0][0]=0</code></li><li>答案：<code>f[N][V]</code></li></ol><p>上一道题中，逆序遍历体积是为了保证更新当前状态时，用到的状态是上一轮的状态，保证每个物品只有一次或零次；在这里，因为每个物品可以取任意多次，所以不再强求用上一轮的状态，即本轮放过的物品，在后面还可以再放，所以可以顺序遍历体积。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v; j&lt;=m; j++) &#123;</span><br><span class="line">            <span class="comment">//dp[j] = max(dp[j], dp[j-v]+w);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=j/v; k++)</span><br><span class="line">               dp[j] = max(dp[j], dp[j-k*v]+w*k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/lanchunhui/article/details/52480106" target="_blank" rel="noopener">最优子结构（optimal substructure）</a><br><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/dong-tai-gui-hua-by-liweiwei1419-2/" target="_blank" rel="noopener">动态规划（Java、Python）</a><br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">动态规划、中心扩散、Manacher 算法</a><br><a href="https://blog.csdn.net/ZK_J1994/article/details/72809260" target="_blank" rel="noopener">Python列表解析配合if else</a><br><a href="https://www.acwing.com/solution/content/3986/" target="_blank" rel="noopener">AcWing 3. 完全背包问题—一维动态规划转移过程模拟 </a></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法一般用来解决需要 “找到要做某事的最小数量” 或 “找到在某些情况下适合的最大物品数量” 的问题，且提供的是无序的输入。</p><h2 id="递归思维"><a href="#递归思维" class="headerlink" title="递归思维"></a>递归思维</h2><h3 id="理论-3"><a href="#理论-3" class="headerlink" title="理论"></a>理论</h3><p>递归是一种应用非常广泛的算法（或者编程技巧）。递归分为两个步骤：<strong>去的过程叫“递”，回来的过程叫“归”</strong>。</p><p>当问题满足如下三个条件时，则适合使用递归解决：</p><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了<strong>数据规模</strong>不同，求解思路完全一样</li><li>存在递归终止条件。另外，还需要注意的是，要通过几个边界值例子，看终止条件是否足够。</li></ol><p>写递归代码有两个最关键的步骤：</p><ol><li>写出递推公式</li><li>找到终止条件</li></ol><p>理解递归代码需要把握住如下几点：</p><ol><li>如果试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区</li><li>如果一个问题 A 可以分解为若干子问题 B、C、D，<strong>可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，</strong>理解起来就简单多了。</li><li>因此，<strong>编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></li></ol><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。<strong>所有的递归代码都可以改为迭代循环的非递归写法。</strong></p><h3 id="常见题目-4"><a href="#常见题目-4" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h4><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p></blockquote><p>这道题可以采用递归的方式解决。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseStringCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    swap(s[start], s[end]);</span><br><span class="line">    reverseStringCore(s, start+<span class="number">1</span>, end<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    reverseStringCore(s, <span class="number">0</span>, s.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以采用循环以及交换元素的方式解决，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, end=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end) &#123;</span><br><span class="line">        swap(s[start], s[end]);</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h4><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p></blockquote><p>可以采用递归方法解决这个问题，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairsCore</span><span class="params">(ListNode* first, ListNode* two)</span> </span>&#123;</span><br><span class="line">    ListNode* third = two-&gt;next;</span><br><span class="line">    two-&gt;next = first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(third &amp;&amp; third-&gt;next)</span><br><span class="line">        first-&gt;next = swapPairsCore(third, third-&gt;next);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        first-&gt;next = third;</span><br><span class="line">    <span class="keyword">return</span> two;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> swapPairsCore(head, head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II</a></h4><blockquote><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p></blockquote><p>根据二叉树的性质，若根节点的值为$i$，则左子树的范围为$1\sim i-1$，右子树的范围为$i+1 \sim n$，且左子树和右子树也同样为二叉搜索树，因此可以递归的解决这个问题。</p><p>定义<code>generateTrees(start, end)</code>函数表示当前值的集合<code>[start,end]</code>，返回序列<code>[start,end]</code>生成的所有可行的二叉搜索树（使用<code>vector</code>表示，每个值均为可行二叉搜索树的根节点）。考虑枚举<code>[start,end]</code>中的值<code>i</code>为当前二叉搜索树的根，那么序列划分为了<code>[start,i−1]</code>和<code>[i+1,end]</code>两部分。递归调用这两部分，即<code>generateTrees(start, i - 1)</code>和<code>generateTrees(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，那么最后一步只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; generateTreesCore(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">    <span class="comment">// 某棵树终止</span></span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++) &#123;  <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; leftV = generateTreesCore(start, i<span class="number">-1</span>);  <span class="comment">// 获得所有可行的左子树集合（存储根节点）</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; rightV = generateTreesCore(i+<span class="number">1</span>, end);   <span class="comment">// 获得所有可行的右子树集合（存储根节点）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> nodeL:leftV) &#123;   <span class="comment">// 遍历每一个可行左子树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> nodeR:rightV) &#123;  <span class="comment">// 遍历每一个可行右子树</span></span><br><span class="line">                TreeNode* node = <span class="keyword">new</span> TreeNode(i);   <span class="comment">// 接到根节点上，形成一棵树，放到本次迭代的vecotr中</span></span><br><span class="line">                node-&gt;left = nodeL;</span><br><span class="line">                node-&gt;right = nodeR;</span><br><span class="line">                res.push_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是所有可行搜索树的根节点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    res = generateTreesCore(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h4><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p></blockquote><p>这道题其实可以用循环来做，但是一般来说，这是一道很典型的递归问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span> || N==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fib(N<span class="number">-1</span>) + fib(N<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口思想"><a href="#滑动窗口思想" class="headerlink" title="滑动窗口思想"></a>滑动窗口思想</h2><h3 id="理论-4"><a href="#理论-4" class="headerlink" title="理论"></a>理论</h3><p>这类题目更像是双指针的升级版，滑动窗口的核心是维护一个窗口集，根据窗口集来进行处理。核心步骤包括：</p><ol><li>右指针右移，窗口数据更新（注意移动的范围）</li><li>判断窗口是否需要收缩</li><li>左指针右移，窗口数据更新</li><li>根据题意计算结果</li></ol><h3 id="常见题目-5"><a href="#常见题目-5" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><blockquote><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p></blockquote><p>很明显，这个题目需要用滑动窗口去做。在 S 上滑动窗口，通过移动右指针不断扩张窗口。当窗口包含 T 全部所需的字符后，如果能收缩，就收缩窗口得到最小窗口。而判断是否包含 T 所需的全部字符，需要借助哈希表记录所有字符以及出现的位置。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; need, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p:need) &#123;  <span class="comment">// 注意必须是need循环，window可能字符并不全</span></span><br><span class="line">        <span class="keyword">if</span>(window[p.first] &lt; p.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;  <span class="comment">// need 存储 t 每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t.size(); i++)</span><br><span class="line">        need[t[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;  <span class="comment">// 注意这个初始值，是为了使用++right，而不是right++，保证统计windows时下标与need.find一致</span></span><br><span class="line">    <span class="keyword">int</span> ansL=<span class="number">-1</span>, len=INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span>&lt;<span class="keyword">int</span>(s.size())) &#123;  <span class="comment">// 注意这个right的取值</span></span><br><span class="line">        <span class="keyword">if</span>(need.find(s[++right]) != need.end()) &#123;  <span class="comment">// 右移，注意window只存储了t中出现的字符</span></span><br><span class="line">            window[s[right]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(judge(need, window) &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; len) &#123;   <span class="comment">// 记录最小字符子串的开始坐标和长度，上面用的是++right，所以这里要加1</span></span><br><span class="line">                len = right-left+<span class="number">1</span>;</span><br><span class="line">                ansL = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need.find(s[left]) != need.end())   <span class="comment">// 左移，注意window只存储了t中出现的字符</span></span><br><span class="line">                window[s[left]]--;</span><br><span class="line"></span><br><span class="line">            left++;  <span class="comment">// 注意这个left的位置，不要放在上面的if条件里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansL&gt;<span class="number">-1</span>?s.substr(ansL, len):<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的空间复杂度可以优化，使用一个哈希表，哈希表的每个字符对应的值含义为：</p><ol><li>若大于0，则滑动窗口中该字符还应该出现几次</li><li>若等于0，则滑动窗口中该字符次数的次数正好</li><li>若小于0，则滑动窗口中该字符多出现了几次</li></ol><p>对应的若哈希表中的所有值均小于等于0，则应该缩小窗口，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; need)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p:need) &#123;  <span class="comment">// 注意必须是need循环，window可能字符并不全</span></span><br><span class="line">        <span class="keyword">if</span>(p.second &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;  <span class="comment">// need 存储 t 每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t.size(); i++)</span><br><span class="line">        need[t[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;  <span class="comment">// 注意这个初始值，是为了使用++right，而不是right++，保证统计windows时下标与need.find一致</span></span><br><span class="line">    <span class="keyword">int</span> ansL=<span class="number">-1</span>, len=INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span>&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.find(s[++right]) != need.end()) &#123;</span><br><span class="line">            need[s[right]]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(judge(need) &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; len) &#123;   <span class="comment">// 记录最小字符子串的开始坐标和长度</span></span><br><span class="line">                len = right-left+<span class="number">1</span>;</span><br><span class="line">                ansL = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need.find(s[left]) != need.end())   <span class="comment">// 左移</span></span><br><span class="line">                need[s[left]]++;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansL&gt;<span class="number">-1</span>?s.substr(ansL, len):<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></h4><blockquote><p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。</p></blockquote><p>这道题乍一看比上一道题要难，该题要判断是否包含 s1 的排列，而上一道题是判断包含 T 所有字符的最小子串。其实包含 s1 的排列和包含 T 所有字符只是两个说法而已，实际在用的时候都只需要使用一个哈希表记录出现过的字符以及出现的次数即可。</p><p>另外，该题和上一道题的区别在于本题的滑动窗口大小是固定的。有两个思路可以解决这个问题。</p><p>第一个思路是使用上一道题的模板，使用一个match变量记录当前滑动窗口中有多少个字符满足了出现的次数。滑动窗口的缩小条件为当前窗口的大小大于等于 s1 的长度，注意在移动左右指针的时候，更新window窗口以及match变量的值。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; need, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p: need) &#123;  <span class="comment">// 注意必须是need循环，window可能字符并不全</span></span><br><span class="line">        <span class="keyword">if</span>(window[p.first] &lt; p.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: s1)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;  <span class="comment">// 注意这个初始值，是为了使用++right，而不是right++，保证统计windows时下标与need.find一致</span></span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span> &lt; <span class="keyword">int</span>(s2.size())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.find(s2[++right]) != need.end()) &#123;   <span class="comment">// 移动右指针的时候更新 window 和 match的值</span></span><br><span class="line">            window[s2[right]]++;</span><br><span class="line">            <span class="keyword">if</span>(window[s2[right]] == need[s2[right]]) &#123;</span><br><span class="line">                match++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right-left+<span class="number">1</span> &gt;= s1.size()) &#123;  <span class="comment">// 目标框大小固定，当超过时，缩小框</span></span><br><span class="line">            <span class="keyword">if</span>(match == need.size())  <span class="comment">// 包含了 s1 的全排列</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(need.find(s2[left]) != need.end()) &#123;  <span class="comment">// 移动左指针的时候更新 window 和 match的值</span></span><br><span class="line">                <span class="keyword">if</span>(window[s2[left]] == need[s2[left]])</span><br><span class="line">                    match--;</span><br><span class="line">                window[s2[left]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;  <span class="comment">// 注意这个left的位置，不要放在上面的if条件里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个思路是只使用一个哈希表，哈希表的每个字符对应的值含义为：</p><ol><li>若大于0，则滑动窗口中该字符还应该出现几次</li><li>若等于0，则滑动窗口中该字符次数的次数正好</li><li>若小于0，则滑动窗口中该字符多出现了几次</li></ol><p>对应的代码为（该代码是比较标准的固定窗口大小的模板）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: s1)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s2[right++];</span><br><span class="line">        need[c]--;</span><br><span class="line">        <span class="keyword">while</span>(need[c]&lt;<span class="number">0</span> &amp;&amp; left&lt;=right) &#123;  <span class="comment">// 该字符多出现了，收缩窗口</span></span><br><span class="line">            need[s2[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right-left == s1.size())  <span class="comment">// 注意上面的right++了，所以这里不需要加1了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 当满足此条件是，一定是need中所有的值均为0，否则的话一定会有小于0的值，执行上述while循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><blockquote><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序</li></ul></blockquote><p>该题目可以使用滑动窗口的思想解决，并且由题意可知这是一个固定大小窗口的题目。因此窗口收缩的判断条件为当前窗口的大小大于等于 p 的长度。另外，在收缩窗口的时候，注意判断当前窗口是否满足要求。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: p)</span><br><span class="line">        need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right+<span class="number">1</span>&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.find(s[++right]) != need.end()) &#123;</span><br><span class="line">            window[s[right]]++;</span><br><span class="line">            <span class="keyword">if</span>(window[s[right]] == need[s[right]])</span><br><span class="line">                match++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left+<span class="number">1</span> &gt;= p.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(match == need.size()) &#123;</span><br><span class="line">                result.push_back(left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(need.find(s[left]) != need.end()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(need[s[left]] == window[s[left]])</span><br><span class="line">                    match--;</span><br><span class="line">                window[s[left]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考上一个题目，可以简化为使用一个哈希表解决。另外，上一题目是比较标准的固定窗口大小的模板，套用之后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: p)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">while</span>(right&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        need[c]--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(need[c]&lt;<span class="number">0</span> &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            need[s[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left == p.size())</span><br><span class="line">            result.push_back(left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p></blockquote><p>这个题目明显可以使用滑窗思想解决。使用一个哈希表记录每个字符出现了多少次，窗口收缩条件为若当前字符出现了多次，则收缩左指针直到当前字符出现一次。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;<span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        record[c]++;</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span>(record[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            record[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = max(result, right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>滑动窗口的模板可以分为两个：</p><ol><li>一般模板</li><li>固定滑窗大小的模板</li></ol><p>第二个模板代码更加简洁，并且空间时间复杂度较低。若遇到固定窗口大小的题目，优先使用第二个模板。</p><h3 id="参考-6"><a href="#参考-6" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/" target="_blank" rel="noopener">不同的二叉搜索树 II</a><br><a href="https://leetcode-cn.com/problems/permutation-in-string/solution/hua-dong-chuang-kou-by-muyids-4/" target="_blank" rel="noopener">滑动窗口(十行代码)</a></p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="理论-5"><a href="#理论-5" class="headerlink" title="理论"></a>理论</h3><ol><li><p>定义：</p><ul><li>每个节点中的值必须大于（或等于）存储在其左侧子树中的<strong>任何值。</strong></li><li>每个节点中的值必须小于（或等于）存储在其右子树中的<strong>任何值。</strong></li></ul></li><li><p>二叉搜索树的<strong>中序遍历是递增序列</strong>，这个性质经常能够使用到。</p></li><li><p>二叉搜索树经常使用<strong>递归</strong>方法实现。</p></li><li>在平均情况下，能够在 $\mathcal{O}(\log N)$ 的时间内完成搜索和插入元素。</li></ol><h3 id="常见题目-6"><a href="#常见题目-6" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p></blockquote><p>这个题目的难点在于，一个节点的左子树节点值必须都小于该节点，而该节点的右子树节点值必须大于该节点。因此递归过程中需要使用两个变量在递归的时候记录端点值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBSTCore</span><span class="params">(TreeNode* node, <span class="keyword">long</span> <span class="keyword">long</span> minV, <span class="keyword">long</span> <span class="keyword">long</span> maxV)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;val&lt;=minV || node-&gt;val&gt;=maxV) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValidBSTCore(node-&gt;left, minV, node-&gt;val) &amp;&amp; isValidBSTCore(node-&gt;right, node-&gt;val, maxV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> minV = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxV = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBSTCore(root, minV, maxV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h4><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p></blockquote><p>考虑最简单的插入方式。将插入的节点作为叶子节点插入。插入到哪个叶节点可以遵循如下原则：</p><ol><li>若<code>val &gt; node.val</code>，且右子树为空，则插入到右子树</li><li>若<code>val &lt; node.val</code>，且左子树为空，则插入到左子树</li></ol><p>基于循环方式的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    TreeNode* newNode = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    </span><br><span class="line">    TreeNode* node = root;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &lt; val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;right = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;left = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java版本的基于递归的方式参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert into the right subtree</span></span><br><span class="line">    <span class="keyword">if</span> (val &gt; root.val) root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="comment">// insert into the left subtree</span></span><br><span class="line">    <span class="keyword">else</span> root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h4><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p></blockquote><p>该题的考察点在于二叉搜索树的定义。</p><p>首先介绍一下二叉搜索树前驱节点、后继节点的概念：</p><ol><li>前驱节点：比当前节点小的最大节点，即中序遍历序列的下一个节点。</li><li>后继节点：比当前节点大的最小节点，即中序遍历序列的前一个节点。</li></ol><p>然后，还需要注意几个关键点：</p><pre><code>1. 对于删除节点，只需要更改当前节点的值即可，不需要调整左右指针   2. 删除节点的时候只需要让当前节点值等于NULL即可   3. C++在函数内部会更改形参的值，对于实际调用或者递归的时候，要考虑形参和实参的关系</code></pre><p>解决问题的思路为：</p><ol><li>若删除的是叶子节点，直接删除即可</li><li>如果含有右节点，则将后继节点的值赋值给当前节点，递归删除后继节点</li><li>如果含有左节点，则将前驱节点的值赋值给当前节点，递归删除前驱节点</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到前驱节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">findPre</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    node = node-&gt;left;</span><br><span class="line">    <span class="keyword">while</span>(node-&gt;right) <span class="comment">// 注意这个判断条件，可以返回不为NULL的结果</span></span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到后驱节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">findPost</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    node = node-&gt;right;</span><br><span class="line">    <span class="keyword">while</span>(node-&gt;left)</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; key) </span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);  <span class="comment">// 注意调用递归的时候更新递归子函数的更改的结果</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; key)</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) &#123;  <span class="comment">// 删除的是叶子节点</span></span><br><span class="line">            <span class="comment">//delete root;  // new对应delete，new[]对应delete[]</span></span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) &#123;  <span class="comment">// 如果含有右子树</span></span><br><span class="line">            TreeNode* post = findPost(root);</span><br><span class="line">            root-&gt;val = post-&gt;val;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, root-&gt;val); <span class="comment">// 必须采用递归的方式，不能直接置post=NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode* pre = findPre(root);</span><br><span class="line">            root-&gt;val = pre-&gt;val;</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下为什么第32行需要采用递归的方式删除。</p><p>首先，从特殊例子来看，如下图所示，节点33的前驱节点为25，后继节点为34，这两个节点均不是叶子节点，所以需要递归删除。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/309271bd1f94c57fd4e19f5eee624dd2ad3ef8e4d5a3b6eca5556e9f2e43a3bc-file_1576477912310" alt="在这里插入图片描述" style="zoom:40%;"></p><p>其次，从语法上来看：</p><ol><li>函数内部若直接将<code>post=NULL</code>，则只是局部指针变量指向了<code>NULL</code>，并没有对整个树进行更改</li><li>若在函数内部<code>*post=NULL</code>，则<code>*post</code>是一个<code>TreeNode</code>对象，将该对象置为<code>NULL</code>，会隐式的调用构造函数，而<code>NULL</code>会隐式的转换为0，调用构造函数的结果会将该节点的<code>val</code>置为0，而不是将该块区域置为<code>NULL</code>。</li><li>若采用递归的方式调用，极端情况下，考虑调用的结果<code>root-&gt;right=NULL</code>，<code>root-&gt;right</code>是一个<code>TreeNode</code>指针，可以置为<code>NULL</code>。然后该次调用会将root的结果返回，直到更新整个树。</li></ol><h3 id="参考-7"><a href="#参考-7" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-2/" target="_blank" rel="noopener">二叉搜索树中的插入操作</a></p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="理论-6"><a href="#理论-6" class="headerlink" title="理论"></a>理论</h3><p>回溯法（backtrack）常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于全排列，穷尽所有可能，遍历的过程实际上是一个决策树的遍历过程。时间复杂度一般 $O(N!)$，它不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</p><p>常用模板如下，核心就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">func backtrack(选择列表,路径):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(选择列表,路径)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>在这个模板中需要注意的有：</p><ol><li>路径：也就是已经做出的选择</li><li>选择列表：也就是当前可以做的选择（可以使用<code>可以遍历的下标范围</code>或者<code>标记是否访问过的数组</code>来得到选择列表并避免回溯重复。若访问某一个元素的时候，前面的元素不在选择列表中，则可以使用前者，否则的话可以使用后者）</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件</li></ol><h3 id="常见题目-7"><a href="#常见题目-7" class="headerlink" title="常见题目"></a>常见题目</h3><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h4><blockquote><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。<strong>说明：</strong>解集不能包含重复的子集。</p></blockquote><p>这道题明显是需要用回溯法解决的，因为要遍历所有可能的子集。因为不含重复元素，所以参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsetsCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">    result.push_back(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        subsetsCore(result, tmp, nums, i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    subsetsCore(result, tmp, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h4><blockquote><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。<strong>说明：</strong>解集不能包含重复的子集。</p></blockquote><p>该题和上一个题目的区别在于，本题的 nums 中是可能包含重复元素的。若还采用上一题的思路，会出现重复的子集。相比上一个题目，主要多了两个步骤：</p><ol><li>将 nums 中的元素从小到大排序，这样可以保证相同的数字挨在一起</li><li>若<code>i&gt;begin &amp;&amp; nums[i]==nums[i-1]</code>则说明该次循环还在这一级，且出现了重复元素，直接跳过。其中<code>i&gt;begin</code>保证只跳过同级的相同元素，而不同级的相同元素不会跳过</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsetsWithDupCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">    res.push_back(tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 只跳过同级的相同元素，而不同级的相同元素不会跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;begin &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        subsetsWithDupCore(res, tmp, nums, i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());  <span class="comment">// 将元素从小到大排序，方便之后跳过重复元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    subsetsWithDupCore(res, tmp, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h4><blockquote><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p></blockquote><p>因为这是一个全排列问题，在以后面数字作为首字母的时候，前面的数字也要遍历到，因此不能使用下标的变换去更新下一次的回溯范围，而只能使用标记是否访问过的数组。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuteCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flag, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size() == nums.size()) &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        flag[i] = <span class="number">1</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        permuteCore(res, tmp, flag, nums);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(nums.size(), <span class="number">0</span>);</span><br><span class="line">    permuteCore(res, tmp, flag, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h4><blockquote><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p></blockquote><p>该题和上一题的区别在于该题的序列可能包含重复数字。按照 <a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a> 的解题思路，并结合上一题的解法：</p><ol><li>将序列从小到大进行排序，这样可以让重复数字放在一块</li><li><code>i&gt;0 &amp;&amp; !flag[i-1] &amp;&amp; nums[i]==nums[i-1]</code>保证若处于不同层次的循环，且相邻两个元素相等，则不需要进行回溯了。</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuteUniqueCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flag, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size() == nums.size()) &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">/* 需要跳过的有几种情况</span></span><br><span class="line"><span class="comment">        1. flag[i] 表示当前回溯路径第i个元素已经访问了</span></span><br><span class="line"><span class="comment">        2. !flag[i-1]表示已经处于上一层回溯了，此时需要判断是否与前一个元素值相等，相等的话就不用回溯了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(flag[i] || (i&gt;<span class="number">0</span> &amp;&amp; !flag[i<span class="number">-1</span>] &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        flag[i] = <span class="number">1</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        permuteUniqueCore(res, tmp, flag, nums);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end()); <span class="comment">// 一定要排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(nums.size(), <span class="number">0</span>); <span class="comment">// 注意大小，与nums元素一一对应</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    permuteUniqueCore(res, tmp, flag, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h4><blockquote><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的数字可以<strong>无限制重复被选取。</strong></p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul></blockquote><p>这个题目有两个地方需要注意：数组 <code>candidates</code>无重复元素、每个元素可以使用多次。使用一个变量<code>sum</code>记录当前<strong>路径</strong>的累加和，若累加和等于<code>target</code>则停止并添加到最终结果中，若累加和大于<code>target</code>则<strong>停止</strong>。因为遍历到后面的元素后，前面的元素不在回溯路径中了，所以可以使用下标范围来得到<strong>选择列表</strong>。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combinationSumCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;candidates.size(); i++) &#123;</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        tmp.push_back(candidates[i]);</span><br><span class="line">        combinationSumCore(res, tmp, candidates, i, target, sum);  <span class="comment">// 注意这里的index传参为i，因为数字可以无限制重复选取</span></span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    combinationSumCore(res, tmp, candidates, <span class="number">0</span>, target, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h4><blockquote><p>给定一个数组 <code>candidates</code>  和一个目标数 <code>target</code> ，找出 <code>candidates</code>  中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code>  中的每个数字在每个组合中<strong>只能使用一次。</strong></p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul></blockquote><p>这个题目和上一个题目的区别在于：数组<code>candidates</code>可能含有重复元素、每个元素只能使用一次。根据前面的经验，处理重复元素的方法：</p><ol><li>将 <code>candidates</code> 中的元素从小到大排序，这样可以保证相同的数字挨在一起</li><li>若<code>i&gt;index &amp;&amp; candidates[i]==candidates[i-1]</code>则说明该次循环还在这一级，且出现了重复元素，直接跳过。其中<code>i&gt;index</code>保证只跳过同级的相同元素，而不同级的相同元素不会跳过</li></ol><p>另外，因为每个元素只能使用一次，因此在进行下一次回溯的时候，下标需要加1。最终参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combinationSumCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;candidates.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;index &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        tmp.push_back(candidates[i]);</span><br><span class="line">        combinationSumCore(res, tmp, candidates, i+<span class="number">1</span>, target, sum);  <span class="comment">// 注意这里的index传参为i+1，因为数字可以只能选取一次</span></span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    sort(candidates.begin(), candidates.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    combinationSumCore(res, tmp, candidates, <span class="number">0</span>, target, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h4><blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="/DataStructureAlgorithm/LeetCode总结/17_telephone_keypad.png" alt="img" style="zoom: 50%;"></p></blockquote><p>这个题目明显要使用回溯去解决，因为要从各个按键里面找到一个字母，然后组成结果，不存在优化的可能。</p><ol><li>路径：使用<code>vector</code>记录</li><li>选择列表：当前按下数字对应的所有字母</li><li>结束条件：若当前路径的长度等于<code>digits</code>的长度，则将路径添加到最终路径，终止本次回溯</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">letterCombinationsCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span>&amp; digits, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;&amp; m, <span class="built_in">string</span>&amp; tmpS, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == digits.size()) &#123;</span><br><span class="line">        res.push_back(tmpS);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到当前数字对应的字母</span></span><br><span class="line">    <span class="built_in">string</span> s = m[digits[index]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++) &#123;</span><br><span class="line">        tmpS.push_back(s[i]);</span><br><span class="line">        letterCombinationsCore(res, digits, m, tmpS, index+<span class="number">1</span>);</span><br><span class="line">        tmpS.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(digits.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m&#123;</span><br><span class="line">        &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> tmpS;</span><br><span class="line">    letterCombinationsCore(res, digits, m, tmpS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></h4><blockquote><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。返回 <em>s</em> 所有可能的分割方案。</p></blockquote><p>这道题可以使用回溯法解决。</p><ol><li>路径：使用<code>vector&lt;string&gt;</code>记录当前所有回文子串</li><li>选择列表：从当前索引到 <code>s.size()-1</code> 均可以当做子串的结尾；若当前子串为回文子串，则继续进行回溯</li><li>结束条件：当前索引已经等于<code>s.size()</code>了，则将当前路径添加到最终结果中</li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;  <span class="comment">// 使用递归+双指针的方式判断是否为回文子串，代码更加简洁</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[i++] == s[j--]) <span class="keyword">return</span> judge(s, i, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; result, <span class="keyword">int</span> begin, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp, <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin == s.size()) &#123;</span><br><span class="line">        result.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;s.size(); i++) &#123;  <span class="comment">// 每一个索引都可以作为当前子串的结尾索引</span></span><br><span class="line">        <span class="keyword">if</span>(judge(s, begin, i)) &#123;  <span class="comment">// 若为回文子串，则继续进行回溯；否则进行下一个循环</span></span><br><span class="line">            tmp.push_back(s.substr(begin, i-begin+<span class="number">1</span>));;</span><br><span class="line">            partitionCore(result, i+<span class="number">1</span>, tmp, s);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">    partitionCore(result, <span class="number">0</span>, tmp, s);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></h4><blockquote><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。</p></blockquote><p>这个题目比较复杂，借助这道题和大佬的讲解。这里详细讲解一下回溯算法的分析步骤。</p><p>回溯算法事实上就是在一个树形问题上做深度优先遍历，因此 <strong>首先需要把问题转换为树形问题</strong>。在画树形图的过程中，一定会发现有些枝叶是没有必要的，把没有必要的枝叶剪去的操作就是<strong>剪枝</strong>，在代码中一般通过 <code>break</code> 或者 <code>contine</code> 和 <code>return</code> （表示递归终止）实现。画出本题的树形图如下图所示：</p><p><img src="/DataStructureAlgorithm/LeetCode总结/b581bdde1cef982f0af3182af17fc3c41960c76a7445af0dcfd445c89b4c2eaa-「力扣」第 93 题：复原 IP 地址-1.png" alt="「力扣」第 93 题：复原 IP 地址-1.png" style="zoom: 43%;"></p><ol><li>路径：这个题目麻烦的地方是IP地址之间要用<code>.</code>进行分割，若用<code>string</code>存储路径，则比较麻烦，不如直接使用<code>vector&lt;string&gt;</code>进行记录，记录完毕之后若满足条件，则再拼接到一块</li><li>选择列表：因为已经遍历过的元素，以后不会在出现了，因为可以使用下标记录下一次访问的位置。每次回溯的时候，可遍历的子串长度在<code>[1,3]</code>之间。并且需要排除如下几种情况<ul><li>若<code>子串长度+当前下标-1&gt;=.size()</code></li><li><code>0x、0xx</code>都是非法的</li><li>子串的数值不能大于255</li></ul></li><li>结束条件：<ul><li>若遍历完所有的<code>s</code>，并且已经有四段合法字符串了，则记为有效结果，结束</li><li>若没有遍历完<code>s</code>，并且已经有四段合法字符串了，则记为无效结果，结束</li></ul></li></ol><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp, <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start==s.size() &amp;&amp; tmp.size()==<span class="number">4</span>) &#123; <span class="comment">// tmp有四段，并且遍历完s了</span></span><br><span class="line">        <span class="built_in">string</span> str = tmp[<span class="number">0</span>];  <span class="comment">// 这样写可以保证最后不会多一个 .</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;tmp.size(); i++)</span><br><span class="line">            str = str + <span class="string">'.'</span> + tmp[i];</span><br><span class="line">        res.push_back(str); <span class="comment">// 其中一种可行方案</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(start&lt;s.size() &amp;&amp; tmp.size()==<span class="number">4</span>)  <span class="comment">// tmp有四段，并且没有遍历完s</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len&lt;=<span class="number">3</span>; len++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(len+start<span class="number">-1</span> &gt;= s.size())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(len!=<span class="number">1</span> &amp;&amp; s[start]==<span class="string">'0'</span>)  <span class="comment">// 0x，00x非法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">string</span> str = s.substr(start, len);</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">3</span> &amp;&amp; atoi(str.c_str())&gt;<span class="number">255</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        tmp.push_back(str);</span><br><span class="line">        DFS(res, tmp, s, start+len);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">    DFS(res, tmp, s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考-8"><a href="#参考-8" class="headerlink" title="参考"></a>参考</h3><p><a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">回溯算法解题套路框架</a><br><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/c-shuang-bai-hui-su-xie-fa-by-jiang-ly/" target="_blank" rel="noopener">C++ 双百回溯写法</a><br><a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/" target="_blank" rel="noopener">回溯算法（画图分析剪枝条件）</a><br><a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/" target="_blank" rel="noopener">『手画图解』DFS 回溯 细节</a></p><h2 id="参考-9"><a href="#参考-9" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/" target="_blank" rel="noopener">Sort List （归并排序链表）</a><br><a href="https://blog.csdn.net/fuxuemingzhu/article/details/101900729" target="_blank" rel="noopener">【LeetCode】代码模板，刷题必会</a><br><a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">labuladong的算法小抄</a><br><a href="https://greyireland.gitbook.io/algorithm-pattern/" target="_blank" rel="noopener">algorithm-pattern</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;二叉树遍历模板&quot;&gt;&lt;a href=&quot;#二叉树遍历模板&quot; class=&quot;headerlink&quot; title=&quot;二叉树遍历模板&quot;&gt;&lt;/a&gt;二叉树遍历模板&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;前序遍历&lt;/strong&gt;：&lt;strong&gt;先访问根节点&lt;/strong&gt;，再前序遍历左子树，再前序遍历右子树&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中序遍历&lt;/strong&gt;：先中序遍历左子树，&lt;strong&gt;再访问根节点&lt;/strong&gt;，再中序遍历右子树&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后序遍历&lt;/strong&gt;：先后序遍历左子树，再后序遍历右子树，&lt;strong&gt;再访问根节点&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以根访问顺序决定是什么遍历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;左子树都是优先右子树&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="DataStructureAlgorithm" scheme="https://www.zdaiot.com/categories/DataStructureAlgorithm/"/>
    
    
      <category term="数据结构" scheme="https://www.zdaiot.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://www.zdaiot.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Few-Shot Learning with Global Class Representations</title>
    <link href="https://www.zdaiot.com/DeepLearningApplications/Few-shot%20Learning/Few-Shot%20Learning%20with%20Global%20Class%20Representations/"/>
    <id>https://www.zdaiot.com/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/</id>
    <published>2020-07-19T12:05:05.000Z</published>
    <updated>2020-07-19T12:05:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul><li>标题：Few-Shot Learning with Global Class Representations</li><li>年份：2019</li><li>期刊：ICCV</li><li>标签：global class representations,  few-shot learning</li><li>数据：miniImageNet，Omniglot</li></ul><h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><ol><li>通过<strong>在训练阶段引入新类的数据</strong>，同时对基类和新类学习<strong>全局类别表征</strong>，并利用样本生成策略解决类别不均衡问题，有效防止模型在基类数据中出现过拟合的现象，从而提高了模型泛化到新类的能力。</li><li>方法可以很容易的扩展到广义小样本学习（相比标准小样本学习，广义小样本学习中测试样本不仅包含新类，还包含了基类）。</li><li>所提的方法在标准小样本学习与广义小样本学习的benchmark上均取得了很好的效果。并且在广义小样本学习上，性能的提升更大。</li></ol><h2 id="创新点来源"><a href="#创新点来源" class="headerlink" title="创新点来源"></a>创新点来源</h2><p>首先，先了解几个知识点：</p><ol><li>对于FSL问题，base classes每类均有足够的训练样本，而novel classes每类只有少量的标记样本。</li><li>现有的FSL方法都是基于元学习的。在元学习阶段，在base classes上采样来模拟Few-Shot Learning的条件。学习到的迁移知识通常以good initial conditions、embeddings、optimization strategies形式存储。元学习阶段之后，目标Few-Shot Learning问题通常有两种途径解决：一使用the learned<br>optimization strategy进行fine-tuning；二在不更新网络权重的情况下进行前向计算。</li></ol><p>但是基于元学习的方法有一个根本性的问题：通常只使用基类数据训练模型（initial condition, embedding or optimization strategy），无法保证模型在目标数据上进行有效的泛化，即使在fine-tuning步骤之后。由于基类和新类之间<strong>存在严重的样本不均衡问题</strong>，导致容易过拟合到基类数据，这一点在广义小样本问题中尤为突出。通过<strong>在训练阶段引入新类的数据</strong>，同时对基类和新类学习全局类别表征，并利用样本生成策略解决类别不均衡问题，有效防止训练模型在基类数据中出现过拟合的现象，从而提高了模型泛化到新类的能力。</p><p>跟原型网络相比，本文主要有如下几个不同点：</p><ol><li>本文学习的是全局类别表征，而不是episodic one；</li><li>base class和novel class训练样本都用来学习表征。这保证学习到的类表征是具有全局一致性的，而不是local的；</li><li>本文引入了feature hallucination based方法，可以用来合成新的样本，解决类不平衡性问题。</li></ol><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>然而，这种全局类别表征最大的障碍是base与novel class训练样本之间的不均衡。作者使用了如下两种方式解决的这个问题：</p><ol><li>通过合成数据增加novel class的类内多样性，通过在类样本子空间中随机抽样数据点，作者所提的合成样本策略可以有效地增加类内方差；</li><li>引入元训练去平衡base与novel class。具体来说就是representation registration，这部分内容比较复杂，在下面会详细展开。</li></ol><h3 id="Registration-Module"><a href="#Registration-Module" class="headerlink" title="Registration Module"></a>Registration Module</h3><p>假设样本集合为$C_{total}=\{c_1,\dots,c_N\}$，其中$N$表示类别总数。给定训练集集合$D_{train}$和测试集集合$D_{test}$，其中$D_{train}$的类别空间为$C_{total}$。registration module的主要作用为：将训练样本和全局类别表征进行比较，并选择出对应的全局类别表征。registration loss定义为全局表征和registration module的联合优化。下面进行具体介绍。</p><p>首先将训练集合中的一个训练样本$x_i$输入到特征提取器$F$中，获得其视觉特征，定义为$f_i=F(x_i)$。然后将该样本的视觉特征与全局类别特征表达$G=\{g_{c_j},c_i \in C_{total}\}$输入到registration module $R$中。对于每一个视觉特征$f_i$，registration module $R$都会产生一个向量$V_i=[v_i^{c_1},\cdots,v_i^{c_N}]^T$，其中第$j$个元素表示$f_i$与第$c_j$类全局类别表征$g_{c_j}$之间的相似性。在本文中，相似性得分的定义如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200719222836379.png" alt="image-20200719222836379" style="zoom:80%;"></p><p>其中，$\theta(\cdot)$和$\phi(\cdot)$分别是样本视觉特征与全局类别表征的嵌入。</p><p>对于样本$x_i$（类别为$y_i$），定义registration loss $L_{reg}$，使得该样本与它对应的全局类别表征最接近，其中$CE$表示交叉熵损失：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200719223827007.png" alt="image-20200719223827007" style="zoom:80%;"></p><p>通过将样本与所有全局类别表征（$C_{total}$）进行比较，<strong>registration module使得每个全局类别表征接近其类内的样本，而远离类外的样本。</strong>值得注意的是，representation和特征提取网络都是可以端到端训练的，并且联合优化的。具体地说，利用训练好的全局类别表征，特征提取器被优化以将样本聚集在这些全局类表征周围；给定特征提取器，每个全局类别表征被优化为更接近同类样本而远离异类样本。</p><h3 id="Sample-Synthesis-Module"><a href="#Sample-Synthesis-Module" class="headerlink" title="Sample Synthesis Module"></a>Sample Synthesis Module</h3><p>为了解决novel classes样本过少引起的类别不平衡问题，本文提出了一个样本合成策略为novel classes合成样本。主要分为两个步骤：</p><ol><li><p>使用原始样本产生新样本。具体来说，输入原始图像，使用随机裁剪、随机翻转和data hallucination策略合成样本。使用该方法后，每个novel class都可以获得总数为$k_t$的样本总数。</p></li><li><p>对于每一个新类$c_j$，首先从$k_t$个样本中随机选择出$k_r$个样本，从这$k_r$ 个特征$\{f_1,\cdots,f_{k_r}\}$组成的特征空间中，随机采样一个点合成一个样本。具体来说，在0~1均匀分布中采样出$k_r$个值$\{v_1,\cdots,v_{k_r}\}$；然后以这$k_r$ 个值作为权重对这些特征进行加权求和，得到了$c_j$类新的样本$r_{c_j}$，具体方程如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200719231102918.png" alt="image-20200719231102918" style="zoom:80%;"></p></li></ol><p>通过上述的策略，类内的样本多样性会增加，样本过少的问题也得到了减轻。上述这两个步骤可以概括为下面这副图：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200719232056995.png" alt="image-20200719232056995"></p><h3 id="Few-Shot-Learning-By-Registration"><a href="#Few-Shot-Learning-By-Registration" class="headerlink" title="Few Shot Learning By Registration"></a>Few Shot Learning By Registration</h3><p>除了上述的样本合成策略外，本文还使用了元训练策略。在FSL中，类标集合$C_{total}$分为两个不相交的子集$C_{base}$和$C_{novel}$。</p><p>在元训练阶段，首先从$C_{total}$个类别中抽取$n_{train}$个类别组成训练集合$C_{train}$；$C_{train}$每个类别均随机抽取$n_s$个样本组成支撑集$S=\{(x_i,y_i),i=1,2,\cdots,n_s\times n_{train}\}$；$C_{train}$每个类别随机抽取$n_q$个样本组成查询集$Q=\{(x_k,y_k),k=1,\cdots,n_q\times n_{train}\}$。值得注意的是，在训练集合中的novel class只有少量的$n_{few}$个样本，这通常远远少于$n_s+n_q$。所以，作者首先使用上一小节提到的数据合成的方法，合成$n_s+n_q$个样本，然后将他们划分为$n_s$和$n_q$，分别放到支撑集与查询集里面。</p><p>在元测试阶段，主要和元训练阶段有如下几个方面的不同：</p><ol><li>$C_{test}$仅由从novel classes中随机选择的$n_{test}$个类别组成；</li><li>使用这$n_{test}$个novel class在训练集合中的标记样本作为支撑集</li><li>查询集从$D_{test}$集合中选取，而不是$D_{train}$集合。</li></ol><p>如果在元训练阶段，每个novel class有$n_{few}$的标记样本，那么FSL问题称为$n_{few}$-shot FSL；如果模型在测试阶段，从$n_{test}$的候选类别中预测结果，那么FSL问题称为$n_{test}$-way FSL。</p><p>接下来就开始进行整个FSL框架的描述。整个FSL框架示意图如下图所示：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720115533701.png" alt="image-20200720115533701" style="zoom:80%;"></p><p><strong>第一步</strong>，利用元学习策略将所提的样本合成模块加入到FSL框架中。也就是说，在每一次训练迭代过程中，<strong>支撑集$S$</strong>中的样本$S=\{x_i,i=1,2,\cdots,n_s\times n_{train}\}$首先被送入到特征提取器$F$中获得对应的视觉特征$\{f_i=F(x_i),i=1,\cdots,n_s \times n_{train}\}$。然后<strong>支撑集中的每一个类别建立episodic表征</strong>，记为$\{r_{c_i},c_i \in C_{train}\}$。该episodic表征$r_{c_i}$集成了当前mini-batch的支持集合$S$中的类$C_i$的信息；因此它是局部类别表征而不是全局类别表征。具体操作为：对于base classes，跟原型网络相似，平均同一类的视觉特征来获得episodic类别表征；对于novel class，将支撑集某类的特征作为输入，利用上述样本合成策略，为该类合成新的样本，从而得到的episodic novel类别表征更加多样化。</p><p><strong>第二步，</strong>将registration module融入到FSL框架中，根据其episodic表征选择全局类别表征，选中的全局类别表征被用来对查询图片进行分类。特别的，将支撑集的episodic类别表征$\{r_{c_j},c_j \in C_{train} \}$和全局类别表征$G=\{g_{c_j},c_j \in C_{total}\}$输入到registration module $R$中，计算每一个episodic类别表征与全局类别表征之间的相似度，方程见上述方程1。</p><p>相似度得分被用来为查询数据集选择全局类标表征。为了使得全局类别表征更具有分离性，registration module定义了一个registration loss，使得episodic类别表征与对应类别全局类别表征之间的相似度得分更高。全局类别表征的分离性更强，识别未标记样本的能力越强。根据上面的方程2，每一个类别episodic表征$r_{c_i}$的registration损失定义如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720094226942.png" alt="image-20200720094226942" style="zoom:80%;"></p><p>其中$V_i=[v_i^{c_1},\cdots,v_i^{c_N}]^T$表示$C_{train}$中类别$c_i$的episodic类别表征$r_{c_i}$与所有全局类别表征$\{g_{c_j},c_j\in C_{total}\}$的相似性得分。</p><p><strong>第三步，</strong>利用得到的相似度得分，为$C_{train}$中的每一个类选择一个全局类别表征作为其类表征，并以选出的全局类别表征为参考进行最近邻搜索来识别查询图像。但是，当选择使用的是argmax操作时，它是不可微的。因此，以soft manner的形式选择类别表征。具体就是以概率分布$V_i$为权重，将所有类别的全局类标表征加权求和，得到$C_{train}$中第$i$类的类别表征$\varepsilon_i$，记做$\varepsilon_i=V_iG$。这样就获得了$C_{train}$中所有类别对应的全局类别特征$\{\varepsilon_i,i=1,\cdots,n_{train}\}$。查询样本$\{x_k,y_k  \} \in Q$的分类损失定义如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720101436396.png" alt="image-20200720101436396" style="zoom:80%;"></p><p>其中，$F$为特征提取模块，$W_k=[w_k^1,\cdots,w_k^{n_{train} }]^T$表示查询样本$x_k$与选中的全局类别表征$\varepsilon_i$之间的相似性。</p><p>将registration loss与分类损失结合到一块，就可以得到训练过程中的总损失函数，方程如下：</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720101832702.png" alt="image-20200720101832702" style="zoom:80%;"></p><p>元训练的整个过程如下，值得注意的事项我均以下划线表示出来了。</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720103144949.png" alt="image-20200720103144949"></p><p>在元测试集阶段，使用相同的流程去预测未标记样本的类标。也就是说，首先将<strong>支撑集</strong>输入到特征提取器中，得到每一个类别的episodic类别表征。然后，通过registration module与episodic类别表征得到对应的全局类别表征。然后，通过计算测试样本的特征向量与选出的全局类别表征之间的欧几里德距离来执行最近邻搜索。</p><h3 id="Extension-to-Generalized-FSL"><a href="#Extension-to-Generalized-FSL" class="headerlink" title="Extension to Generalized FSL"></a>Extension to Generalized FSL</h3><p>虽然本文方法初始是用来设计标准FSL过程的，但是它能够很容易的扩展到广义FSL问题：<strong>唯一的区别在于测试样本同时从基类和新类抽取</strong>，预测时需要预测查询样本属于$C_{total}$个类别的类标。<strong>而标准FSL的测试数据只来源于novel classses</strong>。registration module不仅优化novel类别表征，还更新了base类别表征。通过将每个查询样本与base和novel的全局类标表征进行比较，registration module可以直接预测查询样本属于$C_{total}$中每个类的概率。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>本文的实验主要是在miniImageNet和Omniglot两个数据集上展开的。关于这两个数据集的说明这里就不详细展开了，可以看之前的文章。</p><h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><p><strong>网络结构：</strong>特征提取器由四个残差block组成，每个block由64个$3 \times 3$卷积核、BN层、RELU激活函数和一个$2 \times 2$的最大池化层组成。registration module中的两个嵌入模块$\theta$和$\phi$均使用的是全连接层，全连接层的输出维度为512。</p><p><strong>训练过程：</strong>首先，借助分类任务，使用所有的base classes训练特征提取器。然后，通过首先使用预先训练好的$F$其类中提取图像的视觉特征，然后对这些视觉特征进行平均来初始化每个全局类别表征。data hallucinator用预先训练的$F$作为特征提取器进行预训练。registration module采用的是高斯初始化，并从零开始训练。初始化特征提取器、全局类别表征、data hallucinator、registration module之后，将他们放到一块进行端到端的训练。</p><h3 id="Results-on-Omniglot"><a href="#Results-on-Omniglot" class="headerlink" title="Results on Omniglot"></a>Results on Omniglot</h3><p>5way 1-shot/5-shot，20way 1-shot/5-shot。其中，<strong>way表示测试集合中类别的个数，而shot表示每类支撑集的个数</strong>。不管是1-shot还是5-shot，每个类别均有五个查询样本。在元测试阶段，支持集中的图像是从训练集中随机选择的，而查询集中的图像是从测试集中随机选择的。可以观察到，本文的方法取得了新的最先进的性能。这验证了该方法的有效性，因为它采用了独特的全局类别表征学习策略。</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720113100233.png" alt="image-20200720113100233" style="zoom:80%;"></p><h3 id="Results-on-miniImageNet"><a href="#Results-on-miniImageNet" class="headerlink" title="Results on miniImageNet"></a>Results on miniImageNet</h3><p>我们可以看到，我们的方法在5-way 5-shot设置上的性能明显优于其他FSL方案，并且在5-way 1-shot设置下达到了最好的效果。</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720113539560.png" alt="image-20200720113539560" style="zoom:80%;"></p><h3 id="Generalized-Few-Shot-Learning"><a href="#Generalized-Few-Shot-Learning" class="headerlink" title="Generalized Few-Shot Learning"></a>Generalized Few-Shot Learning</h3><p>使用的是miniImageNet数据集，类别划分方式相同（64//16/20），采用的新的数据划分方式，对于base classes，从600张图片中随机选择500张图片，novel classes中随机选取少量样本作为训练数据集。从剩下的数据中，每个base/novel类别，从中选取100张图片作为测试集。</p><p>定义广义FSL问题的评价指标为：</p><ol><li>$acc_a$：将所有类别的测试样本识别正确的概率</li><li>$acc_b$：将base classes的测试样本识别正确的概率</li><li>$accu_a$：将novel classes的测试样本识别正确的概率</li></ol><blockquote><p>值得注意的是，计算上述指标的时候，均需要将测试样本映射到$C_{total}$的标记空间。</p></blockquote><p><img src="/DeepLearningApplications/Few-shot Learning/Few-Shot Learning with Global Class Representations/image-20200720114953770.png" alt="image-20200720114953770" style="zoom:80%;"></p><p>实验结果如上表所示，可以观察到：</p><ol><li>本文的方法在所有的评价指标上都取得了最好的结果，比标准设置下的结果有更大的差距。这表明在这种更具挑战性的环境下，本文的模型具有最强的泛化能力。</li><li>本文方法优于PN和RN，因为这里学习每个类的全局类别表征，而它们估计episodic类别表征。</li><li>MN的结果比本文的方法低得多。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先分析基于元学习的方法有一个根本性的问题：通常只使用基类数据训练模型（initial condition, embedding or optimization strategy），无法保证模型在目标数据上进行有效的泛化，即使在fine-tuning步骤之后。由于基类和新类之间<strong>存在严重的样本不均衡问题</strong>，导致容易过拟合到基类数据，这一点在广义小样本问题中尤为突出。</p><p>针对这个根本性问题，作者通过<strong>在训练阶段引入新类的数据</strong>，同时对基类和新类学习<strong>全局类别表征</strong>，并利用样本生成策略解决类别不均衡问题，有效防止训练模型在基类数据中出现过拟合的现象，从而提高了模型泛化到新类的能力。</p><p>本文值得借鉴的地方是episodic类别表征与全局类别表征之间的关系是通过registration module进行的。也就是每次会使用registration module模块，对每个episodic类别特征与所有全局类标表征做相似性度量，选择出该类别对应的全局类标特征。然后由选出的全局类标特征与查询样本进行比较，得到查询样本的类标。不过，关于样本扩充的方式不太适用于非图像领域。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/78743300" target="_blank" rel="noopener">ICCV 2019 | 基于全局类别表征的小样本学习 GCR（附代码）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;标题：Few-Shot Learning with Global Class Representations&lt;/li&gt;
&lt;li&gt;年份：2019&lt;/li&gt;
&lt;li&gt;期刊：ICCV&lt;/li&gt;
&lt;li&gt;标签：global class representations,  few-shot learning&lt;/li&gt;
&lt;li&gt;数据：miniImageNet，Omniglot&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;创新点&quot;&gt;&lt;a href=&quot;#创新点&quot; class=&quot;headerlink&quot; title=&quot;创新点&quot;&gt;&lt;/a&gt;创新点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;通过&lt;strong&gt;在训练阶段引入新类的数据&lt;/strong&gt;，同时对基类和新类学习&lt;strong&gt;全局类别表征&lt;/strong&gt;，并利用样本生成策略解决类别不均衡问题，有效防止模型在基类数据中出现过拟合的现象，从而提高了模型泛化到新类的能力。&lt;/li&gt;
&lt;li&gt;方法可以很容易的扩展到广义小样本学习（相比标准小样本学习，广义小样本学习中测试样本不仅包含新类，还包含了基类）。&lt;/li&gt;
&lt;li&gt;所提的方法在标准小样本学习与广义小样本学习的benchmark上均取得了很好的效果。并且在广义小样本学习上，性能的提升更大。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;创新点来源&quot;&gt;&lt;a href=&quot;#创新点来源&quot; class=&quot;headerlink&quot; title=&quot;创新点来源&quot;&gt;&lt;/a&gt;创新点来源&lt;/h2&gt;
    
    </summary>
    
    
      <category term="DeepLearningApplications" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/"/>
    
      <category term="Few-shot Learning" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/Few-shot-Learning/"/>
    
    
      <category term="Few Shot Learning" scheme="https://www.zdaiot.com/tags/Few-Shot-Learning/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer总结</title>
    <link href="https://www.zdaiot.com/DataStructureAlgorithm/%E5%89%91%E6%8C%87Offer%E6%80%BB%E7%BB%93/"/>
    <id>https://www.zdaiot.com/DataStructureAlgorithm/剑指Offer总结/</id>
    <published>2020-07-09T01:14:14.000Z</published>
    <updated>2020-07-09T01:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近快要面试了，再刷一遍剑指Offer，看大家分享刷LeetCode和剑指Offer的时候都是有模板的，如果按照随机顺序刷，很容易忘记而且不容易总结刷题思路。所以常常把一类题放到一块一起刷。</p><p>《剑指Offer》有如下优点：</p><ul><li>很可能在面试中出现原题（至少在微软面试经常能遇到原题）</li><li>题量少，但是涵盖的内容较全，性价比较高</li><li>能培养一个良好的刷题习惯</li></ul><p>缺点是：</p><ul><li>题目较少，<strong>刷着容易过拟合</strong></li><li>动态规划的题比较少，因此需要在力扣上专项训练。</li></ul><h2 id="数据结构类题目"><a href="#数据结构类题目" class="headerlink" title="数据结构类题目"></a>数据结构类题目</h2><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06-从尾到头打印链表</a>：stack（想到并写出了利用栈的方法，但是没想到递归的方法，但实际上两者需要内存大致相同）</p><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18-删除链表的节点</a>：双指针，头结点处理时可以使用哑点或者特殊处理</p><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22-链表中倒数第k个结点</a>：双指针（没想起思路）</p><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24-反转链表</a>：三个指针。注意<code>pre</code>指针的初始化，另外最终返回的是<code>pre</code>指针</p><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25-合并两个排序的链表</a>：双指针，哑点的使用（要注意基于递归的写法，建议练习）</p><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">面试题35-复杂链表的复制</a>：（想到并写出了利用map的方法，但是没想到节省空间的方法）</p><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">面试题52-两个链表的第一个公共节点</a>（想到并写出了利用栈的方法，但是没想到双指针法）</p><p><strong>链表测试用例：</strong></p><ol><li>特殊输入测试（输入的链表头结点指针为NULL）</li><li>普通链表（输入的链表有多个节点；输入的链表只有一个节点）</li></ol><p><strong>套路：</strong></p><ol><li>哑点的使用</li><li>双指针、三指针等用法</li></ol><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题07-重建二叉树</a>：递归（想到递归，终止判断条件和递归时子函数传参有误，根源在于对于迭代器和重建二叉树过程理解不到位）</p><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26-树的子结构</a>：两个递归（有大概思路，但是代码没想到是两个递归，需注意递归终止条件）</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27-二叉树的镜像</a>：递归（掌握，建议练习）</p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32-1 -从上往下打印二叉树</a>：队列（掌握）</p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32-2 -从上往下打印二叉树 2</a>：队列（掌握）</p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32-3 -从上往下打印二叉树 3</a>：两个栈（想到了使用<code>&lt;algorithm&gt;</code>中<code>reverse</code>方法，但是没想到使用两个栈或者双边队列）</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">面试题33-二叉搜索树的后序遍历序列</a>：后序遍历特点（未想起思路，代码需要这是一个递归过程）</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题34-二叉树中和为某一值的路径</a>：深度优先遍历，前序、中序、后序，这里用到了前序（想到了思路，但是不会写代码）</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36-二叉搜索树与双向链表</a>：递归（没想到思路，第二遍仍然没有写出来代码，建议练习）</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">面试题55-1-二叉树的深度</a>：递归（写的代码比较复杂）</p><p><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题55-2-平衡二叉树</a>：后序遍历（只想到了递归的方法，莫名其妙写成了后序遍历，建议练习）</p><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28-对称的二叉树</a>：递归（有大致思路，但写不出具体代码）</p><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37-序列化二叉树</a>：递归（有大致思路，但写不出具体代码，第二遍对于str库还不是很了解）</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">面试题54-二叉搜索树的第k大节点</a>：中序遍历，右根左（掌握）</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - I-二叉搜索树的最近公共祖先</a>：遍历（没有想到简单思路，第二遍代码写的复杂了，可以使用非递归的形式）</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - II-二叉树的最近公共祖先</a>：遍历（没有想到思路，第二遍仍然没有想到简单思路）</p><p><strong>二叉树测试用例：</strong></p><ol><li>普通二叉树（完全二叉树、非完全二叉树）</li><li>特殊二叉树（所有节点都没有右子节点的二叉树、所有节点都没有左子节点的二叉树、只有一个节点的二叉树）</li><li>特殊输入测试（二叉树的根节点指针为NULL；输入不满足题意）</li></ol><blockquote><p>看到二叉搜索树，就要想到前序、中序、后序遍历方式。其中中序遍历是按照从小到大的顺序排列的。</p></blockquote><p>套路：</p><ul><li>尝试将递归语句放到<code>if</code>条件中，可以</li></ul><h3 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h3><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09-用两个栈实现队列</a>：栈（想出来的思路不是最优解）</p><p><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">面试题30-包含min函数的栈</a>：辅助栈（push函数有点小问题）</p><p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">面试题31-栈的压入、弹出序列</a>：辅助栈（没有想到思路，第二遍仍没有写出来最优解，建议练习）</p><p><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">面试题58-1-翻转单词顺序</a>：<code>istringstream</code>的使用（没有想到最优解，第二遍仍然不会用这个库，建议记忆）</p><p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59-1-滑动窗口的最大值</a>：双边队列（没有想到，第二遍仍然没有想到）</p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40-最小的K个数</a>：最小堆，<code>priority_queue</code>的使用（没有想起来思路，第二遍对于该库还不是很熟悉）</p><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41-数据流中的中位数</a>：最大堆最小堆（没有想到思路，第二遍对库还不是很熟悉）</p><h3 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h3><p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">面试题50-第一个只出现一次的字符</a>：哈希表（想到了思路，但不会写代码。第二遍没有想出来是两遍遍历）</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题12-矩阵中的路径(BFS)</a>：回溯（能想到思路，代码不是很熟，第二遍代码仍然有问题，建议练习）</p><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">面试题13-机器人的运动范围(DFS)</a>：回溯（代码不是很熟练）</p><h2 id="具体算法类题目"><a href="#具体算法类题目" class="headerlink" title="具体算法类题目"></a>具体算法类题目</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof" target="_blank" rel="noopener">面试题10-1-斐波拉契数列</a>：循环、递归（没有想到数字溢出的情况，第二遍仍然没有考虑到）</p><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">面试题10-2-青蛙跳台阶问题</a>：循环、递归（掌握）</p><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">面试题04-二维数组中的查找</a>：右上角开始（能想到思路，但是代码不太会写）</p><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">面试题11-旋转数组的最小数字</a>：二分查找（思路也不是最优解，写出来的代码未完全覆盖所有测试用例）</p><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">面试题53-1-在排序数组中查找数字 I</a>：二分查找（能想到思路，建议练习，注意）</p><p><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题53-II-0～n-1中缺失的数字</a>：二分查找（能想到思路，但是没有注意到缺失数字在数组末尾的情况，第二遍仍然没有注意到，建议练习）</p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">面试题38-字符串的排列</a>：递归（能想到思路，建议练习）</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">面试题42-连续子数组的最大和</a>：DP（掌握，但不知道方法是DP）</p><p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">面试题19-正则表达式匹配</a>：递归（未想到思路，第二遍思路仍然不清晰，建议练习）</p><p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">面试题47-礼物的最大价值</a>：DP（没写出来递推公式）</p><p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题48-最长不含重复字符的子字符串</a>：DP（有思路但没想到转换为公式）</p><p><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">面试题60-n个骰子的点数</a>：DP（没想出来状态表达式，且代码容易写错）</p><h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">面试题14-I-剪绳子</a>：贪婪算法（没有想到思路）</p><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">面试题14-II-剪绳子</a>：贪婪算法（没有想到思路，第二遍不会解决大数问题，建议练习）</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题12-矩阵中的路径(BFS)</a>：回溯（能想到思路，代码不是很熟）</p><p><a href>面试题13-机器人的运动范围(DFS)</a>：回溯（代码不是很熟练）</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51-数组中的逆序对</a>：归并排序（只想到了暴力求解的方法，经典建议练习）</p><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">面试题53-I-在排序数组中查找数字 I</a>：二分查找</p><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40-最小的K个数</a>：最小堆（没有想起来思路）</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">面试题15-二进制中1的个数</a>：位运算（没有考虑到n&amp;n-1）</p><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof" target="_blank" rel="noopener">面试题16-数值的整数次方</a>：位运算（没有想到最优解，且测试用例想的不齐全，第二遍没有想到递归）</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56-1-数组中数字出现的次数</a>：异或性质（没有想到最优解）</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">面试题56-2-数组中数字出现的次数 II</a>：位运算（没有想到这个思路，第二遍仍然没有想出来解法）</p><p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">面试题65-不用加减乘除做加法</a>：位运算（没有想到思路，且没有考虑到负数的情况，第二遍仍然没有考虑到）</p><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题03-数组中重复的数字</a>：元素交换（只想到基于map的思路，不是最优解）</p><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05-替换空格</a>：从后向前移位（有思路，但是代码写的有问题）</p><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">面试题17-打印从1到最大的n位数</a>：大数问题（代码写的有问题，第二遍代码仍然不熟悉）</p><p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题20-表示数值的字符串</a>：主要考察代码的完整性（思路不是很清晰）</p><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">面试题21-调整数组顺序使奇数位于偶数前面</a>：（有思路，但是写出来的代码不是最优的）</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39-数组中出现次数超过一半的数字</a>：（只想到基于map的思路，不是最优解）</p><p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题43- 1～n整数中1出现的次数</a>：一位一位的按照当前值为<code>0,1,其他</code>计算1出现次数（没有想到最优解，第二遍仍然没有想到最优解）</p><p><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题44-数字序列中某一位的数字</a>：找规律（能想到思路，但是无法正确转换为代码，第二遍仍是，建议练习）</p><p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof" target="_blank" rel="noopener">面试题45-把数组排成最小的数</a>：自定义排序（思路有，但无法转换为具体的公式，第二遍不会使用C++自定义排序）</p><p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题46-把数字翻译成字符串</a>：循环（思路和官方思路稍有不同）</p><p><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">面试题49-丑数</a>：空间换时间（没有理解题意，第二遍仍然没有写出来代码）</p><p><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">面试题57-1-和为s的两个数字</a>：双指针（掌握）</p><p><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">面试题57-2-和为S的连续正数序列</a>：前后指针（没有写出来最优解，第二遍没有写出来简便代码，建议练习）</p><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题58-2-左旋转字符串</a>：字符翻转（使用C++ string字符串切割拼接更简单，第二遍仍然没有写出来简单代码）</p><p><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">面试题61-扑克牌中的顺子</a>：0的个数与中间元素的个数（没有抽象出具体问题，第二遍没有注意到相等的情况）</p><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62-圆圈中最后剩下的数</a>：约瑟夫环（没有推出递推公式，第二遍仍然没有思路，建议练习）</p><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">面试题63-股票的最大利润</a>：抽象建模（掌握）</p><p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">面试题64-求1+2+…+n</a>：发散思维（没有想法方法，第二遍仍然没有想到思路）</p><p><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">面试题66-构建乘积数组</a>：矩阵（没有想到简便方法，建议练习）</p><p><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">面试题67-把字符串转换成整数</a>：考虑问题的全面性、<code>isdigit</code>的使用（没有想到简洁代码的写法，第二遍没有想到函数库的使用）</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>每道题都要知道<strong>最优思路</strong></li><li>要会写<strong>结构体的定义和主函数</strong></li><li>每个算法都要<strong>分析时间、空间复杂度；想到所有的测试用例</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近快要面试了，再刷一遍剑指Offer，看大家分享刷LeetCode和剑指Offer的时候都是有模板的，如果按照随机顺序刷，很容易忘记而且不容易总结刷题思路。所以常常把一类题放到一块一起刷。&lt;/p&gt;
&lt;p&gt;《剑指Offer》有如下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很可能在面试中出现原题（至少在微软面试经常能遇到原题）&lt;/li&gt;
&lt;li&gt;题量少，但是涵盖的内容较全，性价比较高&lt;/li&gt;
&lt;li&gt;能培养一个良好的刷题习惯&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题目较少，&lt;strong&gt;刷着容易过拟合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;动态规划的题比较少，因此需要在力扣上专项训练。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="DataStructureAlgorithm" scheme="https://www.zdaiot.com/categories/DataStructureAlgorithm/"/>
    
    
      <category term="数据结构" scheme="https://www.zdaiot.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://www.zdaiot.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库常见用法</title>
    <link href="https://www.zdaiot.com/C/%E8%AF%AD%E6%B3%95/C++%E6%A0%87%E5%87%86%E5%BA%93%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    <id>https://www.zdaiot.com/C/语法/C++标准库常见用法/</id>
    <published>2020-07-08T09:20:17.000Z</published>
    <updated>2020-07-08T09:20:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在刷leetcode的时候，经常要用到标准库，这里总结一下标准库的常见用法，用于查询使用。</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>queue模板类的定义在<code>&lt;queue&gt;</code>头文件中。只能在容器的末尾添加新元素，只能从头部移除元素。</p><p>与stack模板类很相似，queue模板类也需要两个模板参数，一个是元素类型，一个容器类型，元素类型是必要的，容器类型是可选的，默认为deque类型。</p><p>定义queue对象的示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">double</span>&gt; q2;</span><br></pre></td></tr></table></figure><p>queue的基本操作有：</p><ol><li>入队，如<code>q.push(x);</code> 将x接到队列的末端</li><li>出队，如<code>q.pop();</code> 弹出队列的第一个元素，注意，并不会返回被弹出元素的值</li><li>访问队首元素，如<code>q.front();</code> 即最早被压入队列的元素</li><li>访问队尾元素，如<code>q.back();</code> 即最后被压入队列的元素</li><li>判断队列空，如<code>q.empty();</code> 当队列空时，返回true</li><li>访问队列中的元素个数，如<code>q.size();</code></li></ol><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector模板类的定义在<code>&lt;vector&gt;</code>头文件中。</p><p>定义vector对象的示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v2;</span><br><span class="line"><span class="comment">//初始化size,但每个元素值为默认值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; abc(<span class="number">10</span>);    <span class="comment">//初始化了10个默认值为0的元素</span></span><br><span class="line"><span class="comment">//初始化size,并且设置初始值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cde(<span class="number">10</span>，<span class="number">1</span>);    <span class="comment">//初始化了10个值为1的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>vector的基本操作有：</p><ol><li><p>尾部插入数字：<code>vec.push_back(a);</code></p></li><li><p>使用下标访问元素：<code>cout&lt;&lt;vec[0]&lt;&lt;endl;</code> 记住下标是从0开始的。</p></li><li><p>使用迭代器访问元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>插入元素：<code>vec.insert(vec.begin()+i,a);</code> 在第<code>i</code>个元素后面插入<code>a</code>;</p></li><li><p>删除元素：</p><p><code>vec.erase(vec.begin()+2);</code> 删除第3个元素；</p><p><code>vec.erase(vec.begin()+i,vec.end()+j);</code> 删除区间<code>[i,j-1];</code>区间从0开始</p><p><code>vec.pop_back();</code> 删除最后一个元素</p></li><li><p>向量大小：<code>vec.size();</code></p></li><li><p>得到首元素：<code>vec[0];</code> 或者<code>vec.front();</code></p></li><li><p>得到最后一个元素：<code>vec[vec.size() - 1];</code> 或者<code>vec.back();</code></p></li><li><p>清空：<code>vec.clear()</code>　　　//清空之后，<code>vec.size()</code>为０</p></li><li><p>反转：<code>reverse(vec.begin(), vec.end());</code></p></li></ol><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack模板类的定义在<code>&lt;stack&gt;</code>头文件中。</p><p>定义stack对象的示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; s2;</span><br></pre></td></tr></table></figure><p>stack的基本操作有：</p><ol><li><code>top()</code>：返回一个栈顶元素的引用，类型为 <code>T&amp;</code>。如果栈为空，返回值未定义。</li><li><code>push(const T&amp; obj)</code>：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</li><li><code>push(T&amp;&amp; obj)</code>：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</li><li><code>pop()</code>：弹出栈顶元素。</li><li><code>size()</code>：返回栈中元素的个数。</li><li><code>empty()</code>：在栈中没有元素的情况下返回 true。</li><li><code>emplace()</code>：用传入的参数调用构造函数，在栈顶生成对象。</li><li><code>swap(stack&lt;T&gt; &amp; other_stack)</code>：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。</li></ol><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是一类关联式容器。提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力。</p><p>它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。对于迭代器来说，可以修改实值，而不能修改key。</p><p>map定义在<code>&lt;map&gt;</code>头文件中。注意，STL头文件没有扩展名<code>.h</code></p><p>定义map示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;mapstring;         <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span> &gt;mapint;</span><br><span class="line"><span class="built_in">map</span>&lt;sring, <span class="keyword">char</span>&gt;mapstring;         <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;mapchar;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mapchar;            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;mapint；</span><br></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; maplive;  </span><br><span class="line">maplive.insert(pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;(<span class="number">102</span>,<span class="string">"aclive"</span>));</span><br><span class="line">maplive.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::value_type(<span class="number">321</span>,<span class="string">"hai"</span>));</span><br><span class="line">maplive[<span class="number">112</span>]=<span class="string">"April"</span>;<span class="comment">//map中最简单最常用的插入添加！</span></span><br></pre></td></tr></table></figure><p>map中元素的查找： find()函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span> &gt;::iterator l_it;; </span><br><span class="line">l_it = maplive.find(<span class="number">112</span>);</span><br><span class="line"><span class="keyword">if</span>(l_it==maplive.end())</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"we do not find 112"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">l_it-&gt;second;   <span class="comment">// 注意这个地方使用的是-&gt;second</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"wo find 112"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map中元素的查找：count()函数，返回值为0或1，表示是否包含。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m.count(key)&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> null;</span><br></pre></td></tr></table></figure><p>map中元素的删除：如果删除112；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span> &gt;::iterator l_it;;   </span><br><span class="line">l_it = maplive.find(<span class="number">112</span>);</span><br><span class="line"><span class="keyword">if</span>(l_it == maplive.end())</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"we do not find 112"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">maplive.erase(l_it);  <span class="comment">//delete 112;</span></span><br></pre></td></tr></table></figure><p>map的基本操作函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">C++ Maps是一种关联式容器，包含“关键字/值”对</span><br><span class="line">begin()     返回指向<span class="built_in">map</span>头部的迭代器</span><br><span class="line">clear(）     删除所有元素</span><br><span class="line">count()     返回指定元素出现的次数</span><br><span class="line">empty()     如果<span class="built_in">map</span>为空则返回<span class="literal">true</span></span><br><span class="line">end()      返回指向<span class="built_in">map</span>末尾的迭代器</span><br><span class="line">equal_range()  返回特殊条目的迭代器对</span><br><span class="line">erase()     删除一个元素</span><br><span class="line">find()      查找一个元素</span><br><span class="line">get_allocator() 返回<span class="built_in">map</span>的配置器</span><br><span class="line">insert()     插入元素</span><br><span class="line">key_comp()    返回比较元素key的函数</span><br><span class="line">lower_bound()  返回键值&gt;=给定元素的第一个位置</span><br><span class="line">max_size()    返回可以容纳的最大元素个数</span><br><span class="line">rbegin()     返回一个指向<span class="built_in">map</span>尾部的逆向迭代器</span><br><span class="line">rend()      返回一个指向<span class="built_in">map</span>头部的逆向迭代器</span><br><span class="line">size()      返回<span class="built_in">map</span>中元素的个数</span><br><span class="line">swap()      交换两个<span class="built_in">map</span></span><br><span class="line">upper_bound()   返回键值&gt;给定元素的第一个位置</span><br><span class="line">value_comp()   返回比较元素value的函数</span><br></pre></td></tr></table></figure><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque（双端队列）是由一段一段的定量连续空间构成，可以向两端发展，因此<strong>不论在尾部或头部安插元素都十分迅速。 在中间部分安插元素则比较费时，因为必须移动其它元素。</strong></p><p>deque定义在头文件<code>deque</code>中。</p><p>定义deque如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a; <span class="comment">// 定义一个int类型的双端队列a</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>); <span class="comment">// 定义一个int类型的双端队列a，并设置初始大小为10</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>, <span class="number">1</span>); <span class="comment">// 定义一个int类型的双端队列a，并设置初始大小为10且初始值都为1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; b(a); <span class="comment">// 定义并用双端队列a初始化双端队列b</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; b(a.begin(), a.begin()+<span class="number">3</span>); <span class="comment">// 将双端队列a中从第0个到第2个(共3个)作为双端队列b的初始值</span></span><br></pre></td></tr></table></figure><p>容量函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器大小：deq.size();</span><br><span class="line">容器最大容量：deq.max_size();</span><br><span class="line">更改容器大小：deq.resize();</span><br><span class="line">容器判空：deq.empty();</span><br><span class="line">减少容器大小到满足元素所占存储空间的大小：deq.shrink_to_fit();</span><br></pre></td></tr></table></figure><p>添加函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">头部添加元素：deq.push_front(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">末尾添加元素：deq.push_back(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">任意位置插入一个元素：deq.insert(iterator it, <span class="keyword">const</span> T&amp; x);</span><br><span class="line">任意位置插入 n 个相同元素：deq.insert(iterator it, <span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; x);</span><br><span class="line">插入另一个向量的 [forst,last] 间的数据：deq.insert(iterator it, iterator first, iterator last);</span><br></pre></td></tr></table></figure><p>删除函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">头部删除元素：deq.pop_front();</span><br><span class="line">末尾删除元素：deq.pop_back();</span><br><span class="line">任意位置删除一个元素：deq.erase(iterator it);</span><br><span class="line">删除 [first,last] 之间的元素：deq.erase(iterator first, iterator last);</span><br><span class="line">清空所有元素：deq.clear();</span><br><span class="line"></span><br><span class="line">删除键为bfff指向的元素</span><br><span class="line">cmap.erase(<span class="string">"bfff"</span>);</span><br><span class="line"> </span><br><span class="line">删除迭代器 key所指向的元素</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator key = cmap.find(<span class="string">"mykey"</span>);</span><br><span class="line"><span class="keyword">if</span>(key!=cmap.end()) &#123;</span><br><span class="line">cmap.erase(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除所有元素</span><br><span class="line">cmap.erase(cmap.begin(),cmap.end())</span><br></pre></td></tr></table></figure><p>访问函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下标访问：deq[<span class="number">1</span>]; <span class="comment">// 并不会检查是否越界</span></span><br><span class="line">at 方法访问：deq.at(<span class="number">1</span>); <span class="comment">// 以上两者的区别就是 at 会检查是否越界，是则抛出 out of range 异常</span></span><br><span class="line">访问第一个元素：deq.front();</span><br><span class="line">访问最后一个元素：deq.back();</span><br></pre></td></tr></table></figure><p>可以看到，deque 与 vector 的用法基本一致，除了以下几处不同：</p><ul><li>deque 没有 capacity() 函数，而 vector 有；</li><li>deque 有 push_front() 和 pop_front() 函数，而 vector 没有；</li><li>deque 没有 data() 函数，而 vector 有。</li></ul><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>priority_queue 容器适配器定义了一个<strong>元素有序排列</strong>的队列。默认队列头部的元素优先级最高。因为它是一个队列，所以<strong>只能访问第一个元素</strong>，这也意味着优先级最高的元素总是第一个被处理。</p><p>priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它定义了一个用来决定元素顺序的断言。因此模板类型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="keyword">typename</span> Compare=<span class="built_in">std</span>::less&lt;T&gt;&gt; class priority_queue</span><br></pre></td></tr></table></figure><p>priority_queue 实例默认有一个 vector 容器。<strong>函数对象类型 <code>less&lt;T&gt;</code> 是一个默认的排序断言（最大堆），最大的元素排在队列前面，出队的时候会出最大的元素，而入队的时候会重排</strong>，定义在头文件 function 中，决定了容器中最大的元素会排在队列前面。fonction 中定义了 <code>greater&lt;T&gt;</code>，用来作为模板的最后一个参数对元素排序，<strong>最小元素会排在队列前面，出队的时候最小的元素先出队，而入队的时候会重排</strong>。当然，如果指定模板的最巵一个参数，就必须提供另外的两个模板类型参数。</p><p>可以如下所示生成一个空的优先级队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; words; </span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; lo;  <span class="comment">// 大顶堆</span></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; hi; <span class="comment">// 小顶堆</span></span><br></pre></td></tr></table></figure><p>可以用适当类型的对象初始化一个优先级队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> wrds[] &#123; <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; words &#123; <span class="built_in">std</span>::begin(wrds), <span class="built_in">std</span>::end(wrds)&#125;; <span class="comment">// "two" "three" "one" "four"</span></span><br></pre></td></tr></table></figure><p>对 priority_queue 进行操作有一些限制：</p><ul><li><code>push(const T&amp; obj)</code>：将obj的副本放到容器的适当位置，这通常会包含一个<strong>排序</strong>操作。</li><li><code>push(T&amp;&amp; obj)</code>：将obj放到容器的适当位置，这通常会包含一个<strong>排序</strong>操作。</li><li><code>emplace(T constructor a rgs...)</code>：通过调用传入参数的构造函数，在序列的适当位置构造一个T对象。为了维持优先顺序，通常需要一个<strong>排序</strong>操作。</li><li><code>top()</code>：返回优先级队列中第一个元素的引用。</li><li><code>pop()</code>：移除第一个元素。</li><li><code>size()</code>：返回队列中元素的个数。</li><li><code>empty()</code>：如果队列为空的话，返回true。</li><li><code>swap(priority_queue&lt;T&gt;&amp; other)</code>：和参数的元素进行交换，所包含对象的类型必须相同。</li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。应该注意的是set中数元素的值不能直接被改变。</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>下面是一个使用 insert() 的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt;&gt; words &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> pr1 = words.insert(<span class="string">"four"</span>);</span><br><span class="line"><span class="keyword">auto</span> pr2 = words.insert (<span class="string">"two"</span>) ;</span><br><span class="line"><span class="keyword">auto</span> iter3 = words.insert(pr.first, <span class="string">"seven"</span>);</span><br><span class="line">words.insert (&#123; <span class="string">"five"</span>,<span class="string">"six"</span>&#125;) ;</span><br><span class="line"><span class="built_in">string</span> wrds[] &#123;<span class="string">"eight"</span>, <span class="string">"nine"</span>, <span class="string">"ten"</span>&#125;;</span><br><span class="line">words.insert(<span class="built_in">std</span>::begin(wrds) , <span class="built_in">std</span>::end(wrds));</span><br></pre></td></tr></table></figure><p>插入单个元素会返回一个 <code>pair&lt;iterator，bool&gt;</code> 对象。插入单个元素和一个标识，会返回一个迭代器。插入一段元素或一个初始化列表就不会有返回值。当 insert() 的参数是初始化列表时，会用列表中的字符串创建 string 对象。下面是两个在 set 容器中创建元素的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&gt; names;</span><br><span class="line"><span class="keyword">auto</span> pr = names.emplace(<span class="string">"Lisa"</span>, <span class="string">"Carr"</span>);</span><br><span class="line"><span class="keyword">auto</span> iter = names.emplace_hint(pr.first, <span class="string">"Joe"</span>, <span class="string">"King"</span>);</span><br></pre></td></tr></table></figure><p>这和 map 一样。成员函数 emplace() 会返回一个 pair<iterator,bool> 对象，而 emplace_hint() 只返回一个迭代器。前者的参数被直接传入元素的构造函数，用来创建元素。emplace_hint() 的第一个参数是一个迭代器，它指出了元素可能的插入位置，随后的参数会被传入元素的构造函数。</iterator,bool></p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>成员函数 clear() 会删除 set 的所有元素。成员函数 erase() 会删除迭代器指定位置的元素或与对象匹配的元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; numbers &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = numbers.erase(++<span class="built_in">std</span>::begin(numbers));</span><br><span class="line"><span class="keyword">auto</span> n = numbers.erase(<span class="number">12</span>);</span><br><span class="line">n = numbers.erase(<span class="number">13</span>);</span><br><span class="line">numbers.clear();</span><br></pre></td></tr></table></figure><p>成员函数 erase() 可以删除一段元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; numbers &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter1 = <span class="built_in">std</span>::begin(numbers); <span class="comment">// iter1 points to 1st element</span></span><br><span class="line">advance(iterl, <span class="number">5</span>); <span class="comment">// Points to 6th element-12</span></span><br><span class="line"><span class="keyword">auto</span> iter = numbers.erase(++<span class="built_in">std</span>:rbegin(numbers), iter1);<span class="comment">// Remove 2nd to 5th inclusive. iter points to 12</span></span><br></pre></td></tr></table></figure><p>如果 set 没有元素，成员函数 empty() 返回 true，成员函数 size() 返回它所包含的元素个数。如果担心无法在 set 中存储尽可能多的元素，可以调用成员函数 max_size() 来得到可存储的最大元素个数，这显然会是一个很大的值。</p><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>set 的成员函数 find() 会返回一个和参数匹配的元素的迭代器。如果对象不在 set 中，会返回一个结束迭代器。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; words &#123;<span class="string">"one"</span>, <span class="string">"two"</span>,<span class="string">"three"</span>, <span class="string">"four"</span>,<span class="string">"five"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = words.find (<span class="string">"one"</span>) ; <span class="comment">// iter points to "one"</span></span><br><span class="line">iter = words.find(<span class="built_in">string</span>&#123;<span class="string">"two"</span>&#125;);   <span class="comment">// iter points to "two"</span></span><br><span class="line">iter = words.find (<span class="string">"six"</span>);   <span class="comment">// iter is std:: end (words)</span></span><br></pre></td></tr></table></figure><p>调用成员函数 <code>count()</code> 可以返回指定键所对应的元素个数，返回值通常是 0 或 1，因为 set 容器中的元素是唯一的。set 容器模板定义了成员函数 equal_range()、lower_bound()、 upper_bound()，这和 multiset 容器在很大程度上是一致的。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>这个知识点不应该放在这里，但是我想把这篇文章当成是刷LeetCode时的查阅语法的地方，所以就姑且放在这里吧。</p><p>要访问<strong>顺序容器和关联容器</strong>中的元素，需要通过“迭代器（iterator）”进行。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，<strong>迭代器和指针类似。</strong></p><p>迭代器按照定义方式分成以下四种。</p><p>1) 正向迭代器，定义方法：<code>容器类名::iterator 迭代器名;</code></p><p>2) 常量正向迭代器，定义方法：<code>容器类名::const_iterator 迭代器名;</code></p><p>3) 反向迭代器，定义方法：<code>容器类名::reverse_iterator 迭代器名;</code></p><p>4) 常量反向迭代器，定义方法：<code>容器类名::const_reverse_iterator 迭代器名;</code></p><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li></ul><p>以下是不同容器对应的迭代器功能。</p><div class="table-container"><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set / multiset</td><td>双向</td></tr><tr><td>map / multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table></div><p>值得注意的有如下几点：</p><ol><li>双向迭代器不支持用“&lt;”进行比较</li><li>不支持随机访问的迭代器不能使用下标访问元素</li><li><code>.end()</code>得到的迭代器指向最后一个元素的下一个元素</li><li>判断一个容器是不是为空，若想用迭代器的用法，建议使用<code>vec.begin() == vec.end()</code>，不要使用<code>*vec.begin() == NULL</code>，会报错</li></ol><p>例如，vector 的迭代器是随机迭代器，因此遍历 vector 容器有以下几种做法。下面的程序中，每个循环演示了一种做法。</p><p>【实例】遍历 vector 容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">100</span>); <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size() ; ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i != v.end (); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i &lt; v.end ();++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    i = v.begin();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v.end()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 "+= 整数"  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i!=v.end(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i&lt;v.end(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p><strong>因为双向迭代器不支持用“&lt;”进行比较。以下代码也不合法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><p><strong>因为 list 不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</strong></p><p>在 C++中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string定义在头文件<code>string</code>中。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>string可以采用如下方式<strong>定义</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">()</span></span>;  <span class="comment">// si = ""</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;  <span class="comment">// s2 = "Hello"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">4</span>, <span class="string">'K'</span>)</span></span>;  <span class="comment">// s3 = "KKKK"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">"12345"</span>, <span class="number">1</span>, <span class="number">3</span>)</span></span>;  <span class="comment">//s4 = "234"，即 "12345" 的从下标 1 开始，长度为 3 的子串</span></span><br></pre></td></tr></table></figure><p>以下将从字符串下标 n 开始、长度为 m 的字符串称为<code>子串(n, m)</code>。</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>对 string 对象<strong>赋值</strong>：</p><ol><li><p>可以用 <code>char*</code> 类型的变量、常量，以及 char 类型的变量、常量对 string 对象进行赋值。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line">s1 = <span class="string">"Hello"</span>;  <span class="comment">// s1 = "Hello"</span></span><br><span class="line">s2 = <span class="string">'K'</span>;  <span class="comment">// s2 = "K”</span></span><br></pre></td></tr></table></figure></li><li><p>string 类还有 assign 成员函数，可以用来对 string 对象赋值。assign 成员函数返回对象自身的引用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1("12345"), s2;</span><br><span class="line">s3.assign(s1);  <span class="comment">// s3 = s1</span></span><br><span class="line">s2.assign(s1, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s2 = "23"，即 s1 的子串(1, 2)</span></span><br><span class="line">s2.assign(<span class="number">4</span>, <span class="string">'K'</span>);  <span class="comment">// s2 = "KKKK"</span></span><br><span class="line">s2.assign(<span class="string">"abcde"</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s2 = "cde"，即 "abcde" 的子串(2, 3)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> c = s[<span class="number">0</span>]; <span class="comment">// 按下标访问得到的char</span></span><br><span class="line"><span class="keyword">char</span> *cc = s.c_str(); <span class="comment">// string转为char*</span></span><br></pre></td></tr></table></figure><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>求字符串的<strong>长度</strong>：length 成员函数返回字符串的长度。size 成员函数可以实现同样的功能。</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>string对象中字符串的<strong>连接</strong>：除了可以<strong>使用<code>+</code>和<code>+=</code>运算符</strong>对 string 对象执行字符串的连接操作外，string 类还有 append 成员函数，可以用来向字符串后面添加内容。append 成员函数返回对象自身的引用。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1("123"), s2("abc");</span><br><span class="line">s1.append(s2);  <span class="comment">// s1 = "123abc"</span></span><br><span class="line">s1.append(s2, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s1 = "123abcbc"</span></span><br><span class="line">s1.append(<span class="number">3</span>, <span class="string">'K'</span>);  <span class="comment">// s1 = "123abcbcKKK"</span></span><br><span class="line">s1.append(<span class="string">"ABCDE"</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s1 = "123abcbcKKKCDE"，添加 "ABCDE" 的子串(2, 3)</span></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>除了可以用 &lt;、&lt;=、==、!=、&gt;=、&gt; 运算符比较 string 对象外，string 类还有 compare 成员函数，可用于比较字符串。compare 成员函数有以下返回值：</p><ul><li>小于 0 表示当前的字符串小；</li><li>等于 0 表示两个字符串相等；</li><li>大于 0 表示另一个字符串小。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s1("hello"), s2("hello, world");</span><br><span class="line"><span class="keyword">int</span> n = s1.compare(s2);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, s2, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">//比较s1的子串 (1,2) 和s2的子串 (0,3)</span></span><br><span class="line">n = s1.compare(<span class="number">0</span>, <span class="number">2</span>, s2);  <span class="comment">// 比较s1的子串 (0,2) 和 s2</span></span><br><span class="line">n = s1.compare(<span class="string">"Hello"</span>);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"Hello"</span>);  <span class="comment">//比较 s1 的子串(1,2)和"Hello”</span></span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"Hello"</span>, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//比较 s1 的子串(1,2)和 "Hello" 的子串(1,2)</span></span><br></pre></td></tr></table></figure><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>swap 成员函数可以交换两个 string 对象的内容。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"West”), s2("</span>East<span class="string">");</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">s1.swap(s2);  // s1 = "</span>East<span class="string">"，s2 = "</span>West<span class="string">"</span></span></span></span><br></pre></td></tr></table></figure><h3 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h3><p>substr 成员函数可以用于求子串 (n, m)，原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="built_in">string</span>::npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>调用时，如果省略 m 或 m 超过了字符串的长度，则求出来的子串就是从下标 n 开始一直到字符串结束的部分。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"this is ok"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1.substr(<span class="number">2</span>, <span class="number">4</span>);  <span class="comment">// s2 = "is i"</span></span><br><span class="line">s2 = s1.substr(<span class="number">2</span>);  <span class="comment">// s2 = "is is ok"</span></span><br></pre></td></tr></table></figure><h3 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h3><p>insert 成员函数可以在 string 对象中插入另一个字符串，返回值为对象自身的引用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1("Limitless"), s2("00");</span><br><span class="line">s1.insert(<span class="number">2</span>, <span class="string">"123"</span>);  <span class="comment">//在下标 2 处插入字符串"123"，s1 = "Li123mitless"</span></span><br><span class="line">s1.insert(<span class="number">3</span>, s2);  <span class="comment">//在下标 2 处插入 s2 , s1 = "Li10023mitless"</span></span><br><span class="line">s1.insert(<span class="number">3</span>, <span class="number">5</span>, <span class="string">'X'</span>);  <span class="comment">//在下标 3 处插入 5 个 'X'，s1 = "Li1XXXXX0023mitless"</span></span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">s.push_back(<span class="string">'w'</span>);</span><br><span class="line">s.resize(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="格式互转"><a href="#格式互转" class="headerlink" title="格式互转"></a>格式互转</h2><h3 id="转int"><a href="#转int" class="headerlink" title="转int"></a>转int</h3><p>C语言转换形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> i = atoi(str.c_str()); <span class="comment">// 不做范围检查，超出上界，则输出上界，超出下界，则输出下界；</span></span><br></pre></td></tr></table></figure><p>C++转换形式(C++11)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">std</span>::stoi(str); <span class="comment">//会做范围检查，超过范围会报错</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/msdnwolaile/article/details/52708144" target="_blank" rel="noopener">C++ vector用法（详解！！函数，实现）</a><br><a href="https://blog.csdn.net/wangshihui512/article/details/8930652" target="_blank" rel="noopener">C++ 标准模板库STL 队列 queue 使用方法与应用介绍（一）</a><br><a href="http://c.biancheng.net/view/478.html" target="_blank" rel="noopener">C++ stack(STL stack)用法详解</a><br><a href="https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html" target="_blank" rel="noopener">C++ map用法</a><br><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html" target="_blank" rel="noopener">C++中的STL中map用法详解</a><br><a href="http://c.biancheng.net/view/338.html" target="_blank" rel="noopener">C++迭代器（STL迭代器）iterator详解</a><br><a href="http://c.biancheng.net/view/479.html" target="_blank" rel="noopener">C++ queue(STL queue)用法详解</a><br><a href="https://www.cnblogs.com/linuxAndMcu/p/10260124.html" target="_blank" rel="noopener">[C++ STL] deque使用详解</a><br><a href="https://blog.csdn.net/dongyanxia1000/article/details/52838922" target="_blank" rel="noopener">vector删除元素之pop_back(),erase(),remove()</a><br><a href="http://c.biancheng.net/view/480.html" target="_blank" rel="noopener">C++ priority_queue(STL priority_queue)用法详解</a><br><a href="https://blog.csdn.net/tengfei461807914/article/details/52203202" target="_blank" rel="noopener">C++ string的用法和例子</a><br><a href="http://c.biancheng.net/view/400.html" target="_blank" rel="noopener">C++ string类（C++字符串）完全攻略</a><br><a href="http://c.biancheng.net/view/538.html" target="_blank" rel="noopener">C++ set添加、删除和访问(STL set添加、删除和访问)元素详解</a><br><a href="https://blog.csdn.net/weixin_36888577/article/details/79937886" target="_blank" rel="noopener">c++优先队列(priority_queue)用法详解</a><br><a href="https://blog.csdn.net/qq_33221533/article/details/82119031" target="_blank" rel="noopener">c++中的atoi()和stoi()函数的用法和区别</a><br><a href="https://blog.csdn.net/caroline_wendy/article/details/29390573" target="_blank" rel="noopener">C++ - string类型转换int类型</a><br><a href="https://blog.csdn.net/wangjingqi930330/article/details/81938998" target="_blank" rel="noopener">c++ map查找key</a><br><a href="https://blog.csdn.net/yjunyu/article/details/77728410" target="_blank" rel="noopener">vector的几种初始化及赋值方式</a><br><a href="https://blog.csdn.net/zvall/article/details/52267007" target="_blank" rel="noopener">c++ map删除元素的三种方式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在刷leetcode的时候，经常要用到标准库，这里总结一下标准库的常见用法，用于查询使用。&lt;/p&gt;
&lt;h2 id=&quot;queue&quot;&gt;&lt;a href=&quot;#queue&quot; class=&quot;headerlink&quot; title=&quot;queue&quot;&gt;&lt;/a&gt;queue&lt;/h2&gt;&lt;p&gt;queue模板类的定义在&lt;code&gt;&amp;lt;queue&amp;gt;&lt;/code&gt;头文件中。只能在容器的末尾添加新元素，只能从头部移除元素。&lt;/p&gt;
&lt;p&gt;与stack模板类很相似，queue模板类也需要两个模板参数，一个是元素类型，一个容器类型，元素类型是必要的，容器类型是可选的，默认为deque类型。&lt;/p&gt;
&lt;p&gt;定义queue对象的示例代码如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.zdaiot.com/categories/C/"/>
    
      <category term="语法" scheme="https://www.zdaiot.com/categories/C/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="C++" scheme="https://www.zdaiot.com/tags/C/"/>
    
      <category term="queue" scheme="https://www.zdaiot.com/tags/queue/"/>
    
      <category term="vector" scheme="https://www.zdaiot.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>目标检测评价指标</title>
    <link href="https://www.zdaiot.com/DeepLearningApplications/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>https://www.zdaiot.com/DeepLearningApplications/目标检测/目标检测评价指标/</id>
    <published>2020-07-07T06:54:08.000Z</published>
    <updated>2020-07-07T06:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>mAP: mean Average Precision，即各类别AP的平均值</p><p>AP: PR曲线下面积，后文会详细讲解</p><p>PR曲线: Precision-Recall曲线</p><p>Precision: TP / (TP + FP)</p><p>Recall: TP / (TP + FN)</p><p>TP: IoU&gt;0.5的检测框数量（同一Ground Truth只计算一次）</p><p>FP: IoU&lt;=0.5的检测框，或者是检测到同一个GT的多余检测框的数量</p><p>FN: 没有检测到的GT的数量</p><p>注意：<strong>一般来说mAP针对整个数据集而言的；AP针对数据集中某一个类别而言的；而percision和recall针对单张图片某一类别的。</strong></p><h2 id="mAP的具体计算"><a href="#mAP的具体计算" class="headerlink" title="mAP的具体计算"></a>mAP的具体计算</h2><p>由前面定义，我们可以知道，要计算mAP必须先绘出各类别PR曲线，计算出AP。而如何采样PR曲线，VOC采用过两种不同方法。参见：<a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/htmldoc/devkit_doc.html#SECTION00044000000000000000" target="_blank" rel="noopener">The PASCAL Visual Object Classes Challenge 2012 (VOC2012) Development Kit</a></p><ol><li><p>在VOC2010以前，只需要选取当Recall &gt;= 0, 0.1, 0.2, …, 1共11个点时的Precision最大值，然后AP就是这11个Precision的平均值。</p></li><li><p>在VOC2010及以后，需要针对每一个不同的Recall值（包括0和1），选取其大于等于这些Recall值时的Precision最大值，然后计算PR曲线下面积作为AP值。</p></li><li>COCO数据集，设定多个IOU阈值（0.5-0.95,0.05为步长），在每一个IOU阈值下都有某一类别的AP值，然后求不同IOU阈值下的AP平均，就是所求的最终的某类别的AP值。</li></ol><p>下面给出<strong>某一个类别</strong>AP的计算示例：</p><p>对于多类别目标检测，首先选定一个类别，比如说<code>Aeroplane</code>类别，从检测器中筛选出<strong>这种类别的检测框（其他类别的先不管，并且这里是所有图片的结果）</strong>。假设网络有以下输出(BB表示BoundingBox序号，IoU&gt;0.5时GT=1)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BB  | confidence | GT</span><br><span class="line">----------------------</span><br><span class="line">BB1 |  0.9       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB2 |  0.9       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB1 |  0.8       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB3 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB4 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB5 |  0.7       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB6 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB7 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB8 |  0.7       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB9 |  0.7       | 1</span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure><p>这里需要注意的有如下几点：</p><ol><li>这里的confidence一般指的是分类得分，也就是预测框中物体属于<code>Aeroplane</code>类别的概率</li><li>上面各行是按照confidence进行排序的，跟后面计算时的rank对应；另外这样排序后也方便将检测到同一个GT的多余检测框去掉</li><li>这里有两个BB1，这两个并不是同一个bbox，指的是同一个GT匹配上了不同的bbox</li><li>因为percision和recall针对单张图片某一类别的。而在实际计算的时候，是将所有图片该类别的检测结果和GT放到一块计算的。</li></ol><p>因此，我们有 TP=5 (第一个BB1, BB2, BB5, BB8, BB9), FP=5 (重复检测到的BB1也算FP)。除了表里检测到的5个GT以外，我们还有2个GT没被检测到，因此: FN = 2. 这时我们就可以按照Confidence的顺序给出各处的PR值，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rank=1  precision=1.00 and recall=0.14</span><br><span class="line">----------</span><br><span class="line">rank=2  precision=1.00 and recall=0.29</span><br><span class="line">----------</span><br><span class="line">rank=3  precision=0.66 and recall=0.29</span><br><span class="line">----------</span><br><span class="line">rank=4  precision=0.50 and recall=0.29</span><br><span class="line">----------</span><br><span class="line">rank=5  precision=0.40 and recall=0.29</span><br><span class="line">----------</span><br><span class="line">rank=6  precision=0.50 and recall=0.43</span><br><span class="line">----------</span><br><span class="line">rank=7  precision=0.43 and recall=0.43</span><br><span class="line">----------</span><br><span class="line">rank=8  precision=0.38 and recall=0.43</span><br><span class="line">----------</span><br><span class="line">rank=9  precision=0.44 and recall=0.57</span><br><span class="line">----------</span><br><span class="line">rank=10 precision=0.50 and recall=0.71</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><p>对于上述PR值，如果我们采用：</p><ol><li>VOC2010之前的方法，选取$Recall &gt;= 0, 0.1, …, 1$的11处Percision的最大值：$1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, 0, 0$。此时<code>Aeroplane</code>类别的 $AP = 5.5 / 11 = 0.5$</li><li>VOC2010及以后的方法，对于$Recall &gt;= 0, 0.14, 0.29, 0.43, 0.57, 0.71, 1$，选取此时Percision的最大值：$1, 1, 1, 0.5, 0.5, 0.5, 0$。此时<code>Aeroplane</code>类别的 $AP = (0.14-0)<em>1 + (0.29-0.14)</em>1 + (0.43-0.29)<em>0.5 + (0.57-0.43)</em>0.5 + (0.71-0.57)<em>0.5 + (1-0.71)</em>0 = 0.5$</li><li>COCO数据集，设定多个IOU阈值（0.5-0.95,0.05为步长），在每一个IOU阈值下都有某一类别的AP值，然后求不同IOU阈值下的AP平均，就是所求的最终的某类别的AP值。</li></ol><p><strong>mAP就是对每一个类别都计算出AP然后再计算AP平均值就好了</strong>。</p><p>建议参考GluonCV库里面的voc_detection.py实现了两种mAP计算方式，思路清晰：<a href="https://github.com/dmlc/gluon-cv/blob/master/gluoncv/utils/metrics/voc_detection.py" target="_blank" rel="noopener">https://github.com/dmlc/gluon-cv/blob/master/gluoncv/utils/metrics/voc_detection.py</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/53405779/answer/419532990" target="_blank" rel="noopener">目标检测中的mAP是什么含义？ - Wentao的回答 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/70306015" target="_blank" rel="noopener">目标检测的性能评价指标</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;mAP: mean Average Precision，即各类别AP的平均值&lt;/p&gt;
&lt;p&gt;AP: PR曲线下面积，后文会详细讲解&lt;/p&gt;
&lt;p&gt;PR曲线: Precision-Recall曲线&lt;/p&gt;
&lt;p&gt;Precision: TP / (TP + FP)&lt;/p&gt;
    
    </summary>
    
    
      <category term="DeepLearningApplications" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/"/>
    
      <category term="目标检测" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="评价指标" scheme="https://www.zdaiot.com/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
      <category term="目标检测" scheme="https://www.zdaiot.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="mAP" scheme="https://www.zdaiot.com/tags/mAP/"/>
    
  </entry>
  
  <entry>
    <title>TensorRT INT8量化原理</title>
    <link href="https://www.zdaiot.com/MLFrameworks/TensorRT/TensorRT%20INT8%E9%87%8F%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    <id>https://www.zdaiot.com/MLFrameworks/TensorRT/TensorRT INT8量化原理/</id>
    <published>2020-07-07T01:02:31.000Z</published>
    <updated>2020-07-07T01:02:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要参考了<a href="https://arleyzhang.github.io/articles/923e2c40/" target="_blank" rel="noopener">TensorRT(5)-INT8校准原理</a>，并添加了一些自己的见解。</p><h2 id="Low-Precision-Inference"><a href="#Low-Precision-Inference" class="headerlink" title="Low Precision Inference"></a>Low Precision Inference</h2><p>现有的深度学习框架，如Pytorch、Tensorflow在训练一个深度神经网络时，往往都会使用 <strong>float 32（Full Precise ，简称FP32）</strong>的数据精度来表示，权值、偏置、激活值等。若一个网络很深的话，比如像VGG，ResNet这种，网络参数是极其多的，计算量就更多了（比如VGG 19.6 billion FLOPS, ResNet-152 11.3 billion FLOPS）。如果多的计算量，如果都采用FP32进行推理，对于嵌入式设备来说计算量是不能接受的。解决此问题主要有两种方案：</p><ol><li>模型压缩、剪枝。在这里不做讨论。</li><li>在部署推理时（inference）使用低精度数据，比如INT8。当然训练的时候仍然采取FP32的精度。</li></ol><p><strong>下面从经验上分析低精度推理的可行性。</strong></p><p>实际上有些人认为，即便在推理时使用低精度的数据（比如INT8），在提升速度的同时，也并不会造成太大的精度损失，比如 <a href="https://petewarden.com/2015/05/23/why-are-eight-bits-enough-for-deep-neural-networks/" target="_blank" rel="noopener">Why are Eight Bits Enough for Deep Neural Networks?</a> 以及<a href="https://towardsdatascience.com/low-precision-inference-with-tensorrt-6eb3cda0730b" target="_blank" rel="noopener">Low Precision Inference with TensorRT</a> 这两篇博文。</p><p>文章的作者认为网络在训练的过程中学习到了数据样本的模式可分性，同时由于数据中存在的噪声，使得网络具有较强的鲁棒性，也就是说在输入样本中做轻微的变动并不会过多的影响性能。与图像上目标间的位置、姿态、角度等变化相比，这些噪声引进的变动只是很少的一部分。但实际上这些噪声引进的变动同样会使各个层的激活值输出发生变动，然而却对结果影响不大，也就是说<strong>训练好的网络对这些噪声具有一定的容忍度（tolerance ）。</strong></p><p>正是由于在训练过程中使用高精度（FP32）的数值表示，才使得网络具有一定的容忍度。训练时使用高精度的数值表示，可以使得网络在每一步训练都会对参数进行少量的修正，这在网络最后收敛的时候是很重要的，因为收敛的时候要求修正量很小很小（一般训练初始 阶段学习率稍大，越往后学习率越小）。</p><p>那么<strong>如果使用低精度的数据来表示网络参数以及中间值的话，势必会存在误差，这个误差某种程度上可以认为是一种噪声</strong>。那也就是说，<strong>使用低精度数据引进的差异是在网络的容忍度之内的</strong>，所以对结果不会产生太大影响。</p><p>以上分析都是基于经验的，理论上的分析比较少，不过文章提到了两篇 paper，如下：</p><ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/37631.pdf" target="_blank" rel="noopener">Improving the speed of neural networks on CPUs</a></li><li><a href="https://arxiv.org/abs/1412.7024" target="_blank" rel="noopener">Training deep neural networks with low precision multiplications</a></li></ul><p>感兴趣的同学可以自行研究。</p><p>TensorRT 的INT8模式只支持计算能力为6.1的GPU（Compute Capability 6.1 ），比如： GP102 (Tesla P40 and NVIDIA Titan X), GP104 (<a href="https://devblogs.nvidia.com/parallelforall/new-pascal-gpus-accelerate-inference-in-the-data-center/" target="_blank" rel="noopener">Tesla P4</a>), and GP106 GPUs，主要根源是这些<strong>GPU支持 DP4A硬件指令</strong>。DP4A下面会稍微介绍一下。</p><h2 id="TensorRT-INT8-Inference"><a href="#TensorRT-INT8-Inference" class="headerlink" title="TensorRT INT8 Inference"></a>TensorRT INT8 Inference</h2><p>首先看一下不同精度的动态范围：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">动态范围</th><th style="text-align:left">最小正数</th></tr></thead><tbody><tr><td style="text-align:left">FP32</td><td style="text-align:left">$−3.4×10^{38} +3.4×10^{38}$</td><td style="text-align:left">$1.4×10^{−45}$</td></tr><tr><td style="text-align:left">FP16</td><td style="text-align:left">$−65504 +65504$</td><td style="text-align:left">$5.96×10^{−8}$</td></tr><tr><td style="text-align:left">INT8</td><td style="text-align:left">$−128 +127$</td><td style="text-align:left">1</td></tr></tbody></table></div><p>实际上将FP32的精度降为INT8还是比较具有挑战性的。</p><h3 id="Quantization"><a href="#Quantization" class="headerlink" title="Quantization"></a>Quantization</h3><p>将FP32降为INT8的过程相当于<strong>信息再编码</strong>（re-encoding information ），就是原来使用32bit来表示一个tensor，现在使用8bit来表示一个tensor，还要求精度不能下降太多。将FP32转换为 INT8的操作需要针对<strong>每一层的输入张量（tensor）和 网络学习到的参数（learned parameters）</strong>进行。</p><p>首先能想到的最简单的映射方式就是线性映射（或称线性量化，linear quantization）, 就是说映射前后的关系满足下式：</p><script type="math/tex; mode=display">\text{FP32 Tensor (T) = scale_factor(sf) * 8-bit Tensor(t) + FP32_bias (b)}</script><p>试验证明，偏置实际上是不需要的，因此去掉偏置，也就是</p><script type="math/tex; mode=display">T = sf * t</script><p>$sf$是<strong>每一层上每一个tensor</strong>的换算系数或称比例因子（scaling factor），因此现在的问题就变成了如何确定比例因子。然后最简单的方法是下图这样的：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/no_satuation_int8_quantization.png" alt="no_satuation_int8_quantization"></p><ul><li>简单的将一个tensor 中的 $-|max|$ 和 $|max|$ FP32 value 映射为 -127 和 127 ，中间值按照线性关系进行映射。</li><li>称这种映射关系为不饱和的（No saturation，$max$很大实际模型的激活值可能取不到），对称的。</li></ul><p>但是试验结果显示这样做会导致比较大的精度损失。</p><p>下面这张图展示的是不同网络结构的不同layer的激活值分布，有卷积层，有池化层，他们之间的分布很不一样，因此<strong>合理的量化方式应该适用于不同的激活值分布，并且减小信息损失。</strong>因为从FP32到INT8其实就是一种信息再编码的过程。</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/distribution-of-different-layers.png.png" alt="1535654439553"></p><p>上图的解释有思考如下：</p><ul><li>上图是一些网络模型中间层的激活值统计，横坐标是激活值，纵坐标是统计数量的归一化表示，这里是归一化表示，不是绝对数值统计；</li><li>这个激活值统计针对的是<strong>一批图片</strong>，不同的图片输出的激活值不完全相同。所以图上并不是一条曲线而是多条曲线（一张图片对应一条曲线，或者称为散点图更好一点），只不过前面一部分重复在一块了（红色虚线圈起来的部分），说明对于<strong>不同图片生成的大部分激活值其分布是相似的</strong>；但是在激活值比较大时（红色实线圈起来的部分），曲线不重复了，一个激活值对应多个不同的统计量，这时的激活值分布就比较乱了。</li><li>后面这一部分在整个层中是占少数的（占比很小，比如10^-9, 10^-7, 10^-3），因此<strong>后面这一段完全可以不考虑到映射关系中去，保留激活值分布的主要部分</strong>。开始以为网络之所以能把不同类别的图片分开是由于后面实线部分的差异导致的，后来想了一下：这个并不包含Tensor空间位置的分布，只是数值上的分布，所以后面的应该对结果影响不大。</li></ul><p>因此TensorRT的做法是：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/satuation_int8_quantization.png" alt="satuation_int8_quantization"></p><ul><li>这种做法不是将 $±|max|$ 映射为 $±127$，而是存在一个 阈值 $|T|$ ，将 $±|T|$ 映射为±127，显然这里 $|T|&lt;|max|$。</li><li>超出 阈值 $±|T|$ 外的直接映射为阈值 $±127$。比如上图中的三个红色点，直接映射为$-127$。</li><li>称这种映射关系为<strong>饱和的（Saturate ），不对称的。</strong></li><li><strong>只要阈值选取得当，就能将分布散乱的较大的激活值舍弃掉，也就有可能使精度损失不至于降低太多。</strong></li></ul><p>网络的前向计算涉及到两部分数值：权值和激活值（weights 和activation，二者要做乘法运算，可以将激活值看作是某层的输出要和下一层的权重做乘法运算），Szymon Migacz也提到他们曾经做过实验，说对weights 做saturation变换没有什么变化，因此<strong>对于weights的INT8量化就使用的是不饱和的方式</strong>（饱和方式需要确定$|T|$，比较麻烦）；而对activation做saturation变换就有比较显著的性能提升，因此<strong>对activation使用的是饱和的量化方式</strong>。</p><p>那现在的问题是如何确定$|T|$？假设有一个FP32的tensor，FP32肯定是能够表达这个tensor的最佳分布。现在我们要用一个不同的分布（INT8）来表达这个tensor，这个INT8 分布不是一个最佳的分布。<strong>饱和的INT8分布由于阈值|T|的取值会有很多种情况（$128 \sim |max|$），其中肯定有一种情况是相对其他最接近FP32的，我们就是要把这种情况找出来。</strong></p><p>那么就<strong>需要一个衡量指标来衡量不同的INT8 分布与原来的FP3F2分布之间的差异程度。</strong>这个衡量指标就是<strong>相对熵</strong>（relative entropy），又称为<strong>KL散度</strong>（<strong>Kullback–Leibler divergence</strong>，简称<strong>KLD</strong>），信息散度（information divergence），信息增益（information gain）。叫法实在太多了，最常见的就是相对熵，跟交叉熵也是有关系的。</p><ul><li><p>假设我们要给一个信息进行完美编码，那么最短平均编码长度就是信息熵。</p></li><li><p>如果编码方案不一定完美（由于对概率分布的估计不一定正确），这时的平均编码长度就是交叉熵。</p><p>平均编码长度 = 最短平均编码长度 + 一个增量</p><p>交叉熵在深度学习中广泛使用，衡量了测试集标签分布和模型预测分布之间的差异程度。</p></li><li><p><strong>编码方法不一定完美时，平均编码长度相对于最小值的增加量（即上面那个增量）是相对熵。</strong></p></li></ul><p>即 <strong>交叉熵=信息熵+相对熵</strong></p><p>通俗的理解 信息熵，交叉熵，相对熵，参考：<a href="https://www.zhihu.com/question/41252833" target="_blank" rel="noopener">知乎：如何通俗的解释交叉熵与相对熵?</a></p><p>如何理解信息熵用来表示最短平均编码长度，参考： <a href="http://blog.csdn.net/hearthougan/article/details/77774948" target="_blank" rel="noopener">如何理解用信息熵来表示最短的平均编码长度</a></p><p>在这里，FP32的tensor就是要表达的信息量，FP32也是最佳分布（可以认为最短编码长度32bit），现在要做的是使用INT8 来编码FP32的信息，同时要求INT8编码后差异尽可能最小。考虑两个分布 P（FP32）、Q（INT8）KL散度计算如下：</p><script type="math/tex; mode=display">\text{KL_divergence(P,Q):= SUM(P[i] * log(P[i] / Q[i] ), i)}</script><p>$P，Q$分别称为reference_distribution、quantize _distribution，$i$表示第$i$层。实际上这里也说明了<strong>每一层的tensor 的$|T|$值都是不一样的。确定每一层的$|T|$值的过程称为校准（Calibration ）。</strong></p><h3 id="Calibration"><a href="#Calibration" class="headerlink" title="Calibration"></a>Calibration</h3><p>上面已经说了 <strong>KL散度越小代表INT8编码后的信息损失越少</strong>。接下来来看看如何根据KL散度寻找最佳INT8分布。其实前面也已经提到了，如果要让最后的精度损失不大，是要考虑一些先验知识的，这个先验知识就是每一层在 FP32精度下的激活值分布，只有根据这个才能找到更加合理的阈值$|T|$。也就是说首先得有一个以FP32精度训练好的模型。基本上现有的深度学习框架都是默认FP32精度的，有些模型还支持FP16精度训练。所以基本上只要没有特别设定，训练出来的模型肯定是 FP32 的。</p><p>那激活值分布如何得到？这里的做法是<strong>从验证集</strong>选取一个子集作为校准集（Calibration Dataset），校准集应该具有代表性，多样性，最好是验证集的一个子集，不应该只是分类类别的一小部分。激活值分布就是从校准集中得到的。</p><p>按照<a href="http://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#calibrationset" target="_blank" rel="noopener">NVIDIA 官方的说法</a>：</p><blockquote><p>Note: The calibration set must be representative of the input provided to TensorRT at runtime; for example, for image classification networks, it should not consist of images from just a small subset of categories. For ImageNet networks, around 500 calibration images is adequate.</p></blockquote><p>对于ImageNet 数据集来说 校准集大小一般500张图片就够了（Szymon Migacz的演讲说用1000张），这里有点怀疑也有点震惊，没想到 ImageNet 1000个分类，100多万张图片，500张就够了，不过从2.5节的图表中的结果可以看出500张确实够了。</p><p>然后要做的是：</p><ul><li>首先在校准集上进行 FP32 inference 推理；</li><li>对于<strong>网络的每一层</strong>（遍历）：<ul><li>收集这一层的激活值，并做<strong>直方图</strong>（histograms ），分成几个组别（bins）（官方给的一个说明使用的是2048组），分组是为了下面遍历|T| 时，减少遍历次数；</li><li>对于不同的阈值|T|进行遍历，因为这里|T|的取值肯定在第128-2047组之间，所以就选取每组的中间值进行遍历；<ul><li>选取使得 KL_divergence(ref_distr, quant_distr) 取得最小值的 |T|。</li></ul></li></ul></li><li>返回一系列|T|值，每一层都有一个|T|。创建 <strong>CalibrationTable</strong> 。</li></ul><p>解释一下：假设最后使得KL散度最小的|T|值是第200组的中间值，那么就把原来第0-200组的数值线性映射到0-128之间，超出范围的直接映射到128。</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/Calibration-process.png" alt="1516636471289"></p><p>校准的过程可以参考一下这个：<a href="https://www.jianshu.com/p/43318a3dc715，" target="_blank" rel="noopener">https://www.jianshu.com/p/43318a3dc715，</a> 这篇文章提供了一个详细的根据KL散度来将原始信息进行编码的例子，包括直方图的使用。跟这里的校准过程极为相像。</p><p>下面是一个官方 <a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf" target="_blank" rel="noopener">GTC2017 PPT</a> 中给的校准的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先分成 2048个组，每组包含多个数值（基本都是小数）</span></span><br><span class="line">Input: FP32 histogram H with <span class="number">2048</span> bins: bin[ <span class="number">0</span> ], …, bin[ <span class="number">2047</span> ] </span><br><span class="line">  </span><br><span class="line">For i in range( 128 , 2048 ): // |T|的取值肯定在 第128-2047 组之间,取每组的中点</span><br><span class="line">reference_distribution_P = [ bin[ <span class="number">0</span> ] , ..., bin[ i<span class="number">-1</span> ] ] <span class="comment">// 选取前 i 组构成P，i&gt;=128</span></span><br><span class="line">outliers_count = sum( bin[ i ] , bin[ i+<span class="number">1</span> ] , … , bin[ <span class="number">2047</span> ] ) <span class="comment">//边界外的组</span></span><br><span class="line">reference_distribution_P[ i<span class="number">-1</span> ] += outliers_count <span class="comment">//边界外的组加到边界P[i-1]上，没有直接丢掉</span></span><br><span class="line">P /= sum(P) <span class="comment">// 归一化</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 将前面的P（包含i个组，i&gt;=128），映射到 0-128 上，映射后的称为Q，Q包含128个组，</span></span><br><span class="line">    <span class="comment">// 一个整数是一组</span></span><br><span class="line">candidate_distribution_Q = quantize [ bin[ <span class="number">0</span> ], …, bin[ i<span class="number">-1</span> ] ] into <span class="number">128</span> levels</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时的P（包含i个组，i&gt;=128）和Q向量（包含128个组）的大小是不一样的，无法直接计算二者的KL散度</span></span><br><span class="line"><span class="comment">//因此需要将Q扩展为 i 个组，以保证跟P大小一样</span></span><br><span class="line">expand candidate_distribution_Q to ‘ i ’ bins </span><br><span class="line"></span><br><span class="line">Q /= sum(Q) <span class="comment">// 归一化</span></span><br><span class="line"><span class="comment">//计算P和Q的KL散度</span></span><br><span class="line">divergence[ i ] = KL_divergence( reference_distribution_P, candidate_distribution_Q)</span><br><span class="line">End For</span><br><span class="line"><span class="comment">//找出 divergence[ i ] 最小的数值，假设 divergence[m] 最小，</span></span><br><span class="line"><span class="comment">//那么|T|=( m + 0.5 ) * ( width of a bin )</span></span><br><span class="line">Find index ‘m’ <span class="keyword">for</span> which divergence[ m ] is minimal</span><br><span class="line">threshold = ( m + <span class="number">0.5</span> ) * ( width of a bin )</span><br></pre></td></tr></table></figure><p>解释一下第16行：</p><ul><li>计算KL散度 KL_divergence(P, Q) 时，要求序列P和Q的长度一致，即 len(P) == len(Q)；</li><li>Candidate_distribution_Q 是将 P 线性映射到 128个bins得到的，长度为128。而reference_distribution_P 包含 i （i&gt;=128）个 bins （bin[0] - bin[i-1] ），二者长度不等；</li><li>需要将 candidate_distribution_Q 扩展回 i 个bins 然后才能与 i个bins 的 reference_distribution_P计算KL散度。</li></ul><p>举个简单的例子：</p><ul><li><p>假设reference_distribution_P 包含 8 个bins（这里一个bin就只包含一个数据）:</p><p>P = [ 1, 0, 2, 3, 5, 3, 1, 7]</p></li><li><p>我们想把它映射为 2 个bins，于是 4个一组合并：</p><p>[1 + 0 + 2 + 3 , 5 + 3 + 1 + 7] = [6, 16]</p></li><li><p>然后要成比例的 扩展回到 8个组，保留原来是0的组：</p><p>Q = [ 6/3, 0, 6/3, 6/3, 16/4, 16/4, 16/4, 16/4] = [ 2, 0, 2, 2, 4, 4, 4, 4]</p></li><li><p>然后对 P和Q进行标准化：</p><p>P /= sum(P) 、Q /= sum(Q)</p></li><li><p>最后计算散度：</p><p>result = KL_divergence(P, Q)</p></li></ul><p>我们来看看 ResNet-152中 res4b30层校准前后的结果对比，图中那个白线就是|T|的取值（可能小于128，因为分成2048组是最前面的128组其值不一定大于128）：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/satuation-before-and-after.png" alt="1516638878836"></p><p>再看看其他几种网络的校准情况：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/Calibration-result1.jpg" alt="result_1"></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/Calibration-result2.jpg" alt="result_2"></p><h3 id="DP4A-Dot-Product-of-4-8-bits-Accumulated-to-a-32-bit"><a href="#DP4A-Dot-Product-of-4-8-bits-Accumulated-to-a-32-bit" class="headerlink" title="DP4A(Dot Product of 4 8-bits Accumulated to a 32-bit)"></a>DP4A(<strong>D</strong>ot <strong>P</strong>roduct of <strong>4</strong> 8-bits <strong>A</strong>ccumulated to a 32-bit)</h3><p>TensorRT 进行优化的方式是 DP4A (<strong>D</strong>ot <strong>P</strong>roduct of <strong>4</strong> 8-bits <strong>A</strong>ccumulated to a 32-bit)，如下图：</p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/DP4A.png" alt="1516642345023"></p><p>这是PASCAL 系列GPU的硬件指令，INT8卷积就是使用这种方式进行的卷积计算。这个没搞太明白是怎么回事，参考这篇博客获取详细信息<a href="https://devblogs.nvidia.com/mixed-precision-programming-cuda-8/" target="_blank" rel="noopener">Mixed-Precision Programming with CUDA 8</a>。下面是 官方 <a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf" target="_blank" rel="noopener">GTC2017 PPT</a> 中给的INT8卷积计算的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I8 input tensors: I8_input, I8_weights, INT8输入tensor</span></span><br><span class="line"><span class="comment">// I8 output tensors: I8_output， INT8输出tensor</span></span><br><span class="line"><span class="comment">// F32 bias (original bias from the F32 model),FP32的偏置</span></span><br><span class="line"><span class="comment">// F32 scaling factors: input_scale, output_scale, weights_scale[K], 这个是前面说的缩放因子sf</span></span><br><span class="line">I32_gemm_out = I8_input * I8_weights <span class="comment">// Compute INT8 GEMM (DP4A)，卷积计算，INT32输出</span></span><br><span class="line">F32_gemm_out = (<span class="keyword">float</span>)I32_gemm_out <span class="comment">// Cast I32 GEMM output to F32 float，强制转换为FP32</span></span><br><span class="line"><span class="comment">//前面计算I8_input * I8_weights时，总的缩放系数为 input_scale * weights_scale[K]</span></span><br><span class="line"><span class="comment">//但是输出的缩放系数为output_scale，所以为了保证缩放程度匹配，要将F32_gemm_out乘以 </span></span><br><span class="line"><span class="comment">//output_scale / (input_scale * weights_scale[ i ] )</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// At this point we have F32_gemm_out which is scaled by ( input_scale * weights_scale[K] ),</span></span><br><span class="line"><span class="comment">// but to store the final result in int8 we need to have scale equal to "output_scale", so we have to rescale:</span></span><br><span class="line"><span class="comment">// (this multiplication is done in F32, *_gemm_out arrays are in NCHW format)</span></span><br><span class="line">For i in <span class="number">0</span>, ... K<span class="number">-1</span>:</span><br><span class="line">rescaled_F32_gemm_out[ :, i, :, :] = F32_gemm_out[ :, i, :, :] * [ output_scale /(input_scale * weights_scale[ i ] ) ]</span><br><span class="line">  </span><br><span class="line"><span class="comment">//将FP32精度的偏置 乘上缩放因子，加到前面的计算结果中</span></span><br><span class="line"><span class="comment">// Add bias, to perform addition we have to rescale original F32 bias so that it's scaled with "output_scale"</span></span><br><span class="line">rescaled_F32_gemm_out _with_bias = rescaled_F32_gemm_out + output_scale * bias</span><br><span class="line"><span class="comment">//ReLU 激活</span></span><br><span class="line"><span class="comment">// Perform ReLU (in F32)</span></span><br><span class="line">F32_result = ReLU(rescaled_F32_gemm_out _with_bias)</span><br><span class="line"><span class="comment">//重新转换为 INT8</span></span><br><span class="line"><span class="comment">// Convert to INT8 and save to global</span></span><br><span class="line">I8_output = Saturate( Round_to_nearest_integer( F32_result ) )</span><br></pre></td></tr></table></figure><p>它这个INT8卷积的计算是这样的，虽然输入的tensor已经降为 INT8，但是在卷积计算的时候用了DP4A的计算模式，卷积计算完之后是INT32的，然后又要转成 FP32，然后激活，最后再将FP32的转为INT8.</p><p>只知道这么计算会快很多，但不知道为什么，详情还是看<a href="https://devblogs.nvidia.com/mixed-precision-programming-cuda-8/" target="_blank" rel="noopener">Mixed-Precision Programming with CUDA 8</a> 这个吧，我看的也是糊里糊涂的。</p><p>不过这个对于tensorRT的使用没啥影响，这个是很底层的东西，涉及到硬件优化。</p><h3 id="Typical-workflow-in-TensorRT"><a href="#Typical-workflow-in-TensorRT" class="headerlink" title="Typical workflow in TensorRT"></a>Typical workflow in TensorRT</h3><p>典型的工作流还是直接使用 <a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf" target="_blank" rel="noopener">GTC2017 PPT</a> 原文说法吧：</p><ul><li>You will need:<ul><li>Model trained in FP32.</li><li>Calibration dataset.</li></ul></li><li>TensorRT will:<ul><li>Run inference in FP32 on calibration dataset.</li><li>Collect required statistics.</li><li>Run calibration algorithm → optimal scaling factors.</li><li>Quantize FP32 weights → INT8.</li><li>Generate “CalibrationTable” and INT8 execution engine.</li></ul></li></ul><h3 id="Results-Accuracy-amp-Performance"><a href="#Results-Accuracy-amp-Performance" class="headerlink" title="Results - Accuracy &amp; Performance"></a>Results - Accuracy &amp; Performance</h3><p><strong>精度并没有损失太多</strong></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/performance-auccary.png" alt="1516641328187"></p><p><strong>速度提升还蛮多的，尤其是当 batch_size 大于1时，提升更明显</strong></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/performance-speed.png" alt="1516641398718"></p><p><strong>TITAN X GPU优化效果</strong></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/performance-titanx.png" alt="1516642501791"></p><p><strong>DRIVE PX 2, dGPU 优化效果</strong></p><p><img src="/MLFrameworks/TensorRT/TensorRT INT8量化原理/performance-dgpu.png" alt="1516642517725"></p><h3 id="Open-challenges-improvements"><a href="#Open-challenges-improvements" class="headerlink" title="Open challenges / improvements"></a>Open challenges / improvements</h3><p>一些开放式的提升和挑战：</p><ul><li>Unsigned int8 for activations after ReLU. 无符号 INT8 的映射。</li><li>RNNs → open research problem. TensorRT 3.0开始已经支持RNN了。</li><li>Fine tuning of saturation thresholds. 对阈值 |T|的 微调方法。</li><li>Expose API for accepting custom, user provided scale factors. 开放API，使用户可以自定义 换算系数（比例因子）</li></ul><p>这几个开放问题还是很值得研究的。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul><li>介绍了一种自动化，无参数的 FP32 到 INT8 的转换方法；</li><li>对称的，不饱和的线性量化，会导致精度损失较大；</li><li>通过最小化 KL散度来选择 饱和量化中的 阈值 |T|;</li><li>FP32完全可以降低为INT8推理，精度几乎持平，速度有很大提升。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://arleyzhang.github.io/articles/923e2c40/" target="_blank" rel="noopener">TensorRT(5)-INT8校准原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要参考了&lt;a href=&quot;https://arleyzhang.github.io/articles/923e2c40/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TensorRT(5)-INT8校准原理&lt;/a&gt;，并添加了一些自己的见解。&lt;/p&gt;
&lt;h2 id=&quot;Low-Precision-Inference&quot;&gt;&lt;a href=&quot;#Low-Precision-Inference&quot; class=&quot;headerlink&quot; title=&quot;Low Precision Inference&quot;&gt;&lt;/a&gt;Low Precision Inference&lt;/h2&gt;&lt;p&gt;现有的深度学习框架，如Pytorch、Tensorflow在训练一个深度神经网络时，往往都会使用 &lt;strong&gt;float 32（Full Precise ，简称FP32）&lt;/strong&gt;的数据精度来表示，权值、偏置、激活值等。若一个网络很深的话，比如像VGG，ResNet这种，网络参数是极其多的，计算量就更多了（比如VGG 19.6 billion FLOPS, ResNet-152 11.3 billion FLOPS）。如果多的计算量，如果都采用FP32进行推理，对于嵌入式设备来说计算量是不能接受的。解决此问题主要有两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模型压缩、剪枝。在这里不做讨论。&lt;/li&gt;
&lt;li&gt;在部署推理时（inference）使用低精度数据，比如INT8。当然训练的时候仍然采取FP32的精度。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;下面从经验上分析低精度推理的可行性。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/categories/MLFrameworks/TensorRT/"/>
    
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/tags/TensorRT/"/>
    
      <category term="INT8" scheme="https://www.zdaiot.com/tags/INT8/"/>
    
  </entry>
  
  <entry>
    <title>RetinaFace：Single-stage Dense Face Localisation in the Wild</title>
    <link href="https://www.zdaiot.com/DeepLearningApplications/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/RetinaFace%EF%BC%9ASingle-stage%20Dense%20Face%20Localisation%20in%20the%20Wild/"/>
    <id>https://www.zdaiot.com/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/</id>
    <published>2020-07-04T14:14:08.000Z</published>
    <updated>2020-07-04T14:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><ol><li>对于WIDER FACE数据集，手动标记五个landmark坐标，这种<strong>额外监督信息对于hard face detection的性能提升有巨大的作用</strong>。</li><li>在已有的监督分支下，并行的新增了一个<strong>额外的自监督mesh decoder分支</strong>，用于预测pixel-wise 3D shape人脸信息。</li><li>基于单阶段目标检测框架，提出了一种新的人脸检测方法RetinaFace，该方法采用<strong>多任务学习策略</strong>来同时预测face score、face box、five landmarks以及每个人脸像素的三维位置和对应关系</li><li>在WIDER FACE hard测试集中，RetinaFace的AP比现有的最好方法提升了1.1%，达到了91.4%。</li><li>通过使用轻量级的backbone，对于VGA分辨率的图片，RetinaFace能够在单CPU下实现real-time的速度。</li></ol><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="face-localisation定义"><a href="#face-localisation定义" class="headerlink" title="face localisation定义"></a>face localisation定义</h3><p>狭义上的face localisation的定义是传统意义上的face detection。广义上的face localisation包括了face detection、face alignment、pixel-wise face parsing、3D dense correspondence regression。</p><h3 id="人脸检测和通用目标检测"><a href="#人脸检测和通用目标检测" class="headerlink" title="人脸检测和通用目标检测"></a>人脸检测和通用目标检测</h3><p><strong>人脸检测和一般的目标检测有如下几个不同点：</strong></p><ol><li>长宽比例变化范围小，从1:1变化到1:1.5。</li><li>尺度变化范围大，从几像素到几千像素。</li></ol><h3 id="双阶段和单阶段"><a href="#双阶段和单阶段" class="headerlink" title="双阶段和单阶段"></a>双阶段和单阶段</h3><p>双阶段的方法使用了“proposal and refinement”机制可以获得更高的定位精度。与此相反，单阶段方法的密集采样，导致训练过程中正负样本的极度不平衡。为了解决这种不平衡，sampling（online hard example mining）和re-weighting（focal loss）被广泛的使用。跟双阶段的方法相比，单阶段方法的速度更快，<strong>有更高的recall</strong>，但是也有<strong>更高的false positive概率</strong>（因为负样本数目远远大于正样本数目），因此定位精度并不是很高。</p><h3 id="context-module"><a href="#context-module" class="headerlink" title="context module"></a>context module</h3><p><strong>为了增强模型检测极小人脸的上下文推理能力</strong>，SSH和PyramidBox在特征金字塔上应用context module来扩大感受野。<strong>为了增强CNN的非刚性变换建模能力，可变形卷积网络（DCN）采用了一种新的可变形层来模拟几何变换</strong>。WIDER Face Challenge2018的冠军解决方案表明刚性(扩展)和非刚性(变形)上下文建模是互补和正交的，可以提高人脸检测的性能。</p><h2 id="创新点来源"><a href="#创新点来源" class="headerlink" title="创新点来源"></a>创新点来源</h2><p>根据前人的研究，额外的landmark信息能够帮助模型获得更好的检测性能，但是是否能够改善tiny face detection的性能，前人并没有研究。因此，<strong>是否能够利用五个人脸关键点信息提升WIDER FACE hard test数据集的性能呢？</strong></p><p>另外，Mask-RCNN通过在现有的分支基础上，并行的新增了一个预测object mask的分支，这极大地提升检测性能。这更加能够让人确信，dense pixel-wise annotations确实能够有助于提升检测性能。但是不可能在WIDER FACE数据集数据集上添加dense face annotation的信息。因此，既然监督信息不容易获得，那么<strong>是否能够使用无监督的方法进一步提升检测器的性能呢</strong>？</p><p>FAN提出了<strong>利用anchor-level attention map去提升遮挡人脸检测的性能</strong>。但是the proposed attention map特别粗糙不包含任何语义信息。最近自监督3D morphable models 在3D人脸建模上取得了巨大的进步。特别是Mesh Docoder利用在joint shape和texture上的图卷积取得了real-time的速度。然而，将该方法应用到单阶段目标检测器上的挑战有：一是相机参数难以精确地评估；二是采用单一特征向量(特征金字塔上1×1Conv)来预测joint latent shape和texture，而不是RoI pooled feature，这带来了feature shift的风险。本文在现有分支的基础上，并行的新增了一个额外的自监督mesh decoder分支，用于预测pixel-wise 3D shape人脸信息。</p><p>本文继续采用单阶段检测的思想，借助于强监督和自监督的信息，提出multi-loss，得到了一个SOTA的方法——RetinaFace。本文的核心思想如下图所示：</p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705222331868.png" alt="image-20200705222331868" style="zoom:80%;"></p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>如下图为RetinaFace的结构图，左半边部分就没什么好说的了，这里重点说下右边的context module。</p><p>该模块的主要作用是<strong>增加感受视野并增强了刚性上下文建模能力</strong>（enhance the rigid context modelling power）。Context Module（x5）的含义是针对每一个feature pyramid  level都有一个对应的context module，也就是说feature pyramid  levels之间不共享context module。该模块的结构为：输入通道数为256的Tensor，经过三个通道数分别为128、64、64的$3 \times 3$卷积层，<strong>这3个卷积层的感受视野分别为$3\times3,5\times5,7\times7$</strong>。然后将三个卷积层的输出沿着channel重新拼接成通道数为256的tensor。 </p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705221121986.png" alt="image-20200705221121986" style="zoom:67%;"></p><h3 id="Multi-task-Loss"><a href="#Multi-task-Loss" class="headerlink" title="Multi-task Loss"></a>Multi-task Loss</h3><p>对于每个anchor $i$，最小化下面的multi-task loss：</p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705114403965.png" alt="image-20200705114403965" style="zoom:67%;"></p><p>（1）Face分类损失$L_{cls}(p_i, p_i^<em>)$，其中$p_i$是anchor $i$是人脸的预测概率。对于positive anchor，$p_i^</em>=1$；对于negative anchor，$p_i^*=0$。分类损失$L_{cls}$是二分类（face/not face）softmax损失。</p><p>（2）Face定位回归损失$L_{box}(t_i,t_i^<em>)$，其中$t_i=\{t_x,t_y,t_w,t_h\}_i$，$t_i^</em>=\{t_x^<em>,t_y^</em>,t_w^<em>,t_h^</em>\}_i$分别表示预测出的box坐标和对应的positive anchor的ground-truth box坐标。根据Fast r-cnn，将box回归目标（<strong>如中心坐标、宽高</strong>）标准化。计算损失时使用$L_{box}(t_i,t_i^<em>)=R(t_i-t_i^</em>)$，其中$R$是在Fast r-cnn中定义的smooth-$L_1$损失。</p><p>（3）人脸landmark回归损失$L_{pts}(l_i,l_i^<em>)$，其中$l_i=\{l_{x_1},l_{y_1},\cdots,l_{x_5},l_{y_5}\}_i$，$l_i^</em>=\{l_{x_1}^<em>,l_{y_1}^</em>,\cdots,l_{x_5}^<em>,l_{y_5}^</em>\}_i$，分别表示预测出的五个人脸landmark和对应的positive anchor的ground-truth。跟box centre回归相似，五个人脸landmark回归也采用了基于anchor centre的target normalisation。</p><p>（4）Dense回归损失$L_{pixel}$。</p><p>其中loss-balancing参数$\lambda_1-\lambda_3$被设置为0.25，0.1和0.01，这意味着监督信息得到的box和landmark回归损失重要性比较大。</p><h3 id="Dense-Regression-Branch"><a href="#Dense-Regression-Branch" class="headerlink" title="Dense Regression Branch"></a>Dense Regression Branch</h3><p>这部分讲道理我看的不是很明白，虽然我研究的就是GNN，23333。但是感觉要想理解这个模块，需要了解3D建模的一些知识。总而言之，这个模块的主要流程是：就是将2D的人脸映射到3D模型上，再将3D模型解码为2D图片，然后计算经过编解码的图片和原始图片的差别。中间用到了图卷积。</p><p>这里实际上用到了mesh decoder来做解码，mesh decoder是一种基于图卷积的方法，参数量会比我们平时用的普通2D卷积计算量要少。如下图，我们知道普通的卷积操作参数一般是$Kernel_H \times Kernel_w \times Channel_{in} \times Channel_{out}$，而图卷积在计算参数的时候，参数量只有$K \times Channel_{in} \times Channel_{out}$，$K$表示$K$阶切比雪夫多项式。</p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705230220447.png" alt="image-20200705230220447" style="zoom:67%;"></p><p>当预测出形状和纹理参数$P_{ST} \in {\mathbb R}^{128}$后，使用一个高效的可微分3D网格渲染器利用相机参数和光照参数将coloured-mesh $D_{P_{ST}}$投影到2D图像平面上。一旦得到了rendered 2D face ${\cal R}({\cal D_{P_{ST}}}, P_{cam}, P_{ill})$后，我们使用以下函数比较rendered 2D face和原始2D face的像素差异：</p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705231032985.png" alt="image-20200705231032985" style="zoom:67%;"></p><p>其中，$W、H$是anchor $I_{i,j}^*$的宽和高。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><strong>WIDER FACE</strong>由香港中文大学于2016年建立，该数据集包含32203张图像，393703个人脸，其中大量图片受到光照、遮挡、化妆、表情变化、小脸等因素影响。这些数据中40%为训练集（Training）、10%为验证集（Validation）、50%为测试集（Testing）。WIDER FACE一经提出，便引起了广泛关注，成为近几年来人脸检测领域最权威的数据集之一。WIDER FACE数据集分为Validation和Test两个评估集，每个集合中的数据根据人脸检测的难易程度分为Easy、Medium、Hard。</p><p><strong>FDDB</strong>（Face Detection Data Set and Benchmark）由美国马萨诸塞大学（UMass）于2010年建立，该数据集包含2845张图像，5171个人脸。其中包含大量遮挡、复杂的姿态以及低分辨率的人脸。结果公布分为公开方法（published methods）和非公开方法（unpublished methods）两个榜单。FDDB是早期评估各类人脸检测算法最重要的数据集之一。根据FDDB数据集召回率的计算方式不同，可以分为Discrete和Continuous两种评估方式。</p><p>该论文主要使用的是WIDER FACE数据集，正如图4和表1所示，根据在人脸上标注五个landmark（眼睛中心、鼻尖和嘴角）信息的难度不同，将人脸图像质量划分为五个等级。在训练集上标注了84.6k个landmark和在验证集上标注了18.5个landmark。</p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705165805544.png" alt="image-20200705165805544" style="zoom:80%;"></p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705165826313.png" alt="image-20200705165826313" style="zoom:67%;"></p><h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><p><strong>Feature Pyramid.</strong>  RetinaFace在$P_2-P_6$上使用Feature Pyramid，其中$P_2-P_5$来自于ResNet residual stage（$C_2-C_5$），并使用top-down结构和侧连接。$P_6$是在$C_5$上使用stride=2的3x3的卷积得到，并使用“Xavier”方法初始化。</p><p><strong>Context Module.</strong>   受到SSH和PyramidBox的启发，作者在五个feature pyramid levels上使用独立的context modules，<strong>增加感受视野并增强了刚性上下文建模能力</strong>（enhance the rigid context modelling power）。受到WIDER Face Challenge2018的冠军启发，作者还用<strong>可变形卷积网络（DCN）</strong>替换侧连接和上下文模块（context modules）内的所有3×3卷积层，进一步<strong>增强了非刚性上下文建模能力</strong>（strengthens the non-rigid context modelling capacity）。</p><p><strong>Loss Head.</strong> 对于negative anchors，只计算分类损失。对于positive anchors，则计算所提出的multi-task loss。在不同的feature map $H_n \times W_n \times 256, n\in \{2, \cdots, 6\}$上应用共享loss head（$1 \times 1$卷积），对于mesh decoder，作者使用了一个计算量很小的pre-trained模型。</p><p><strong>Anchor Settings.</strong>  正如表2所示，在$P_2-P_6$不同的feature pyramid  levels上应用特定尺度的anchors。其中，<strong>$P_2$被设计使用tiling small anchors捕捉tiny faces，这也带来了更大的计算量和更高的false positives风险。</strong>作者设计scale step为$2^{1/3}$，长宽比例为1:1。输入图像尺寸为$640 \times 640$，anchors的尺寸覆盖了feature pyramid  levels上从$16 \times 16$到$406 \times 406$各个范围。<strong>这里总共有102300个anchors，其中75%的anchors来自$P_2$。</strong></p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705172828971.png" alt="image-20200705172828971" style="zoom:67%;"></p><p>在训练过程中，如果anchors和ground-truth box的IoU大于0.5，则判定为anchors匹配上了该ground-truth box（若anchor匹配上了多个ground-truth box，则和有最大IoU的ground-truth box进行匹配）；若anchor与所有的ground-truth box都小于 0.3，则判定该anchor为背景；在训练过程中，其余anchors被忽略。因为在matching step后，绝大部分的anchor（&gt;99%）都是negative，我们使用标准的<strong>OHEM步骤</strong>减轻positive和negative训练样本之间的严重不平衡。具体来说，根据损失值将negative anchors进行排序，选择值比较大的一些，保证negative:positive至少为$3:1$。</p><p><strong>Data Augmentation.</strong>   在WIDER FACE训练集中有大概20%的tiny faces。作者从原始图片中随机裁剪正方形的patches，然后resize这些patches到$640 \times 640$<strong>以产生更大training faces</strong>。具体来说，按照原始图像短边的$[0.3,1]$之间的随机大小从原始图像裁剪正方形patches。对于裁剪边界的faces，如果它的中心点落在crop patch中间，则保留face box的重叠部分。除了随机裁剪之外，我们还以0.5的概率随机水平翻转，photo-metric colour distortion。</p><p><strong>Training Details.</strong>   在四块英伟达P40上使用SGD优化器训练RetinaFace（momentum at 0.9, weight decay at 0.0005, batch size of 8 × 4）。学习率从$10^{-3}$开始，在5个epoch后降低到$10^{-2}$，在第55和第68epoch时学习率均除以10。总共训练80个epoch。</p><p><strong>Testing Details.</strong>  对于在WIDER FACE上的测试，按照标准的流程，使用翻转和multi-scale（图像的短边在[500,800,1100,1400,1700]）策略。使用IoU阈值为0.4对预测出的face boxes应用Box voting策略。</p><h3 id="Ablation-Study"><a href="#Ablation-Study" class="headerlink" title="Ablation Study"></a>Ablation Study</h3><p>为了更好的理解RetinaFace，作者进一步作了关于标注的five facial landmarks和所提的dense regression branch的作用。使用的指标为在IoU=0.5时的AP和在IoU=0.5:0.05:0.95时的mAP，如下表所示。从中可以看出，通过使用FPN、context module、DCN等，作者得到了一个强有力的baseline，在Hard上的AP为91.286。通过添加five facial landmark regression，在Hard上的face box AP提升了0.408%，mAP提升了0.775%，说明了landmark信息对于人脸检测精度的提升有着重要的作用。另外，添加dense regression branch后，增加了在Easy和Medium上的AP，在Hard上的AP反而降低了，这表明在具有挑战性的场景下dense regression的难度。然而，若将这两者结合到一起，会进一步的提升在Hard上的AP。这表明landmark regression确实有助于dense regression，这反过来又进一步提高了人脸检测性能。</p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705184709026.png" alt="image-20200705184709026" style="zoom:67%;"></p><h3 id="Face-box-Accuracy"><a href="#Face-box-Accuracy" class="headerlink" title="Face box Accuracy"></a>Face box Accuracy</h3><p>如下所示，RetailFace在验证集、测试集的Easy、Medium、Hard上都取得了最高的AP。跟最近的SOTA方法对比，RetinaFace在有大量tiny faces的hard子集上取得了更高的得分（91.4% vs 90.3%）。</p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705185847100.png" alt="image-20200705185847100" style="zoom:80%;"></p><p>图6展示了一张人脸图像的定性结果。RetinaFace从真实的1151个人脸中成功找到了大约900个人脸（阈值为0.5）。除了精确的box外，RetinaFace预测的five face landmark在姿态、遮挡和分辨率等变化下也非常健壮。虽然在严重遮挡情况下出现dense face localisation失败的情况，但在一些清晰度较大的人脸上的dense regression结果是好的，甚至显示出表情变化。</p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705190237099.png" alt="image-20200705190237099" style="zoom:80%;"></p><h3 id="推理速度"><a href="#推理速度" class="headerlink" title="推理速度"></a>推理速度</h3><p>除了大网络（ResNet-152, size of 262MB, and AP 91.8% on the WIDER FACE hard set）外，作者还提出了一个轻量化模型（MobileNet-0.25，size of 1MB，and AP 78.2% on the WIDER FACE hard set）。<strong>对于轻量化模型，作者在输入图像上使用$7 \times 7$的卷积（stride=4），只在$P_3-P_5$上设置anchors，并且移除了DCN层。</strong>此外，固定了backbone的前两个卷积层，以实现更高的精度。</p><p>表5给出了两种模型在不同输入大小下的推理时间。作者省略了dense regression branch上的时间开销，因此推理时间与输入图像的人脸密度无关。作者利用TVM来加速模型推理，并分别在NVIDIA Tesla P40 GPU、Intel i7-6700K CPU和ARM RK3399上进行了实验。RetinaFace ResNet-152具有更高的精度，VGA图像(640×480)的运行速度为13FPS。相比之下，RetinaFace MobileNet-0.25是为高效的人脸检测而设计的，对于4K图像(4096×2160)，在GPU上的速度为40FPS，对于高清图像(1920×1080)，在多线程CPU上达到20FPS，对于VGA图像，在单线程CPU上达到60FPS(640×480)。另外，对于VGA图像(640×480)在ARM处理器上能够达到16 FPS。</p><p><img src="/DeepLearningApplications/人脸检测/RetinaFace：Single-stage Dense Face Localisation in the Wild/image-20200705205725112.png" alt="image-20200705205725112" style="zoom:67%;"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RetinaFace通过如下几种途径来提高WIDER FACE hard上的性能：</p><ol><li>使用额外的landmark监督信息和3D position自监督信息</li><li>在特征金字塔上应用context module来扩大感受野，增强模型检测极小人脸的上下文推理能力</li><li>使用$P_2$来预测极小人脸</li><li>训练时的数据增强：从原始图片中随机裁剪正方形的patches，然后resize这些patches到$640 \times 640$<strong>以产生更大training faces</strong>。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_14845119/article/details/79105360" target="_blank" rel="noopener">人脸检测之SSH(Single Stage Headless)</a><br><a href="https://zhuanlan.zhihu.com/p/70834919" target="_blank" rel="noopener">insightface新作：RetinaFace单阶段人脸检测</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创新点&quot;&gt;&lt;a href=&quot;#创新点&quot; class=&quot;headerlink&quot; title=&quot;创新点&quot;&gt;&lt;/a&gt;创新点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对于WIDER FACE数据集，手动标记五个landmark坐标，这种&lt;strong&gt;额外监督信息对于hard face detection的性能提升有巨大的作用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在已有的监督分支下，并行的新增了一个&lt;strong&gt;额外的自监督mesh decoder分支&lt;/strong&gt;，用于预测pixel-wise 3D shape人脸信息。&lt;/li&gt;
&lt;li&gt;基于单阶段目标检测框架，提出了一种新的人脸检测方法RetinaFace，该方法采用&lt;strong&gt;多任务学习策略&lt;/strong&gt;来同时预测face score、face box、five landmarks以及每个人脸像素的三维位置和对应关系&lt;/li&gt;
&lt;li&gt;在WIDER FACE hard测试集中，RetinaFace的AP比现有的最好方法提升了1.1%，达到了91.4%。&lt;/li&gt;
&lt;li&gt;通过使用轻量级的backbone，对于VGA分辨率的图片，RetinaFace能够在单CPU下实现real-time的速度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;h3 id=&quot;face-localisation定义&quot;&gt;&lt;a href=&quot;#face-localisation定义&quot; class=&quot;headerlink&quot; title=&quot;face localisation定义&quot;&gt;&lt;/a&gt;face localisation定义&lt;/h3&gt;&lt;p&gt;狭义上的face localisation的定义是传统意义上的face detection。广义上的face localisation包括了face detection、face alignment、pixel-wise face parsing、3D dense correspondence regression。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DeepLearningApplications" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/"/>
    
      <category term="人脸检测" scheme="https://www.zdaiot.com/categories/DeepLearningApplications/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="人脸检测" scheme="https://www.zdaiot.com/tags/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>动态链接库和静态链接库</title>
    <link href="https://www.zdaiot.com/C/%E8%AF%AD%E6%B3%95/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    <id>https://www.zdaiot.com/C/语法/动态链接库和静态链接库/</id>
    <published>2020-06-28T03:20:17.000Z</published>
    <updated>2020-06-28T03:20:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于C/C++程序，编译主要分为三个步骤：</p><ol><li>源文件进行预处理，这个过程主要是处理一些#号定义的命令或语句（如宏、#include、预编译指令#ifdef等），生成<code>*.i</code>文件</li><li>进行编译，这个过程主要是进行词法分析、语法分析和语义分析等，生成<code>*.s</code>的汇编文件；</li><li>进行汇编，这个过程比较简单，就是将对应的汇编指令翻译成机器指令，生成可重定位的二进制目标文件。</li></ol><p>通常情况下，<strong>对函数库的链接是放在编译时期</strong>（compile time）完成的。所有相关的对象文件 （object file）与牵涉到的函数库（library）被链接合成一个可执行文件 （executable file）。 <strong>静态链接和动态链接两者最大的区别就在于链接的时机不一样，静态链接是在形成可执行程序前，而动态链接的进行则是在程序执行时</strong>。下面来详细介绍这两种链接方式。</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><h3 id="为什么要进行静态链接"><a href="#为什么要进行静态链接" class="headerlink" title="为什么要进行静态链接"></a>为什么要进行静态链接</h3><p>在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即每个<code>*.c</code>文件会形成一个<code>*.o</code>文件，为了满足前面说的依赖关系，则需要<strong>将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序</strong>。这个链接的过程就是静态链接。</p><p>此时程序在运行时，与函数库再无瓜葛，因为所有需要的函数已拷贝到自己下面。所以这些函数库被成为静态库（static libaray），通常文件名为<code>libxxx.a</code>的形式。</p><h3 id="静态链接的原理"><a href="#静态链接的原理" class="headerlink" title="静态链接的原理"></a>静态链接的原理</h3><p>由很多目标文件进行链接形成的是静态库，反之静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件，如下图，使用<code>ar</code>命令的<code>-a</code>参数查看静态库的组成：</p><p><img src="/C/语法/动态链接库和静态链接库/20180505234059214" alt="img"></p><p>这里的<code>*.o</code>目标文件在博客<a href="https://blog.csdn.net/kang___xi/article/details/79571137" target="_blank" rel="noopener">从编写源代码到程序在内存中运行的全过程解析</a>中已经讲的很清楚了，可以参考一下。</p><p> 以下面这个图来简单说明一下从静态链接到可执行文件的过程，根据在源文件中包含的头文件和程序中使用到的库函数，如stdio.h中定义的printf()函数，在libc.a中找到目标文件printf.o(这里暂且不考虑printf()函数的依赖关系)，然后将这个目标文件和我们hello.o这个文件进行链接形成我们的可执行文件。</p><p><img src="/C/语法/动态链接库和静态链接库/20180505235327609" alt="img" style="zoom: 67%;"></p><p>这里有一个小问题，就是从上面的图中可以看到静态运行库里面的一个目标文件只包含一个函数，如libc.a里面的printf.o只有printf()函数，strlen.o里面只有strlen()函数。</p><p>​    我们知道，链接器在链接静态链接库的时候是以目标文件为单位的。比如我们引用了静态库中的printf()函数，那么链接器就会把库中包含printf()函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件就不要链接到最终的输出文件中。</p><h3 id="静态链接的优缺点"><a href="#静态链接的优缺点" class="headerlink" title="静态链接的优缺点"></a>静态链接的优缺点</h3><p>静态链接的缺点很明显，一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本；另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><h3 id="为什么会出现动态链接"><a href="#为什么会出现动态链接" class="headerlink" title="为什么会出现动态链接"></a>为什么会出现动态链接</h3><p> 动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。</p><h3 id="动态链接的原理"><a href="#动态链接的原理" class="headerlink" title="动态链接的原理"></a>动态链接的原理</h3><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。下面简单介绍动态链接的过程：</p><p>假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。</p><h3 id="动态链接的优缺点"><a href="#动态链接的优缺点" class="headerlink" title="动态链接的优缺点"></a>动态链接的优缺点</h3><p>动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p><p>据估算，动态链接和静态链接相比，性能损失大约在5%以下。经过实践证明，这点性能损失用来换区程序在空间上的节省和程序构建和升级时的灵活性是值得的。</p><h3 id="动态链接地址是如何重定位的呢？"><a href="#动态链接地址是如何重定位的呢？" class="headerlink" title="动态链接地址是如何重定位的呢？"></a>动态链接地址是如何重定位的呢？</h3><p>前面我们讲过静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>简单的说，静态库和应用程序编译在一起，在任何情况下都能运行，而动态库是动态链接，顾名思义就是在应用程序启动的时候才会链接，所以，当用户的系统上没有该动态库时，应用程序就会运行失败。再看它们的特点：</p><p><strong>动态库：</strong></p><ul><li>类库的名字一般是 libxxx.so</li><li>共享：多个应用程序可以使用同一个动态库，启动多个应用程序的时候，只需要将动态库加载到内存一次即可；</li><li>开发模块好：要求设计者对功能划分的比较好。</li><li>动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。</li></ul><p><strong>静态库：</strong></p><ul><li>类库的名字一般是libxxx.a</li><li>代码的装载速度快，执行速度也比较快，因为编译时它只会把你需要的那部分链接进去。</li><li>应用程序相对比较大，如果多个应用程序使用的话，会被装载多次，浪费内存。</li><li>如果静态函数库改变了，那么你的程序必须重新编译。</li></ul><p>如果你的系统上有多个应用程序都使用该库的话，就把它编译成动态库，这样虽然刚启动的时候加载比较慢，但是多任务的时候会比较节省内存；如果你的系统上只有一到两个应用使用该库，并且使用的API比较少的话，就编译成静态库吧，一般的静态库还可以进行裁剪编译，这样应用程序可能会比较大，但是启动的速度会大大提高。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>这里附一个附录，是关于怎么添加各种环境变量的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#(动态库搜索路径) 程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/lib/</span><br><span class="line"><span class="comment">#(静态库搜索路径) 程序编译期间查找动态链接库时指定查找共享库的路径</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/lib/</span><br><span class="line"><span class="comment">#执行程序搜索路径</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/protobuf/bin/</span><br><span class="line"><span class="comment">#c程序头文件搜索路径</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$C_INCLUDE_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/include/</span><br><span class="line"><span class="comment">#c++程序头文件搜索路径</span></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=<span class="variable">$CPLUS_INCLUDE_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/include/</span><br><span class="line"><span class="comment">#pkg-config 路径</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/usr/<span class="built_in">local</span>/protobuf/lib/pkgconfig/</span><br></pre></td></tr></table></figure><p>需要注意的是<code>export PATH=&quot;/data2/zhaodali/software/protobuf/bin:$PATH&quot;</code>会先从前面加载protobuf，但是若设置为：<code>export PATH=$PATH:/data2/zhaodali/software/protobuf/bin</code>，则会先从系统路径中加载protobuf！！！</p><h2 id="跨机器运行"><a href="#跨机器运行" class="headerlink" title="跨机器运行"></a>跨机器运行</h2><p>在一台机器上设置好动态、静态链接库的环境变量，然后编译出可执行文件后。直接拷贝该执行文件到另一台机器上，少什么动态链接库就使用上面的<code>export</code>指令设置其路径即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/cyyljw/p/10949660.html" target="_blank" rel="noopener">静态链接和动态链接区别</a><br><a href="https://www.jianshu.com/p/8743a0edb1ee" target="_blank" rel="noopener">静态链接库、动态链接库、导入库的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于C/C++程序，编译主要分为三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源文件进行预处理，这个过程主要是处理一些#号定义的命令或语句（如宏、#include、预编译指令#ifdef等），生成&lt;code&gt;*.i&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;进行编译，这个过程主要是进行词法分析、语法分析和语义分析等，生成&lt;code&gt;*.s&lt;/code&gt;的汇编文件；&lt;/li&gt;
&lt;li&gt;进行汇编，这个过程比较简单，就是将对应的汇编指令翻译成机器指令，生成可重定位的二进制目标文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常情况下，&lt;strong&gt;对函数库的链接是放在编译时期&lt;/strong&gt;（compile time）完成的。所有相关的对象文件 （object file）与牵涉到的函数库（library）被链接合成一个可执行文件 （executable file）。 &lt;strong&gt;静态链接和动态链接两者最大的区别就在于链接的时机不一样，静态链接是在形成可执行程序前，而动态链接的进行则是在程序执行时&lt;/strong&gt;。下面来详细介绍这两种链接方式。&lt;/p&gt;
&lt;h2 id=&quot;静态链接&quot;&gt;&lt;a href=&quot;#静态链接&quot; class=&quot;headerlink&quot; title=&quot;静态链接&quot;&gt;&lt;/a&gt;静态链接&lt;/h2&gt;&lt;h3 id=&quot;为什么要进行静态链接&quot;&gt;&lt;a href=&quot;#为什么要进行静态链接&quot; class=&quot;headerlink&quot; title=&quot;为什么要进行静态链接&quot;&gt;&lt;/a&gt;为什么要进行静态链接&lt;/h3&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.zdaiot.com/categories/C/"/>
    
      <category term="语法" scheme="https://www.zdaiot.com/categories/C/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="动态链接库" scheme="https://www.zdaiot.com/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    
      <category term="静态链接库" scheme="https://www.zdaiot.com/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    
      <category term="环境变量" scheme="https://www.zdaiot.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>编译DALI库</title>
    <link href="https://www.zdaiot.com/MLFrameworks/TensorRT/%E7%BC%96%E8%AF%91DALI%E5%BA%93/"/>
    <id>https://www.zdaiot.com/MLFrameworks/TensorRT/编译DALI库/</id>
    <published>2020-06-20T09:35:33.000Z</published>
    <updated>2020-06-20T09:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>DALI库是一个用于数据预处理以及数据读取的第三方加速库。最近因为调用这个库的时候会出问题，所以重新编译了一下，这里记录下编译的过程。</p><p>首先，DALI库的<a href="https://github.com/NVIDIA/DALI/" target="_blank" rel="noopener">官方地址</a>，<a href="https://docs.nvidia.com/deeplearning/dali/user-guide/docs/index.html" target="_blank" rel="noopener">官方文档地址</a>，因为我这里使用的是旧版本的DALI库——0.11版本，其编译文档可以在<a href="https://docs.nvidia.com/deeplearning/dali/archives/dali_0110_beta/dali-developer-guide/docs/compilation.html" target="_blank" rel="noopener">这里</a>找到，一般来说，直接按照流程编译是没有问题的，但是对于没有Root权限情况下的编译，就有点麻烦了。下面介绍一下：</p><p>首先，下面的编译条件要满足，尤其是对于GCC版本，我编译的使用使用了GCC4.9.2。</p><p><img src="/MLFrameworks/TensorRT/编译DALI库/image-20200620174055268.png" alt="image-20200620174055268" style="zoom:60%;"></p><p>值得注意的是，对于上面的编译条件，有一个通常不满足，那就是FFmpeg库，按照官方文档里面的指示，可以从<a href="https://developer.download.nvidia.com/compute/redist/nvidia-dali/ffmpeg-3.4.2.tar.bz2" target="_blank" rel="noopener">这里</a>下载FFmpeg安装包，我这里将安装包放到了<code>/data2/zhaodali/software</code>下，然后执行下面操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -jxvf ffmpeg-3.4.2.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> ffmpeg-3.4.2</span><br><span class="line"><span class="comment"># 使用--prefix指定安装路径</span></span><br><span class="line">./configure  --prefix=/data2/zhaodali/software/ffmpeg-3.4.2/install  --<span class="built_in">disable</span>-static  --<span class="built_in">disable</span>-all  --<span class="built_in">disable</span>-autodetect  --<span class="built_in">disable</span>-iconv  --<span class="built_in">enable</span>-shared  --<span class="built_in">enable</span>-avformat  --<span class="built_in">enable</span>-avcodec  --<span class="built_in">enable</span>-avfilter  --<span class="built_in">enable</span>-protocol=file  --<span class="built_in">enable</span>-demuxer=mov,matroska</span><br><span class="line">make -j 34</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>然后，编译DALI库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/NVIDIA/dali</span><br><span class="line">git checkout release_v0.11</span><br><span class="line"><span class="built_in">cd</span> dali</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># 指定为Debug模型，指定ffmpeg路径，指定安装路径</span></span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Debug  -DCMAKE_PREFIX_PATH=/data2/zhaodali/software/ffmpeg-3.4.2/install/ -DCMAKE_INSTALL_PREFIX=/data2/zhaodali/software/DALI/install</span><br><span class="line">make -j<span class="string">"<span class="variable">$(nproc)</span>"</span></span><br></pre></td></tr></table></figure><p>其实这里不需要安装，编译完成之后，DALI库的头文件在<code>/data2/zhaodali/software/DALI/build/dali/python/nvidia/dali/include</code>这里，而库文件为<code>/data2/zhaodali/software/DALI/build/dali/python/nvidia/dali/libdali.so</code>，然后就可以使用C++接口调用DALI库了。撒花~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DALI库是一个用于数据预处理以及数据读取的第三方加速库。最近因为调用这个库的时候会出问题，所以重新编译了一下，这里记录下编译的过程。&lt;/p&gt;
&lt;p&gt;首先，DALI库的&lt;a href=&quot;https://github.com/NVIDIA/DALI/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方地址&lt;/a&gt;，&lt;a href=&quot;https://docs.nvidia.com/deeplearning/dali/user-guide/docs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档地址&lt;/a&gt;，因为我这里使用的是旧版本的DALI库——0.11版本，其编译文档可以在&lt;a href=&quot;https://docs.nvidia.com/deeplearning/dali/archives/dali_0110_beta/dali-developer-guide/docs/compilation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;找到，一般来说，直接按照流程编译是没有问题的，但是对于没有Root权限情况下的编译，就有点麻烦了。下面介绍一下：&lt;/p&gt;
&lt;p&gt;首先，下面的编译条件要满足，尤其是对于GCC版本，我编译的使用使用了GCC4.9.2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/MLFrameworks/TensorRT/编译DALI库/image-20200620174055268.png&quot; alt=&quot;image-20200620174055268&quot; style=&quot;zoom:60%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，对于上面的编译条件，有一个通常不满足，那就是FFmpeg库，按照官方文档里面的指示，可以从&lt;a href=&quot;https://developer.download.nvidia.com/compute/redist/nvidia-dali/ffmpeg-3.4.2.tar.bz2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;下载FFmpeg安装包，我这里将安装包放到了&lt;code&gt;/data2/zhaodali/software&lt;/code&gt;下，然后执行下面操作：&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/categories/MLFrameworks/TensorRT/"/>
    
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/tags/TensorRT/"/>
    
      <category term="DALI" scheme="https://www.zdaiot.com/tags/DALI/"/>
    
  </entry>
  
  <entry>
    <title>TensorRT基本概念</title>
    <link href="https://www.zdaiot.com/MLFrameworks/TensorRT/TensorRT%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.zdaiot.com/MLFrameworks/TensorRT/TensorRT基本概念/</id>
    <published>2020-06-14T10:57:36.000Z</published>
    <updated>2020-06-14T10:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要参考了<a href="https://arleyzhang.github.io/articles/7f4b25ce/" target="_blank" rel="noopener">TensorRT(1)-介绍-使用-安装</a>，并加上了一些自己的理解。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TensorRT是一个高性能的深度学习推理（Inference）优化器，可以为深度学习应用提供低延迟、高吞吐率的部署推理。TensorRT 之前称为GIE。</p><p><img src="/MLFrameworks/TensorRT/TensorRT基本概念/Training-vs-Inference-1.jpg" alt="Training-vs-Inference-Graphic"></p><p>由上图可以很清楚的看出，训练（training）和 推理（inference）的区别：</p><ul><li>训练（training）包含了前向传播和后向传播两个阶段，针对的是训练集。训练时通过误差反向传播来不断修改网络权值（weights）。</li><li>推理（inference）只包含前向传播一个阶段，针对的是除了训练集之外的新数据。可以是测试集，但不完全是，更多的是整个数据集之外的数据。其实就是针对新数据进行预测，预测时，速度是一个很重要的因素。</li></ul><p>为了提高部署推理的速度，出现了很多轻量级神经网络，比如squeezenet，mobilenet，shufflenet等。基本做法都是基于现有的经典模型提出一种新的模型结构，然后用这些改造过的模型重新训练，再重新部署。</p><p><strong>而tensorRT则是对训练好的模型进行优化，tensorRT只是推理优化器。</strong>当你的网络训练完之后，可以将训练模型文件直接丢进tensorRT中，而不再需要依赖深度学习框架（Caffe，TensorFlow等），如下：</p><p><img src="/MLFrameworks/TensorRT/TensorRT基本概念/TensorRT-model-import1.png" alt="1517972547350"></p><p>可以认为tensorRT是一个只有前向传播的深度学习框架，这个框架可以<strong>将 Caffe，TensorFlow等网络模型解析，然后与tensorRT中对应的层进行一一映射</strong>，把其他框架的模型统一全部转换到tensorRT中，然后在tensorRT中可以针对NVIDIA自家GPU实施优化策略，并进行部署加速。</p><p>TensorRT4.0几乎可以支持所有常用的深度学习框架，对于caffe和tensorflow来说，tensorRT可以直接解析他们的网络模型；对于caffe2，pytorch，mxnet，chainer，CNTK等框架则是首先要将模型转为 ONNX 的通用深度学习模型，然后对ONNX模型做解析。而tensorflow和MATLAB已经将TensorRT集成到框架中去了。</p><p>基本上比较经典的层比如，卷积，反卷积，全连接，RNN，softmax等，在tensorRT中都是有对应的实现方式的，tensorRT是可以直接解析的。</p><p>对于自定义层，<strong>tensorRT中有一个 Plugin 层，这个层提供了 API 可以由用户自己定义tensorRT不支持的层。</strong> 如下图：</p><p><img src="/MLFrameworks/TensorRT/TensorRT基本概念/TensorRT-plugin.png" alt="pasted-image-0-1-625x519"></p><h2 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h2><p><img src="/MLFrameworks/TensorRT/TensorRT基本概念/TensorRT-optimize-method-1592132734926.png" alt="1535459793419"></p><p>TensorRT优化方法主要有以下几种方式，最主要的是前面两种。</p><h3 id="层间融合或张量融合（Layer-amp-Tensor-Fusion）"><a href="#层间融合或张量融合（Layer-amp-Tensor-Fusion）" class="headerlink" title="层间融合或张量融合（Layer &amp; Tensor Fusion）"></a>层间融合或张量融合（Layer &amp; Tensor Fusion）</h3><p>如下图左侧是GoogLeNet Inception模块的计算图。这个结构中有很多层，在部署模型推理时，这每一层的运算操作都是由GPU完成的，但实际上是GPU通过启动不同的CUDA（Compute unified device architecture）核心来完成计算的，CUDA核心计算张量的速度是很快的，但是<strong>往往大量的时间是浪费在CUDA核心的启动和对每一层输入/输出张量的读写操作上面，这造成了内存带宽的瓶颈和GPU资源的浪费</strong>。TensorRT通过对<strong>层间的横向或纵向合并</strong>（合并后的结构称为<strong>CBR</strong>，意指 convolution, bias, and ReLU layers are fused to form a single layer），使得层的数量大大减少。</p><ul><li>横向合并可以把卷积、偏置和激活层合并成一个CBR结构，只占用一个CUDA核心。而在绝大部分框架中，比如卷积、偏置和激活层这三层是需要调用三次cuDNN对应的API</li><li>纵向合并可以把结构相同，但是权值不同的层合并成一个更宽的层，也只占用一个CUDA核心。</li></ul><p>合并之后的计算图（下图右侧）的层次更少了，占用的CUDA核心数也少了，因此整个模型结构会更小，更快，更高效。对于concat这一层，比如说这边计算出来一个1×3×24×24，另一边计算出来1×5×24×24，concat到一起，变成一个1×8×24×24的矩阵，这个叫concat这层这其实是完全没有必要的，因为TensorRT完全可以实现直接接到需要的地方，不用专门做concat的操作，所以这一层也可以取消掉。</p><p><img src="/MLFrameworks/TensorRT/TensorRT基本概念/TensorRT-layer-fusion.png" alt="1517973035996"></p><p>另外还可以做并发（Concurrency），如下图左半部分（max pool和1×1 CBR）与右半部分（大的1×1 CBR，3×3 CBR和5×5 CBR）彼此之间是相互独立的两条路径，本质上是不相关的，可以在GPU上通过并发来做，来达到的优化的目标。</p><p><img src="/MLFrameworks/TensorRT/TensorRT基本概念/v2-1eb534671cfada04b5d027dbaf352f5e_720w.jpg" alt="img"></p><h3 id="数据精度校准（Weight-amp-Activation-Precision-Calibration）"><a href="#数据精度校准（Weight-amp-Activation-Precision-Calibration）" class="headerlink" title="数据精度校准（Weight &amp;Activation Precision Calibration）"></a>数据精度校准（Weight &amp;Activation Precision Calibration）</h3><p><strong>大部分深度学习框架在训练神经网络时网络中的张量（Tensor）都是32位浮点数的精度（Full 32-bit precision，FP32）</strong>，一旦网络训练完成，在<strong>部署推理的过程中由于不需要反向传播，完全可以适当降低数据精度</strong>，比如降为FP16或INT8的精度。更低的数据精度将会使得内存占用和延迟更低，模型体积更小。</p><p>如下表为不同精度的动态范围：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Precision</th><th style="text-align:center">Dynamic Range</th></tr></thead><tbody><tr><td style="text-align:center">FP32</td><td style="text-align:center">−3.4×1038 +3.4×1038−3.4×1038 +3.4×1038</td></tr><tr><td style="text-align:center">FP16</td><td style="text-align:center">−65504 +65504−65504 +65504</td></tr><tr><td style="text-align:center">INT8</td><td style="text-align:center">−128 +127</td></tr></tbody></table></div><p>INT8只有256个不同的数值，使用INT8来表示 FP32精度的数值，肯定会丢失信息，造成性能下降。不过TensorRT会提供完全自动化的校准（Calibration ）过程，会以最好的匹配性能将FP32精度的数据降低为INT8精度，最小化性能损失。关于校准过程，后面会专门做一个探究。可以见<a href="https://arleyzhang.github.io/articles/923e2c40/" target="_blank" rel="noopener">TensorRT(5)-INT8校准原理</a></p><h3 id="Kernel-Auto-Tuning"><a href="#Kernel-Auto-Tuning" class="headerlink" title="Kernel Auto-Tuning"></a>Kernel Auto-Tuning</h3><p>网络模型在推理计算时，是调用GPU的CUDA核进行计算的。TensorRT可以针对不同的算法，不同的网络模型，不同的GPU平台，进行 CUDA核的调整（怎么调整的还不清楚），以保证当前模型在特定平台上以最优性能计算。</p><p>TensorRT will pick the implementation from a library of kernels that delivers the best performance for the target GPU, input data size, filter size, tensor layout, batch size and other parameters.</p><h3 id="Dynamic-Tensor-Memory"><a href="#Dynamic-Tensor-Memory" class="headerlink" title="Dynamic Tensor Memory"></a>Dynamic Tensor Memory</h3><p>在每个tensor的使用期间，TensorRT会为其指定显存，避免显存重复申请，减少内存占用和提高重复使用效率。</p><h3 id="Multi-Stream-Execution"><a href="#Multi-Stream-Execution" class="headerlink" title="Multi-Stream Execution"></a>Multi-Stream Execution</h3><p>Scalable design to process multiple input streams in parallel，这个应该就是GPU底层的优化了。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>TensorRT中有三个Parser用于模型的导入：</p><ul><li>Caffe Parser: 支持Caffe框架模型的导入</li><li>UFF Parser：通用框架格式(UFF)是描述DNN的执行图的数据格式</li><li>ONNX Parser：通用模型交换格式(ONNX)是一种开放式的文件格式，用于存储训练好的模型</li></ul><p>需要清楚的是，各种框架间模型的转换，需要的仅仅是模型的定义及权值。通过将模型保存为以上三个Parser可以解析的格式，则基本上就可以将模型导入到TensorRT中。</p><p>事实上，一个模型从导入到执行，会经过下面三个阶段：</p><ul><li>Network Definition: 这一阶段在TensorRT中定义网络模型，可以使用TensorRT提供的Parser导入已有模型进行定义，也可以使用TensorRT中提供的网络层来编程定义(这一步应该也需要准备好相关的权值)</li><li>Builder：前面提到过，TensorRT会对模型进行优化，这一步就是配置各项优化参数，并能生成可执行Inference的Engine</li><li>Engine：Engine可理解为一个Builder的实例，是我们导入的模型经过Builder的配置所生成的一个优化过的Inference执行器，所有的Inference可直接调用Engine来执行</li></ul><p><strong>一个模型从导入到生成Engine是需要花费一些时间的，因此TensorRT提供了Engine的序列化和反序列化操作，一旦我们确定了一个Engine，可以对其进行序列化操作，下次执行Inference时直接反序列化该Engine即可。</strong></p><p>其余琐碎的东西：</p><ul><li>TensorRT提供了C++接口和Python接口，官方建议使用C++接口</li><li><strong>一个Engine的建立是根据特定GPU和CUDA版本来的，所以在一个机器上序列化的Engine到另一个机器上不一定能使用，因此在使用Builder生成Engine前，要注意自己的环境配置</strong></li><li>TensorRT可结合DALI(加速数据读取)和DLA(加速某些层的运算)一起使用</li><li>对于TensorRT中不支持的层，需要自己编写相应的文件，TensorRT提供了相关支持</li></ul><h2 id="TensorRT使用流程"><a href="#TensorRT使用流程" class="headerlink" title="TensorRT使用流程"></a>TensorRT使用流程</h2><p>在使用tensorRT的过程中需要提供以下文件（以caffe为例）：</p><ol><li>A network architecture file (deploy.prototxt), 模型文件</li><li>Trained weights (net.caffemodel), 权值文件</li><li>A label file to provide a name for each output class. 标签文件</li></ol><p>前两个是为了解析模型时使用，最后一个是推理输出时将数字映射为有意义的文字标签。</p><p>tensorRT的使用包括两个阶段， build and deployment：</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>build：Import and optimize trained models to generate inference engines。build阶段主要完成模型转换（从caffe或TensorFlow到TensorRT），<strong>在模型转换时会完成前述优化过程中的层间融合，精度校准</strong>。这一步的输出是一个<strong>针对特定GPU平台和网络模型的优化过的TensorRT模型</strong>，这个TensorRT模型可以<strong>序列化</strong>存储到磁盘或内存中。<strong>存储到磁盘中的文件称之为 plan file</strong>。</p><p><img src="/MLFrameworks/TensorRT/TensorRT基本概念/TensorRT-workflow-1.png" alt="pasted-image-0-5-625x140"></p><p>下面代码是一个简单的build过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个builder</span></span><br><span class="line">IBuilder* builder = createInferBuilder(gLogger);</span><br><span class="line"><span class="comment">// parse the caffe model to populate the network, then set the outputs</span></span><br><span class="line"><span class="comment">// 创建一个network对象，不过这时network对象只是一个空架子</span></span><br><span class="line">INetworkDefinition* network = builder-&gt;createNetwork();</span><br><span class="line"><span class="comment">//tensorRT提供一个高级别的API：CaffeParser，用于解析Caffe模型</span></span><br><span class="line"><span class="comment">//parser.parse函数接受的参数就是上面提到的文件，和network对象</span></span><br><span class="line"><span class="comment">//这一步之后network对象里面的参数才被填充，才具有实际的意义</span></span><br><span class="line">CaffeParser parser;</span><br><span class="line"><span class="keyword">auto</span> blob_name_to_tensor = parser.parse(“deploy.prototxt”,</span><br><span class="line">                                        trained_file.c_str(),</span><br><span class="line">                                        *network,</span><br><span class="line">                                        DataType::kFLOAT);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 标记输出 tensors</span></span><br><span class="line"><span class="comment">// specify which tensors are outputs</span></span><br><span class="line">network-&gt;markOutput(*blob_name_to_tensor-&gt;find(<span class="string">"prob"</span>));</span><br><span class="line"><span class="comment">// Build the engine</span></span><br><span class="line"><span class="comment">// 设置batchsize和工作空间，然后创建inference engine</span></span><br><span class="line">builder-&gt;setMaxBatchSize(<span class="number">1</span>);</span><br><span class="line">builder-&gt;setMaxWorkspaceSize(<span class="number">1</span> &lt;&lt; <span class="number">30</span>); </span><br><span class="line"><span class="comment">//调用buildCudaEngine时才会进行前述的层间融合或精度校准优化方式</span></span><br><span class="line">ICudaEngine* engine = builder-&gt;buildCudaEngine(*network);</span><br></pre></td></tr></table></figure><p>上面的过程使用了一个高级别的API：CaffeParser，直接读取 caffe的模型文件，就可以解析，也就是填充network对象。解析的过程也可以直接使用一些低级别的C++API，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ITensor* in = network-&gt;addInput(“input”, DataType::kFloat, Dims3&#123;…&#125;);</span><br><span class="line">IPoolingLayer* pool = network-&gt;addPooling(in, PoolingType::kMAX, …);</span><br></pre></td></tr></table></figure><p><strong>解析caffe模型之后，必须要指定输出tensor，设置batch size，和设置工作空间。</strong></p><ol><li>设置batch size就跟使用caffe测试是一样的。关于<code>builder-&gt;setMaxBatchSize(1);</code>官方解释为：The maximum batch size specifies the batch size for which TensorRT will optimize. At runtime, a smaller batch size may be chosen.</li><li>设置工作空间是进行前述层间融合和张量融合的必要措施。层间融合和张量融合的过程是在调用<code>builder-&gt;buildCudaEngine</code>时才进行的。关于<code>builder-&gt;setMaxWorkspaceSize(1 &lt;&lt; 30);</code>官方解释为：Layer algorithms often require temporary workspace. This parameter limits the maximum size that any layer in the network can use. If an insufficient scratch is provided, it is possible that TensorRT may not be able to find an implementation for a given layer.</li></ol><p>另外，官方文档问题：Q: How do I choose the optimal workspace size?</p><p>A: Some TensorRT algorithms require additional workspace on the GPU. The method IBuilderConfig::setMaxWorkspaceSize() controls the maximum amount of workspace that may be allocated, and will prevent algorithms that require more workspace from being considered by the builder. At runtime, the space is allocated automatically when creating an IExecutionContext. The amount allocated will be no more than is required, even if the amount set in IBuilderConfig::setMaxWorkspaceSize() is much higher. Applications should therefore allow the TensorRT builder as much workspace as they can afford; at runtime TensorRT will allocate no more than this, and typically less.</p><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>deploy：Generate runtime inference engine for inference。deploy阶段主要完成推理过程，<strong>Kernel Auto-Tuning 和 Dynamic Tensor Memory 应该是在这里完成的</strong>。将上面一个步骤中的plan文件<strong>首先反序列化，并创建一个 runtime engine，然后就可以输入数据</strong>（比如测试集或数据集之外的图片），然后输出分类向量结果或检测结果。</p><p><img src="/MLFrameworks/TensorRT/TensorRT基本概念/TensorRT-workflow-2.png" alt="pasted-image-0-6-625x129"></p><p>以下是一个简单的deploy代码：<strong>这里面没有包含反序列化过程和测试时的batch流获取</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The execution context is responsible for launching the </span></span><br><span class="line"><span class="comment">// compute kernels 创建上下文环境 context，用于启动kernel</span></span><br><span class="line">IExecutionContext *context = engine-&gt;createExecutionContext();</span><br><span class="line"><span class="comment">// In order to bind the buffers, we need to know the names of the </span></span><br><span class="line"><span class="comment">// input and output tensors. //获取输入，输出tensor索引</span></span><br><span class="line"><span class="keyword">int</span> inputIndex = engine-&gt;getBindingIndex(INPUT_LAYER_NAME),</span><br><span class="line"><span class="keyword">int</span> outputIndex = engine-&gt;getBindingIndex(OUTPUT_LAYER_NAME);</span><br><span class="line"><span class="comment">//申请GPU显存</span></span><br><span class="line"><span class="comment">// Allocate GPU memory for Input / Output data</span></span><br><span class="line"><span class="keyword">void</span>* buffers = <span class="built_in">malloc</span>(engine-&gt;getNbBindings() * <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">cudaMalloc(&amp;buffers[inputIndex], batchSize * size_of_single_input);</span><br><span class="line">cudaMalloc(&amp;buffers[outputIndex], batchSize * size_of_single_output);</span><br><span class="line"><span class="comment">//使用cuda 流来管理并行计算</span></span><br><span class="line"><span class="comment">// Use CUDA streams to manage the concurrency of copying and executing</span></span><br><span class="line">cudaStream_t stream;</span><br><span class="line">cudaStreamCreate(&amp;stream);</span><br><span class="line"><span class="comment">//从内存到显存，input是读入内存中的数据；buffers[inputIndex]是显存上的存储区域，用于存放输入数据</span></span><br><span class="line"><span class="comment">// Copy Input Data to the GPU</span></span><br><span class="line">cudaMemcpyAsync(buffers[inputIndex], input, </span><br><span class="line">                batchSize * size_of_single_input, </span><br><span class="line">                cudaMemcpyHostToDevice, stream);</span><br><span class="line"><span class="comment">//启动cuda核计算</span></span><br><span class="line"><span class="comment">// Launch an instance of the GIE compute kernel</span></span><br><span class="line">context.enqueue(batchSize, buffers, stream, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//从显存到内存，buffers[outputIndex]是显存中的存储区，存放模型输出；output是内存中的数据</span></span><br><span class="line"><span class="comment">// Copy Output Data to the Host</span></span><br><span class="line">cudaMemcpyAsync(output, buffers[outputIndex], </span><br><span class="line">                batchSize * size_of_single_output, </span><br><span class="line">                cudaMemcpyDeviceToHost, stream));</span><br><span class="line"><span class="comment">//如果使用了多个cuda流，需要同步</span></span><br><span class="line"><span class="comment">// It is possible to have multiple instances of the code above</span></span><br><span class="line"><span class="comment">// in flight on the GPU in different streams.</span></span><br><span class="line"><span class="comment">// The host can then sync on a given stream and use the results</span></span><br><span class="line">cudaStreamSynchronize(stream);</span><br></pre></td></tr></table></figure><p>在执行的时候创建<strong>context，主要是分配预先的资源</strong>，engine加context就可以做推断（Inference）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://arleyzhang.github.io/articles/7f4b25ce/" target="_blank" rel="noopener">TensorRT(1)-介绍-使用-安装</a><br><a href="https://www.cnblogs.com/vh-pg/p/11677137.html" target="_blank" rel="noopener">《一》TensorRT之基本概念</a><br><a href="https://murphypei.github.io/blog/2019/09/trt-useage" target="_blank" rel="noopener">TensorRT 实战教程</a><br><a href="https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html" target="_blank" rel="noopener">tensorrt/developer-guide</a><br><a href="https://blog.csdn.net/ahxieqi/article/details/93628439" target="_blank" rel="noopener">TensorRT - Custom Layer</a><br><a href="https://zhuanlan.zhihu.com/p/35657027" target="_blank" rel="noopener">高性能深度学习支持引擎实战——TensorRT</a><br><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1592725491&amp;ver=2413&amp;signature=jTi63A64A9cB*DVMLC6B*FcZvqHk559SHhZwh5k87zM7ckAbRwt0ycJy9hizKGyEHjhvGb39a5LJfnn0x1u8iiZOtvfGHwuUzTVwPVa-sIL5YXMiIjTwXRVVQooBzwTX&amp;new=1" target="_blank" rel="noopener">深度学习算法优化系列二十二 | 利用TensorRT部署YOLOV3-Tiny INT8量化模型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要参考了&lt;a href=&quot;https://arleyzhang.github.io/articles/7f4b25ce/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TensorRT(1)-介绍-使用-安装&lt;/a&gt;，并加上了一些自己的理解。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;TensorRT是一个高性能的深度学习推理（Inference）优化器，可以为深度学习应用提供低延迟、高吞吐率的部署推理。TensorRT 之前称为GIE。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/MLFrameworks/TensorRT/TensorRT基本概念/Training-vs-Inference-1.jpg&quot; alt=&quot;Training-vs-Inference-Graphic&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上图可以很清楚的看出，训练（training）和 推理（inference）的区别：&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/categories/MLFrameworks/TensorRT/"/>
    
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/tags/TensorRT/"/>
    
      <category term="onnx" scheme="https://www.zdaiot.com/tags/onnx/"/>
    
  </entry>
  
  <entry>
    <title>使用TensorRT对Pytorch模型加速</title>
    <link href="https://www.zdaiot.com/MLFrameworks/TensorRT/%E4%BD%BF%E7%94%A8TensorRT%E5%AF%B9Pytorch%E6%A8%A1%E5%9E%8B%E5%8A%A0%E9%80%9F/"/>
    <id>https://www.zdaiot.com/MLFrameworks/TensorRT/使用TensorRT对Pytorch模型加速/</id>
    <published>2020-06-14T07:40:33.000Z</published>
    <updated>2021-08-20T08:38:38.414Z</updated>
    
    <content type="html"><![CDATA[<p>最近稍微学习了一下TensorRT，这里参考这很多博客，主要参考了<a href="https://zhuanlan.zhihu.com/p/88318324" target="_blank" rel="noopener">如何使用TensorRT对训练好的PyTorch模型进行加速?</a>。然后加上自己的一些注释。</p><p>现在训练深度学习模型主流的框架有TensorFlow，Pytorch，mxnet，caffe等。这个贴子只涉及Pytorch，对于TensorFlow的话，可以参考<a href="https://zhuanlan.zhihu.com/p/84125533" target="_blank" rel="noopener">TensorRT部署深度学习模型</a>，这个帖子是C++如何部署TensorRT。其实原理都是一样的，对于TensorFlow模型，需要把pb模型转化为uff模型；对于Pytorch模型，需要把pth模型转化为onnx模型；对于caffe模型，则不需要转化，因为tensorRT是可以直接读取caffe模型的；mxnet模型也是需要转化为onnx的。</p><p>对于TensorRT的安装，这里就不赘述了，之前我的博客有介绍过。</p><h2 id="Python环境下Pytorch模型转化为TensorRT"><a href="#Python环境下Pytorch模型转化为TensorRT" class="headerlink" title="Python环境下Pytorch模型转化为TensorRT"></a>Python环境下Pytorch模型转化为TensorRT</h2><p>Python环境下Pytorch模型转化为TensorRT有<strong>两种路径</strong>，一种是先把Pytorch的pt模型转化为onnx，然后再转化为TensorRT；另一种是直接把pytorch的pt模型转成TensorRT。</p><h3 id="Pytorch-gt-Onnx-gt-TensorRT"><a href="#Pytorch-gt-Onnx-gt-TensorRT" class="headerlink" title="Pytorch-&gt;Onnx-&gt;TensorRT"></a>Pytorch-&gt;Onnx-&gt;TensorRT</h3><p>首先，先把pt模型转化为onnx模型，需要安装onnx，直接<code>pip install onnx</code>即可。以ResNet50为例，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> onnx</span><br><span class="line">print(torch.__version__)</span><br><span class="line"></span><br><span class="line">input_name = [<span class="string">'input'</span>]</span><br><span class="line">output_name = [<span class="string">'output'</span>]</span><br><span class="line">input = Variable(torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)).cuda()</span><br><span class="line">model = torchvision.models.resnet50(pretrained=<span class="literal">True</span>).cuda()</span><br><span class="line">torch.onnx.export(model, input, <span class="string">'resnet50.onnx'</span>, input_names=input_name, output_names=output_name, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查一下生成的onnx</span></span><br><span class="line">test = onnx.load(<span class="string">'resnet50.onnx'</span>)</span><br><span class="line">onnx.checker.check_model(test)</span><br><span class="line">print(<span class="string">"==&gt; Passed"</span>)</span><br></pre></td></tr></table></figure><p>以上代码使用torchvision里面预训练的resnet50模型为基础，将resnet50的pt模型转化成res50.onnx，其中<strong>规定onnx的输入名是’input’，输出名是’output’</strong>，输入图像的大小是3通道224x224。其中batch size是1，其实这个batch size你可以取3、4、5等。运行这个代码就可以生成一个名为resnet50.onnx文件。</p><p>比较Pytorch和TensorRT的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pycuda.autoinit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pycuda.driver <span class="keyword">as</span> cuda</span><br><span class="line"><span class="keyword">import</span> tensorrt <span class="keyword">as</span> trt</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'test.jpg'</span></span><br><span class="line">max_batch_size = <span class="number">1</span></span><br><span class="line">onnx_model_path = <span class="string">'resnet50.onnx'</span></span><br><span class="line"></span><br><span class="line">TRT_LOGGER = trt.Logger()  <span class="comment"># This logger is required to build an engine</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img_np_nchw</span><span class="params">(filename)</span>:</span></span><br><span class="line">    image = cv2.imread(filename)</span><br><span class="line">    image_cv = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line">    image_cv = cv2.resize(image_cv, (<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">    miu = np.array([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>])</span><br><span class="line">    std = np.array([<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    img_np = np.array(image_cv, dtype=float) / <span class="number">255.</span></span><br><span class="line">    r = (img_np[:, :, <span class="number">0</span>] - miu[<span class="number">0</span>]) / std[<span class="number">0</span>]</span><br><span class="line">    g = (img_np[:, :, <span class="number">1</span>] - miu[<span class="number">1</span>]) / std[<span class="number">1</span>]</span><br><span class="line">    b = (img_np[:, :, <span class="number">2</span>] - miu[<span class="number">2</span>]) / std[<span class="number">2</span>]</span><br><span class="line">    img_np_t = np.array([r, g, b])</span><br><span class="line">    img_np_nchw = np.expand_dims(img_np_t, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> img_np_nchw</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostDeviceMem</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host_mem, device_mem)</span>:</span></span><br><span class="line">        <span class="string">"""Within this context, host_mom means the cpu memory and device means the GPU memory</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.host = host_mem</span><br><span class="line">        self.device = device_mem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Host:\n"</span> + str(self.host) + <span class="string">"\nDevice:\n"</span> + str(self.device)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate_buffers</span><span class="params">(engine)</span>:</span></span><br><span class="line">    inputs = []</span><br><span class="line">    outputs = []</span><br><span class="line">    bindings = []</span><br><span class="line">    stream = cuda.Stream()</span><br><span class="line">    <span class="keyword">for</span> binding <span class="keyword">in</span> engine:</span><br><span class="line">        size = trt.volume(engine.get_binding_shape(binding)) * engine.max_batch_size</span><br><span class="line">        dtype = trt.nptype(engine.get_binding_dtype(binding))</span><br><span class="line">        <span class="comment"># Allocate host and device buffers</span></span><br><span class="line">        host_mem = cuda.pagelocked_empty(size, dtype)</span><br><span class="line">        device_mem = cuda.mem_alloc(host_mem.nbytes)</span><br><span class="line">        <span class="comment"># Append the device buffer to device bindings.</span></span><br><span class="line">        bindings.append(int(device_mem))</span><br><span class="line">        <span class="comment"># Append to the appropriate list.</span></span><br><span class="line">        <span class="keyword">if</span> engine.binding_is_input(binding):</span><br><span class="line">            inputs.append(HostDeviceMem(host_mem, device_mem))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outputs.append(HostDeviceMem(host_mem, device_mem))</span><br><span class="line">    <span class="keyword">return</span> inputs, outputs, bindings, stream</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_engine</span><span class="params">(max_batch_size=<span class="number">1</span>, onnx_file_path=<span class="string">""</span>, engine_file_path=<span class="string">""</span>, \</span></span></span><br><span class="line"><span class="function"><span class="params">               fp16_mode=False, int8_mode=False, save_engine=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               )</span>:</span></span><br><span class="line">    <span class="string">"""Attempts to load a serialized engine if available, otherwise builds a new TensorRT engine and saves it."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_engine</span><span class="params">(max_batch_size, save_engine)</span>:</span></span><br><span class="line">        <span class="string">"""Takes an ONNX file and creates a TensorRT engine to run inference with"""</span></span><br><span class="line">        <span class="keyword">with</span> trt.Builder(TRT_LOGGER) <span class="keyword">as</span> builder, \</span><br><span class="line">                builder.create_network() <span class="keyword">as</span> network, \</span><br><span class="line">                trt.OnnxParser(network, TRT_LOGGER) <span class="keyword">as</span> parser:</span><br><span class="line"></span><br><span class="line">            builder.max_workspace_size = <span class="number">1</span> &lt;&lt; <span class="number">30</span>  <span class="comment"># Your workspace size</span></span><br><span class="line">            builder.max_batch_size = max_batch_size</span><br><span class="line">            <span class="comment"># pdb.set_trace()</span></span><br><span class="line">            builder.fp16_mode = fp16_mode  <span class="comment"># Default: False</span></span><br><span class="line">            builder.int8_mode = int8_mode  <span class="comment"># Default: False</span></span><br><span class="line">            <span class="keyword">if</span> int8_mode:</span><br><span class="line">                <span class="comment"># To be updated</span></span><br><span class="line">                <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Parse model file</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(onnx_file_path):</span><br><span class="line">                quit(<span class="string">'ONNX file &#123;&#125; not found'</span>.format(onnx_file_path))</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'Loading ONNX file from path &#123;&#125;...'</span>.format(onnx_file_path))</span><br><span class="line">            <span class="keyword">with</span> open(onnx_file_path, <span class="string">'rb'</span>) <span class="keyword">as</span> model:</span><br><span class="line">                print(<span class="string">'Beginning ONNX file parsing'</span>)</span><br><span class="line">                parser.parse(model.read())</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'Completed parsing of ONNX file'</span>)</span><br><span class="line">            print(<span class="string">'Building an engine from file &#123;&#125;; this may take a while...'</span>.format(onnx_file_path))</span><br><span class="line"></span><br><span class="line">            engine = builder.build_cuda_engine(network)</span><br><span class="line">            print(<span class="string">"Completed creating Engine"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> save_engine:</span><br><span class="line">                <span class="keyword">with</span> open(engine_file_path, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(engine.serialize())</span><br><span class="line">            <span class="keyword">return</span> engine</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(engine_file_path):</span><br><span class="line">        <span class="comment"># If a serialized engine exists, load it instead of building a new one.</span></span><br><span class="line">        print(<span class="string">"Reading engine from file &#123;&#125;"</span>.format(engine_file_path))</span><br><span class="line">        <span class="keyword">with</span> open(engine_file_path, <span class="string">"rb"</span>) <span class="keyword">as</span> f, trt.Runtime(TRT_LOGGER) <span class="keyword">as</span> runtime:</span><br><span class="line">            <span class="keyword">return</span> runtime.deserialize_cuda_engine(f.read())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> build_engine(max_batch_size, save_engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_inference</span><span class="params">(context, bindings, inputs, outputs, stream, batch_size=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># Transfer data from CPU to the GPU.</span></span><br><span class="line">    [cuda.memcpy_htod_async(inp.device, inp.host, stream) <span class="keyword">for</span> inp <span class="keyword">in</span> inputs]</span><br><span class="line">    <span class="comment"># Run inference.</span></span><br><span class="line">    context.execute_async(batch_size=batch_size, bindings=bindings, stream_handle=stream.handle)</span><br><span class="line">    <span class="comment"># Transfer predictions back from the GPU.</span></span><br><span class="line">    [cuda.memcpy_dtoh_async(out.host, out.device, stream) <span class="keyword">for</span> out <span class="keyword">in</span> outputs]</span><br><span class="line">    <span class="comment"># Synchronize the stream</span></span><br><span class="line">    stream.synchronize()</span><br><span class="line">    <span class="comment"># Return only the host outputs.</span></span><br><span class="line">    <span class="keyword">return</span> [out.host <span class="keyword">for</span> out <span class="keyword">in</span> outputs]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postprocess_the_outputs</span><span class="params">(h_outputs, shape_of_output)</span>:</span></span><br><span class="line">    h_outputs = h_outputs.reshape(*shape_of_output)</span><br><span class="line">    <span class="keyword">return</span> h_outputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img_np_nchw = get_img_np_nchw(filename)</span><br><span class="line">img_np_nchw = img_np_nchw.astype(dtype=np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># These two modes are dependent on hardwares</span></span><br><span class="line">fp16_mode = <span class="literal">False</span></span><br><span class="line">int8_mode = <span class="literal">False</span></span><br><span class="line">trt_engine_path = <span class="string">'./model_fp16_&#123;&#125;_int8_&#123;&#125;.trt'</span>.format(fp16_mode, int8_mode)</span><br><span class="line"><span class="comment"># Build an engine</span></span><br><span class="line">engine = get_engine(max_batch_size, onnx_model_path, trt_engine_path, fp16_mode, int8_mode)</span><br><span class="line"><span class="comment"># Create the context for this engine</span></span><br><span class="line">context = engine.create_execution_context()</span><br><span class="line"><span class="comment"># Allocate buffers for input and output</span></span><br><span class="line">inputs, outputs, bindings, stream = allocate_buffers(engine)  <span class="comment"># input, output: host # bindings</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do inference</span></span><br><span class="line">shape_of_output = (max_batch_size, <span class="number">1000</span>)</span><br><span class="line"><span class="comment"># Load data to the buffer</span></span><br><span class="line">inputs[<span class="number">0</span>].host = img_np_nchw.reshape(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># inputs[1].host = ... for multiple input</span></span><br><span class="line">t1 = time.time()</span><br><span class="line">trt_outputs = do_inference(context, bindings=bindings, inputs=inputs, outputs=outputs, stream=stream)  <span class="comment"># numpy data</span></span><br><span class="line">t2 = time.time()</span><br><span class="line">feat = postprocess_the_outputs(trt_outputs[<span class="number">0</span>], shape_of_output)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'TensorRT ok'</span>)</span><br><span class="line"></span><br><span class="line">model = torchvision.models.resnet50(pretrained=<span class="literal">True</span>).cuda()</span><br><span class="line">resnet_model = model.eval()</span><br><span class="line"></span><br><span class="line">input_for_torch = torch.from_numpy(img_np_nchw).cuda()</span><br><span class="line">t3 = time.time()</span><br><span class="line">feat_2 = resnet_model(input_for_torch)</span><br><span class="line">t4 = time.time()</span><br><span class="line">feat_2 = feat_2.cpu().data.numpy()</span><br><span class="line">print(<span class="string">'Pytorch ok!'</span>)</span><br><span class="line"></span><br><span class="line">mse = np.mean((feat - feat_2) ** <span class="number">2</span>)</span><br><span class="line">print(<span class="string">"Inference time with the TensorRT engine: &#123;&#125;"</span>.format(t2 - t1))</span><br><span class="line">print(<span class="string">"Inference time with the PyTorch model: &#123;&#125;"</span>.format(t4 - t3))</span><br><span class="line">print(<span class="string">'MSE Error = &#123;&#125;'</span>.format(mse))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'All completed!'</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TensorRT ok</span><br><span class="line">Pytorch ok!</span><br><span class="line">Inference time with the TensorRT engine: 0.0037250518798828125</span><br><span class="line">Inference time with the PyTorch model: 0.3574800491333008</span><br><span class="line">MSE Error = 3.297184357139993e-12</span><br></pre></td></tr></table></figure><blockquote><p>这里测得时间有点不准，第一次运行的时间是比较长的，但是我暂时没有GPU实验，所以先不讨论这个结果了。</p></blockquote><p>代码来源于<a href="https://github.com/RizhaoCai/PyTorch_ONNX_TensorRT" target="_blank" rel="noopener">PyTorch_ONNX_TensorRT</a>。</p><h3 id="Pytorch-gt-TensorRT"><a href="#Pytorch-gt-TensorRT" class="headerlink" title="Pytorch-&gt;TensorRT"></a>Pytorch-&gt;TensorRT</h3><p>接下来介绍Python环境下，直接把Pytorch模型转化为TensorRT，参考的代码来源于<a href="https://github.com/NVIDIA-AI-IOT/torch2trt" target="_blank" rel="noopener">NVIDIA-AI-IOT/torch2trt</a>这个工程比较简单易懂，质量很高，安装也不难，原文作者（即下面的第一个参考链接）运行的结果如下：</p><p><img src="/MLFrameworks/TensorRT/使用TensorRT对Pytorch模型加速/v2-db9df98635059fa8d8db009b2347600e_720w.jpg" alt="img"></p><p>对于你自己的Pytorch模型，只需要把代码的model进行替换即可。注意在运行过程中经常会出现”output tensor has no attribute _trt”，这是因为你模型当中有一些操作还没有实现，需要自己实现。</p><h2 id="C-环境下Pytorch模型转化为TensorRT"><a href="#C-环境下Pytorch模型转化为TensorRT" class="headerlink" title="C++环境下Pytorch模型转化为TensorRT"></a>C++环境下Pytorch模型转化为TensorRT</h2><p>C++环境下Pytorch模型转化为TensorRT有<strong>两种路径</strong>，一种是先把Pytorch的<code>pth</code>模型转化为<code>onnx</code>，然后使用TensorRT进行解析从而构造TensorRT引擎，这里和Python环境下的第一种方法大同小异；另一种是先把Pytorch的<code>pth</code>模型转化为<code>onnx</code>模型，然后使用<a href="https://github.com/onnx/onnx-tensorrt" target="_blank" rel="noopener">onnx-tensorrt</a>转换为TensorRT的<code>trt</code>文件，然后在C++环境下的使用TensorRT直接加载<code>trt</code>文件，从而构建engine。</p><h3 id="Pytorch-gt-Onnx-gt-TensorRT解析"><a href="#Pytorch-gt-Onnx-gt-TensorRT解析" class="headerlink" title="Pytorch-&gt;Onnx-&gt;TensorRT解析"></a>Pytorch-&gt;Onnx-&gt;TensorRT解析</h3><p>c++环境下，以TensorRT5.1.5.0的sampleOnnxMNIST为例子，用opencv读取一张图片，然后让TensorRT进行doInference输出(1,1000)的特征。代码如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime_api.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"NvInfer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"NvOnnxParser.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"argsParser.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"image.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DebugP(x) std::cout &lt;&lt; <span class="meta-string">"Line"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="meta-string">"  "</span> &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> nvinfer1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INPUT_H = <span class="number">224</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INPUT_W = <span class="number">224</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INPUT_C = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> OUTPUT_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定输入输出名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* INPUT_BLOB_NAME = <span class="string">"input"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* OUTPUT_BLOB_NAME = <span class="string">"output"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> gSampleName = <span class="string">"TensorRT.sample_onnx_image"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">samplesCommon::Args gArgs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onnxToTRTModel</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; modelFile, <span class="comment">// name of the onnx model</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> maxBatchSize,    <span class="comment">// batch size - NB must be at least as large as the batch we want to run with</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    IHostMemory*&amp; trtModelStream)</span> <span class="comment">// output buffer for the TensorRT model</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. create the builder</span></span><br><span class="line">    <span class="comment">//创建一个 IBuilder，传进gLogger参数是为了方便打印信息，gLogger是一个日志类，在common.h文件中定义</span></span><br><span class="line">    <span class="comment">//builder 这个地方感觉像是使用了建造者模式。</span></span><br><span class="line">    IBuilder* builder = createInferBuilder(gLogger.getTRTLogger());</span><br><span class="line">    assert(builder != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">//创建一个 network对象，但是这个network对象只是一个空架子，里面的属性还没有具体的数值。</span></span><br><span class="line">    nvinfer1::INetworkDefinition* network = builder-&gt;createNetwork();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个onnx模型解析对象parser</span></span><br><span class="line">    <span class="keyword">auto</span> parser = nvonnxparser::createParser(*network, gLogger.getTRTLogger());</span><br><span class="line">    <span class="comment">//Optional - uncomment below lines to view network layer information</span></span><br><span class="line">    <span class="comment">//config-&gt;setPrintLayerInfo(true);</span></span><br><span class="line">    <span class="comment">//parser-&gt;reportParsingInfo();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用解析函数parseFromFile填充network对象，将onnx中的tensor解析为tensorRT中的tensor，此处使用到了模型文件，还用到了 common.cpp 文件中的辅助函数：locateFile( ) </span></span><br><span class="line">    <span class="keyword">if</span> ( !parser-&gt;parseFromFile( locateFile(modelFile, gArgs.dataDirs).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(gLogger.getReportableSeverity()) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        gLogError &lt;&lt; <span class="string">"Failure while parsing ONNX file"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Build the engine</span></span><br><span class="line">    <span class="comment">// 设置batch size；实际推理时不能大于该batch size</span></span><br><span class="line">    builder-&gt;setMaxBatchSize(maxBatchSize);</span><br><span class="line">    <span class="comment">//builder-&gt;setMaxWorkspaceSize(1 &lt;&lt; 20);</span></span><br><span class="line">    <span class="comment">// 设置工作空间 size，Layer algorithms often require temporary workspace.</span></span><br><span class="line">    builder-&gt;setMaxWorkspaceSize(<span class="number">10</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 设置推理方式</span></span><br><span class="line">    builder-&gt;setFp16Mode(gArgs.runInFp16);</span><br><span class="line">    builder-&gt;setInt8Mode(gArgs.runInInt8);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gArgs.runInInt8)</span><br><span class="line">    &#123;</span><br><span class="line">        samplesCommon::setAllTensorScales(network, <span class="number">127.0f</span>, <span class="number">127.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    samplesCommon::enableDLA(builder, gArgs.useDLACore);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. Build engine</span></span><br><span class="line">    <span class="comment">//使用network创建 CudaEngine，优化方法在这里执行。</span></span><br><span class="line">    <span class="comment">//至此，Onnx模型已转换为tensorRT object。</span></span><br><span class="line">    ICudaEngine* engine = builder-&gt;buildCudaEngine(*network);</span><br><span class="line">    assert(engine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can destroy the parser</span></span><br><span class="line">    parser-&gt;destroy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// serialize the engine, then close everything down</span></span><br><span class="line">    <span class="comment">//将转换好的tensorRT object序列化到内存中，trtModelStream是一块内存空间。</span></span><br><span class="line">    <span class="comment">//这里也可以序列化到磁盘中。</span></span><br><span class="line">    trtModelStream = engine-&gt;serialize();</span><br><span class="line">    engine-&gt;destroy();</span><br><span class="line">    network-&gt;destroy();</span><br><span class="line">    builder-&gt;destroy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doInference</span><span class="params">(IExecutionContext&amp; context, <span class="keyword">float</span>* input, <span class="keyword">float</span>* output, <span class="keyword">int</span> batchSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用传进来的context恢复engine。</span></span><br><span class="line">    <span class="keyword">const</span> ICudaEngine&amp; engine = context.getEngine();</span><br><span class="line">    <span class="comment">//engine.getNbBindings()是为了获取与这个engine相关的输入输出tensor的数量。</span></span><br><span class="line">    <span class="comment">//这个地方，输入+输出 总共就2个，所以做个验证。</span></span><br><span class="line">    <span class="comment">// input and output buffer pointers that we pass to the engine - the engine requires exactly IEngine::getNbBindings(),</span></span><br><span class="line">    <span class="comment">// of these, but in this case we know that there is exactly one input and one output.</span></span><br><span class="line">    assert(engine.getNbBindings() == <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//void* 型数组，主要用于下面GPU开辟内存。</span></span><br><span class="line">    <span class="keyword">void</span>* buffers[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In order to bind the buffers, we need to know the names of the input and output tensors.</span></span><br><span class="line">    <span class="comment">// note that indices are guaranteed to be less than IEngine::getNbBindings()</span></span><br><span class="line">    <span class="comment">//获取与这个engine相关的输入输出tensor的索引。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inputIndex = engine.getBindingIndex(INPUT_BLOB_NAME);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> outputIndex = engine.getBindingIndex(OUTPUT_BLOB_NAME);</span><br><span class="line">    </span><br><span class="line">    DebugP(inputIndex); DebugP(outputIndex);</span><br><span class="line">    <span class="comment">//为输入输出tensor开辟显存。</span></span><br><span class="line">    <span class="comment">// create GPU buffers and a stream</span></span><br><span class="line">    CHECK(cudaMalloc(&amp;buffers[inputIndex], batchSize * INPUT_C * INPUT_H * INPUT_W * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    CHECK(cudaMalloc(&amp;buffers[outputIndex], batchSize * OUTPUT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建cuda流，用于管理数据复制，存取，和计算的并发操作</span></span><br><span class="line">    cudaStream_t stream;</span><br><span class="line">    CHECK(cudaStreamCreate(&amp;stream));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从内存到显存，从CPU到GPU，将输入数据拷贝到显存中</span></span><br><span class="line">    <span class="comment">//input是读入内存中的数据；buffers[inputIndex]是显存上的存储区域，用于存放输入数据</span></span><br><span class="line">    <span class="comment">// DMA the input to the GPU,  execute the batch asynchronously, and DMA it back:</span></span><br><span class="line">    CHECK(cudaMemcpyAsync(buffers[inputIndex], input, batchSize * INPUT_C * INPUT_H * INPUT_W * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), cudaMemcpyHostToDevice, stream));</span><br><span class="line">    <span class="comment">//启动cuda核，异步执行推理计算</span></span><br><span class="line">    context.enqueue(batchSize, buffers, stream, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">//从显存到内存，将计算结果拷贝回内存中</span></span><br><span class="line">    <span class="comment">//output是内存中的存储区域;buffers[outputIndex]是显存中的存储区域，存放模型输出.</span></span><br><span class="line">    CHECK(cudaMemcpyAsync(output, buffers[outputIndex], batchSize * OUTPUT_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), cudaMemcpyDeviceToHost, stream));</span><br><span class="line">     <span class="comment">//这个是为了同步不同的cuda流。</span></span><br><span class="line">    cudaStreamSynchronize(stream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁流对象和释放显存</span></span><br><span class="line">    <span class="comment">// release the stream and the buffers</span></span><br><span class="line">    cudaStreamDestroy(stream);</span><br><span class="line">    CHECK(cudaFree(buffers[inputIndex]));</span><br><span class="line">    CHECK(cudaFree(buffers[outputIndex]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! \brief This function prints the help information for running this sample</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHelpInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: ./sample_onnx_mnist [-h or --help] [-d or --datadir=&lt;path to data directory&gt;] [--useDLACore=&lt;int&gt;]\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--help          Display help information\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--datadir       Specify path to a data directory, overriding the default. This option can be used multiple times to add multiple directories. If no data directories are given, the default is to use (data/samples/mnist/, data/mnist/)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--useDLACore=N  Specify a DLA engine for layers that support DLA. Value can range from 0 to n-1, where n is the number of DLA engines on the platform."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--int8          Run in Int8 mode.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--fp16          Run in FP16 mode."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> argsOK = samplesCommon::parseArgs(gArgs, argc, argv);</span><br><span class="line">    <span class="keyword">if</span> (gArgs.help)</span><br><span class="line">    &#123;</span><br><span class="line">        printHelpInfo();</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!argsOK)</span><br><span class="line">    &#123;</span><br><span class="line">        gLogError &lt;&lt; <span class="string">"Invalid arguments"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        printHelpInfo();</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gArgs.dataDirs.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        gArgs.dataDirs = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&#123;<span class="string">"data/samples/mnist/"</span>, <span class="string">"data/mnist/"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sampleTest = gLogger.defineTest(gSampleName, argc, <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>**&gt;(argv));</span><br><span class="line"></span><br><span class="line">    gLogger.reportTestStart(sampleTest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a TensorRT model from the onnx model and serialize it to a stream</span></span><br><span class="line">    IHostMemory* trtModelStream&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行onnxToTRTModel</span></span><br><span class="line">    <span class="keyword">if</span> (!onnxToTRTModel(<span class="string">"resnet50.onnx"</span>, <span class="number">1</span>, trtModelStream))</span><br><span class="line">        gLogger.reportFail(sampleTest);</span><br><span class="line"></span><br><span class="line">    assert(trtModelStream != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Successfully parsed ONNX file!!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Start reading the input image!!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    cv::Mat image = cv::imread(locateFile(<span class="string">"test.jpg"</span>, gArgs.dataDirs), cv::IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (image.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The input image is empty!!! Please check....."</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DebugP(image.size());</span><br><span class="line">    cv::cvtColor(image, image, cv::COLOR_BGR2RGB);</span><br><span class="line"></span><br><span class="line">    cv::Mat dst = cv::Mat::zeros(INPUT_H, INPUT_W, CV_32FC3);</span><br><span class="line">    cv::resize(image, dst, dst.size());</span><br><span class="line">    DebugP(dst.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span>* data = normal(dst); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建运行时环境 IRuntime对象，传入 gLogger 用于打印信息</span></span><br><span class="line">    <span class="comment">// deserialize the engine</span></span><br><span class="line">    IRuntime* runtime = createInferRuntime(gLogger);</span><br><span class="line">    assert(runtime != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (gArgs.useDLACore &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        runtime-&gt;setDLACore(gArgs.useDLACore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ICudaEngine* engine = runtime-&gt;deserializeCudaEngine(trtModelStream-&gt;data(), trtModelStream-&gt;size(), <span class="literal">nullptr</span>);</span><br><span class="line">    assert(engine != <span class="literal">nullptr</span>);</span><br><span class="line">    trtModelStream-&gt;destroy();</span><br><span class="line">    <span class="comment">// 创建上下文环境，主要用于inference 函数中启动cuda核</span></span><br><span class="line">    IExecutionContext* context = engine-&gt;createExecutionContext();</span><br><span class="line">    assert(context != <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> prob[OUTPUT_SIZE];</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::high_resolution_clock Time;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;&gt; ms;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">float</span>&gt; fsec;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deploy 阶段：调用 inference 函数，进行推理过程</span></span><br><span class="line">    <span class="comment">// run inference and cout time</span></span><br><span class="line">    <span class="keyword">auto</span> t0 = Time::now();</span><br><span class="line">    doInference(*context, data, prob, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> t1 = Time::now();</span><br><span class="line">    fsec fs = t1 - t0;</span><br><span class="line">    ms d = <span class="built_in">std</span>::chrono::duration_cast&lt;ms&gt;(fs);</span><br><span class="line">    total += d.count();</span><br><span class="line">    <span class="comment">// 销毁无用对象</span></span><br><span class="line">    <span class="comment">// destroy the engine</span></span><br><span class="line">    context-&gt;destroy();</span><br><span class="line">    engine-&gt;destroy();</span><br><span class="line">    runtime-&gt;destroy();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="string">"Running time of one image is:"</span> &lt;&lt; total &lt;&lt; <span class="string">"ms"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    gLogInfo &lt;&lt; <span class="string">"Output:\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; OUTPUT_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gLogInfo &lt;&lt; prob[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    gLogInfo &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gLogger.reportTest(sampleTest, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>image.cpp</code>的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"image.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> kMean[<span class="number">3</span>] = &#123; <span class="number">0.485f</span>, <span class="number">0.456f</span>, <span class="number">0.406f</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> kStdDev[<span class="number">3</span>] = &#123; <span class="number">0.229f</span>, <span class="number">0.224f</span>, <span class="number">0.225f</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> map_[<span class="number">7</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; ,</span><br><span class="line">&#123;<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">128</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">128</span>&#125;,</span><br><span class="line">&#123;<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">128</span>,<span class="number">0</span>,<span class="number">128</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">128</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">normal</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cv::Mat image(img.rows, img.cols, CV_32FC3);</span></span><br><span class="line"><span class="keyword">float</span> * data;</span><br><span class="line">data = (<span class="keyword">float</span>*)<span class="built_in">calloc</span>(img.rows*img.cols * <span class="number">3</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; ++c)</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img.rows; ++i)</span><br><span class="line">&#123; <span class="comment">//获取第i行首像素指针 </span></span><br><span class="line">cv::Vec3b *p1 = img.ptr&lt;cv::Vec3b&gt;(i);</span><br><span class="line"><span class="comment">//cv::Vec3b *p2 = image.ptr&lt;cv::Vec3b&gt;(i);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img.cols; ++j)</span><br><span class="line">&#123;</span><br><span class="line">data[c * img.cols * img.rows + i * img.cols + j] = (p1[j][c] / <span class="number">255.0f</span> - kMean[c]) / kStdDev[c];</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>image.hpp的内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">float</span> *data;</span><br><span class="line">&#125; image;</span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">normal</span><span class="params">(cv::Mat img)</span></span>;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="/MLFrameworks/TensorRT/使用TensorRT对Pytorch模型加速/v2-c0444b35f607445bf62fd4c7cc30be8d_720w.jpg" alt="img"></p><p>同样的<code>test.jpg</code>在python环境下的运行结果为：</p><p><img src="/MLFrameworks/TensorRT/使用TensorRT对Pytorch模型加速/v2-877f488bcd1c4cb278a050c1647dcaa8_720w.png" alt="img"></p><p>可以发现，c++环境下resnet50输出的(1,1000)的特征与Python环境下feat1(TensorRT)和feat2(pytorch)的结果差距很小。</p><p><strong>总结：</strong></p><ol><li><code>onnxToTRTModel</code>的过程为：创建一个builder和network，使用parser解析Onnx模型填充network；使用builder类的方法设置batch size、workspace、推理方法（fp32、fp16、int8）。使用<code>builder-&gt;buildCudaEngine(*network)</code>执行优化方法创建engine。因为一个模型从导入到生成Engine是需要花费一些时间的，所以<strong>可以将engine序列化到内存或者存储文件中</strong>，便于使用（需要注意的是，若将序列化文件存储到了文件中，该文件和GPU平台高度相关，换一个平台需要重新生成该文件）。最后是销毁一些中间变量<code>parser</code>、<code>engine</code>、<code>network</code>、<code>builder</code>。</li><li><code>mian</code>函数主要过程为：执行<code>onnxToTRTModel</code>函数得到序列化engine——内存中的<code>trtModelStream</code>。创建运行时环境 IRuntime对象<code>runtime</code>，然后使用该对象反序列化<code>trtModelStream</code>得到<code>engine</code>；使用<code>engine</code>创建上下文环境<code>context</code>，主要用于inference 函数中启动cuda核。执行<code>doInference</code>函数过程。然后销毁<code>context</code>、<code>engine</code>、<code>runtime</code>。</li><li><code>doInference</code>函数的主要过程为：从上下文环境<code>context</code>恢复<code>engine</code>。为输入输出tensor开辟显存，到<code>void* buffers</code>中。创建cuda流，用于管理数据复制，存取，和计算的并发操作。从内存到显存，从CPU到GPU，将输入数据拷贝到显存中。启动cuda核，异步执行推理计算。从显存到内存，将计算结果拷贝回内存中。同步不同的cuda流。销毁流对象<code>stream</code>和释放显存<code>buffers</code>。</li></ol><h3 id="Pytorch-gt-Onnx-gt-TensorRT模型"><a href="#Pytorch-gt-Onnx-gt-TensorRT模型" class="headerlink" title="Pytorch-&gt;Onnx-&gt;TensorRT模型"></a>Pytorch-&gt;Onnx-&gt;TensorRT模型</h3><p>上面的是将pytorch首先转化为onnx，然后让TensorRT解析onnx从而构建TensorRT引擎。那么我们如何让TensorRT直接加载引擎文件呢，也就是说，我们先把onnx转化为TensorRT的trt文件，然后让c++环境下的TensorRT直接加载trt文件，从而构建engine。</p><p>在这里我们首先使用onnx-tensorrt这个项目来使resnet50.onnx转化为resnet50.trt。采用的项目是<a href="https://github.com/onnx/onnx-tensorrt" target="_blank" rel="noopener">onnx-tensorrt</a>这个项目的安装也不难，这个也在我之前的博客里面有介绍，所以不展开了。</p><p>运行如下命令，就可以获得rensnet50.trt这个引擎文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onnx2trt resnet50.onnx -o resnet50.trt</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>onnx-tensort这个项目在编译的时有一个指定GPU计算能力的选项</strong>，如下图所示：</p><p><img src="/MLFrameworks/TensorRT/使用TensorRT对Pytorch模型加速/v2-d1e0cab46990702c9a71d312c28532ce_720w.jpg" alt="img"></p><p><strong>另外在onnx2trt命令有个<code>-b</code>操作，是指定生成的trt文件的batch size的。在实际test过程中，你的batch size是多少，这个就设置成多少。按照下面参考链接1作者的说法：</strong></p><blockquote><p> 记得我当时trt文件的batch size是1，但是我实际的batch size是8，运行后，只有一张图片有结果，其他7张图片都是0。</p></blockquote><p>还有，导出onnx模型时，网络的数据输入要和TensorRt数据输入大小保持一致（b,c,w,h）。对于retinaface，若不这样做，否则可能因为特征图大小不一样，导致预测的anchor偏置数量与预设anchor数量不一致。在进行后处理时导致访问非法内存。</p><p>如果能顺利生成trt文件的话，在代码中可以直接添加以下函数，来生成engine, 其他就不需要改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_TRT_File</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; engineFile, IHostMemory*&amp; trtModelStream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::fstream file;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"loading filename from:"</span> &lt;&lt; engineFile &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     nvinfer1::IRuntime* trtRuntime;</span><br><span class="line">     <span class="comment">//nvonnxparser::IPluginFactory* onnxPlugin = createPluginFactory(gLogger.getTRTLogger());</span></span><br><span class="line">     file.open(engineFile, <span class="built_in">std</span>::ios::binary | <span class="built_in">std</span>::ios::in);</span><br><span class="line">     file.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::end);</span><br><span class="line">     <span class="keyword">int</span> length = file.tellg();</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length:"</span> &lt;&lt; length &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     file.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::beg);</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">char</span>[]&gt; data(<span class="keyword">new</span> <span class="keyword">char</span>[length]);</span><br><span class="line">     file.read(data.get(), length);</span><br><span class="line">     file.close();</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"load engine done"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deserializing"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">// 创建运行时环境 IRuntime对象，传入 gLogger 用于打印信息</span></span><br><span class="line">     trtRuntime = createInferRuntime(gLogger.getTRTLogger());</span><br><span class="line">     <span class="comment">//ICudaEngine* engine = trtRuntime-&gt;deserializeCudaEngine(data.get(), length, onnxPlugin);</span></span><br><span class="line">     <span class="comment">// 反序列化前向引擎</span></span><br><span class="line">     ICudaEngine* engine = trtRuntime-&gt;deserializeCudaEngine(data.get(), length, <span class="literal">nullptr</span>);</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deserialize done"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     assert(engine != <span class="literal">nullptr</span>);</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The engine in TensorRT.cpp is not nullptr"</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//将转换好的tensorRT object序列化到内存中，trtModelStream是一块内存空间。</span></span><br><span class="line">     <span class="comment">//这里也可以序列化到磁盘中。</span></span><br><span class="line">     <span class="comment">// Serialize engine and destroy it</span></span><br><span class="line">     trtModelStream = engine-&gt;serialize();</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果想保存引擎文件的话，可以在自己的代码中添加这几句话，就可以生成trt文件，然后下次直接调用trt文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nvinfer1::IHostMemory* data = engine-&gt;serialize();</span><br><span class="line"><span class="built_in">std</span>::ofstream file;</span><br><span class="line">file.open(filename, <span class="built_in">std</span>::ios::binary | <span class="built_in">std</span>::ios::out);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"writing engine file..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">file.write((<span class="keyword">const</span> <span class="keyword">char</span>*)data-&gt;data(), data-&gt;size());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"save engine file done"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按照目前我的观察，这里只说C++接口，按照第一种方法可以在导出Onnx模型后，使用C++代码控制使用fp32、fp16或者int8进行推理，但是若按照第二种方法，无法使用C++代码控制使用fp32、fp16或者int8进行推理，虽然onnx2trt有一个<code>-d</code>参数指明是float32还是float16，但即便是这样，按照<a href="https://github.com/onnx/onnx-tensorrt/issues/32" target="_blank" rel="noopener">How to use FP16 ot INT8? #32</a>，好像也有很多坑待填。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/88318324" target="_blank" rel="noopener">如何使用TensorRT对训练好的PyTorch模型进行加速?</a><br><a href="https://arleyzhang.github.io/articles/7f4b25ce/" target="_blank" rel="noopener">TensorRT(1)-介绍-使用-安装</a><br><a href="https://arleyzhang.github.io/articles/c17471cb/" target="_blank" rel="noopener">TensorRT(2)-基本使用：mnist手写体识别</a><br><a href="https://blog.csdn.net/may0324/article/details/90083988" target="_blank" rel="noopener">caffe模型TensorRT部署实践（一）</a><br><a href="https://github.com/NVIDIA/TensorRT/issues/322" target="_blank" rel="noopener">The TensorRT support multi-gpus inference? #322</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近稍微学习了一下TensorRT，这里参考这很多博客，主要参考了&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88318324&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何使用TensorRT对训练好的PyTorch模型进行加速?&lt;/a&gt;。然后加上自己的一些注释。&lt;/p&gt;
&lt;p&gt;现在训练深度学习模型主流的框架有TensorFlow，Pytorch，mxnet，caffe等。这个贴子只涉及Pytorch，对于TensorFlow的话，可以参考&lt;a href=&quot;https://zhuanlan.zhihu.com/p/84125533&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TensorRT部署深度学习模型&lt;/a&gt;，这个帖子是C++如何部署TensorRT。其实原理都是一样的，对于TensorFlow模型，需要把pb模型转化为uff模型；对于Pytorch模型，需要把pth模型转化为onnx模型；对于caffe模型，则不需要转化，因为tensorRT是可以直接读取caffe模型的；mxnet模型也是需要转化为onnx的。&lt;/p&gt;
&lt;p&gt;对于TensorRT的安装，这里就不赘述了，之前我的博客有介绍过。&lt;/p&gt;
&lt;h2 id=&quot;Python环境下Pytorch模型转化为TensorRT&quot;&gt;&lt;a href=&quot;#Python环境下Pytorch模型转化为TensorRT&quot; class=&quot;headerlink&quot; title=&quot;Python环境下Pytorch模型转化为TensorRT&quot;&gt;&lt;/a&gt;Python环境下Pytorch模型转化为TensorRT&lt;/h2&gt;&lt;p&gt;Python环境下Pytorch模型转化为TensorRT有&lt;strong&gt;两种路径&lt;/strong&gt;，一种是先把Pytorch的pt模型转化为onnx，然后再转化为TensorRT；另一种是直接把pytorch的pt模型转成TensorRT。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/categories/MLFrameworks/TensorRT/"/>
    
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/tags/Pytorch/"/>
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/tags/TensorRT/"/>
    
      <category term="onnx" scheme="https://www.zdaiot.com/tags/onnx/"/>
    
  </entry>
  
  <entry>
    <title>onnx-tensorrt安装</title>
    <link href="https://www.zdaiot.com/MLFrameworks/TensorRT/onnx-tensorrt%E5%AE%89%E8%A3%85/"/>
    <id>https://www.zdaiot.com/MLFrameworks/TensorRT/onnx-tensorrt安装/</id>
    <published>2020-06-09T06:57:33.000Z</published>
    <updated>2020-06-09T06:57:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近踩了一下从onnx导出到TensorRT的坑，在这记录一下。</p><h2 id="安装TensorRT"><a href="#安装TensorRT" class="headerlink" title="安装TensorRT"></a>安装TensorRT</h2><p>从<a href="https://developer.nvidia.com/tensorrt" target="_blank" rel="noopener">官方地址</a>下载合适版本的TensorRT，例如我这里下载的就是<code>TensorRT-7.0.0.11.CentOS-7.6.x86_64-gnu.cuda-10.2.cudnn7.6.tar.gz</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line"><span class="comment"># tar -xzvf TensorRT-7.0.0.11.CentOS-7.6.x86_64-gnu.cuda-10.2.cudnn7.6.tar.gz -C /指定你要的路径</span></span><br><span class="line"><span class="comment"># 比如</span></span><br><span class="line">tar -xzvf TensorRT-7.0.0.11.CentOS-7.6.x86_64-gnu.cuda-10.2.cudnn7.6.tar.gz -C /data2/zhaodali/software</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量 </span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/data2/zhaodali/software/TensorRT-7.0.0.11/lib</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Python支持，选择对应python版本的whl进行安装</span></span><br><span class="line"><span class="built_in">cd</span> /data2/zhaodali/software/TensorRT-7.0.0.11/python</span><br><span class="line">pip install tensorrt-7.0.0.11-cp37-none-linux_x86_64.whl</span><br></pre></td></tr></table></figure><h2 id="安装ONNX-tensorrt"><a href="#安装ONNX-tensorrt" class="headerlink" title="安装ONNX_tensorrt"></a>安装ONNX_tensorrt</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules https://github.com/onnx/onnx-tensorrt.git</span><br><span class="line"><span class="built_in">cd</span> onnx-tensorrt</span><br><span class="line"><span class="comment"># 值得注意的是，这个版本必须要和tensorrt的版本对应！！！</span></span><br><span class="line">git checkout 7.0</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># cmake .. -DTENSORRT_ROOT=&lt;tensorrt_install_dir&gt; -DGPU_ARCHS='xxx'</span></span><br><span class="line"><span class="comment"># 从https://developer.nvidia.com/cuda-gpus这里查看你GPU的计算能力，替换上面的'xxx'</span></span><br><span class="line">cmake .. -DTENSORRT_ROOT=/data2/zhaodali/software/TensorRT-7.0.0.11 -DGPU_ARCHS=<span class="string">"61"</span></span><br><span class="line">make -j 12</span><br></pre></td></tr></table></figure><p>这个时候，遇到了一个问题：<code>Expected &quot;required&quot;, &quot;optio nal&quot;, or &quot;repeated&quot;.</code>经过查询，是protoc的版本过低导致的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令 whereis protoc 可以查看哪些路径下安装了protoc</span></span><br><span class="line"><span class="comment"># 命令 which protoc 可以查看默认选用protoc的路径</span></span><br><span class="line"><span class="comment"># 命令 protoc --version 可以查看当前protoc版本</span></span><br><span class="line"></span><br><span class="line">[zhaodali@64 ~]$ whereis protoc</span><br><span class="line">protoc: /usr/bin/protoc /usr/<span class="built_in">local</span>/bin/protoc</span><br><span class="line">[zhaodali@64 ~]$ <span class="built_in">which</span> protoc</span><br><span class="line">/usr/bin/protoc</span><br><span class="line">.[zhaodali@64 ~]$ protoc --version</span><br><span class="line">libprotoc 2.5.0</span><br></pre></td></tr></table></figure><p>这个时候需要重新编译protoc，操作过程为：</p><p>从<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">官方地址</a>下载最新的安装包，例如我这里下载的为<code>protobuf-all-3.12.3.tar.gz</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf protobuf-all-3.12.3.tar.gz</span><br><span class="line"><span class="comment"># 更改安装路径</span></span><br><span class="line"><span class="built_in">cd</span> protobuf-3.12.3/</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure --prefix=/data2/zhaodali/software/protobuf</span><br><span class="line">make -j 12</span><br><span class="line">make check</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，注意将$PATH放在后面</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/data2/zhaodali/software/protobuf/bin:<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure><p>需要注意的是<code>export PATH=&quot;/data2/zhaodali/software/protobuf/bin:$PATH&quot;</code>会先从前面加载protobuf，但是若设置为：<code>export PATH=$PATH:/data2/zhaodali/software/protobuf/bin</code>，则会先从系统路径中加载protobuf！！！</p><p>这里附一个附录，是关于怎么添加各种环境变量的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#(动态库搜索路径) 程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/lib/</span><br><span class="line"><span class="comment">#(静态库搜索路径) 程序编译期间查找动态链接库时指定查找共享库的路径</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/lib/</span><br><span class="line"><span class="comment">#执行程序搜索路径</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/protobuf/bin/</span><br><span class="line"><span class="comment">#c程序头文件搜索路径</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$C_INCLUDE_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/include/</span><br><span class="line"><span class="comment">#c++程序头文件搜索路径</span></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=<span class="variable">$CPLUS_INCLUDE_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/include/</span><br><span class="line"><span class="comment">#pkg-config 路径</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/usr/<span class="built_in">local</span>/protobuf/lib/pkgconfig/</span><br></pre></td></tr></table></figure><p>这个时候又遇到了一个问题，提示cmake的版本过低，23333我可真难。首先从<a href="https://cmake.org/files" target="_blank" rel="noopener">官方地址</a>下载最新的cmake安装包，例如我下载的就是<a href="https://cmake.org/files/v3.17/cmake-3.17.1.tar.gz" target="_blank" rel="noopener">cmake-3.17.1.tar.gz</a>。然后执行如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tar xvf cmake-3.17.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> cmake-3.17.1</span><br><span class="line">./bootstrap --prefix=/data2/zhaodali/software/cmake3171</span><br><span class="line"> make -j 12</span><br><span class="line"> make install</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 设置环境变量</span></span><br><span class="line"> vim ~/.bash_profile </span><br><span class="line"> <span class="built_in">export</span> PATH=/data2/zhaodali/software/cmake3171/bin:<span class="variable">$PATH</span></span><br><span class="line"> <span class="built_in">source</span> ~/.bash_profile </span><br><span class="line"> <span class="comment"># 验证</span></span><br><span class="line"> cmake --version</span><br></pre></td></tr></table></figure><p>然后这个时候，重新回到<code>onnx-tensorrt/build</code>，执行如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> onnx-tensorrt/build</span><br><span class="line">rm -r *</span><br><span class="line">cmake .. -DTENSORRT_ROOT=/data2/zhaodali/software/TensorRT-7.0.0.11 -DGPU_ARCHS=<span class="string">"61"</span> -DCMAKE_PREFIX_PATH=/data2/zhaodali/software/protobuf</span><br><span class="line">make -j 12</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>这个时候又报错了，提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at cmake_install.cmake:47 (file):</span><br><span class="line">  file INSTALL cannot copy file</span><br><span class="line">  <span class="string">"/data2/zhaodali/software/onnx-tensorrt/build/onnx2trt"</span> to</span><br><span class="line">  <span class="string">"/usr/local/bin/onnx2trt"</span>: Success.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make: *** [install] Error 1</span><br></pre></td></tr></table></figure><p>这是因为我们没有sudo权限的问题，所以执行如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> onnx-tensorrt/build</span><br><span class="line">rm -r *</span><br><span class="line"><span class="comment"># -DCMAKE_INSTALL_PREFIX设置安装路径</span></span><br><span class="line"><span class="comment"># -DCMAKE_PREFIX_PATH可以设置库的路径</span></span><br><span class="line">cmake .. -DTENSORRT_ROOT=/data2/zhaodali/software/TensorRT-7.0.0.11 -DGPU_ARCHS=<span class="string">"61"</span> -DCMAKE_PREFIX_PATH=/data2/zhaodali/software/protobuf -DCMAKE_INSTALL_PREFIX=/data2/zhaodali/software/onnx-trt</span><br><span class="line">make -j 12</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"> vim ~/.bash_profile </span><br><span class="line"> <span class="built_in">export</span> PATH=/data2/zhaodali/software/bin:<span class="variable">$PATH</span></span><br><span class="line"> <span class="built_in">source</span> ~/.bashrc</span><br><span class="line"> <span class="comment"># 这个环境变量是我自己猜着写的，没想到还真的work了</span></span><br><span class="line"> <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/data2/zhaodali/software/onnx-trt/lib</span><br><span class="line"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/data2/zhaodali/software/onnx-trt/bin</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 测试，输入下面指令看是否有输出</span></span><br><span class="line"> onnx2trt</span><br></pre></td></tr></table></figure><p>终于成功了，撒花~~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_44638957/article/details/103704661" target="_blank" rel="noopener">TensorRT7 + Onnx_TensorRT 安装过程记录</a><br><a href="https://www.zhihu.com/question/58592005/answer/270998973" target="_blank" rel="noopener">protobuf版本问题？ - Gilbert.Wu的回答 - 知乎</a><br><a href="https://cloud.tencent.com/developer/article/1074430" target="_blank" rel="noopener">centos6.x升级protobuf操作流程.</a><br><a href="https://blog.csdn.net/u012005313/article/details/45844655" target="_blank" rel="noopener">Linux cmake安装，配置以及测试</a><br><a href="https://my.oschina.net/Alexmyj/blog/1541769" target="_blank" rel="noopener">在CentOS安装CMake 升级cmake 3.5</a><br><a href="https://blog.csdn.net/u012903741/article/details/81741803" target="_blank" rel="noopener">Centos 7安装protobuf3.6.1</a><br><a href="https://github.com/NVIDIA/DALI/issues/104" target="_blank" rel="noopener">How to import the path of compiled protobuf in cmake #104</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近踩了一下从onnx导出到TensorRT的坑，在这记录一下。&lt;/p&gt;
&lt;h2 id=&quot;安装TensorRT&quot;&gt;&lt;a href=&quot;#安装TensorRT&quot; class=&quot;headerlink&quot; title=&quot;安装TensorRT&quot;&gt;&lt;/a&gt;安装TensorRT&lt;/h2&gt;&lt;p&gt;从&lt;a href=&quot;https://developer.nvidia.com/tensorrt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方地址&lt;/a&gt;下载合适版本的TensorRT，例如我这里下载的就是&lt;code&gt;TensorRT-7.0.0.11.CentOS-7.6.x86_64-gnu.cuda-10.2.cudnn7.6.tar.gz&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 解压缩&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# tar -xzvf TensorRT-7.0.0.11.CentOS-7.6.x86_64-gnu.cuda-10.2.cudnn7.6.tar.gz -C /指定你要的路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 比如&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -xzvf TensorRT-7.0.0.11.CentOS-7.6.x86_64-gnu.cuda-10.2.cudnn7.6.tar.gz -C /data2/zhaodali/software&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 添加环境变量 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vim ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; LD_LIBRARY_PATH=&lt;span class=&quot;variable&quot;&gt;$LD_LIBRARY_PATH&lt;/span&gt;:/data2/zhaodali/software/TensorRT-7.0.0.11/lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt; ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 安装Python支持，选择对应python版本的whl进行安装&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; /data2/zhaodali/software/TensorRT-7.0.0.11/python&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install tensorrt-7.0.0.11-cp37-none-linux_x86_64.whl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;安装ONNX-tensorrt&quot;&gt;&lt;a href=&quot;#安装ONNX-tensorrt&quot; class=&quot;headerlink&quot; title=&quot;安装ONNX_tensorrt&quot;&gt;&lt;/a&gt;安装ONNX_tensorrt&lt;/h2&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/categories/MLFrameworks/TensorRT/"/>
    
    
      <category term="TensorRT" scheme="https://www.zdaiot.com/tags/TensorRT/"/>
    
      <category term="onnx" scheme="https://www.zdaiot.com/tags/onnx/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch导出onnx模型</title>
    <link href="https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch%E5%AF%BC%E5%87%BAonnx%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch导出onnx模型/</id>
    <published>2020-06-05T22:04:33.000Z</published>
    <updated>2020-06-05T22:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>详细的导出流程其实看<a href="https://pytorch.org/docs/stable/onnx.html" target="_blank" rel="noopener">官方文档</a>就可以了。这里我主要是说明的是我感兴趣的几个参数以及我自己的一些疑惑。</p><h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><p><code>export_params</code>：该参数默认为True，也就是会导出训练好的权重；若设置为False，则导出的是没有训练过的模型。</p><p><code>verbose</code>：默认为False，若设置为True，则会打印导出onnx时的一些日志，便于分析网络结构。</p><p><code>opset_version</code>：对于1.5.0的Pytorch，默认仍然是9，也就是对应当前onnx的最稳定的版本。</p><p><code>keep_initializers_as_inputs</code>：其实我也没太明白这个参数的作用。对应的官方文档为：(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a><em>,</em> <em>default None</em>) – If True, all the initializers (typically corresponding to parameters) in the exported graph will also be added as inputs to the graph. If False, then initializers are not added as inputs to the graph, and only the non-parameter inputs are added as inputs. This may allow for better optimizations (such as constant folding etc.) by backends/runtimes that execute these graphs. If unspecified (default None), then the behavior is chosen automatically as follows. If operator_export_type is OperatorExportTypes.ONNX, the behavior is equivalent to setting this argument to False. For other values of operator_export_type, the behavior is equivalent to setting this argument to True. Note that for ONNX opset version &lt; 9, initializers MUST be part of graph inputs. Therefore, if opset_version argument is set to a 8 or lower, this argument will be ignored.</p><p>按照我个人的理解，加上这个参数，是不是参数初始化的方式也会添加进去？当设置<code>verbose=True</code>时，对于该参数是False还是True，打印出的网络结构完全一样，但是后者的onnx权重会大一点。对于Pytorch0.4.1，默认的ONNX opset version=6（可以在<a href="https://github.com/pytorch/pytorch/blob/v0.4.1/torch/onnx/symbolic.py#L93" target="_blank" rel="noopener">这里</a>看到），此时应该是相当于该参数为False。</p><p>若该参数设置为False，在onnx导出到caffe2模型的时候，会遇到各种神奇的问题，所以直接设置该参数为True即可。</p><p><code>dynamic_axes</code>：可以指定哪些维度是变化的，例如当我们导出模型的时候，输入的第一个维度是batch_size，但是这个维度应该是动态变化的，可以通过该参数指定这个可以动态变化。</p><h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>对于默认的<code>opset_version=9</code>，若Pytorch的模型中含有<code>torch.nn.functional.interpolate</code>操作，在导出模型的时候会提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/data2/zhaodali/anaconda3/lib/python3.7/site-packages/torch/onnx/symbolic_helper.py:246: UserWarning: You are trying to <span class="built_in">export</span> the model with onnx:Upsample <span class="keyword">for</span> ONNX opset version 9. This operator might cause results to not match the expected results by PyTorch.</span><br><span class="line">ONNX<span class="string">'s Upsample/Resize operator did not match Pytorch'</span>s Interpolation until opset 11. Attributes to determine how to transform the input were added <span class="keyword">in</span> onnx:Resize <span class="keyword">in</span> opset 11 to support Pytorch<span class="string">'s behavior (like coordinate_transformation_mode and nearest_mode).</span></span><br><span class="line"><span class="string">We recommend using opset 11 and above for models using this operator. </span></span><br><span class="line"><span class="string">  "" + str(_export_onnx_opset_version) + ". "</span></span><br></pre></td></tr></table></figure><p>而导出的模型会将<code>interpolate</code>映射为<code>%407 : Float(1, 64, 40, 40) = onnx::Upsample[mode=&quot;nearest&quot;](%390, %406)</code>。括号内的含义为以节点390和406作为该节点的输入，输出为407节点。</p><p>此时，若按照它的提示在<code>torch.onnx._export</code>函数中加上参数<code>opset_version=11</code>，则导出的模型会将<code>interpolate</code>映射为<code>%408 : Float(1, 64, 40, 40) = onnx::Resize[coordinate_transformation_mode=&quot;asymmetric&quot;, cubic_coeff_a=-0.75, mode=&quot;nearest&quot;, nearest_mode=&quot;floor&quot;](%390, %400, %400, %407)</code>。括号内的含义为以节点390、400、400、407作为该节点的输入，输出为408节点。</p><p>但是不管是<code>onnx::Upsample</code>操作（<a href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#Upsample" target="_blank" rel="noopener">文档</a>）还是<code>onnx::Resize</code>操作（<a href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#Resize" target="_blank" rel="noopener">文档</a>），输出的结果都和Pytorch模型的输出大致相同（有一定的误差，但是最大误差也在小数点后五位了，也能接受）。</p><p>若想从onnx转到caffe2模型中，需要设置<code>opset_version=9</code>。虽然可以转换过去，但是调用也不成功，此时需要使用<a href="https://github.com/daquexian/onnx-simplifier" target="_blank" rel="noopener">onnx-simplifier</a>将模型进行简化一下，简化完毕后即可使用caffe2调用，这算是一个大坑。</p><p>另外，推荐使用<a href="https://github.com/lutzroeder/netron" target="_blank" rel="noopener">netron</a>对模型进行可视化，可以观察中间节点是否有问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;详细的导出流程其实看&lt;a href=&quot;https://pytorch.org/docs/stable/onnx.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;就可以了。这里我主要是说明的是我感兴趣的几个参数以及我自己的一些疑惑。&lt;/p&gt;
&lt;h2 id=&quot;主要参数&quot;&gt;&lt;a href=&quot;#主要参数&quot; class=&quot;headerlink&quot; title=&quot;主要参数&quot;&gt;&lt;/a&gt;主要参数&lt;/h2&gt;&lt;p&gt;&lt;code&gt;export_params&lt;/code&gt;：该参数默认为True，也就是会导出训练好的权重；若设置为False，则导出的是没有训练过的模型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;verbose&lt;/code&gt;：默认为False，若设置为True，则会打印导出onnx时的一些日志，便于分析网络结构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;opset_version&lt;/code&gt;：对于1.5.0的Pytorch，默认仍然是9，也就是对应当前onnx的最稳定的版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/categories/MLFrameworks/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch编译</title>
    <link href="https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch%E7%BC%96%E8%AF%91/"/>
    <id>https://www.zdaiot.com/MLFrameworks/Pytorch/Pytorch编译/</id>
    <published>2020-06-05T01:51:33.000Z</published>
    <updated>2020-06-05T01:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下大部分内容来源于<a href="https://oldpan.me/archives/pytorch-build-simple-instruction" target="_blank" rel="noopener">Pytorch源码编译简明指南</a>，并加上自己踩得一些坑。</p><h2 id="获取源代码"><a href="#获取源代码" class="headerlink" title="获取源代码"></a>获取源代码</h2><p>编译首先是要获取源代码。</p><p>从<strong>官方</strong>获取源代码是最好的方式，从Pytorch的<a href="https://github.com/pytorch/pytorch/" target="_blank" rel="noopener">github官网</a>可以下载最新的代码。</p><p>记住，从官方克隆最新的代码的时候要加入<code>recursive</code>这个参数，因为Pytorch本身需要很多的第三方库参与编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/pytorch/pytorch</span><br></pre></td></tr></table></figure><p>当然如果你想编译特定版本的Pytorch，需要如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/pytorch/pytorch</span><br><span class="line"><span class="built_in">cd</span> pytorch</span><br><span class="line">git checkout v1.0.0</span><br><span class="line">git submodule update --recursive</span><br></pre></td></tr></table></figure><p>上面这条命令是下载并更新第三方库，我们要保证需要的第三方库都下载完毕，不然在编译过程中会中断。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>以下是Pytorch源码包展开的目录结构(只展示了主要的一些文件夹)，其中主要的源码都在以下展示的文件夹中：</p><p><img src="/MLFrameworks/Pytorch/Pytorch编译/20190106163251.jpg" alt="20190106163251"></p><h3 id="核心文件夹"><a href="#核心文件夹" class="headerlink" title="核心文件夹"></a>核心文件夹</h3><p>核心文件夹主要是c10、aten、torch、caffe2.</p><p>为什么将c10放到最前面呢？</p><p>因为官方已经表明<strong>c10</strong>目录是最重要的源代码文件夹，也就是几乎所有的源代码都与这里的代码有关系,比如我们的类型定义，Pytorch最重要的<strong>Tensor</strong>的内存分配方式等等，都在这个文件夹中，官方也说到了，之后会慢慢将Aten中的代码移至这个文件夹，也就是说这个文件夹将包含Pytorch中最核心的代码。</p><p>而<strong>Aten</strong>文件夹则包含了一些实现了<strong>Tensor</strong>的底层(和c10类似)，也包括了很多的层前向代码和后向实现的代码(例如卷积层的前向和后向操作代码),包括CPU和GPU端，总之都是C++的核心操作代码。</p><p><strong>torch</strong>文件夹也同样重要，其中主要包含了一些稍微高层些的操作函数，例如<strong>torch.ones</strong>等，有C++和Python端，也包括了Python核心代码和包装代码，如果我们使用python版Pytorch的话，与这些代码接触就比较密切了。</p><p>而<strong>Caffe2</strong>则不用多说，caffe2则主要针对移动端设计了很多优化后的运算代码，模型融合、模型量化等等的代码，其后端有QNNPACK等一些针对移动端的底层运算库(有开发人员说GLOW也在caffe2后端考虑之内)。</p><h3 id="third-party"><a href="#third-party" class="headerlink" title="third_party"></a>third_party</h3><p>Pytorch毕竟是<strong>大型</strong>的深度学习库，所以需要的依赖库也是有很多的，其中有很多我们耳熟能详的数值计算库(eigen、gemmlowp)、模型转换库(onnx、onnx-tensorrt)、并行训练库(gloo、nccl)、自家的底层端实现库(QNNPACK)以及绑定python端的pybind11等一系列所依赖的库。</p><p>当然还有很多库这里就不一一介绍了，总之，我们在编译的时候，Pytorch的编译代码会根据我们的设置在编译的时候，自动判断当前系统中是否存在需要的第三方库。如果不存在则使用这里的第三方库(直接编译并使用第三方库的diamante)，这也是为什么我们需要执行<code>git submodule update --init --recursive</code>来下载所依赖第三库源码的原因。</p><h3 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h3><p><strong>tools</strong>这个文件夹中的内容到底是做什么的，简单看一下官方的介绍：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This folder contains a number of scripts which are used as</span><br><span class="line">part of the PyTorch build process.  This directory also doubles</span><br><span class="line">as a Python module hierarchy (thus the <span class="code">`__init__.py`</span>).</span><br></pre></td></tr></table></figure><p>其中包含了一些脚本生成代码工具(利用python)、用于编译一些组件的脚本和代码，还有一些开发人员需要的工具、以及AMD显卡帮助编译代码和一些特殊情况需要使用的工具等。在我们编译Pytorch源码的过程中会使用到这个文件夹中的代码。</p><blockquote><p>有一点需要说明，那就是Pytorch利用了很多的代码生成，例如操作层函数的头文件<code>NativeFunction.h</code>等，所以tools中的代码生成脚本还是比较重要的。</p></blockquote><p>提一个可能会使用到的脚本<code>build_pytorch_libs.sh</code>，这个脚本是用来编译<strong>libtorch库</strong>的，libtorch就是不需要python包装的使用C++的Pytorch库，方便于部署阶段使用。</p><p>关于<strong>libtorch</strong>的具体介绍和简单使用可以看这里：<a href="https://oldpan.me/archives/pytorch-c-libtorch-inference" target="_blank" rel="noopener">利用Pytorch的C++前端(libtorch)读取预训练权重并进行预测</a>。</p><p>关于tools中的文件就不具体介绍了，大家可以看一下其中的<code>readme</code>。</p><p>其他的文件夹就不多说了，相对上面的来说并不是很重要。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译重头戏来了，编译过程中大家可能会遇到各种各样的问题，但是其实只要我们将环境准备妥当，大部分都可以一次性编译好的：</p><ul><li>确保你的cuda和cudnn安装正确，环境变量都设置正确</li><li>确保你的python环境纯净，最好使用anaconda创建一个环境，安装好pytorch需要的依赖包。<br><a href="https://github.com/pytorch/pytorch#from-source" target="_blank" rel="noopener">https://github.com/pytorch/pytorch#from-source</a></li><li>确保你的C++编译器的版本不要太低，最好4.9以及以上</li></ul><blockquote><p>若在原来的Python环境下编译，可能出现一些奇怪的错误，例如因为我之前有Pytorch基于cuda10.2的，现在我在cuda9.0下编译出来的pytorch，也去调用cuda10.2了，更改环境变量也没有用。</p></blockquote><h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><p>python的安装方式并不是单独利用Cmake进行构建的，而是结合了python端的setuptools搭配cmake进行构建，pytorch的项目还是比较庞大的，所以编译代码也是老长，我们主要看看编译过程中的环境变量即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Environment variables you are probably interested in:</span><br><span class="line">#</span><br><span class="line">#   DEBUG</span><br><span class="line">#     build with -O0 and -g (debug symbols)</span><br><span class="line">#</span><br><span class="line">#   REL_WITH_DEB_INFO</span><br><span class="line">#     build with optimizations and -g (debug symbols)</span><br><span class="line">#</span><br><span class="line">#   MAX_JOBS</span><br><span class="line">#     maximum number of compile jobs we should use to compile your code</span><br><span class="line">#</span><br><span class="line">#   NO_CUDA</span><br><span class="line">#     disables CUDA build</span><br><span class="line">#   </span><br><span class="line">#   ....</span><br><span class="line">#   ....</span><br><span class="line">#   </span><br><span class="line"># Environment variables for feature toggles:</span><br><span class="line">#</span><br><span class="line">#   NO_CUDNN</span><br><span class="line">#     disables the cuDNN build</span><br><span class="line">#</span><br><span class="line">#   NO_FBGEMM</span><br><span class="line">#     disables the FBGEMM build</span><br><span class="line">#</span><br><span class="line">#   NO_TEST</span><br><span class="line">#     disables the test build</span><br><span class="line">#</span><br><span class="line">#   NO_MIOPEN</span><br><span class="line">#     disables the MIOpen build</span><br></pre></td></tr></table></figure><p>这些编译变量根据我们的需要在执行<code>python setup.py install</code>使用，如果你不想编译CUDA，则<code>NO_CUDA=1 python setup.py install</code>。另外，在编译之前，我们需要安装一些Python库，如numpy，否则编译出来的Pytorch就没法使用numpy和Pytorch的接口。完整过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy pyyaml mkl mkl-include setuptools cmake cffi typing</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>执行以上语句我们就可以进行编译了。</p><h3 id="编译出现的问题1"><a href="#编译出现的问题1" class="headerlink" title="编译出现的问题1"></a>编译出现的问题1</h3><p>编译Pytorch1.0.0时，若编译过程中遇到<code>RuntimeError: Source files: [&#39;Type.h&#39;, &#39;Tensor.h&#39;, &#39;TensorMethods.h&#39;] did not match generated files.</code>。这个问题是编译中产生的，原因是<strong>PyTorch1.0.0以后</strong>的版本<code>aten/src/ATen/gen.py</code>中的第42行加入如下图的部分，也就是会创建一个core_tmp的文件夹，但是由于某种原因，<code>Tensor.h, TensorMethods.h</code>并没有被拷贝过去，所以我们显式的设置GEN_TO_SOURCE就可以避免这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GEN_TO_SOURCE=/你的路径/pytorch/aten/src/ATen/core/ <span class="comment"># 这个路径的设置也非常重要，如果不设置的话，系统会生成一个core_tmp/，会找不到文件需要链接的头文件导致编译失败~.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line"><span class="built_in">export</span> GEN_TO_SOURCE=/data2/zhaodali/tmp/pytorch/aten/src/ATen/core/</span><br></pre></td></tr></table></figure><h3 id="编译出现的问题2"><a href="#编译出现的问题2" class="headerlink" title="编译出现的问题2"></a>编译出现的问题2</h3><p>对于Pytorch0.4.1或者Pytorch0.5.0的版本中，caffe2要单独编译的。也就是在执行<code>python setup.py install</code><strong>之后（两者顺序不能调到）</strong>，还需要执行一下<code>python setup_caffe.py install</code>。caffe2依赖的Python包为<code>numpy,future,hypothesis,protobuf</code>另外，对于Python3.7还需要更改<code>vim pytorch/caffe2/python/pybind_state.h</code> 的第二百行从<code>str = PyUnicode_AsUTF8AndSize(input[i], &amp;strSize);</code>改为<code>str = const_cast&lt;char*&gt;(PyUnicode_AsUTF8AndSize(input[i], &amp;strSize));</code>。</p><blockquote><p>在gcc version 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC)编译成功了caffe2和pytorch0.5.0</p></blockquote><h3 id="编译出现的问题3"><a href="#编译出现的问题3" class="headerlink" title="编译出现的问题3"></a>编译出现的问题3</h3><p>在下拉Pytorch0.4.1的第三方库的时候，出现了错误：<code>fatal: repository &#39;https://github.com/NervanaSystems/nervanagpu.git/&#39; not found</code>，则执行下面语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从 .gitmodules中删除nervanagpu</span><br><span class="line">git clean -xdf</span><br><span class="line">git submodule deinit -f .</span><br><span class="line">git submodule sync</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h3 id="ninja"><a href="#ninja" class="headerlink" title="ninja"></a>ninja</h3><p>ninja可以大大加快编译速度，而且在编译过程中提示的错误信息更加完整和详细，如果我们想使用<strong>ninja</strong>来编译，那么直接在当前的python环境中<code>pip install ninja</code>即可。</p><p>Pytorch的安装程序会自动查找当前环境中是否有ninja，如果有的话，则优先使用ninja进行编译。</p><h3 id="不同的安装模式"><a href="#不同的安装模式" class="headerlink" title="不同的安装模式"></a>不同的安装模式</h3><p>只安装libtorch库:创建build文件夹，在里头执行<strong>python ../tools/build_libtorch.py</strong></p><p>开发者模式:<code>python setup.py build develop</code>(对Python开发有帮助)</p><h2 id="安装后的自我检验"><a href="#安装后的自我检验" class="headerlink" title="安装后的自我检验"></a>安装后的自我检验</h2><p>默认我们安装Pytorch的时候会自带上caffe2(当然也可以选择不安装caffe2，但是运行某些特定卷积操作时会报错~)，因此我们在安装成功后不仅要检测Pytorch是否安装成功，同时也要检查caffe2是否安装成功。</p><h3 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h3><p>检查Pytorch安装是否成功：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">print(torch.cuda.is_available())</span><br><span class="line">print(torch.backends.cudnn.is_acceptable(torch.cuda.FloatTensor(<span class="number">1</span>)))</span><br><span class="line">print(torch.backends.cudnn.version())</span><br><span class="line">print(torch.version.cuda)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="literal">True</span>  <span class="comment"># 出现Turn说明cuda正常</span></span><br><span class="line">Ture  <span class="comment"># 出现Ture说明cudnn正常</span></span><br><span class="line"><span class="number">7301</span>  <span class="comment"># 这是我的版本号</span></span><br><span class="line"><span class="number">9.0</span><span class="number">.176</span></span><br></pre></td></tr></table></figure><p>如果遇到报错<code>ModuleNotFoundError: No module named &#39;torch._C&#39;</code>，则大部分情况是因为当前在<code>pytorch</code>源码文件夹下编译的，考虑使用<code>cd ..</code>退出该文件夹，再进行验证。</p><h3 id="caffe2"><a href="#caffe2" class="headerlink" title="caffe2"></a>caffe2</h3><p>在安装caffe2的环境下运行python并导入<code>caffe2.python</code>，如果顺利加载则证明安装成功。如果不能成功import的话，可以先看看错误信息，很有可能是一些小错误，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.6</span><span class="number">.6</span> |Anaconda, Inc.| (default, Oct  <span class="number">9</span> <span class="number">2018</span>, <span class="number">12</span>:<span class="number">34</span>:<span class="number">16</span>) </span><br><span class="line">[GCC <span class="number">7.3</span><span class="number">.0</span>] on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> caffe2.python <span class="keyword">import</span> core</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/home/prototype/anaconda3/envs/pytorch-dev/lib/python3.6/site-packages/caffe2/python/__init__.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> caffe2.proto <span class="keyword">import</span> caffe2_pb2</span><br><span class="line">  File <span class="string">"/home/prototype/anaconda3/envs/pytorch-dev/lib/python3.6/site-packages/caffe2/proto/caffe2_pb2.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> google.protobuf.internal <span class="keyword">import</span> enum_type_wrapper</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">'google'</span></span><br></pre></td></tr></table></figure><p>上方的导入出错是因为当期的虚拟环境没有安装<code>protobuf</code>，简单执行命令<code>pip install protobuf</code>即可，其他类似错误根据错误提示信息安装相应的库就可以了。</p><p>如果成功<code>import</code>则不会出现报错信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.6</span><span class="number">.6</span> |Anaconda, Inc.| (default, Oct  <span class="number">9</span> <span class="number">2018</span>, <span class="number">12</span>:<span class="number">34</span>:<span class="number">16</span>) </span><br><span class="line">[GCC <span class="number">7.3</span><span class="number">.0</span>] on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> caffe2.python <span class="keyword">import</span> core</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="如何卸载"><a href="#如何卸载" class="headerlink" title="如何卸载"></a>如何卸载</h2><p>如果是源码安装的<strong>Pytorch</strong>，卸载需要执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall torch</span><br><span class="line">python setup.py clean</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://oldpan.me/archives/pytorch-build-simple-instruction" target="_blank" rel="noopener">Pytorch源码编译简明指南</a><br><a href="https://blog.csdn.net/ENAIC__suger/article/details/88579337" target="_blank" rel="noopener">如何查看pytorch对应cuda的版本</a><br><a href="https://blog.csdn.net/zsf10220208/article/details/101280969" target="_blank" rel="noopener">源码编译pytorch 1.0 遇到的问题</a><br><a href="https://www.twblogs.net/a/5d1247c2bd9eee1e5c822d3b" target="_blank" rel="noopener">PyTorch學習筆記(16)——編寫你自己的PyTorch kernel(基於PyTorch1.2.0)</a><br><a href="https://github.com/pytorch/pytorch/pull/9259/files" target="_blank" rel="noopener">Fix the build break for python3.7 PyUnicode_AsUTF8AndSize() prototype changing #9259</a><br><a href="https://github.com/pytorch/pytorch/issues/20845" target="_blank" rel="noopener">NervanaSystems/nervanagpu Repository not found for 0.4.0 #20845</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下大部分内容来源于&lt;a href=&quot;https://oldpan.me/archives/pytorch-build-simple-instruction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pytorch源码编译简明指南&lt;/a&gt;，并加上自己踩得一些坑。&lt;/p&gt;
&lt;h2 id=&quot;获取源代码&quot;&gt;&lt;a href=&quot;#获取源代码&quot; class=&quot;headerlink&quot; title=&quot;获取源代码&quot;&gt;&lt;/a&gt;获取源代码&lt;/h2&gt;&lt;p&gt;编译首先是要获取源代码。&lt;/p&gt;
&lt;p&gt;从&lt;strong&gt;官方&lt;/strong&gt;获取源代码是最好的方式，从Pytorch的&lt;a href=&quot;https://github.com/pytorch/pytorch/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github官网&lt;/a&gt;可以下载最新的代码。&lt;/p&gt;
&lt;p&gt;记住，从官方克隆最新的代码的时候要加入&lt;code&gt;recursive&lt;/code&gt;这个参数，因为Pytorch本身需要很多的第三方库参与编译：&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/categories/MLFrameworks/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://www.zdaiot.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Caffe2基础概念</title>
    <link href="https://www.zdaiot.com/MLFrameworks/Caffe2/Caffe2%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.zdaiot.com/MLFrameworks/Caffe2/Caffe2基础概念/</id>
    <published>2020-06-04T07:23:33.000Z</published>
    <updated>2020-06-04T07:23:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面记录一下caffe2的一些基本概念。</p><p>Caffe2框架是一个<strong>静态的图框架</strong>。同大多静态图框架一样，它的应用程序一般会干两件事情，先是建立模型（即建图，主要使用Python等较友好的语言脚本或像caffe那样直接使用prototxt文件），然后则是迭代执行模型。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p>可以看成是一个函数，输入一些数据，输出一些数据，如 layers、数值操作等。感觉与TensorFlow中的op是一个概念。</p><ul><li>基本结构参考<a href="https://github.com/caffe2/caffe2/blob/master/caffe2/proto/caffe2.proto" target="_blank" rel="noopener">这里</a>，创建<code>Operator</code>的本质就是创建了一个protobuf对象。</li><li>C++： they all derive from a common interface, and are registered by type, so that we can call different operators during runtime。</li></ul><h3 id="Nets"><a href="#Nets" class="headerlink" title="Nets"></a>Nets</h3><p>由<code>Operator</code>组成的计算图。</p><ul><li>Python（<a href="https://github.com/caffe2/caffe2/blob/master/caffe2/python/core.py//github.com/caffe2/caffe2/blob/master/caffe2/proto/caffe2.proto" target="_blank" rel="noopener">源码</a>）： Caffe2’s core.Net is a wrapper class around a NetDef protocol buffer。</li><li>C++（<a href="https://github.com/caffe2/caffe2/blob/master/caffe2/core/net.cc" target="_blank" rel="noopener">源码</a>）。</li></ul><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p>operator之间通过相互依赖的输入、输出发生关联关系。而这些operator的输入、输出则被称为Blob。<strong>Blob是深度学习模型当中数据元素的抽象</strong>，它可以指的是具体的输入、输出数据，也可以指的是operator计算当中用当到的可训练参数等。</p><ul><li>Python：可以看成一个numpy’s ndarray对象。</li><li>C++（<a href="https://github.com/caffe2/caffe2/blob/master/caffe2/core/blob.h" target="_blank" rel="noopener">源码</a>）：a typed pointer that can store any type of C++ objects。</li></ul><h3 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h3><p>当具体执行某个深度学习模型训练或推理任务时，需要考虑<strong>对全局所用到的变量及计算单元命名空间进行管理</strong>。它应当作为<strong>深度学习任务的发起者及终结者（当然还是收拾者）</strong>。这么一个角色在<strong>Tensorflow里面是Session</strong>，而caffe2中则是Workspace。它包含了一切运行时创建的对象，包括所有的Blob，以及Net等。</p><p>操作：</p><ul><li>对<code>Blob</code>的操作（如获取、判断是否存在、保存等）。</li><li>对当前<code>Workspace</code>的一些操作（如切换、重置等）。</li><li>运行计算图。</li><li>Python（<a href="https://github.com/caffe2/caffe2/blob/master/caffe2/python/workspace.py" target="_blank" rel="noopener">源码</a>）：从<a href="https://github.com/caffe2/caffe2/blob/master/caffe2/python/_import_c_extension.py" target="_blank" rel="noopener">这里</a>和<a href="https://github.com/caffe2/caffe2/blob/master/caffe2/python/pybind_state_gpu.cc" target="_blank" rel="noopener">这里</a>中可以看出，几乎所有操作都通过pybind11调用了底层C++代码。</li><li>C++（<a href="https://github.com/caffe2/caffe2/blob/master/caffe2/core/workspace.h" target="_blank" rel="noopener">源码</a>）。</li></ul><h3 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h3><p>显然反映high level数据抽象的Blob都应有相应的底层内存单元在背后。而Tensor则是这些底层内存单元的进一步封装。每个tensor都可以直接访问对应的内存单元地址，它之上的数据元素类型，它的大小，内存初始化及析构函数等则被封装到另外一个单元当中。这个单元即为TypeMeta，它具体反映tensor里面的数据元素的类型及相应的底层实现所需细节。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>Tensor与Operator分别对应相应的内存单元抽象及计算单元抽象。众所周知，当下可用于深度学习任务的计算单元有许多像CPU/GPU/FPGA/ASIC芯片等。它们在执行具体的计算任务时，分别有着不同的实现（分别包装着其各自特定的计算指令集及内存分配与读写单元）。<strong>caffe2中将各类不同的device封装为一个个不同的context对象</strong>。然后Tensor/Operator则以模板的形式分别在实例化时支持不同的底层计算设备context。</p><h3 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h3><p>像Windows中使用注册表来管理其系统上的配置等信息一样，<strong>caffe2中也使用了全局Registry的方式对各种不同类型Op/OpSchema/Net等具体实现都进行了注册</strong>。这样当具体某个operator运行时，都会去全局Registry table里面查找此operator在相应设备上对应的注册实现并调用执行。一旦它发现此种类型实现不存在，那么就会报错退出。Net的不同类型执行也与此机理大致相似。</p><h3 id="Python绑定"><a href="#Python绑定" class="headerlink" title="Python绑定"></a>Python绑定</h3><p>Caffe2中上当只支持C++与Python两种语言。在它的哲学当中，一切计算复杂的单元都应由C++实现的函数中来完成，而Python只是因其用户友好性被用来进行建图，规划整个图执行，并不真正参与核心的计算。这一点保证了它的高效率，但同时也意味着它对其它语言的支持不够好，同时<strong>也无法很灵活地添加一些由Python等高级语言写的Operators</strong>。</p><p><strong>一般由Python脚本所描绘的图会会序列化为protobuf文件</strong>，然后传入C++端，开始执行网络的计算过程。</p><p>在使用Python构建一个完整的用来training工作的图时，只需要显示写出做前向计算的系列operators，然后通过使用AddGradientOperators方法（以最终的loss作为其输入参数）可自动完成反向梯度计算的operators的添加。</p><p>总之Caffe2中的一切真正计算像先向/反向计算/Checkpoints保存/参数更新乃至参数初始化等等无一例外均是通过某一实现好的C++ operator函数来执行。</p><h2 id="Blob-amp-Workspace-操作"><a href="#Blob-amp-Workspace-操作" class="headerlink" title="Blob &amp; Workspace 操作"></a>Blob &amp; Workspace 操作</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li>导入库</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> caffe2.python <span class="keyword">import</span> core, workspace, model_helper</span><br><span class="line"><span class="keyword">from</span> caffe2.proto <span class="keyword">import</span> caffe2_pb2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><ul><li>Blob 与 Workspace 操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># blob的底层实现可以是numpy中ndarray对象</span></span><br><span class="line">X = np.random.randn(<span class="number">2</span>, <span class="number">3</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前workspace拥有的blob</span></span><br><span class="line">print(<span class="string">"Current blobs in the workspace: &#123;&#125;"</span>.format(workspace.Blobs()))  </span><br><span class="line"></span><br><span class="line"><span class="comment"># workspace是否有当前指定的blob</span></span><br><span class="line">print(<span class="string">"Workspace has blob 'X'? &#123;&#125;"</span>.format(workspace.HasBlob(<span class="string">"X"</span>)))  </span><br><span class="line">workspace.FeedBlob(<span class="string">"X"</span>, X)  <span class="comment"># 添加blob到workspace</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从workspace中获取blob</span></span><br><span class="line"><span class="comment"># 如果要获取不存在的blob，会报错</span></span><br><span class="line">print(<span class="string">"Fetched X:\n&#123;&#125;"</span>.format(workspace.FetchBlob(<span class="string">"X"</span>)))  </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    workspace.FetchBlob(<span class="string">"invincible_pink_unicorn"</span>)</span><br><span class="line"><span class="keyword">except</span> RuntimeError <span class="keyword">as</span> err:</span><br><span class="line">    print(err)</span><br><span class="line"><span class="comment"># 查看当前workspace拥有的blob</span></span><br><span class="line">print(<span class="string">"Current blobs in the workspace: &#123;&#125;"</span>.format(workspace.Blobs()))  </span><br><span class="line"><span class="comment"># workspace是否有当前指定的blob</span></span><br><span class="line">print(<span class="string">"Workspace has blob 'X'? &#123;&#125;"</span>.format(workspace.HasBlob(<span class="string">"X"</span>)))</span><br></pre></td></tr></table></figure><ul><li>workspace 相关操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前workspace</span></span><br><span class="line">print(<span class="string">"Current workspace: &#123;&#125;"</span>.format(workspace.CurrentWorkspace()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前workspace中的blobs</span></span><br><span class="line">print(<span class="string">"Current blobs in the workspace: &#123;&#125;"</span>.format(workspace.Blobs()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换workspace</span></span><br><span class="line">workspace.SwitchWorkspace(<span class="string">"gutentag"</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前workspace</span></span><br><span class="line">print(<span class="string">"Current workspace: &#123;&#125;"</span>.format(workspace.CurrentWorkspace()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前workspace中的blobs</span></span><br><span class="line">print(<span class="string">"Current blobs in the workspace: &#123;&#125;"</span>.format(workspace.Blobs()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换workspace</span></span><br><span class="line">workspace.SwitchWorkspace(<span class="string">"default"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前workspace</span></span><br><span class="line">print(<span class="string">"Current workspace: &#123;&#125;"</span>.format(workspace.CurrentWorkspace()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前workspace中的blobs</span></span><br><span class="line">print(<span class="string">"Current blobs in the workspace: &#123;&#125;"</span>.format(workspace.Blobs()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清楚当前workspace中的所有内容</span></span><br><span class="line">workspace.ResetWorkspace()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前workspace中的blobs</span></span><br><span class="line">print(<span class="string">"Current blobs in the workspace after reset: &#123;&#125;"</span>.format(workspace.Blobs()))</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul><li>blob与workspace操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/core/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/core/operator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/core/operator_gradient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/proto/caffe2.pb.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> caffe2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Blob* blob, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tensor = blob-&gt;Get&lt;TensorCPU&gt;();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; data = tensor.data&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">"("</span> &lt;&lt; tensor.dims() &lt;&lt; <span class="string">"): "</span> </span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(data, data+tensor.size())</span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//define blobs with std::vector</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; x(<span class="number">4</span>*<span class="number">3</span>*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">float</span> &amp;v : x ) &#123;</span><br><span class="line">            v = (<span class="keyword">float</span>)rand() / RAND_MAX - <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// define workspace</span></span><br><span class="line">        Workspace workspace;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print all blobls</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"current workspace has blobs"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; blobs = workspace.Blobs();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s:blobs)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//feed blob</span></span><br><span class="line">        <span class="keyword">auto</span> tensor = workspace.CreateBlob(<span class="string">"X"</span>)-&gt;GetMutable&lt;TensorCPU&gt;();</span><br><span class="line">        TensorCPU value = TensorCPU(&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>&#125;, x, <span class="literal">NULL</span>);</span><br><span class="line">        tensor-&gt;ResizeLike(value);</span><br><span class="line">        tensor-&gt;ShareData(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print all blobs</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"current workspace has blobs"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        blobs = workspace.Blobs();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s:blobs)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fetch blob</span></span><br><span class="line">        <span class="keyword">auto</span> tensor2 = workspace.GetBlob(<span class="string">"X"</span>);</span><br><span class="line">        print(tensor2, <span class="string">"X"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// has blob</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"current workspace has blob \"X\"?"</span> &lt;&lt; workspace.HasBlob(<span class="string">"X"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    caffe2::GlobalInit(&amp;argc, &amp;argv);</span><br><span class="line">    caffe2::run();</span><br><span class="line">    google::protobuf::ShutdownProtobufLibrary();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>workspace 本身操作：</p><ul><li>切换 workspace 的本质就是创建新的Workspace对象。</li><li>重置 workspace 的本质就是调用 <code>std::unique_ptr.reset()</code>，使用新的对象取代旧对象，并删除旧对象。</li><li>C++源码中有一个 map对象 (std::string -&gt; std::unique_ptr) 存储所有workspace 以及他们的名称。</li></ul><h2 id="Operator操作"><a href="#Operator操作" class="headerlink" title="Operator操作"></a>Operator操作</h2><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> caffe2.python <span class="keyword">import</span> core, workspace, model_helper</span><br><span class="line"><span class="keyword">from</span> caffe2.proto <span class="keyword">import</span> caffe2_pb2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">op = core.CreateOperator(</span><br><span class="line">    <span class="string">"Relu"</span>, <span class="comment"># The type of operator that we want to run</span></span><br><span class="line">    [<span class="string">"X"</span>], <span class="comment"># A list of input blobs by their names</span></span><br><span class="line">    [<span class="string">"Y"</span>], <span class="comment"># A list of output blobs by their names</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># op的本质就是protobuf object</span></span><br><span class="line">print(<span class="string">"Type of the created op is: &#123;&#125;"</span>.format(type(op)))</span><br><span class="line">print(<span class="string">"Content:\n"</span>)</span><br><span class="line">print(str(op))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入数据</span></span><br><span class="line">workspace.FeedBlob(<span class="string">"X"</span>, np.random.randn(<span class="number">2</span>, <span class="number">3</span>).astype(np.float32))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行op</span></span><br><span class="line">workspace.RunOperatorOnce(op)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行结果</span></span><br><span class="line">print(<span class="string">"Current blobs in the workspace: &#123;&#125;\n"</span>.format(workspace.Blobs()))</span><br><span class="line">print(<span class="string">"X:\n&#123;&#125;\n"</span>.format(workspace.FetchBlob(<span class="string">"X"</span>)))</span><br><span class="line">print(<span class="string">"Y:\n&#123;&#125;\n"</span>.format(workspace.FetchBlob(<span class="string">"Y"</span>)))</span><br><span class="line">print(<span class="string">"Expected:\n&#123;&#125;\n"</span>.format(np.maximum(workspace.FetchBlob(<span class="string">"X"</span>), <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/core/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/core/operator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/core/operator_gradient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/proto/caffe2.pb.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> caffe2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Blob* blob, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tensor = blob-&gt;Get&lt;TensorCPU&gt;();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; data = tensor.data&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">"("</span> &lt;&lt; tensor.dims() &lt;&lt; <span class="string">"): "</span> </span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(data, data+tensor.size())</span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//define blobs with std::vector</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; x(<span class="number">4</span>*<span class="number">3</span>*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">float</span> &amp;v : x ) &#123;</span><br><span class="line">            v = (<span class="keyword">float</span>)rand() / RAND_MAX - <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// define workspace</span></span><br><span class="line">        Workspace workspace;</span><br><span class="line">        <span class="comment">//feed blob</span></span><br><span class="line">        <span class="keyword">auto</span> tensor = workspace.CreateBlob(<span class="string">"X"</span>)-&gt;GetMutable&lt;TensorCPU&gt;();</span><br><span class="line">        TensorCPU value = TensorCPU(&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>&#125;, x, <span class="literal">NULL</span>);</span><br><span class="line">        tensor-&gt;ResizeLike(value);</span><br><span class="line">        tensor-&gt;ShareData(value);</span><br><span class="line">        <span class="comment">// create a OperatorDef and run it with workspace</span></span><br><span class="line">        caffe2::OperatorDef* op_def = <span class="keyword">new</span> OperatorDef();</span><br><span class="line">        op_def-&gt;set_type(<span class="string">"Relu"</span>);</span><br><span class="line">        op_def-&gt;add_input(<span class="string">"X"</span>);</span><br><span class="line">        op_def-&gt;add_output(<span class="string">"Y"</span>);</span><br><span class="line">        <span class="comment">// run op</span></span><br><span class="line">        workspace.RunOperatorOnce(*op_def);</span><br><span class="line">        <span class="comment">// print op output</span></span><br><span class="line">        print(workspace.GetBlob(<span class="string">"Y"</span>), <span class="string">"Y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    caffe2::GlobalInit(&amp;argc, &amp;argv);</span><br><span class="line">    caffe2::run();</span><br><span class="line">    google::protobuf::ShutdownProtobufLibrary();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h2><h3 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h3><ul><li><code>core.Net</code>实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> caffe2.python <span class="keyword">import</span> core, workspace, model_helper</span><br><span class="line"><span class="keyword">from</span> caffe2.proto <span class="keyword">import</span> caffe2_pb2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建Net</span></span><br><span class="line">net = core.Net(<span class="string">"my_first_net"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看net的protoc</span></span><br><span class="line">print(<span class="string">"Current network proto:\n\n&#123;&#125;"</span>.format(net.Proto()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过net创建Operator,这种创建方式等价于：</span></span><br><span class="line"><span class="comment"># op = core.CreateOperator("SomeOp", ...)</span></span><br><span class="line"><span class="comment"># net.Proto().op.append(op)</span></span><br><span class="line">X = net.GaussianFill([], [<span class="string">"X"</span>], mean=<span class="number">0.0</span>, std=<span class="number">1.0</span>, shape=[<span class="number">2</span>, <span class="number">3</span>], run_once=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看net的protoc</span></span><br><span class="line">print(<span class="string">"New network proto:\n\n&#123;&#125;"</span>.format(net.Proto()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># net创建Operator的，返回值是BlobReference</span></span><br><span class="line"><span class="comment"># BlobReference中保存了blob name以及创建该BlobReference的net</span></span><br><span class="line">print(<span class="string">"Type of X is: &#123;&#125;"</span>.format(type(X)))</span><br><span class="line">print(<span class="string">"The blob name is: &#123;&#125;"</span>.format(str(X)))</span><br><span class="line">W = net.GaussianFill([], [<span class="string">"W"</span>], mean=<span class="number">0.0</span>, std=<span class="number">1.0</span>, shape=[<span class="number">5</span>, <span class="number">3</span>], run_once=<span class="number">0</span>)</span><br><span class="line">b = net.ConstantFill([], [<span class="string">"b"</span>], shape=[<span class="number">5</span>,], value=<span class="number">1.0</span>, run_once=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过BlobReference直接创建Operator，其中Blob为输入</span></span><br><span class="line"><span class="comment"># 以下操作等价于 Y = net.FC([X, W, b], ["Y"])</span></span><br><span class="line">Y = X.FC([W, b], [<span class="string">"Y"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要运行Net可以通过workspace</span></span><br><span class="line"><span class="comment"># 方法一：workspace.RunNetOnce()</span></span><br><span class="line">workspace.ResetWorkspace()</span><br><span class="line">print(<span class="string">"Current blobs in the workspace: &#123;&#125;"</span>.format(workspace.Blobs()))</span><br><span class="line">workspace.RunNetOnce(net)</span><br><span class="line">print(<span class="string">"Blobs in the workspace after execution: &#123;&#125;"</span>.format(workspace.Blobs()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let's dump the contents of the blobs</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> workspace.Blobs():</span><br><span class="line">    print(<span class="string">"&#123;&#125;:\n&#123;&#125;"</span>.format(name, workspace.FetchBlob(name)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：先workspace.CreateNet() 再workspace.RunNet()</span></span><br><span class="line">workspace.ResetWorkspace()</span><br><span class="line">print(<span class="string">"Current blobs in the workspace: &#123;&#125;"</span>.format(workspace.Blobs()))</span><br><span class="line">workspace.CreateNet(net)</span><br><span class="line">workspace.RunNet(net.Proto().name)</span><br><span class="line">print(<span class="string">"Blobs in the workspace after execution: &#123;&#125;"</span>.format(workspace.Blobs()))</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> workspace.Blobs():</span><br><span class="line">    print(<span class="string">"&#123;&#125;:\n&#123;&#125;"</span>.format(name, workspace.FetchBlob(name)))</span><br></pre></td></tr></table></figure><ul><li>ModelHelper</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> caffe2.python <span class="keyword">import</span> core, workspace, model_helper</span><br><span class="line"><span class="keyword">from</span> caffe2.proto <span class="keyword">import</span> caffe2_pb2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建模型前，随机生成一些数据</span></span><br><span class="line">data = np.random.rand(<span class="number">16</span>, <span class="number">100</span>).astype(np.float32)</span><br><span class="line">label = (np.random.rand(<span class="number">16</span>) * <span class="number">10</span>).astype(np.int32)</span><br><span class="line">workspace.FeedBlob(<span class="string">"data"</span>, data)</span><br><span class="line">workspace.FeedBlob(<span class="string">"label"</span>, label)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ModelHelper搭建模型</span></span><br><span class="line">m = model_helper.ModelHelper(name=<span class="string">"my first net"</span>)</span><br><span class="line">weight = m.param_init_net.XavierFill([], <span class="string">'fc_w'</span>, shape=[<span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line">bias = m.param_init_net.ConstantFill([], <span class="string">'fc_b'</span>, shape=[<span class="number">10</span>, ])</span><br><span class="line">fc_1 = m.net.FC([<span class="string">"data"</span>, <span class="string">"fc_w"</span>, <span class="string">"fc_b"</span>], <span class="string">"fc1"</span>)</span><br><span class="line">pred = m.net.Sigmoid(fc_1, <span class="string">"pred"</span>)</span><br><span class="line">softmax, loss = m.net.SoftmaxWithLoss([pred, <span class="string">"label"</span>], [<span class="string">"softmax"</span>, <span class="string">"loss"</span>])</span><br><span class="line">m.AddGradientOperators([loss])</span><br><span class="line">print(m.net.Proto())</span><br><span class="line"></span><br><span class="line"><span class="comment"># ModelHelper创建了两个对象</span></span><br><span class="line"><span class="comment"># m.param_init_net，只需要运行一次，用于初始化</span></span><br><span class="line"><span class="comment"># m.net 用于真正训练/预测模型</span></span><br><span class="line"><span class="comment"># 因为没有 反向传播过程，感觉下面这段代码有点呆</span></span><br><span class="line">workspace.RunNetOnce(m.param_init_net)</span><br><span class="line">workspace.CreateNet(m.net)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    data = np.random.rand(<span class="number">16</span>, <span class="number">100</span>).astype(np.float32)</span><br><span class="line">    label = (np.random.rand(<span class="number">16</span>) * <span class="number">10</span>).astype(np.int32)</span><br><span class="line">    workspace.FeedBlob(<span class="string">"data"</span>, data)</span><br><span class="line">    workspace.FeedBlob(<span class="string">"label"</span>, label)</span><br><span class="line">    workspace.RunNet(m.name, <span class="number">10</span>)</span><br><span class="line">print(workspace.FetchBlob(<span class="string">"softmax"</span>))</span><br><span class="line">print(workspace.FetchBlob(<span class="string">"loss"</span>))</span><br></pre></td></tr></table></figure><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><ul><li>以下代码来自于 <a href="https://github.com/leonardvandriel/caffe2_cpp_tutorial/blob/master/src/caffe2/binaries/intro.cc" target="_blank" rel="noopener">caffe2_cpp_tutorial/src/caffe2/binaries/intro.cc</a></li><li>C++中，没有ModelHelper。在查看了<a href="https://github.com/caffe2/caffe2/blob/master/caffe2/python/model_helper.py" target="_blank" rel="noopener">ModelHelper的源码</a>后发现，ModelHelper本质上就是Caffe2 Python的一个工具类，方便创建各类Operation。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/core/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/core/operator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/core/operator_gradient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe2/proto/caffe2.pb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> caffe2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Blob* blob, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tensor = blob-&gt;Get&lt;TensorCPU&gt;();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; data = tensor.data&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">"("</span> &lt;&lt; tensor.dims() &lt;&lt; <span class="string">"): "</span> </span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(data, data+tensor.size())</span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; data = np.random.rand(16, 100).astype(np.float32)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; data(<span class="number">16</span> * <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : data) &#123;</span><br><span class="line">            v = (<span class="keyword">float</span>)rand() / RAND_MAX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; label = (np.random.rand(16) * 10).astype(np.int32)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; label(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : label) &#123;</span><br><span class="line">            v = <span class="number">10</span> * rand() / RAND_MAX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; workspace.FeedBlob("data", data)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tensor = workspace.CreateBlob(<span class="string">"data"</span>)-&gt;GetMutable&lt;TensorCPU&gt;();</span><br><span class="line">            <span class="keyword">auto</span> value = TensorCPU(&#123;<span class="number">16</span>, <span class="number">100</span>&#125;, data, <span class="literal">NULL</span>);</span><br><span class="line">            tensor-&gt;ResizeLike(value);</span><br><span class="line">            tensor-&gt;ShareData(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; workspace.FeedBlob("label", label)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tensor = workspace.CreateBlob(<span class="string">"label"</span>)-&gt;GetMutable&lt;TensorCPU&gt;();</span><br><span class="line">            <span class="keyword">auto</span> value = TensorCPU(&#123;<span class="number">16</span>&#125;, label, <span class="literal">NULL</span>);</span><br><span class="line">            tensor-&gt;ResizeLike(value);</span><br><span class="line">            tensor-&gt;ShareData(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; m = model_helper.ModelHelper(name="my first net")</span></span><br><span class="line">        NetDef initModel;</span><br><span class="line">        initModel.set_name(<span class="string">"my first net_init"</span>);</span><br><span class="line">        NetDef predictModel;</span><br><span class="line">        predictModel.set_name(<span class="string">"my first net"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; weight = m.param_initModel.XavierFill([], 'fc_w', shape=[10, 100])</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> op = initModel.add_op();</span><br><span class="line">            op-&gt;set_type(<span class="string">"XavierFill"</span>);</span><br><span class="line">            <span class="keyword">auto</span> arg = op-&gt;add_arg();</span><br><span class="line">            arg-&gt;set_name(<span class="string">"shape"</span>);</span><br><span class="line">            arg-&gt;add_ints(<span class="number">10</span>);</span><br><span class="line">            arg-&gt;add_ints(<span class="number">100</span>);</span><br><span class="line">            op-&gt;add_output(<span class="string">"fc_w"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; bias = m.param_initModel.ConstantFill([], 'fc_b', shape=[10, ])</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> op = initModel.add_op();</span><br><span class="line">            op-&gt;set_type(<span class="string">"ConstantFill"</span>);</span><br><span class="line">            <span class="keyword">auto</span> arg = op-&gt;add_arg();</span><br><span class="line">            arg-&gt;set_name(<span class="string">"shape"</span>);</span><br><span class="line">            arg-&gt;add_ints(<span class="number">10</span>);</span><br><span class="line">            op-&gt;add_output(<span class="string">"fc_b"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;OperatorDef*&gt; gradient_ops;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; fc_1 = m.net.FC(["data", "fc_w", "fc_b"], "fc1")</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> op = predictModel.add_op();</span><br><span class="line">            op-&gt;set_type(<span class="string">"FC"</span>);</span><br><span class="line">            op-&gt;add_input(<span class="string">"data"</span>);</span><br><span class="line">            op-&gt;add_input(<span class="string">"fc_w"</span>);</span><br><span class="line">            op-&gt;add_input(<span class="string">"fc_b"</span>);</span><br><span class="line">            op-&gt;add_output(<span class="string">"fc1"</span>);</span><br><span class="line">            gradient_ops.push_back(op);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; pred = m.net.Sigmoid(fc_1, "pred")</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> op = predictModel.add_op();</span><br><span class="line">            op-&gt;set_type(<span class="string">"Sigmoid"</span>);</span><br><span class="line">            op-&gt;add_input(<span class="string">"fc1"</span>);</span><br><span class="line">            op-&gt;add_output(<span class="string">"pred"</span>);</span><br><span class="line">            gradient_ops.push_back(op);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; [softmax, loss] = m.net.SoftmaxWithLoss([pred, "label"], ["softmax",</span></span><br><span class="line">        <span class="comment">// "loss"])</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> op = predictModel.add_op();</span><br><span class="line">            op-&gt;set_type(<span class="string">"SoftmaxWithLoss"</span>);</span><br><span class="line">            op-&gt;add_input(<span class="string">"pred"</span>);</span><br><span class="line">            op-&gt;add_input(<span class="string">"label"</span>);</span><br><span class="line">            op-&gt;add_output(<span class="string">"softmax"</span>);</span><br><span class="line">            op-&gt;add_output(<span class="string">"loss"</span>);</span><br><span class="line">            gradient_ops.push_back(op);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; m.AddGradientOperators([loss])</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> op = predictModel.add_op();</span><br><span class="line">            op-&gt;set_type(<span class="string">"ConstantFill"</span>);</span><br><span class="line">            <span class="keyword">auto</span> arg = op-&gt;add_arg();</span><br><span class="line">            arg-&gt;set_name(<span class="string">"value"</span>);</span><br><span class="line">            arg-&gt;set_f(<span class="number">1.0</span>);</span><br><span class="line">            op-&gt;add_input(<span class="string">"loss"</span>);</span><br><span class="line">            op-&gt;add_output(<span class="string">"loss_grad"</span>);</span><br><span class="line">            op-&gt;set_is_gradient_op(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::reverse(gradient_ops.begin(), gradient_ops.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> op : gradient_ops) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;GradientWrapper&gt; output(op-&gt;output_size());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; output.size(); i++) &#123;</span><br><span class="line">                output[i].dense_ = op-&gt;output(i) + <span class="string">"_grad"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            GradientOpsMeta meta = GetGradientForOp(*op, output);</span><br><span class="line">            <span class="keyword">auto</span> grad = predictModel.add_op();</span><br><span class="line">            grad-&gt;CopyFrom(meta.ops_[<span class="number">0</span>]);</span><br><span class="line">            grad-&gt;set_is_gradient_op(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; print(str(m.net.Proto()))</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        print(predictModel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; print(str(m.param_init_net.Proto()))</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        print(initModel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; workspace.RunNetOnce(m.param_init_net)</span></span><br><span class="line">        CAFFE_ENFORCE(workspace.RunNetOnce(initModel));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; workspace.CreateNet(m.net)</span></span><br><span class="line">        CAFFE_ENFORCE(workspace.CreateNet(predictModel));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; for j in range(0, 100):</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; data = np.random.rand(16, 100).astype(np.float32)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; data(<span class="number">16</span> * <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : data) &#123;</span><br><span class="line">                v = (<span class="keyword">float</span>)rand() / RAND_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; label = (np.random.rand(16) * 10).astype(np.int32)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; label(<span class="number">16</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : label) &#123;</span><br><span class="line">                v = <span class="number">10</span> * rand() / RAND_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; workspace.FeedBlob("data", data)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> tensor = workspace.GetBlob(<span class="string">"data"</span>)-&gt;GetMutable&lt;TensorCPU&gt;();</span><br><span class="line">                <span class="keyword">auto</span> value = TensorCPU(&#123;<span class="number">16</span>, <span class="number">100</span>&#125;, data, <span class="literal">NULL</span>);</span><br><span class="line">                tensor-&gt;ShareData(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; workspace.FeedBlob("label", label)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> tensor = workspace.GetBlob(<span class="string">"label"</span>)-&gt;GetMutable&lt;TensorCPU&gt;();</span><br><span class="line">                <span class="keyword">auto</span> value = TensorCPU(&#123;<span class="number">16</span>&#125;, label, <span class="literal">NULL</span>);</span><br><span class="line">                tensor-&gt;ShareData(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; workspace.RunNet(m.name, 10)   # run for 10 times</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                CAFFE_ENFORCE(workspace.RunNet(predictModel.name()));</span><br><span class="line">                <span class="comment">// std::cout &lt;&lt; "step: " &lt;&lt; i &lt;&lt; " loss: ";</span></span><br><span class="line">                <span class="comment">// print(*(workspace.GetBlob("loss")));</span></span><br><span class="line">                <span class="comment">// std::cout &lt;&lt; std::endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; print(workspace.FetchBlob("softmax"))</span></span><br><span class="line">        print(workspace.GetBlob(<span class="string">"softmax"</span>), <span class="string">"softmax"</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; print(workspace.FetchBlob("loss"))</span></span><br><span class="line">        print(workspace.GetBlob(<span class="string">"loss"</span>), <span class="string">"loss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    caffe2::GlobalInit(&amp;argc, &amp;argv);</span><br><span class="line">    caffe2::run();</span><br><span class="line">    google::protobuf::ShutdownProtobufLibrary();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/51887196" target="_blank" rel="noopener">Caffe2核心代码解析系列之一：综述</a><br><a href="https://zhuanlan.zhihu.com/p/35165653" target="_blank" rel="noopener">Caffe2学习笔记(1) 一些基本概念</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面记录一下caffe2的一些基本概念。&lt;/p&gt;
&lt;p&gt;Caffe2框架是一个&lt;strong&gt;静态的图框架&lt;/strong&gt;。同大多静态图框架一样，它的应用程序一般会干两件事情，先是建立模型（即建图，主要使用Python等较友好的语言脚本或像caffe那样直接使用prototxt文件），然后则是迭代执行模型。&lt;/p&gt;
&lt;h2 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h2&gt;&lt;h3 id=&quot;Operator&quot;&gt;&lt;a href=&quot;#Operator&quot; class=&quot;headerlink&quot; title=&quot;Operator&quot;&gt;&lt;/a&gt;Operator&lt;/h3&gt;&lt;p&gt;可以看成是一个函数，输入一些数据，输出一些数据，如 layers、数值操作等。感觉与TensorFlow中的op是一个概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MLFrameworks" scheme="https://www.zdaiot.com/categories/MLFrameworks/"/>
    
      <category term="Caffe2" scheme="https://www.zdaiot.com/categories/MLFrameworks/Caffe2/"/>
    
    
      <category term="Caffe2" scheme="https://www.zdaiot.com/tags/Caffe2/"/>
    
  </entry>
  
</feed>
