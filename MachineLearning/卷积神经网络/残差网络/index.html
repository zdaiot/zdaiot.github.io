<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="残差网络1. 神经网络越深越好么？2014年，GoogleNet和VGGNet在当年的ILSVRC中各自使用深度卷积神经网络取得了优异的成绩，并在分类错误率上优于2012年AlexNet数个百分点。两种结构相较于AlexNet，继续选择了增加网络复杂程度的策略来增强网络的特征表示能力。2015年，何凯明等人使用残差网络ResNet参加了当年的ILSVRC，在图像分类、目标检测等任务中的表现大幅超越"><meta name="keywords" content="resnet"><meta property="og:type" content="article"><meta property="og:title" content="残差网络"><meta property="og:url" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="残差网络1. 神经网络越深越好么？2014年，GoogleNet和VGGNet在当年的ILSVRC中各自使用深度卷积神经网络取得了优异的成绩，并在分类错误率上优于2012年AlexNet数个百分点。两种结构相较于AlexNet，继续选择了增加网络复杂程度的策略来增强网络的特征表示能力。2015年，何凯明等人使用残差网络ResNet参加了当年的ILSVRC，在图像分类、目标检测等任务中的表现大幅超越"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/20170220200258020.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/201610062149296861518148706853.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/201702202011289381518141503923.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/20170220210432796.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/201702202051315061518148556216.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/201702202056398591518148653477.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/v2-226185ddb0be2a5d2d44cb5cbb721219_b.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/v2-15c57849aa64d5bd4948109bc6b3f77b_b.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/v2-cfc5ee616e706f882e6abe37d1e2e53e_b.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/v2-c28b107c23fbc51fe5aa0f42c83172d6_b.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/v2-3c4870a5dd61d32880bf847f586896aa_b.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/201605081434482631518147933060.jpg"><meta property="og:updated_time" content="2019-09-15T03:33:57.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="残差网络"><meta name="twitter:description" content="残差网络1. 神经网络越深越好么？2014年，GoogleNet和VGGNet在当年的ILSVRC中各自使用深度卷积神经网络取得了优异的成绩，并在分类错误率上优于2012年AlexNet数个百分点。两种结构相较于AlexNet，继续选择了增加网络复杂程度的策略来增强网络的特征表示能力。2015年，何凯明等人使用残差网络ResNet参加了当年的ILSVRC，在图像分类、目标检测等任务中的表现大幅超越"><meta name="twitter:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/20170220200258020.png"><link rel="canonical" href="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>残差网络 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 残差网络<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/MachineLearning/卷积神经网络/残差网络.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-02-08 21:02:42" itemprop="dateCreated datePublished" datetime="2018-02-08T21:02:42+08:00">2018-02-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-09-15 11:33:57" itemprop="dateModified" datetime="2019-09-15T11:33:57+08:00">2019-09-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/卷积神经网络/" itemprop="url" rel="index"><span itemprop="name">卷积神经网络</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5.4k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="残差网络"><a href="#残差网络" class="headerlink" title="残差网络"></a>残差网络</h2><h3 id="1-神经网络越深越好么？"><a href="#1-神经网络越深越好么？" class="headerlink" title="1. 神经网络越深越好么？"></a>1. 神经网络越深越好么？</h3><p>2014年，GoogleNet和VGGNet在当年的ILSVRC中各自使用深度卷积神经网络取得了优异的成绩，并在分类错误率上优于2012年AlexNet数个百分点。两种结构相较于AlexNet，继续选择了增加网络复杂程度的策略来增强网络的特征表示能力。2015年，何凯明等人使用残差网络ResNet参加了当年的ILSVRC，在图像分类、目标检测等任务中的表现大幅超越前一年的比赛的性能水准，并最终取得冠军。残差网络的明显特征是有着相当深的深度，从32层到152层，其深度远远超过了之前提出的深度网络结构，而后又针对小数据设计了1001层的网络结构。残差网络ResNet的深度惊人，极其深的深度使该网络拥有极强大的表达能力。<br>因此，可以明显发现，网络的表达能力是随着网络深度的增加而增强的。何恺明等人的实验也证明，时间复杂度相同的两种网络结构，深度较深的网络性能会有相对的提升。</p><blockquote><p>He, Kaiming, and Jian Sun. “Convolutional neural networks at constrained time cost.” Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2015.</p></blockquote><p>然而，网络并非越深越好。计算代价很会大，在网络深度较深时，继续增加层数并不能提高性能，很有可能导致不收敛问题，虽然有一些方法可以弥补，如归一初始化，各层输入归一化，使得可以收敛的网络的深度提升为原来的十倍。然而，虽然收敛了，但网络却开始退化了，即增加网络层数却导致更大的误差，如图１所示。可以看到，在“平整”网络(与本文所介绍的残差网络复杂程度相同，但未使用残差结构的网络)中，随着网络层数的增加，其性能不但没有提升，反而出现了显著的退化。由于训练误差也随着层数增加而提升，所以这个现象可能并非参数的增加造成的过拟合；此外，这个网络在训练时也使用了ReLU激活、BN等手段，一定程度上缓解了梯度消失，这个现象可能也并非完全由梯度消失造成的。这个问题仍有待理论层面的研究和解决。<br><img src="/MachineLearning/卷积神经网络/残差网络/20170220200258020.png" alt><br>　　　　　　　　　　　　图１使用Cifar-10数据集对“平整”网络进行训练和测试对应的误差<br>那么没有办法让网络更深了吗？假设上面的实验场景中，多增加的26层全部为单位映射，那么完全可以认为不会产生性能的损失。当然实际应用中这样做是没有意义的，但如果增加的层可以近似为单位映射，或者增加了些许扰动的单位映射，那么就有可能实现上述假设。在这一思路的引导下，深度残差学习(Deep Residual Learning)应运而生。</p><h3 id="2-深度残差网络"><a href="#2-深度残差网络" class="headerlink" title="2. 深度残差网络"></a>2. 深度残差网络</h3><p>ResNet 全称是 Residual Network，每一个节点学到的不再是参数本身，而是残差，这就决定了网络有可能无限加深，基线不变，后面的节点学到的是对前面节点的补充，虽然有震荡，但震荡范围越来越小，直到趋于0。</p><h4 id="2-1-残差"><a href="#2-1-残差" class="headerlink" title="2.1 残差"></a>2.1 残差</h4><p>残差在数理统计中是指实际观察值与估计值（拟合值）之间的差。“残差”蕴含了有关模型基本假设的重要信息。如果回归模型正确的话， 我们可以将残差看作误差的观测值。 它应符合模型的假设条件，且具有误差的一些性质。利用残差所提供的信息，来考察模型假设的合理性及数据的可靠性称为残差分析。</p><h4 id="2-2-残差函数"><a href="#2-2-残差函数" class="headerlink" title="2.2 残差函数"></a>2.2 残差函数</h4><p>resnet学习的是残差函数$F(x)=H(x)-x$，这里如果$F(x)=0$, 那么就是上面提到的恒等映射，事实上，resnet“shortcut connections”中的connections是在恒等映射下的特殊情况，它没有引入额外的参数和计算复杂度。 假如优化目标函数是<strong>逼近一个恒等映射, 而不是0映射</strong>， 那么学习找到对恒等映射的扰动会比重新学习一个映射函数要容易。从下图可以看出，残差函数一般会有较小的响应波动，表明恒等映射是一个合理的预处理。<br><img src="/MachineLearning/卷积神经网络/残差网络/201610062149296861518148706853.png" alt></p><h4 id="2-3-Residual结构"><a href="#2-3-Residual结构" class="headerlink" title="2.3 Residual结构"></a>2.3 Residual结构</h4><p><img src="/MachineLearning/卷积神经网络/残差网络/201702202011289381518141503923.png" alt><br>它有二层，如下表达式，其中σ代表非线性函数ReLU</p><script type="math/tex;mode=display">\cal F=\it W_2 \sigma(W_1x)</script><p>然后通过一个shortcut，和第2个ReLU，获得输出y</p><script type="math/tex;mode=display">y = \cal F\it (x,{W_i}) + x</script><p>当需要对输入和输出维数进行变化时（如改变通道数目），可以在shortcut时对x做一个线性变换Ws，如下式，然而实验证明x已经足够了，不需要再搞个维度变换，除非需求是某个特定维度的输出，如下面的resnet网络结构图中的虚线，是将通道数翻倍。</p><script type="math/tex;mode=display">y = \cal F\it (x,{W_i}) + W_s x</script><p>实验证明，这个残差块往往需要两层以上，单单一层的残差块$(y=W_1x+x)$并不能起到提升作用。<br>这种残差学习结构可以通过前向神经网络+shortcut连接实现，如结构图所示。而且shortcut连接相当于简单执行了恒等映射，不会产生额外的参数，也不会增加计算复杂度。同时却可以大大增加模型的训练速度、提高训练效果，并且当模型的层数加深时，这个简单的结构能够很好的解决退化问题。 而且，整个网络可以依旧通过端到端的反向传播训练。</p><h5 id="shortcut的方式"><a href="#shortcut的方式" class="headerlink" title="shortcut的方式"></a>shortcut的方式</h5><ul><li>使用恒等映射，如果residual block的输入输出维度不一致，对增加的维度用0来填充；</li><li>在block输入输出维度一致时使用恒等映射，不一致时使用线性投影以保证维度一致；</li><li>对于所有的block均使用线性投影。</li></ul><p>对这三个选项都进行了实验，发现虽然C的效果好于B的效果好于A的效果，但是差距很小，因此线性投影并不是必需的，而<strong>使用0填充</strong>时，可以保证模型的复杂度最低，这对于更深的网络是更加有利的。<br>进一步实验，作者又提出了deeper的residual block：<br>实际中，考虑计算的成本，对残差块做了计算优化，即将两个3x3的卷积层替换为1x1 + 3x3 + 1x1, 如下图。<br><img src="/MachineLearning/卷积神经网络/残差网络/20170220210432796.jpg" alt></p><h5 id="1X1卷积的作用"><a href="#1X1卷积的作用" class="headerlink" title="1X1卷积的作用"></a>1X1卷积的作用</h5><ul><li>新结构中的中间3x3的卷积层首先在一个降维1x1卷积层下减少了计算，然后在另一个1x1的卷积层下做了还原，既保持了精度又减少了计算量(对于右图，假设不加入1X1的卷积层，参数量为3X3X256X256+3X3X256X256，而加入1X1的卷积之后，参数数量为1X1X256X64+3X3X64X64+1X1X64X64)。</li><li>另外，1X1的卷积可以实现跨通道的交互和信息整合。CNN里的卷积大都是多通道的feature map和多通道的卷积核之间的操作（输入的多通道的feature map和一组卷积核做卷积求和得到一个输出的feature map），如果使用1x1的卷积核，这个操作实现的就是多个feature map的线性组合，可以实现feature map在通道个数上的变化。接在普通的卷积层的后面，配合激活函数，就可以实现network in network的结构了。</li><li>还有一个重要的功能，就是可以在保持feature map 尺寸不变（即不损失分辨率）的前提下大幅增加非线性特性，把网络做得很deep。</li></ul><h4 id="2-4-残差网络结构"><a href="#2-4-残差网络结构" class="headerlink" title="2.4 残差网络结构"></a>2.4 残差网络结构</h4><p>首先构建了一个18层和一个34层的plain网络，即将所有层进行简单的铺叠，然后构建了一个18层和一个34层的residual网络，仅仅是在plain上插入了shortcut，而且这两个网络的参数量、计算量相同，并且和之前有很好效果的VGG-19相比，计算量要小很多。（36亿FLOPs VS 196亿FLOPs，FLOPs即每秒浮点运算次数。）这也是作者反复强调的地方，也是这个模型最大的优势所在(维度匹配的shortcut连接为实线，反之为虚线。维度不匹配时，使用上文中shortcut的方式)。</p><p><img src="/MachineLearning/卷积神经网络/残差网络/201702202051315061518148556216.jpg" alt></p><p>模型构建好后进行实验，在plain上观测到明显的退化现象，而且ResNet上不仅没有退化，34层网络的效果反而比18层的更好，而且不仅如此，ResNet的收敛速度比plain的要快得多。<br><img src="/MachineLearning/卷积神经网络/残差网络/201702202056398591518148653477.jpg" alt></p><h3 id="3-残差网络思考"><a href="#3-残差网络思考" class="headerlink" title="3. 残差网络思考"></a>3. 残差网络思考</h3><h4 id="3-1-为什么同一映射-I-x-x-这一项前的系数为1而不是1-2。"><a href="#3-1-为什么同一映射-I-x-x-这一项前的系数为1而不是1-2。" class="headerlink" title="3.1 为什么同一映射 I(x)=x 这一项前的系数为1而不是1/2。"></a>3.1 为什么同一映射 I(x)=x 这一项前的系数为1而不是1/2。</h4><ul><li>一方面，实践发现机器学习要拟合的（target function）函数 f(x) 经常是很接近同一映射函数的。</li><li>另一方面，神经网络权值的初始值往往在 0 附近。</li></ul><p>因此，以同一映射函数为初始函数，用其他神经网络做微调，相当于赢在了起跑线上。<br>形象但是松散一点描述就是，经验表明要拟合的函数接近一根直线，于是就用一根直线加一些微小的折线们叠加来拟合。如果只用直线，就成了线性分类/回归，细节难把握；而只用微小的折线们，要优化的路很长，并且还容易过拟合。<br>有篇文章仔细分析了残差网络背后的原理，简单的说就是大量的（exponential）不同长度的神经网络组成的组合函数（ensemble）</p><blockquote><p>Christian Szegedy, Sergey Ioffe, and Vincent Vanhoucke. Inception-v4, inception-resnet and the impact of residual connections on learning. arXiv preprint arXiv:1602.07261, 2016.</p></blockquote><h4 id="3-2-效果好的解释"><a href="#3-2-效果好的解释" class="headerlink" title="3.2 效果好的解释"></a>3.2 效果好的解释</h4><ul><li>resnet最初的想法是在训练集上，深层网络不应该比浅层网络差，因为只需要深层网络多的那些层做恒等映射就简化为了浅层网络。所以从学习恒等映射这点出发，考虑到网络要学习一个F(x)=x的映射比学习F(x)=0的映射更难，所以可以把网络结构设计成H(x) = F(x) + x，这样就即完成了恒等映射的学习，又降低了学习难度。这里的x是残差结构的输入，F是该层网络学习的映射，H是整个残差结构的输出。</li><li>resnet能有好的表现主要还是因为<strong>事物本身的特征就是不同层次的，它等价于多个浅层网络的 ensemble</strong><br>比如, 区分男女相对比较容易,不需要复杂的计算或者模型(在深度网络中就是网络不需要那么深),但是要区分出范冰冰和张馨予就需要更多的计算了(模型更复杂,网络更深). 我们把网络看成一个映射或者函数,在没有’捷径’(shortcut)的网络里,无论简单还是复杂的特征都得用一个很复杂很深的网络来处理或转换,这似乎有点不合理,而现在resnet引入了捷径,不同层次提取到的特征可以’走捷径’影响预测结果.<br>在resnet的网络里,我们要区分出李晨,范冰冰和张馨予三个人的思路就是这样的,首先提取区分男女特征,这个特征通过捷径直接影响结果,而更细致的脸型皮肤纹理等等走更细致的网络区分范冰冰和张馨予.<br>所以shortcut(捷径)这个词用的真是好啊,看似简单的修改,背后蕴含本质的区别.</li></ul><h4 id="3-3-为什么要旁路掉-2-层网络才能得到不错的结果？如果只旁路掉-1-层，为什么效果并不好？"><a href="#3-3-为什么要旁路掉-2-层网络才能得到不错的结果？如果只旁路掉-1-层，为什么效果并不好？" class="headerlink" title="3.3 为什么要旁路掉 2 层网络才能得到不错的结果？如果只旁路掉 1 层，为什么效果并不好？"></a>3.3 为什么要旁路掉 2 层网络才能得到不错的结果？如果只旁路掉 1 层，为什么效果并不好？</h4><p>不妨看个具体例子，因为一般情况的证明稍后会看到是比较明显的。只需看一个最简单的回归问题，使用 MSE 损失。我们的目标是在 (-3, 3) 区间拟合 sin(x)：<br><img src="/MachineLearning/卷积神经网络/残差网络/v2-226185ddb0be2a5d2d44cb5cbb721219_b.jpg" alt><br><strong>方法 1</strong> ：<br>如果用直接的方法：</p><script type="math/tex;mode=display">input => Max(0, w_1x+b_1) => Max(0, w_2x+b_2) => ... => w_nx+b_n => output</script><p>我们会发现多加几层后就根本无法训练，全部清零。原因很简单，ReLU 会不断丢失信息。当 ReLU 给出 0 之后，后面就全死了。如果网络的层数少，还可以得到这样的结果：<br><img src="/MachineLearning/卷积神经网络/残差网络/v2-15c57849aa64d5bd4948109bc6b3f77b_b.jpg" alt><br>如果层数一多，就肯定全部清零。<br><strong>方法 2</strong> ：<br>那么加上残差结构吧，比如旁路掉 1 层：</p><script type="math/tex;mode=display">input => x + Max(0, w_1x+b_1) => x + Max(0, w_2x+b_2) => .... => x + Max(0, w_nx+b_n) => output</script><p>这个肯定也不行。因为 x 只会变大，我们会得到类似这样的结果：<br><img src="/MachineLearning/卷积神经网络/残差网络/v2-cfc5ee616e706f882e6abe37d1e2e53e_b.jpg" alt><br>可以用一些办法改善，比如把最后一层的残差和 ReLU 都去掉，但这无疑不是好的办法。<br><strong>方法 3</strong> ：<br>最简单的解决方法就是旁路掉 2 层。因为如果熟悉 ReLU 就会知道，ReLU 是可以给出负值的，只需要 2 层即可。例如：-Max(0, -x) = Min(0, x)。<br>于是，最简单的满足我们要求的 2 层结构，就是 Convolution =&gt; ReLU =&gt; Convolution（这其实就是 1610.02915 PyramidNet 的结构了）：</p><script type="math/tex;mode=display">input => x + w_{1b} \cdot Max(0, w_{1a}x+b_{1a}) + b_{1b} => .... => x + w_{nb} \cdot Max(0, w_{na}x+b_{na}) + b_{nb} => output</script><p>可以得到类似这样的结果：<br><img src="/MachineLearning/卷积神经网络/残差网络/v2-c28b107c23fbc51fe5aa0f42c83172d6_b.jpg" alt><br>易证这种方法可以拟合任何函数，<strong>因为它其实就是在不断”折”一条线</strong>。不过，如果层数很多，仍然可能死掉，拟合效果卡住。<br><strong>方法 4</strong> ：<br>把 ReLU 再换成 leaky 的，例如 PReLU。这就基本解决了死亡问题，可以保证多层训练的效果，例如：<br><img src="/MachineLearning/卷积神经网络/残差网络/v2-3c4870a5dd61d32880bf847f586896aa_b.jpg" alt><br>最后，如果我们把方法 1 中的 ReLU 换成 PReLU，是否可以解决死亡问题？遗憾的是不行。这里涉及到数值稳定性。最好的方法仍然是方法 4 的旁路2层残差+PReLU。<br><img src="/MachineLearning/卷积神经网络/残差网络/201605081434482631518147933060.jpg" alt></p><h4 id="3-4-深层网络容易遇到的问题"><a href="#3-4-深层网络容易遇到的问题" class="headerlink" title="3.4 深层网络容易遇到的问题"></a>3.4 深层网络容易遇到的问题</h4><ul><li>梯度消失</li><li>梯度爆炸</li><li>模型退化(残差结构)</li><li>参数太多(使用1X1卷积)</li></ul></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/" title="残差网络">https://www.zdaiot.com/MachineLearning/卷积神经网络/残差网络/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/resnet/" rel="tag"><i class="fa fa-tag"></i> resnet</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Python/实战/Python拟合函数/" rel="prev" title="Python拟合函数"><i class="fa fa-chevron-left"></i> Python拟合函数</a></div><div class="post-nav-item"> <a href="/MachineLearning/神经网络/反向传播简介/" rel="next" title="反向传播简介">反向传播简介<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#残差网络"><span class="nav-number">1.</span> <span class="nav-text">残差网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-神经网络越深越好么？"><span class="nav-number">1.1.</span> <span class="nav-text">1. 神经网络越深越好么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-深度残差网络"><span class="nav-number">1.2.</span> <span class="nav-text">2. 深度残差网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-残差"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 残差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-残差函数"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 残差函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-Residual结构"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 Residual结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#shortcut的方式"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">shortcut的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1X1卷积的作用"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">1X1卷积的作用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-残差网络结构"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 残差网络结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-残差网络思考"><span class="nav-number">1.3.</span> <span class="nav-text">3. 残差网络思考</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-为什么同一映射-I-x-x-这一项前的系数为1而不是1-2。"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 为什么同一映射 I(x)=x 这一项前的系数为1而不是1/2。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-效果好的解释"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 效果好的解释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-为什么要旁路掉-2-层网络才能得到不错的结果？如果只旁路掉-1-层，为什么效果并不好？"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 为什么要旁路掉 2 层网络才能得到不错的结果？如果只旁路掉 1 层，为什么效果并不好？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-深层网络容易遇到的问题"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 深层网络容易遇到的问题</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">318</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">54</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">374</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2.4m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">36:17</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : 'b740cc50fb7020f8f547896919966b12',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>