<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="一般地，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映"><meta name="keywords" content="CNN结构"><meta property="og:type" content="article"><meta property="og:title" content="卷积神经网络模型结构"><meta property="og:url" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="一般地，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021122942255.gif"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021131032984.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021131431532.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021131748099.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/640.gif"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/2256672-958f31b01695b085.gif"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021141659634.gif"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021154222794.gif"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021155552870.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20170715175257862.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/v2-8f7813b7779133a98a6c2a7cd32b7da3_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.057081729464744324.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.49082435604982.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.1914567755957286.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.33245846731033235.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.232160698149237.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.6412132220143478.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/6401521993329665.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20180511113731323.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20180511113810171.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20180511113901204.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20180511113933913.gif"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.481206159670045.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.44799501959207544.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.8055147160715099.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/3814377-690af2476f0dbeff.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/3814377-9f7a2b498de04185.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/v2-523de4ca9fa2b92d181bbdb81fe7d3f0_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-1.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-5.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-3.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-4.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-2.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20170226222316999.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20171015173915008.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/v2-8d1b873fa119c01de36f3643f19331b7_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/15281a0bb762fa8ab2c21555b4036b66_r.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/d30610fa20a28268763fd6355a7e3426_b.jpg"><meta property="og:updated_time" content="2019-09-15T03:34:25.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="卷积神经网络模型结构"><meta name="twitter:description" content="一般地，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映"><meta name="twitter:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021122942255.gif"><link rel="canonical" href="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>卷积神经网络模型结构 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 卷积神经网络模型结构<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/MachineLearning/卷积神经网络/卷积神经网络模型结构.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-03-25 22:37:06" itemprop="dateCreated datePublished" datetime="2018-03-25T22:37:06+08:00">2018-03-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-09-15 11:34:25" itemprop="dateModified" datetime="2019-09-15T11:34:25+08:00">2019-09-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/卷积神经网络/" itemprop="url" rel="index"><span itemprop="name">卷积神经网络</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>15k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>14 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>一般地，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。</p><p>CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。</p><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>对于1维的卷积，公式（离散）与计算过程（连续）如下，要记住的是其中一个函数（原函数或者卷积函数）在卷积前要翻转180度。</p><script type="math/tex;mode=display">(f*g)[n]=\sum_{m=-M}^M f[n-m]g[m]</script><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021122942255.gif" alt></p><p>对于离散卷积，f的大小是n1，g的大小是n2，卷积后的大小是n1+n2-1。</p><h3 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h3><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021131032984.png" alt></p><p>同样地，卷积的时候需要对卷积核进行180的旋转，同时卷积核中心与需计算的图像像素对齐，输出结构为中心对齐像素的一个新的像素值，计算例子如下</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021131431532.png" alt></p><p>这样计算出左上角(即第一行第一列)像素的卷积后像素值。</p><p>给出一个更直观的例子，从左到右看，原像素经过卷积由1变成-8。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021131748099.png" alt></p><p>通过滑动卷积核，就可以得到整张图片的卷积结果。</p><h3 id="Depth为1的卷积"><a href="#Depth为1的卷积" class="headerlink" title="Depth为1的卷积"></a>Depth为1的卷积</h3><p>假设一张图像有 $5<em>5$ 个像素，1 代表白，0 代表黑，这幅图像被视为 $5</em>5$ 的单色图像。现在用一个由随机地 0 和 1 组成的 $3<em>3$ 矩阵去和图像中的子区域做乘法，每次迭代移动一个像素，这样该乘法会得到一个新的 $3</em>3$ 的矩阵。下面的动图展示了这个过程。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/640.gif" alt></p><p>上述的 $3<em>3$ 的矩阵被称作「滤波器」，它的任务是提取图像特征，它使用「优化算法」来决定 $3</em>3$ 矩阵中具体的 0 和 1。我们在神经网络的卷积层中使用好几个这样的滤波器来提取多个特征。$3*3$ 矩阵的每一个单个步骤被称作「步幅」（stride）。</p><script type="math/tex;mode=display">W_2=(W_1-F+2P)/S+1</script><script type="math/tex;mode=display">H_2=(H_1-F+2P)/S+1</script><p>在上面两个公式中，W2是卷积后Feature Map的宽度；W1是卷积前图像的宽度；F是filter的宽度；P是Zero Padding数量，Zero Padding是指在原始图像周围补几圈0，如果的值是1，那么就补1圈0；S是步幅；H2是卷积后Feature Map的高度；H1是卷积前图像的高度。</p><h3 id="Depth大于1的卷积"><a href="#Depth大于1的卷积" class="headerlink" title="Depth大于1的卷积"></a>Depth大于1的卷积</h3><p>下面的例子中，输入层是高度和宽度是 7 x 7 ，深度是3。两个Filter的，每个Filter的高度和宽度是 3 x 3 ，深度因为要和输入层保持一致，所以也必须是 3。</p><p>最左边的输入层（Input Volume）和Filter W0 进行计算（输入的第一层和Filter的第一层进行运算，第二层和第二层进行运算，第三层和第三层进行运算，最后三层结果累加起来），获得了 Output Volume 的第一个结果（绿色的上面一个矩阵）；和Filter W1 进行计算，获得了 Output Volume 的第二个结果（绿色的下面一个矩阵）。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/2256672-958f31b01695b085.gif" alt></p><p>前面我们已经讲了深度为1的卷积层的计算方法，如果深度大于1怎么计算呢？其实也是类似的。如果卷积前的图像深度为D，那么相应的filter的深度也必须为D。我们扩展一下式1，得到了深度大于1的卷积计算公式：</p><script type="math/tex;mode=display">a_{i,j}=f(\sum_{d=0}^{D-1}\sum_{m=0}^{F-1}\sum_{n=0}^{F-1}w_{d,m,n}x_{d,i+m,j+n}+w_b)</script><p>上式中，D是深度；F是filter的大小(宽度或高度，两者相同)；$w_{d,m,n}$是filter的第n层第i行第j列像素；其他的含义与上述深度为1的时候卷积层计算公式相同。</p><blockquote><p>不管深度为多少，经过一个Filter，最后都通过上面的公式变成一个深度为1的特征图(feature map)。</p><p>feature map的理解：在每个卷积层，数据都是以三维形式存在的。你可以把它看成许多个二维图片叠在一起，其中每一个称为一个feature map。在输入层，如果是灰度图片，那就只有一个feature map；如果是彩色图片，一般就是3个feature map（红绿蓝）。层与层之间会有若干个卷积核（kernel），上一层中每个feature map跟每个卷积核做卷积，都会产生下一层的一个feature map。</p></blockquote><h3 id="卷积的类型"><a href="#卷积的类型" class="headerlink" title="卷积的类型"></a>卷积的类型</h3><p>在matlab中对2维卷积的计算分为了3类，1.full 2.same 3. valid 参考<a href="https://cn.mathworks.com/help/matlab/ref/conv2.html?requestedDomain=www.mathworks.com" target="_blank" rel="noopener">这里</a></p><p><code>图像卷积小节</code>中第一个图对应的是same，<code>Depth为1的卷积小节</code>中的第一个图对应的是valid，full对应如下图：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021141659634.gif" alt></p><p>上图中蓝色为原图像，白色为对应卷积所增加的padding，通常全部为0，绿色是卷积后图片。图6的卷积的滑动是从卷积核右下角与图片左上角重叠开始进行卷积，滑动步长为1，卷积核的中心元素对应卷积后图像的像素点。可以看到卷积后的图像是4X4，比原图2X2大了，我们还记1维卷积大小是n1+n2-1，这里原图是2X2，卷积核3X3，卷积后结果是4X4，与一维完全对应起来了。其实这才是完整的卷积计算，其他比它小的卷积结果都是省去了部分像素的卷积。下面是WIKI对应图像卷积后多出部分的解释：</p><blockquote><p>Kernel convolution usually requires values from pixels outside of the image boundaries. There are a variety of methods for handling image edges.意思就是多出来的部分根据实际情况可以有不同的处理方法。（其实这里的full卷积就是后面要说的反卷积）</p></blockquote><p>这里，我们可以总结出full，same，valid三种卷积后图像大小的计算公式：</p><ol><li>full: 滑动步长为1，图片大小为N1xN1，卷积核大小为N2xN2，卷积后图像大小：N1+N2-1 x N1+N2-1<br>如1.4中的第一个图， 滑动步长为1，图片大小为2x2，卷积核大小为3x3，卷积后图像大小：4x4</li><li>same: 滑动步长为1，图片大小为N1xN1，卷积核大小为N2xN2，卷积后图像大小：N1xN1</li><li>valid:滑动步长为S，图片大小为N1xN1，卷积核大小为N2xN2，卷积后图像大小：(N1-N2)/S+1 x (N1-N2)/S+1</li></ol><p>如1.2中的第一个图，滑动步长为1，图片大小为5x5，卷积核大小为3x3，卷积后图像大小：3x3</p><h3 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h3><p>这里提到的反卷积跟1维信号处理的反卷积计算是很不一样的，FCN作者称为backwards convolution，有人称Deconvolution layer is a very unfortunate name and should rather be called a transposed convolutional layer. 我们可以知道，在CNN中有con layer与pool layer，con layer进行对图像卷积提取特征，pool layer对图像缩小一半筛选重要特征，对于经典的图像识别CNN网络，如IMAGENET，最后输出结果是1X1X1000，1000是类别种类，1x1得到的是。FCN作者，或者后来对end to end研究的人员，就是对最终1x1的结果使用反卷积（事实上FCN作者最后的输出不是1X1，是图片大小的32分之一，但不影响反卷积的使用）。</p><p>这里图像的反卷积与1.4中第一个图的full卷积原理是一样的，使用了这一种反卷积手段使得图像可以变大，FCN作者使用的方法是这里所说反卷积的一种变体，这样就可以获得相应的像素值，图像可以实现end to end。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021154222794.gif" alt></p><p>这里说另外一种反卷积做法，假设原图是3X3，首先使用上采样让图像变成7X7，可以看到图像多了很多空白的像素点。使用一个3X3的卷积核对图像进行滑动步长为1的valid卷积，得到一个5X5的图像，我们知道的是使用上采样扩大图片，使用反卷积填充图像内容，使得图像内容变得丰富，这也是CNN输出end to end结果的一种方法。韩国作者Hyeonwoo Noh使用VGG16层CNN网络后面加上对称的16层反卷积与上采样网络实现end to end 输出，其不同层上采样与反卷积变化效果如下，</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20161021155552870.png" alt></p><h4 id="图像的deconvolution"><a href="#图像的deconvolution" class="headerlink" title="图像的deconvolution"></a>图像的deconvolution</h4><p>目前使用得最多的deconvolution有2种，上文都已经介绍。</p><p>方法1：full卷积， 完整的卷积可以使得原来的定义域变大</p><p>方法2：记录pooling index，然后扩大空间，再用卷积填充</p><p>图像的deconvolution过程如下，</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20170715175257862.png" alt></p><p>输入：2x2， 卷积核：4x4， 滑动步长：3， 输出：7x7。即输入为2x2的图片经过4x4的卷积核进行步长为3的反卷积的过程。</p><ol><li>输入图片每个像素进行一次full卷积，根据full卷积大小计算可以知道每个像素的卷积后大小为 1+4-1=4， 即4x4大小的特征图，输入有4个像素所以4个4x4的特征图</li><li>将4个特征图进行步长为3的fusion（即相加）； 例如红色的特征图仍然是在原来输入位置（左上角），绿色还是在原来的位置（右上角），步长为3是指每隔3个像素进行fusion，重叠部分进行相加，即输出的第1行第4列是由红色特阵图的第一行第四列与绿色特征图的第一行第一列相加得到，其他如此类推。</li></ol><p>可以看出翻卷积的大小是由卷积核大小与滑动步长决定， in是输入大小， k是卷积核大小， s是滑动步长， out是输出大小</p><p>得到 $out = (in - 1) * s + k$</p><p>上图过程就是， $(2 - 1) * 3 + 4 = 7$</p><h3 id="卷积的优势"><a href="#卷积的优势" class="headerlink" title="卷积的优势"></a>卷积的优势</h3><h4 id="局部感知"><a href="#局部感知" class="headerlink" title="局部感知"></a>局部感知</h4><p>由卷积的操作可知，输出图像中的任何一个单元，只跟输入图像的一部分有关系：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/v2-8f7813b7779133a98a6c2a7cd32b7da3_hd.jpg" alt></p><p>而传统神经网络中，由于都是全连接，所以输出的任何一个单元，都要受输入的所有的单元的影响。这样无形中会对图像的识别效果大打折扣。而图像中，每一个区域都有自己的专属特征，我们不希望它受到其他区域的影响。</p><p>简单来说，卷积核的大小一般小于输入图像的大小（如果等于则是全连接），因此卷积提取出的特征会更多地关注局部 —— 这很符合日常我们接触到的图像处理。而每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。</p><h4 id="参数共享"><a href="#参数共享" class="headerlink" title="参数共享"></a>参数共享</h4><p>参数共享机制，让我们的网络的参数数量大大地减少。这样，我们可以用较少的参数，训练出更加好的模型，典型的事半功倍，而且可以有效地<strong>避免过拟合</strong>。 同样，由于filter的参数共享，即使图片进行了一定的平移操作，我们照样可以识别出特征，这叫做 <strong>“平移不变性”</strong>。因此，模型就更加稳健了。</p><h4 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h4><p>一般我们都不会只用一个卷积核对输入图像进行过滤，因为一个核的参数是固定的，其提取的特征也会单一化。这就有点像是我们平时如何客观看待事物，必须要从多个角度分析事物，这样才能尽可能地避免对该事物产生偏见。我们也需要多个卷积核对输入图像进行卷积。</p><h3 id="参数计算"><a href="#参数计算" class="headerlink" title="参数计算"></a>参数计算</h3><p><strong>举例1：</strong></p><p>比如输入是一个32x32x3的图像，3表示RGB三通道，每个filter/kernel是5x5x3，一个卷积核产生一个feature map，下图中，有6个5x5x3的卷积核，故输出6个feature map（activation map），大小即为28x28x6(32 - 5 + 1)。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.057081729464744324.png" alt></p><p>下图中，第二层到第三层，其中每个卷积核大小为5x5x6，这里的6就是28x28x6中的6，两者需要相同，即每个卷积核的“层数”需要与输入的“层数”一致。有几个卷积核，就输出几个feature map，下图中，与第二层作卷积的卷积核有10个，故输出的第三层有10个通道。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.49082435604982.png" alt></p><p><strong>举例2：</strong></p><p>NxN大小的输入（暂时不考虑通道数），与FxF大小的卷积核（暂时不考虑个数）做卷积，那么输出大小为多大？计算公式为：(N - F) / stride + 1，其中stride为做卷积是相邻卷积核的距离。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.1914567755957286.png" alt></p><p><strong>举例3：</strong></p><p>当输入为7x7大小，卷积核为3x3，stride=1，在7x7周围补上一圈0（pad=1个像素），那么输出大小为多大？</p><p>是7x7。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.33245846731033235.png" alt></p><p><strong>举例4：</strong></p><p>输入为32x32x3，卷积核大小为5x5，总共有10个卷积核，做卷积的时候stride=1，pad=2，那么这一层总共含有多少参数？</p><p>每个卷积核含有的参数个数为：5<em>5</em>3 + 1 = 76，其中1是偏置bias，由于有10个卷积核，故总参数为76*10=760。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.232160698149237.png" alt></p><p><strong>总结：</strong></p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.6412132220143478.png" alt></p><p>其中，卷积核的数量K一般是2的整数次幂，这是因为计算方便（计算机计算2^n比较快）</p><h2 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h2><p>这个层主要使用不同的函数为输入降维。通常，最大池化层（max-pooling layer）出现在卷积层之后。池化层使用 $2*2$ 的矩阵，以卷积层相同的方式处理图像，不过它是给图像本身降维。下面分别是使用「最大池化」和「平均池化」的示例。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/6401521993329665.jpg" alt></p><blockquote><p>池化层会损失信息，所以也不是首选的。通常的做法是在卷机层中使用一个较大的步幅。</p></blockquote><p>常用的还有resnet中的global average pool。对于类似imagenet这样的分类任务，可以用来代替常规网络中的倒数第二个全连接层。该池化操作为比如现在输入尺寸为64x64x256，对每一个特征图所有像素求平均，即可得到1x1x256的特征图。使用该操作有两个优点，一：近似全连接操作，但是可以极大降低参数量。二：网络输入可以为任意大小。</p><p>除此之外，还有ROI Pooling。例如，我们有一个<code>8*8</code>大小的feature map，一个感兴趣区域ROI，以及输出大小为<code>2*2</code>.对于一个feature map，region proposal 投影之后位置（左上角，右下角坐标）：（0，3），（7，8）。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20180511113731323.jpg" alt></p><p>将其划分为（<code>2*2</code>）个sections（因为输出大小为<code>2*2</code>），我们可以得到：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20180511113810171.jpg" alt></p><p>对每个section做max pooling，可以得到：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20180511113901204.jpg" alt></p><p>整体过程如下：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20180511113933913.gif" alt></p><p>ROI Pooling 就是将大小不同的feature map 池化成大小相同的feature map，利于输出到下一层网络中。</p><p><strong>总结：global average pool可以代替分类任务中的全连接层，而其余三种池化不可以。global average pool与ROI Pooling均可以实现让网络输入为任意大小。</strong></p><h3 id="池化层作用"><a href="#池化层作用" class="headerlink" title="池化层作用"></a>池化层作用</h3><ul><li>做窗口滑动卷积的时候，卷积值就代表了整个窗口的特征。因为滑动的窗口间有大量重叠区域，出来的卷积值有冗余，进行最大pooling或者平均pooling就是减少冗余。<strong>减少冗余的同时，pooling也丢掉了局部位置信息，所以局部有微小形变，结果也是一样的。就像图片上的字母A，局部出现微小变化，也能够被识别成A</strong>。而加上椒盐噪音，就是字母A上有很多小洞，同样的能够被识别出来。而<strong>平移不变性，就是一个特征，无论出现在图片的那个位置，都会识别出来。所以平移不变性不是pooling带来的，而是层层的权重共享带来的</strong>。</li><li>如果人们选择图像中的连续范围作为池化区域,并且只是池化相同(重复)的隐藏单元产生的特征,那么,这些池化单元就具有平移不变性(translation invariant)。</li></ul><p>注意这两点：１、连续范围　２、池化相同隐藏单元产生的特征。这意思是指，在池化单元内部能够具有平移的不变性，它的平移范围也是有一定范围的，因为每个池化单元都是连续的，所以能够保证图像整体上发生了平移一样能提取特征进行匹配。</p><p>无论是max还是average都是在提取区域特征，均相当于一种抽象，抽象就是过滤掉了不必要的信息（当然也会损失信息细节），所以在抽象层次上可以进行更好的识别。</p><p>至于max与average效果是否一样，还是要看需要识别的图像细节特征情况，这个不一定的，不过据说差异不会超过2%。</p><p>不过仔细点说的话，评估特征提取的误差主要来自两个方面：<br>（1）邻域大小受限造成的估计值方差增大，average能减小这种误差。<br>（2）卷积层参数误差造成估计均值的偏移，max能减小这种误差。</p><p>也就是说，average对背景保留更好，max对纹理提取更好，如果是识别字体什么的，应该考虑max.</p><p>总结来说，主要是两个作用：</p><ol><li>invariance(不变性)，这种不变性包括translation(平移)，rotation(旋转)，scale(尺度)</li><li>保留主要的特征同时减少参数(降维，效果类似PCA)和计算量，防止过拟合，提高模型泛化能力</li></ol><h3 id="参数计算-1"><a href="#参数计算-1" class="headerlink" title="参数计算"></a>参数计算</h3><p>关于池化层的参数计算：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.481206159670045.png" alt></p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.44799501959207544.png" alt></p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/0.8055147160715099.png" alt></p><p><strong>参考：</strong><a href="http://cs231n.stanford.edu/slides/2016/winter1516_lecture7.pdf" target="_blank" rel="noopener">斯坦福大学CS231N课程PPT</a></p><h2 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h2><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><p>一般常见的是这种一维的全连接层，下面这种图就很常见。全连接层，通俗的说就是前面一层的每个单元都与后面一层的相连接。如下图的绿色 Hidden 层，Hidden 层的每个单元都与 Input 层的所有单元相连接，同理 Output 层的与 Hidden 层的也是如此。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1*3)*(3*4)=(1*4)</span><br><span class="line">(1*4)*(4*2)=(1*2)</span><br></pre></td></tr></table></figure><p></p><p>即 Input 到 Hidden 这个全连接层中间的参数矩阵是 (3,4) 维的，Hidden 到 Output 的参数矩阵是 (4,2) 为的</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/3814377-690af2476f0dbeff.png" alt></p><h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><p>二维的图主要是这样的，左边的 v 层是 (4, 2) 的矩阵，通过全连接层，得到一个四维的向量，看中间的 H 层也是每个单元都与前面 v层的八个单元都相连的。他们中间的参数矩阵应该是(2, 1) 的。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/3814377-9f7a2b498de04185.png" alt></p><h3 id="全连接层的作用"><a href="#全连接层的作用" class="headerlink" title="全连接层的作用"></a>全连接层的作用</h3><ul><li>全连接层（fully connected layers，FC）在整个卷积神经网络中起到“分类器”的作用。如果说卷积层、池化层和激活函数层等操作是将原始数据映射到隐层特征空间的话，全连接层则起到<strong>将学到的“分布式特征表示”映射到样本标记空间的作用</strong>。在实际使用中，全连接层可由卷积操作实现：对前层是全连接的全连接层可以转化为卷积核为1x1的卷积；而前层是卷积层的全连接层可以转化为卷积核为hxw的全局卷积，h和w分别为前层卷积结果的高和宽（_<strong>注1</strong>_）。</li><li>卷积取的是局部特征，全连接就是把以前的局部特征重新通过权值矩阵组装成完整的图。因为用到了所有的局部特征，所以叫全连接。</li><li>目前由于全连接层参数冗余（仅全连接层参数就可占整个网络参数80%左右），近期一些性能优异的网络模型如ResNet和GoogLeNet等均用全局平均池化（global average pooling，GAP）取代FC来融合学到的深度特征，最后仍用softmax等损失函数作为网络目标函数来指导学习过程。需要指出的是，用GAP替代FC的网络通常有较好的预测性能。GAP的优势是：1.因为FC的参数众多，这么做就减少了参数的数量（在最近比较火的模型压缩中，这个优势可以很好的压缩模型的大小）。2.因为减少了参数的数量，可以很好的减轻过拟合的发生。另外，这种直接用 feature map 表示属于某个类的 confidence map 的做法很符合CNN的思想。3.若之前无fc层，可以让网络输入任意大小。为具体案例可参见我们在ECCV’16（视频）表象性格分析竞赛中获得冠军的做法：<a href="https://zhuanlan.zhihu.com/p/23176872" target="_blank" rel="noopener">「冠军之道」Apparent Personality Analysis竞赛经验分享 - 知乎专栏</a> ，project：<a href="https://link.zhihu.com/?target=http%3A//210.28.132.67/weixs/project/APA/APA.html" target="_blank" rel="noopener">Deep Bimodal Regression for Apparent Personality Analysis</a></li><li>在FC越来越不被看好的当下，<strong>我们近期的研究（<a href="https://link.zhihu.com/?target=https%3A//cs.nju.edu.cn/wujx/paper/PCM2017_FC.pdf" target="_blank" rel="noopener">In Defense of Fully Connected Layers in Visual Representation Transfer</a></strong>）发现，<strong>FC可在模型表示能力迁移过程中充当“防火墙”的作用</strong>。具体来讲，假设在ImageNet上预训练得到的模型为$\mathcal{M}$ ，则ImageNet可视为源域（迁移学习中的source domain）。微调（fine tuning）是深度学习领域最常用的迁移学习技术。针对微调，若目标域（target domain）中的图像与源域中图像差异巨大（如相比ImageNet，目标域图像不是物体为中心的图像，而是风景照，见下图），不含FC的网络微调后的结果要差于含FC的网络。因此FC可视作模型表示能力的“防火墙”，<u>特别是在源域与目标域差异较大的情况下，FC可保持较大的模型capacity从而保证模型表示能力的迁移。（冗余的参数并不一无是处。）</u></li></ul><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/v2-523de4ca9fa2b92d181bbdb81fe7d3f0_hd.jpg" alt></p><p>_<strong>注1</strong>_: 有关卷积操作“实现”全连接层，有必要多啰嗦几句。</p><p>以VGG-16为例，对224x224x3的输入，最后一层卷积可得输出为7x7x512，如后层是一层含4096个神经元的FC，则可用卷积核为7x7x512x4096的全局卷积来实现这一全连接运算过程，其中该卷积核参数如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“filter size = 7, padding = 0, stride = 1, D_in = 512, D_out = 4096”</span><br></pre></td></tr></table></figure><p></p><p>经过此卷积操作后可得输出为1x1x4096。</p><p>如需再次叠加一个2048的FC，则可设定参数为“filter size = 1, padding = 0, stride = 1, D_in = 4096, D_out = 2048”的卷积层操作。</p><h2 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h2><p>dropout是指在深度学习网络的训练过程中，对于神经网络单元，按照一定的概率将其暂时从网络中丢弃。注意是暂时，对于随机梯度下降来说，由于是随机丢弃，故而每一个mini-batch都在训练不同的网络。</p><p>dropout是CNN中防止过拟合提高效果的一个大杀器，但对于其为何有效，却众说纷纭。这里主要有两种看法。</p><h3 id="解释一"><a href="#解释一" class="headerlink" title="解释一"></a>解释一</h3><h4 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h4><p>规模的神经网络有两个缺点：</p><ul><li>费时</li><li>容易过拟合</li></ul><p>过拟合是很多机器学习的通病，过拟合了，得到的模型基本就废了。而为了解决过拟合问题，一般会采用ensemble方法，即训练多个模型做组合，此时，费时就成为一个大问题，不仅训练起来费时，测试起来多个模型也很费时。总之，几乎形成了一个死锁。</p><p>Dropout的出现很好的可以解决这个问题，每次做完dropout，相当于从原始的网络中找到一个更<strong>瘦</strong>的网络，如下图所示：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-1.png" alt></p><p>因而，对于一个有N个节点的神经网络，有了dropout后，就可以<strong>看做是$2^n$个模型的集合了，但此时要训练的参数数目却是不变的</strong>，这就解脱了费时的问题。</p><h4 id="动机论"><a href="#动机论" class="headerlink" title="动机论"></a>动机论</h4><p>虽然直观上看dropout是ensemble在分类性能上的一个近似，然而实际中，dropout毕竟还是在一个神经网络上进行的，只训练出了一套模型参数。那么他到底是因何而有效呢？这就要从动机上进行分析了。论文中作者对dropout的动机做了一个十分精彩的类比：</p><p>在自然界中，在中大型动物中，一般是有性繁殖，有性繁殖是指后代的基因从父母两方各继承一半。但是从直观上看，似乎无性繁殖更加合理，因为无性繁殖可以保留大段大段的优秀基因。而有性繁殖则将基因随机拆了又拆，破坏了大段基因的联合适应性。</p><p>但是自然选择中毕竟没有选择无性繁殖，而选择了有性繁殖，须知物竞天择，适者生存。我们先做一个假设，那就是基因的力量在于混合的能力而非单个基因的能力。不管是有性繁殖还是无性繁殖都得遵循这个假设。为了证明有性繁殖的强大，我们先看一个概率学小知识。</p><p>比如要搞一次恐怖袭击，两种方式：</p><ul><li>集中50人，让这50个人密切精准分工，搞一次大爆破。</li><li>将50人分成10组，每组5人，分头行事，去随便什么地方搞点动作，成功一次就算。</li></ul><p>哪一个成功的概率比较大？ 显然是后者。因为将一个大团队作战变成了游击战。</p><p>那么，类比过来，有性繁殖的方式不仅仅可以将优秀的基因传下来，还可以降低基因之间的联合适应性，使得复杂的大段大段基因联合适应性变成比较小的一个一个小段基因的联合适应性。</p><p>dropout也能达到同样的效果，它<strong>强迫一个神经单元，和随机挑选出来的其他神经单元共同工作，达到好的效果。消除减弱了神经元节点间的联合适应性，增强了泛化能力</strong>。</p><h4 id="dropout带来的模型的变化"><a href="#dropout带来的模型的变化" class="headerlink" title="dropout带来的模型的变化"></a>dropout带来的模型的变化</h4><p>而为了达到ensemble的特性，有了dropout后，神经网络的训练和预测就会发生一些变化。</p><h5 id="训练层面"><a href="#训练层面" class="headerlink" title="训练层面"></a>训练层面</h5><p>无可避免的，训练网络的每个单元要添加一道概率流程。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-5.png" alt></p><ul><li><p>对应的公式变化如下如下：</p><ul><li>没有dropout的神经网络<br><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-3.png" alt></li><li>有dropout的神经网络<br><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-4.png" alt></li></ul></li></ul><h5 id="测试层面"><a href="#测试层面" class="headerlink" title="测试层面"></a>测试层面</h5><p>预测的时候，每一个单元的参数要预乘以p。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/n7-2.png" alt></p><h3 id="解释二"><a href="#解释二" class="headerlink" title="解释二"></a>解释二</h3><h4 id="观点-1"><a href="#观点-1" class="headerlink" title="观点"></a>观点</h4><p>观点十分明确，就是对于每一个dropout后的网络，进行训练时，相当于做了Data Augmentation，因为，总可以找到一个样本，使得在原始的网络上也能达到dropout单元后的效果。 比如，对于某一层，dropout一些单元后，形成的结果是(1.5,0,2.5,0,1,2,0)，其中0是被drop的单元，那么总能找到一个样本，使得结果也是如此。这样，每一次dropout其实都相当于增加了样本。</p><h2 id="Padding层"><a href="#Padding层" class="headerlink" title="Padding层"></a>Padding层</h2><p>在TensorFlow中，这里有两种padding的方式：</p><ul><li>same：即要求输出的特征图尺寸和输入的特征图尺寸相同。引入零填充去填充所需要的维度。</li><li>valid：即没有padding，只利用已有的数据进行卷积，多余的数据扔掉。</li></ul><p>两种padding示意图如图所示：</p><ul><li><p><code>&quot;VALID&quot;</code> =无填充：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputs:         1  2  3  4  5  6  7  8  9  10 11 (12 13)</span><br><span class="line">               |________________|                dropped</span><br><span class="line">                              |_________________|</span><br></pre></td></tr></table></figure></li><li><p><code>&quot;SAME&quot;</code> =带零填充：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            pad|                                      |pad</span><br><span class="line">inputs:      0 |1  2  3  4  5  6  7  8  9  10 11 12 13|0  0</span><br><span class="line">            |________________|</span><br><span class="line">                           |_________________|</span><br><span class="line">                                          |________________|</span><br></pre></td></tr></table></figure></li></ul><p>在这个例子中：</p><ul><li>输入宽度= 13</li><li>卷积核宽度= 6</li><li>步幅= 5</li></ul><blockquote><p>“VALID” 只会删除最右边的列（或最底部的行）。<br>“SAME” 试图左右均匀填充，但如果要添加的列数是奇数，它将在右侧添加额外的列，就像本例中的情况一样（垂直的时候相同的逻辑：可能会有额外的行底部为零）。</p></blockquote><ul><li><p>对于 SAME 填充，输出高度和宽度计算如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height = ceil(float(in_height) / float(strides[1]))</span><br><span class="line">out_width = ceil(float(in_width) / float(strides[2]))</span><br></pre></td></tr></table></figure></li><li><p>对于 VALID 填充，输出高度和宽度计算如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height = ceil(float(in_height - filter_height + 1) / float(strides1))</span><br><span class="line">out_width = ceil(float(in_width - filter_width + 1) / float(strides[2]))</span><br></pre></td></tr></table></figure></li></ul><h2 id="激励层"><a href="#激励层" class="headerlink" title="激励层"></a>激励层</h2><p>激励层由激活函数构成。激励层的主要作用是：假如非线性因素，提高神经网络对模型的表达能力，解决线性模型所不能解决的问题。</p><h3 id="激活函数性质"><a href="#激活函数性质" class="headerlink" title="激活函数性质"></a>激活函数性质</h3><p><strong>激活函数通常有如下一些性质：</strong></p><ul><li><strong>非线性</strong>： 当激活函数是线性的时候，一个两层的神经网络就可以逼近基本上所有的函数了。但是，如果激活函数是恒等激活函数的时候（即$f(x)=x$)就不满足这个性质了，而且如果 MLP 使用的是恒等激活函数，那么其实整个网络跟单层神经网络是等价的。</li><li><strong>可微性</strong>： 当优化方法是基于梯度的时候，这个性质是必须的。</li><li><strong>单调性</strong>： 当激活函数是单调的时候，单层网络能够保证是凸函数。</li><li>$f(x)\approx x$： 当激活函数满足这个性质的时候，如果参数的初始化是random的很小的值，那么神经网络的训练将会很高效；如果不满足这个性质，那么就需要很用心的去设置初始值。</li><li><strong>输出值的范围</strong>： 当激活函数输出值是 <strong>有限</strong> 的时候，基于梯度的优化方法会更加 <strong>稳定</strong>，因为特征的表示受有限权值的影响更显著；当激活函数的输出是 <strong>无限</strong> 的时候，模型的训练会更加高效，不过在这种情况小，一般需要更小的learning rate.</li></ul><blockquote><p>这些性质，也正是我们使用激活函数的原因！</p></blockquote><h3 id="常见激活函数"><a href="#常见激活函数" class="headerlink" title="常见激活函数"></a>常见激活函数</h3><h4 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h4><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20170226222316999.png" alt></p><p>Sigmoid 是常用的非线性的激活函数，它的数学形式如下：</p><script type="math/tex;mode=display">f(x)=\frac{1}{1+e^{-x}}</script><p>正如前一节提到的，它能够把输入的连续实值“压缩”到0和1之间。</p><p>特别的，如果是非常大的负数，那么输出就是0；如果是非常大的正数，输出就是1.</p><p>sigmoid 函数曾经被使用的很多，不过近年来，用它的人越来越少了。主要是因为它的一些 <strong>缺点</strong>：</p><ul><li><strong>Sigmoids saturate and kill gradients.</strong> sigmoid 有一个非常致命的缺点，当输入非常大或者非常小的时候，这些神经元的梯度是接近于0的，从图中可以看出梯度的趋势。所以，你需要尤其注意参数的初始值来尽量避免saturation的情况。如果你的初始值很大的话，大部分神经元可能都会处在saturation的状态而把gradient kill掉，这会导致网络变的很难学习。</li><li><strong>Sigmoid 的 output 不是0均值.</strong> 这是不可取的，因为这会导致后一层的神经元将得到上一层输出的非0均值的信号作为输入。产生的一个结果就是：如果数据进入神经元的时候是正的(e.g. x&gt;0 elementwise in $f=w^T x + b$，那么 w 计算出的梯度也会始终都是正的。</li><li>当然了，如果你是按batch去训练，那么那个batch可能得到不同的信号，所以这个问题还是可以缓解一下的。因此，非0均值这个问题虽然会产生一些不好的影响，不过跟上面提到的 kill gradients 问题相比还是要好很多的。</li></ul><h4 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h4><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/20171015173915008.png" alt></p><p>tanh 见上图中的红线，可以看出，tanh 跟sigmoid还是很像的，实际上，tanh 是sigmoid的变形：</p><script type="math/tex;mode=display">tanh(x)=2sigmoid(2x)-1</script><p>与 sigmoid 不同的是，tanh 是0均值的。因此，实际应用中，tanh 会比 sigmoid 更好（毕竟去粗取精了嘛）。</p><p>它是有界的$(-1, 1)$，所以不用担心激活膨胀。值得一提的是，tanh的梯度比sigmoid更激烈（导数更陡峭）。因此，选择sigmoid还是tanh将取决于你对梯度强度的需求。和sigmoid类似，tanh也存在梯度衰减问题(梯度饱和问题)。</p><p><strong>为了防止饱和，现在主流的做法会在激活函数前多做一步_batch normalization_，尽可能保证每一层网络的输入具有均值较小的、零中心的分布。</strong></p><h4 id="Relu"><a href="#Relu" class="headerlink" title="Relu"></a>Relu</h4><p>它的数学表达式如下：</p><script type="math/tex;mode=display">f(x) = max(0, x)</script><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/v2-8d1b873fa119c01de36f3643f19331b7_hd.jpg" alt></p><p>很显然，从图中可以看出，输入信号 <strong>&lt;0</strong> 时，输出都是0; <strong>&gt;0</strong> 的情况下，输出等于输入。w 是二维的情况下，使用ReLU之后的效果如下：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/15281a0bb762fa8ab2c21555b4036b66_r.jpg" alt></p><p><strong>ReLU 的优点：</strong></p><ul><li><a href="https://link.zhihu.com/?target=http%3A//www.cs.toronto.edu/%7Efritz/absps/imagenet.pdf" target="_blank" rel="noopener">Krizhevsky et al</a>.发现使用 ReLU 得到的SGD的收敛速度会比 sigmoid/tanh 快很多。有人说这是因为它是linear，而且 non-saturating</li><li>相比于 sigmoid/tanh，ReLU 只需要一个阈值就可以得到激活值，而不用去算一大堆复杂的运算。</li><li>激活的稀疏性。想象一个具有很多神经元的大型神经网络。使用sigmoid或tanh会导致几乎所有神经元以模拟的方式激活。这意味着需要处理几乎所有的激活以描述网络的输出。换句话说，激活是密集的。这样成本很高。理想情况下，我们希望网络中的一些神经元不激活，从而使激活变得稀疏和高效。ReLu在这方面很有用。想象一个具备随机初始权重（或归一化的权重）的网络，基于ReLu的特性（x的负值将输出0），基本上50%的网络将生成0。这意味着更少的神经元将被激活（稀疏激活），网络也更轻量。</li><li>RuLu是非线性的。ReLu的组合也是非线性的！（实际上它是一个很好的逼近子。ReLu的组合可以逼近任何函数。）这意味着我们可以堆叠网络层。不过，它并不是有界的。ReLu的值域是$(0, inf)$。这意味着它将膨胀激活函数。</li></ul><p><strong>ReLU 的缺点</strong>：</p><p>ReLu的水平线部分（X的负值）意味着梯度会趋向于0。当激活位于ReLu的水平区域时，梯度会是0，导致权重无法随着梯度而调整。这意味着，陷入此状态的神经元将停止对误差/输入作出反应（很简单，因为梯度是0，没有什么改变）。这被称为死亡ReLu问题。这一问题会导致一些神经元直接死亡、失去响应，导致网络的很大一部分进入被动状态。有一些缓和这一问题的ReLu变体，将水平线转为非水平部分，例如，当x&lt;0时y = 0.01x，使图像从水平线变为略微倾斜的直线。这就是弱修正ReLu（leaky ReLu）。还有其他一些变体。主要的想法是让梯度不为零，这样网络可以逐渐从训练中恢复。</p><blockquote><p>举个例子：一个非常大的梯度流过一个 ReLU 神经元，更新过参数之后，这个神经元再也不会对任何数据有激活现象了。</p></blockquote><h4 id="Leaky-ReLUs"><a href="#Leaky-ReLUs" class="headerlink" title="Leaky ReLUs"></a>Leaky ReLUs</h4><p>解决这个 _<strong>“dying ReLU”</strong>_ 的问题的。与 ReLU 不同的是：</p><script type="math/tex;mode=display">f(x)=\alpha x      (x < 0)</script><script type="math/tex;mode=display">f(x)=x     (x >= 0)</script><p>这里的 $\alpha$$是一个很小的常数。这样，即修正了数据分布，又保留了一些负轴的值，使得负轴信息不会全部丢失。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络模型结构/d30610fa20a28268763fd6355a7e3426_b.jpg" alt></p><h4 id="Maxout"><a href="#Maxout" class="headerlink" title="Maxout"></a>Maxout</h4><p>Maxout 公式如下：</p><script type="math/tex;mode=display">f_i(x)=max_{j\in [1,k]}z_{ij}</script><p>假设 w 是2维，那么有：</p><script type="math/tex;mode=display">f(x)=max(w_1^Tx+b_1,w_2^Tx+b_2)</script><p>可以注意到，ReLU 和 Leaky ReLU 都是它的一个变形（比如，$w_1, b_1 = 0$ 的时候，就是 ReLU）.</p><p>Maxout的拟合能力是非常强的，它可以拟合任意的的凸函数。作者从数学的角度上也证明了这个结论，即只需2个maxout节点就可以拟合任意的凸函数了（相减），前提是”隐隐含层”节点的个数可以任意多。</p><p>所以，Maxout 具有 ReLU 的优点（如：计算简单，不会 saturation），同时又没有 ReLU 的一些缺点 （如：容易 go die）。缺点是：就是把参数double了。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><p>就功能特性而言，卷积神经网络可以提取数据的<strong>多尺度局部特征</strong>，然后将这些<strong>特征组合</strong>起来形成<strong>高维有效特征</strong>。<strong>同时正是因为这种局部特性，导致CNN是无法得到全局特征的，需要很深才能得到较大的感受视野。这也是CNN的比较大的问题，导致在CNN在NLP中并不是很适用。</strong></p><h4 id="多尺度"><a href="#多尺度" class="headerlink" title="多尺度"></a>多尺度</h4><p>在实际场景中，经常含有不同尺度的目标，比如说在图片1中目标的大小为200x200，但是在图片2中目标的大小为100x100，所以需要提取图像的多尺度特征。</p><p>具体多尺度操作可以分为卷积核的多尺度（例如inception网络）和输入数据的多尺度（例如SPPnet、图像金字塔）。</p><h4 id="局部"><a href="#局部" class="headerlink" title="局部"></a>局部</h4><p><strong>Global Feature</strong></p><p>全局特征是指图像的整体属性，常见的全局特征包括颜色特征、纹理特征和形状特征，比如强度直方图等。由于是像素级的低层可视特征，因此，全局特征具有良好的不变性、计算简单、表示直观等特点，但特征维数高、计算量大是其致命弱点。此外，全局特征描述不适用于图像混叠和有遮挡的情况。局部特征则是从图像局部区域中抽取的特征，包括边缘、角点、线、曲线和特别属性的区域等。常见的局部特征包括角点类和区域类两大类描述方式。</p><p><strong>Local Feature</strong></p><p>与线特征、纹理特征、结构特征等全局图像特征相比，局部图像特征具有在图像中<strong>蕴含数量丰富 ，特征间相关度小，遮挡情况</strong>下不会因为部分特征的消失而影响其他特征的检测和匹配等特点。近年来 ，局部图像特征在人脸识别 、三维重建、目标识别及跟踪 、影视制作 、全景图像拼接 等领域得到了广泛的应用。典型的局部图像特征生成应包括图像极值点检测和描述两个阶段。好的局部图像特征应具有特征检测重复率高、速度快 ,特征描述对光照、旋转、视点变化等图像变换具有鲁棒性，特征描述符维度低，易于实现快速匹配等特点</p><h3 id="结构特性"><a href="#结构特性" class="headerlink" title="结构特性"></a>结构特性</h3><p>就卷积神经网络的连接而言，有局部连接、权重共享、多层等特性。</p><p>其中，局部连接和权重共享可以对应功能特性中的<strong>局部特性</strong>。而多层可以对应功能特性中的<strong>特征组合</strong>。</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="防止过拟合"><a href="#防止过拟合" class="headerlink" title="防止过拟合"></a>防止过拟合</h3><ul><li>提前终止（当验证集上的效果变差的时候）</li><li>L1和L2正则化加权</li><li>soft weight sharing</li><li>dropout</li></ul><h2 id="CNN为什么比DNN好"><a href="#CNN为什么比DNN好" class="headerlink" title="CNN为什么比DNN好"></a>CNN为什么比DNN好</h2><p>DNN的输入是向量形式，没有考虑到平面信息，而这部分在图像处理部分特别重要。CNN的输入是Tensor，可以获得局部信息，而且保留了平面结构信息。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_36612847/article/details/80900181" target="_blank" rel="noopener">深度学习两种图像数据预处理具体方法</a><br><a href="https://blog.csdn.net/u011436429/article/details/80279536" target="_blank" rel="noopener">ROI Pooling原理及实现</a><br><a href="https://zhuanlan.zhihu.com/p/42559190" target="_blank" rel="noopener">【DL笔记6】从此明白了卷积神经网络（CNN）</a><br><a href="https://zhuanlan.zhihu.com/p/42080665" target="_blank" rel="noopener">多尺度特征表示在深度学习中的重要意义</a><br><a href="https://blog.csdn.net/Gerwels_JI/article/details/88395587" target="_blank" rel="noopener">【深度学习】什么是局部特征？什么是全局特征</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/" title="卷积神经网络模型结构">https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络模型结构/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/CNN结构/" rel="tag"><i class="fa fa-tag"></i> CNN结构</a></div><div class="post-nav"><div class="post-nav-item"><a href="/MachineLearning/循环神经网络/RNN、LSTM、GRU/" rel="prev" title="RNN、LSTM、GRU"><i class="fa fa-chevron-left"></i> RNN、LSTM、GRU</a></div><div class="post-nav-item"> <a href="/MachineLearning/环境搭建/ubuntu16.04深度学习环境配置/" rel="next" title="ubuntu16.04深度学习环境配置">ubuntu16.04深度学习环境配置<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#卷积"><span class="nav-number">1.</span> <span class="nav-text">卷积</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图像卷积"><span class="nav-number">1.1.</span> <span class="nav-text">图像卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Depth为1的卷积"><span class="nav-number">1.2.</span> <span class="nav-text">Depth为1的卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Depth大于1的卷积"><span class="nav-number">1.3.</span> <span class="nav-text">Depth大于1的卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卷积的类型"><span class="nav-number">1.4.</span> <span class="nav-text">卷积的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反卷积"><span class="nav-number">1.5.</span> <span class="nav-text">反卷积</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#图像的deconvolution"><span class="nav-number">1.5.1.</span> <span class="nav-text">图像的deconvolution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卷积的优势"><span class="nav-number">1.6.</span> <span class="nav-text">卷积的优势</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#局部感知"><span class="nav-number">1.6.1.</span> <span class="nav-text">局部感知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参数共享"><span class="nav-number">1.6.2.</span> <span class="nav-text">参数共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多核"><span class="nav-number">1.6.3.</span> <span class="nav-text">多核</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数计算"><span class="nav-number">1.7.</span> <span class="nav-text">参数计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#池化层"><span class="nav-number">2.</span> <span class="nav-text">池化层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#池化层作用"><span class="nav-number">2.1.</span> <span class="nav-text">池化层作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数计算-1"><span class="nav-number">2.2.</span> <span class="nav-text">参数计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全连接层"><span class="nav-number">3.</span> <span class="nav-text">全连接层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一维"><span class="nav-number">3.1.</span> <span class="nav-text">一维</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二维"><span class="nav-number">3.2.</span> <span class="nav-text">二维</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全连接层的作用"><span class="nav-number">3.3.</span> <span class="nav-text">全连接层的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dropout"><span class="nav-number">4.</span> <span class="nav-text">Dropout</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解释一"><span class="nav-number">4.1.</span> <span class="nav-text">解释一</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#观点"><span class="nav-number">4.1.1.</span> <span class="nav-text">观点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动机论"><span class="nav-number">4.1.2.</span> <span class="nav-text">动机论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dropout带来的模型的变化"><span class="nav-number">4.1.3.</span> <span class="nav-text">dropout带来的模型的变化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#训练层面"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">训练层面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#测试层面"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">测试层面</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解释二"><span class="nav-number">4.2.</span> <span class="nav-text">解释二</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#观点-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">观点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Padding层"><span class="nav-number">5.</span> <span class="nav-text">Padding层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#激励层"><span class="nav-number">6.</span> <span class="nav-text">激励层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#激活函数性质"><span class="nav-number">6.1.</span> <span class="nav-text">激活函数性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见激活函数"><span class="nav-number">6.2.</span> <span class="nav-text">常见激活函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sigmoid"><span class="nav-number">6.2.1.</span> <span class="nav-text">sigmoid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tanh"><span class="nav-number">6.2.2.</span> <span class="nav-text">tanh</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Relu"><span class="nav-number">6.2.3.</span> <span class="nav-text">Relu</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leaky-ReLUs"><span class="nav-number">6.2.4.</span> <span class="nav-text">Leaky ReLUs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Maxout"><span class="nav-number">6.2.5.</span> <span class="nav-text">Maxout</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性"><span class="nav-number">7.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#功能特性"><span class="nav-number">7.1.</span> <span class="nav-text">功能特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多尺度"><span class="nav-number">7.1.1.</span> <span class="nav-text">多尺度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部"><span class="nav-number">7.1.2.</span> <span class="nav-text">局部</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构特性"><span class="nav-number">7.2.</span> <span class="nav-text">结构特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#技巧"><span class="nav-number">8.</span> <span class="nav-text">技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#防止过拟合"><span class="nav-number">8.1.</span> <span class="nav-text">防止过拟合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CNN为什么比DNN好"><span class="nav-number">9.</span> <span class="nav-text">CNN为什么比DNN好</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">10.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">327</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">55</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">382</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2.3m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">35:03</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : 'a3cf4c2648da3d862b7f73c02fcafa5d',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>