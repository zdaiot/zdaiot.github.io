<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="在本文中我们首先对CNN前向传播算法进行总结；接着在基于CNN前向传播算法的基础上，对CNN的反向传播算法做一个总结。在阅读本文前，建议先研究DNN的反向传播算法：这个是一位大佬的博客深度神经网络（DNN）反向传播算法(BP) 回顾CNN的结构在上一篇里，我们已经讲到了CNN的结构，包括输出层，若干的卷积层+ReLU激活函数，若干的池化层，DNN全连接层，以及最后的用Softmax激活函数的输出层"><meta name="keywords" content="CNN,反向传播"><meta property="og:type" content="article"><meta property="og:title" content="卷积神经网络前向与反向传播"><meta property="og:url" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="在本文中我们首先对CNN前向传播算法进行总结；接着在基于CNN前向传播算法的基础上，对CNN的反向传播算法做一个总结。在阅读本文前，建议先研究DNN的反向传播算法：这个是一位大佬的博客深度神经网络（DNN）反向传播算法(BP) 回顾CNN的结构在上一篇里，我们已经讲到了CNN的结构，包括输出层，若干的卷积层+ReLU激活函数，若干的池化层，DNN全连接层，以及最后的用Softmax激活函数的输出层"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/1042406-20170302112126673-1167058801.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/pooling1543843399003.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/convolution-mlp-mapping.png"><meta property="og:updated_time" content="2019-09-12T11:15:24.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="卷积神经网络前向与反向传播"><meta name="twitter:description" content="在本文中我们首先对CNN前向传播算法进行总结；接着在基于CNN前向传播算法的基础上，对CNN的反向传播算法做一个总结。在阅读本文前，建议先研究DNN的反向传播算法：这个是一位大佬的博客深度神经网络（DNN）反向传播算法(BP) 回顾CNN的结构在上一篇里，我们已经讲到了CNN的结构，包括输出层，若干的卷积层+ReLU激活函数，若干的池化层，DNN全连接层，以及最后的用Softmax激活函数的输出层"><meta name="twitter:image" content="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/1042406-20170302112126673-1167058801.jpg"><link rel="canonical" href="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>卷积神经网络前向与反向传播 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 卷积神经网络前向与反向传播<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-11-24 23:20:38" itemprop="dateCreated datePublished" datetime="2018-11-24T23:20:38+08:00">2018-11-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-09-12 19:15:24" itemprop="dateModified" datetime="2019-09-12T19:15:24+08:00">2019-09-12</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/卷积神经网络/" itemprop="url" rel="index"><span itemprop="name">卷积神经网络</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>17k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>15 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>在本文中我们首先对CNN前向传播算法进行总结；接着在基于CNN前向传播算法的基础上，对CNN的反向传播算法做一个总结。在阅读本文前，建议先研究DNN的反向传播算法：这个是一位大佬的博客<a href="http://www.cnblogs.com/pinard/p/6422831.html" target="_blank" rel="noopener">深度神经网络（DNN）反向传播算法(BP)</a></p><h2 id="回顾CNN的结构"><a href="#回顾CNN的结构" class="headerlink" title="回顾CNN的结构"></a>回顾CNN的结构</h2><p>在上一篇里，我们已经讲到了CNN的结构，包括输出层，若干的卷积层+ReLU激活函数，若干的池化层，DNN全连接层，以及最后的用Softmax激活函数的输出层。这里我们用一个彩色的汽车样本的图像识别再从感官上回顾下CNN的结构。图中的CONV即为卷积层，POOL即为池化层，而FC即为DNN全连接层(不管是Pytorch还是TensorFlow全连接层前面必须加上flatten层，变成一维向量)，包括了我们上面最后的<strong>用Softmax激活函数</strong>的输出层。</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/1042406-20170302112126673-1167058801.jpg" alt></p><p>从上图可以看出，要理顺CNN的前向传播算法，重点是输入层的前向传播，卷积层的前向传播以及池化层的前向传播。而DNN全连接层和用Softmax激活函数的输出层的前向传播算法我们在讲DNN时已经讲到了。</p><h2 id="CNN输入层前向传播到卷积层"><a href="#CNN输入层前向传播到卷积层" class="headerlink" title="CNN输入层前向传播到卷积层"></a>CNN输入层前向传播到卷积层</h2><p>输入层的前向传播是CNN前向传播算法的第一步。一般输入层对应的都是卷积层，因此我们标题是输入层前向传播到卷积层。</p><p>我们这里还是以图像识别为例。</p><p>先考虑最简单的，样本都是二维的黑白图片。这样输入层$X$就是一个矩阵，矩阵的值等于图片的各个像素位置的值。这时和卷积层相连的卷积核$W$就也是矩阵。</p><p>如果样本都是有RGB的彩色图片，这样输入$X$就是3个矩阵，即分别对应R，G和B的矩阵，或者说是一个<strong>张量</strong>。这时和卷积层相连的卷积核$W$就也是张量，对应的最后一维的维度为3.即<strong>每个卷积核都是3个子矩阵组成</strong>。</p><p>同样的方法，对于3D的彩色图片之类的样本，我们的输入$X$可以是4维，5维的张量，那么对应的卷积核$W$也是个高维的张量。</p><p>不管维度多高，对于我们的输入，前向传播的过程可以表示为：</p><script type="math/tex;mode=display">\begin{eqnarray} a^2= \sigma(z^2) = \sigma(a^1*W^2 +b^2) \end{eqnarray}</script><p>其中，上标代表层数，星号代表卷积，而$b$代表我们的偏置, $σ$为激活函数，这里一般都是ReLU。</p><p>和DNN的前向传播比较一下，其实形式非常的像，只是我们这儿是<strong>张量的卷积，而不是矩阵的乘法</strong>。同时由于$W$是张量，那么同样的位置，$W$参数的个数就比DNN多很多了。</p><p>为了简化我们的描述，本文后面如果没有特殊说明，我们都默认输入是3维的张量，即用RBG可以表示的彩色图片。</p><p>这里需要我们自己定义的CNN模型参数是：</p><p>1） 一般我们的卷积核不止一个，比如有$K$个，那么我们输入层的输出，或者说第二层卷积层的对应的输入就$K$个。</p><p>2） 卷积核中每个子矩阵的的大小，一般我们都用子矩阵作为方阵的卷积核，比如$F\times F$的子矩阵。</p><p>3） 填充padding（以下简称$P$），我们卷积的时候，<strong>为了可以更好的识别边缘</strong>，一般都会在输入矩阵在周围加上若干圈的0再进行卷积，加多少圈则$P$为多少。</p><p>4） 步幅stride（以下简称$S$），即在卷积过程中每次移动的像素距离大小。</p><p>这些参数我们在上一篇都有讲述。</p><h2 id="隐藏层前向传播到卷积层"><a href="#隐藏层前向传播到卷积层" class="headerlink" title="隐藏层前向传播到卷积层"></a>隐藏层前向传播到卷积层</h2><p>现在我们再来看普通隐藏层前向传播到卷积层时的前向传播算法。</p><p>假设隐藏层的输出是$M$个矩阵对应的三维张量，则输出到卷积层的卷积核也是$M$个子矩阵对应的三维张量。这时表达式和输入层的很像，也是</p><script type="math/tex;mode=display">\begin{eqnarray} a^l= \sigma(z^l) = \sigma(a^{l-1}*W^l +b^l) \end{eqnarray}</script><p>其中，上标代表层数，星号代表卷积，而$b$代表我们的偏倚, $σ$为激活函数，这里一般都是ReLU。</p><p>也可以写成M个子矩阵子矩阵卷积后对应位置相加的形式，即：</p><script type="math/tex;mode=display">a^l= \sigma(z^l) = \sigma(\sum\limits_{k=1}^{M}z_k^l) = \sigma(\sum\limits_{k=1}^{M}a_k^{l-1}*W_k^l +b^l)</script><p>和上一节唯一的区别仅仅在于，这里的输入是隐藏层来的，而不是我们输入的原始图片样本形成的矩阵。</p><p>需要我们定义的CNN模型参数也和上一节一样，这里我们需要定义卷积核的个数$K$，卷积核子矩阵的维度$F$，填充大小$P$以及步幅$S$。</p><h2 id="隐藏层前向传播到池化层"><a href="#隐藏层前向传播到池化层" class="headerlink" title="隐藏层前向传播到池化层"></a>隐藏层前向传播到池化层</h2><p>池化层的处理逻辑是比较简单的，我们的目的就是对输入的矩阵进行缩小概括。比如输入的若干矩阵是$N \times N$维的，而我们的池化大小是$k \times k$的区域，则输出的矩阵都是$\frac{N}{k} \times \frac{N}{k}$维的。</p><p>这里需要需要我们定义的CNN模型参数是：</p><p>1）池化区域的大小$k$</p><p>2）池化的标准，一般是MAX或者Average。</p><h2 id="隐藏层前向传播到全连接层"><a href="#隐藏层前向传播到全连接层" class="headerlink" title="隐藏层前向传播到全连接层"></a>隐藏层前向传播到全连接层</h2><p>由于全连接层就是普通的DNN模型结构，因此我们可以直接使用DNN的前向传播算法逻辑，即：<script type="math/tex">a^l = \sigma(z^l) = \sigma(W^la^{l-1} + b^l)</script></p><p>这里的激活函数一般是sigmoid或者tanh。</p><p>经过了若干全连接层之后，最后的一层为Softmax输出层。此时输出层和普通的全连接层唯一的区别是，激活函数是softmax函数。</p><p>这里需要需要我们定义的CNN模型参数是：</p><p>1）全连接层的激活函数</p><p>2）全连接层各层神经元的个数</p><h2 id="CNN前向传播算法小结"><a href="#CNN前向传播算法小结" class="headerlink" title="CNN前向传播算法小结"></a>CNN前向传播算法小结</h2><p>有了上面的基础，我们现在总结下CNN的前向传播算法。</p><p>输入：1个图片样本，CNN模型的层数L和所有隐藏层的类型，对于卷积层，要定义卷积核的大小$K$，卷积核子矩阵的维度$F$，填充大小$P$，步幅$S$。对于池化层，要定义池化区域大小$k$和池化标准（MAX或Average），对于全连接层，要定义全连接层的激活函数（输出层除外）和各层的神经元个数。</p><p>输出：CNN模型的输出$a^L$</p><p>1) 根据输入层的填充大小P，填充原始图片的边缘，得到输入张量$a^1$。</p><p>2）初始化所有隐藏层的参数$W,b$</p><p>3）for $l$=2 to $L-1$:</p><p>　　a) 如果第$l$层是卷积层,则输出为<script type="math/tex">a^l= ReLU(z^l) = ReLU(a^{l-1}*W^l +b^l)</script>　　</p><p>　　b) 如果第$l$层是池化层,则输出为$ a^l= pool(a^{l-1})$, 这里的pool指按照池化区域大小$k$和池化标准将输入张量缩小的过程。</p><p>　　c) 如果第$l$层是全连接层,则输出为<script type="math/tex">a^l= \sigma(z^l) = \sigma(W^la^{l-1} +b^l)</script></p><p>4)对于输出层第L层:<script type="math/tex">a^L= softmax(z^L) = softmax(W^La^{L-1} +b^L)</script></p><p>以上就是CNN前向传播算法的过程总结。有了CNN前向传播算法的基础，我们后面再来理解CNN的反向传播算法就简单多了。</p><h2 id="回顾DNN的反向传播算法"><a href="#回顾DNN的反向传播算法" class="headerlink" title="回顾DNN的反向传播算法"></a>回顾DNN的反向传播算法</h2><p>我们首先回顾DNN的反向传播算法。在DNN中，我们是首先计算出输出层的$\delta^L$:</p><script type="math/tex;mode=display">\delta^L =
\frac{\partial J(W,b)}{\partial z^L} = \frac{\partial J(W,b)}{\partial
a^L}\odot \sigma^{'}(z^L)</script><p>利用数学归纳法，用$\delta^{l+1}$的值一步步的向前求出第l层的$\delta^l$，表达式为：</p><script type="math/tex;mode=display">\delta^{l} =
\delta^{l+1}\frac{\partial z^{l+1}}{\partial z^{l}} =
(W^{l+1})^T\delta^{l+1}\odot \sigma^{'}(z^l)</script><p>有了$\delta^l$的表达式，从而求出$W,b$的梯度表达式：</p><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial W^l} =
\frac{\partial J(W,b,x,y)}{\partial z^l} \frac{\partial z^l}{\partial W^l} =
\delta^{l}(a^{l-1})^T</script><script type="math/tex;mode=display">\frac{\partial J(W,b,x,y)}{\partial b^l} =
\frac{\partial J(W,b)}{\partial z^l} \frac{\partial z^l}{\partial b^l} =
\delta^{l}</script><p>有了$W,b$梯度表达式，就可以用梯度下降法来优化$W,b$,求出最终的所有$W,b$的值。</p><p>现在我们想把同样的思想用到CNN中，很明显，CNN有些不同的地方，不能直接去套用DNN的反向传播算法的公式。</p><h2 id="CNN的反向传播算法思想"><a href="#CNN的反向传播算法思想" class="headerlink" title="CNN的反向传播算法思想"></a>CNN的反向传播算法思想</h2><p>要套用DNN的反向传播算法到CNN，有几个问题需要解决：</p><p>1）池化层没有激活函数，这个问题倒比较好解决，我们可以令池化层的激活函数为$\sigma(z) =<br>z$，即激活后就是自己本身。这样池化层激活函数的导数为1.</p><p>2）池化层在前向传播的时候，对输入进行了压缩，那么我们现在需要向前反向推导$\delta^{l-1}$，这个推导方法和DNN完全不同。</p><p>3) 卷积层是通过张量卷积，或者说若干个矩阵卷积求和而得的当前层的输出，这和DNN很不相同，DNN的全连接层是直接进行矩阵乘法得到当前层的输出。这样在卷积层反向传播的时候，上一层的$\delta^{l-1}$递推计算方法肯定有所不同。</p><p>4）对于卷积层，由于$W$使用的运算是卷积，那么从$\delta^l$推导出该层的所有卷积核的$W,b$的方式也不同。</p><p>从上面可以看出，问题1比较好解决，但是问题2,3,4就需要好好的动一番脑筋了，而问题2,3,4也是解决CNN反向传播算法的关键所在。另外大家要注意到的是，DNN中的$a_l,z_l$都只是一个向量，而我们CNN中的$a_l,z_l$都是一个张量，这个张量是三维的，即由若干个输入的子矩阵组成。</p><p>下面我们就针对问题2,3,4来一步步研究CNN的反向传播算法。</p><p>在研究过程中，需要注意的是，由于卷积层可以有多个卷积核，各个卷积核的处理方法是完全相同且独立的，为了简化算法公式的复杂度，我们<strong>下面提到卷积核都是卷积层中若干卷积核中的一个</strong>。</p><p>下文中的符号表：</p><ul><li>$\delta_l$：损失函数$J(W,b,x,y)$对于$z^l$的偏导数</li><li>$z^l$：第$l$层没经过激活函数的输出</li><li>$a^l$：第$l$层经过激活函数后的输出</li></ul><h2 id="已知池化层的-delta-l-，推导上一隐藏层的-delta-l-1"><a href="#已知池化层的-delta-l-，推导上一隐藏层的-delta-l-1" class="headerlink" title="已知池化层的$\delta^l$，推导上一隐藏层的$\delta^{l-1}$"></a>已知池化层的$\delta^l$，推导上一隐藏层的$\delta^{l-1}$</h2><p>我们首先解决上面的问题2，如果已知池化层的$\delta^l$，推导出上一隐藏层的$\delta^{l-1}$。</p><p>我们先把 pooling 层也放回网络连接的形式中：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/pooling1543843399003.png" alt></p><p>红色神经元是前一层的响应结果，一般是卷积后再用激活函数处理。绿色的神经元表示池化层。很明显，池化层主要是起到降维的作用，一般我们会用MAX或者Average对输入进行池化，池化的区域大小已知；而且，由于<strong>池化层没有参数$W$和$b$需要学习，也不存在步长的概念</strong>，因此，当得到池化层的误差项$\delta^l$后，我们只需要直接计算上一层的误差项 $\delta^{l-1}$ 即可。要注意的一点是，由于池化一般会降维，因此传回去的误差矩阵要调整维度，即要从缩小后的误差$\delta^l$，还原前一次较大区域对应的误差，我们称这个操作为即 $upsample$。这样，误差传播的公式原型大概是：</p><script type="math/tex;mode=display">\delta^{l-1}=upsample(\delta^l) \odot \sigma'(z^{l-1})</script><p>其中，$\delta^{l-1}$、$\delta^l$与$z^{l-1}$可以是张量，不一定是向量。</p><p>$upsample$操作也就是在反向传播时，我们首先会把$\delta^l$的所有子矩阵矩阵大小还原成池化之前的大小，然后如果是MAX，则把$\delta^l$的所有子矩阵的各个池化局域的值放在之前做前向传播算法得到最大值的位置。如果是Average，则把$\delta^l$的所有子矩阵的各个池化局域的值取平均后放在还原后的子矩阵位置。这个过程一般叫做<strong>upsample</strong>。</p><p>用一个例子可以很方便的表示：假设我们的池化区域大小是2x2。$\delta^l$的第k个子矩阵为:<script type="math/tex">\delta_k^l = \left( \begin{array}{ccc} 2& 8 \\ 4& 6 \end{array} \right)</script></p><p>由于池化区域为2x2，我们先将$\delta_k^l$的还原到上一层的维度：，即变成：</p><script type="math/tex;mode=display">\left( \begin{array}{ccc} 0&0&0&0 \\0&2& 8&0 \\ 0&4&6&0 \\ 0&0&0&0 \end{array} \right)</script><p>如果是MAX，则是经过一个$max()$函数，对应的导数为：</p><script type="math/tex;mode=display">\frac{\partial \max(x)}{\partial x_k}=\begin{cases} 1 & if\ x_k=max(x) \\ 0 & otherwise \end{cases}</script><p>假设我们之前在前向传播时记录的最大值位置分别是左上，右下，右上，左下，则转换后的矩阵为：</p><script type="math/tex;mode=display">\left( \begin{array}{ccc} 2&0&0&0 \\ 0&0& 0&8 \\ 0&4&0&0 \\ 0&0&6&0 \end{array} \right)</script><p>如果是Average，我们是把一个范围内的响应值取平均后，作为一个 pooling unit 的结果。可以认为是经过一个$average()$函数，即 $average(x)=\frac{1}{m}\sum_{k=1}^m x_k$。在本例中，$m=4$。则对每个 $x_k$ 的导数均为：</p><script type="math/tex;mode=display">\frac{\partial average(x)}{\partial x_k}=\frac{1}{m}</script><p>转换后的矩阵为：</p><script type="math/tex;mode=display">\left( \begin{array}{ccc} 0.5&0.5&2&2 \\ 0.5&0.5&2&2 \\ 1&1&1.5&1.5 \\ 1&1&1.5&1.5 \end{array} \right)</script><p>这样我们就得到了上一层 $\frac{\partial J(W,b)}{\partial a_k^{l-1}}$的值，要得到$\delta_k^{l-1}$：</p><script type="math/tex;mode=display">\delta_k^{l-1} = \frac{\partial J(W,b)}{\partial
a_k^{l-1}} \frac{\partial a_k^{l-1}}{\partial z_k^{l-1}} =
upsample(\delta_k^l) \odot \sigma^{'}(z_k^{l-1})</script><p>其中，upsample函数完成了池化误差矩阵放大与误差重新分配的逻辑。</p><p>我们概括下，对于张量$\delta^{l-1}$，我们有：</p><script type="math/tex;mode=display">\delta^{l-1} = upsample(\delta^l) \odot \sigma^{'}(z^{l-1})</script><h2 id="已知卷积层的-delta-l-，推导上一隐藏层的-delta-l-1"><a href="#已知卷积层的-delta-l-，推导上一隐藏层的-delta-l-1" class="headerlink" title="已知卷积层的$\delta^l$，推导上一隐藏层的$\delta^{l-1}$"></a>已知卷积层的$\delta^l$，推导上一隐藏层的$\delta^{l-1}$</h2><p>对于卷积层的反向传播，我们首先回忆下卷积层的前向传播公式：</p><script type="math/tex;mode=display">a^l= \sigma(z^l) = \sigma(a^{l-1}*W^l +b^l)</script><p>其中$n_{in}$为上一隐藏层的输入子矩阵个数。</p><p>在DNN中，我们知道$\delta^{l-1}$和$\delta^{l}$的递推关系为：</p><script type="math/tex;mode=display">\delta^{l} = \frac{\partial
J(W,b)}{\partial z^l} = \frac{\partial J(W,b)}{\partial z^{l+1}}\frac{\partial
z^{l+1}}{\partial z^{l}} = \delta^{l+1}\frac{\partial z^{l+1}}{\partial
z^{l}}</script><p>因此要推导出$\delta^{l-1}$和$\delta^{l}$的递推关系，必须计算$\frac{\partial z^{l}}{\partial z^{l-1}}$的梯度表达式。 注意到$z^{l}$和$z^{l-1}$的关系为：</p><script type="math/tex;mode=display">z^l = a^{l-1}*W^l +b^l =\sigma(z^{l-1})*W^l +b^l</script><p>因此我们有：</p><script type="math/tex;mode=display">\delta^{l-1} =
\delta^{l}\frac{\partial z^{l}}{\partial z^{l-1}} = \delta^{l}*rot180(W^{l})
\odot \sigma^{'}(z^{l-1})</script><p>这里的式子其实和DNN的类似，区别在于对于含有卷积的式子求导时，卷积核被旋转了180度。即式子中的$rot180()$，翻转180度的意思是上下翻转一次，接着左右翻转一次。在DNN中这里只是矩阵的转置。那么为什么呢？由于这里都是张量，直接推演参数太多了。我们以一个简单的例子说明为啥这里求导后卷积核要翻转。</p><p>假设我们$l-1$层的输出$a^{l-1}$是一个3x3矩阵，第$l$层的卷积核$W^l$是一个2x2矩阵，采用1像素的步幅，则输出$z^{l}$是一个2x2的矩阵。我们简化$b^l$都是0,则有</p><script type="math/tex;mode=display">a^{l-1}*W^l = z^{l}</script><p>我们列出$a,W,z$的矩阵表达式如下：</p><script type="math/tex;mode=display">\left( \begin{array}{ccc}
a_{11}&a_{12}&a_{13} \\ a_{21}&a_{22}&a_{23}\\
a_{31}&a_{32}&a_{33} \end{array} \right) * \left( \begin{array}{ccc}
w_{11}&w_{12}\\ w_{21}&w_{22} \end{array} \right) = \left(
\begin{array}{ccc} z_{11}&z_{12}\\ z_{21}&z_{22} \end{array} \right)</script><p>利用卷积的定义，很容易得出：</p><script type="math/tex;mode=display">z_{11} = a_{11}w_{11} + a_{12}w_{12} + a_{21}w_{21} + a_{22}w_{22}</script><script type="math/tex;mode=display">z_{12} = a_{12}w_{11} + a_{13}w_{12} + a_{22}w_{21} + a_{23}w_{22}</script><script type="math/tex;mode=display">z_{21} = a_{21}w_{11} + a_{22}w_{12} + a_{31}w_{21} + a_{32}w_{22}</script><script type="math/tex;mode=display">z_{22} = a_{22}w_{11} + a_{23}w_{12} + a_{32}w_{21} + a_{33}w_{22}</script><p>更进一步，我们还可以把上面的等式表示成下图：</p><p><img src="/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/convolution-mlp-mapping.png" alt></p><p>上图的网络结构中，左边青色的神经元表示 $a_{11}$ 到 $a_{33}$，中间橙色的表示 $z_{11}$ 到 $z_{22}$。需要注意的是，青色和橙色神经元之间的权值连接用了不同的颜色标出，紫色线表示 $w_{11}$，蓝色线表示 $w_{12}$，依此类推。这样一来，如果你熟悉 BP 链式法则的套路的话，你可能已经懂了卷积层的 BP 是怎么操作的了。因为卷积层其实就是一种特殊的连接层，它是部分连接的，而且参数也是共享的。</p><p>接着我们模拟反向求导：</p><script type="math/tex;mode=display">\nabla a^{l-1} = \frac{\partial J(W,b)}{\partial a^{l-1}} = \frac{\partial J(W,b)}{\partial z^{l}} \frac{\partial z^{l}}{\partial a^{l-1}} = \delta^{l} \frac{\partial z^{l}}{\partial a^{l-1}}</script><p>从上式可以看出，损失函数$J$关于$a^{l-1}$的梯度误差$\nabla a^{l-1}$，等于第$l$层的梯度误差乘以$\frac{\partial z^{l}}{\partial a^{l-1}}$，而$\frac{\partial z^{l}}{\partial a^{l-1}}$对应上面的例子中相关联的$w$的值。假设我们的$z$矩阵对应的反向传播误差是$\delta_{11}, \delta_{12}, \delta_{21}, \delta_{22}$组成的2x2矩阵，则利用上面梯度的式子和4个等式，我们可以分别写出$\nabla a^{l-1}$的9个标量的梯度。 比如对于$a_{11}$的梯度，由于在4个等式中$a_{11}$只和$z_{11}$有乘积关系，从而我们有：</p><script type="math/tex;mode=display">\begin{align}
\nabla a_{11} = & \frac{\partial J}{\partial z_{11}} \frac{\partial z_{11}}{\partial a_{11}}+  \frac{\partial J}{\partial z_{12}}\frac{\partial z_{12}}{\partial a_{11}}+ \frac{\partial J}{\partial z_{21}}\frac{\partial z_{21}}{\partial a_{11}} + \frac{\partial J}{\partial z_{22}}\frac{\partial z_{22}}{\partial a_{11}} \notag
=\delta_{11}w_{11} \notag \end{align}</script><p>对于$a_{12}$的梯度，由于在4个等式中$a_{12}$和$z_{12}，z_{11}$有乘积关系，从而我们有：</p><script type="math/tex;mode=display">\begin{align}
\nabla a_{12} =& \frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial a_{12}} + \frac{\partial J}{\partial z_{12}}\frac{\partial z_{12}}{\partial a_{12}} + \frac{\partial J}{\partial z_{21}}\frac{\partial z_{21}}{\partial a_{12}} + \frac{\partial J}{\partial z_{22}}\frac{\partial z_{22}}{\partial a_{12}} \notag 
=\delta_{11}w_{12} + \delta_{12}w_{11} \notag
\end{align}</script><p>同样的道理我们得到：</p><script type="math/tex;mode=display">\nabla a_{13} = \delta_{12}w_{12}</script><script type="math/tex;mode=display">\nabla a_{21} = \delta_{11}w_{21} + \delta_{21}w_{11}</script><script type="math/tex;mode=display">\nabla a_{22} = \delta_{11}w_{22} + \delta_{12}w_{21} + \delta_{21}w_{12} + \delta_{22}w_{11}</script><script type="math/tex;mode=display">\nabla a_{23} = \delta_{12}w_{22} + \delta_{22}w_{12}</script><script type="math/tex;mode=display">\nabla a_{31} = \delta_{21}w_{21}</script><script type="math/tex;mode=display">\nabla a_{32} = \delta_{21}w_{22} + \delta_{22}w_{21}</script><script type="math/tex;mode=display">\nabla a_{33} = \delta_{22}w_{22}</script><p>这上面9个式子其实可以用一个矩阵卷积的形式表示，即：</p><script type="math/tex;mode=display">\left( \begin{array}{ccc} 0&0&0&0 \\
0&\delta_{11}& \delta_{12}&0 \\ 0&\delta_{21}&\delta_{22}&0 \\ 0&0&0&0
\end{array} \right) * \left( \begin{array}{ccc} w_{22}&w_{21}\\
w_{12}&w_{11} \end{array} \right) = \left( \begin{array}{ccc} \nabla
a_{11}&\nabla a_{12}&\nabla a_{13} \\ \nabla a_{21}&\nabla a_{22}&\nabla
a_{23}\\ \nabla a_{31}&\nabla a_{32}&\nabla a_{33} \end{array} \right)</script><p>为了符合梯度计算，我们在误差矩阵周围填充了一圈0，此时我们将卷积核翻转后和反向传播的梯度误差进行卷积，就得到了前一次的梯度误差。这个例子直观的介绍了为什么对含有卷积的式子反向传播时，卷积核要翻转180度的原因。</p><p>将上式写成矩阵的形式如下：</p><script type="math/tex;mode=display">\frac{\partial J}{\partial a^{l-1}} = \delta^l * rot180(W^l)</script><p>又因为</p><script type="math/tex;mode=display">\delta^{l-1} =  \frac{\partial J}{\partial z^l}\frac{\partial z^l}{\partial z^{l-1}} = \frac{\partial J}{\partial z^l} \frac{\partial z^l}{\partial a^{l-1}} \frac{\partial a^{l-1}}{\partial z^{l-1}} = \frac{\partial J}{\partial a^{l-1}}\frac{\partial a^{l-1}}{\partial z^{l-1}} = \delta^l * rot180(W^l)\odot \sigma^{'}(z^{l-1})</script><p>最后一项之所以使用$\odot$，证明如下，将$\frac{\partial J}{\partial a^{l-1}}\frac{\partial a^{l-1}}{\partial z^{l-1}} $写成离散形式。</p><script type="math/tex;mode=display">\frac{\partial J}{\partial a^{l-1}}\frac{\partial a^{l-1}}{\partial z^{l-1}} = \frac{\partial J}{\partial a_{ij}^{l-1}}\frac{\partial a_{ij}^{l-1}}{\partial z_{ij}^{l-1}}</script><p>从上式可以看出，$\frac{\partial J}{\partial a^{l-1}}$与$\frac{\partial a^{l-1}}{\partial z^{l-1}}$是对应元素相乘的形式。所以得证。</p><p>以上就是卷积层的误差反向传播过程。</p><h2 id="已知卷积层的-delta-l-，推导该层的-W-b-的梯度"><a href="#已知卷积层的-delta-l-，推导该层的-W-b-的梯度" class="headerlink" title="已知卷积层的$\delta^l$，推导该层的$W,b$的梯度"></a>已知卷积层的$\delta^l$，推导该层的$W,b$的梯度</h2><p>好了，我们现在已经可以递推出每一层的梯度误差$\delta^l$了，对于全连接层，可以按DNN的反向传播算法求该层$W,b$的梯度，而池化层并没有$W,b$,也不用求$W,b$的梯度。只有卷积层的$W,b$需要求出。</p><p>注意到卷积层$z$和$W,b$的关系为：</p><script type="math/tex;mode=display">z^l = a^{l-1}*W^l +b</script><p>因此我们有：</p><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial W^{l}} = \frac{\partial J(W,b)}{\partial z^{l}}\frac{\partial z^{l}}{\partial W^{l}} =a^{l-1} *\delta^l</script><p>注意到此时卷积核并没有反转，主要是此时是层内的求导，而不是反向传播到上一层的求导。具体过程我们可以分析一下。</p><p>和上小节一样的一个简化的例子，这里输入是矩阵，不是张量，那么对于第l层，某个个卷积核矩阵W的导数可以表示如下：</p><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial W_{pq}^{l}}  = \sum\limits_i\sum\limits_j(\delta_{ij}^la_{i+p-1,j+q-1}^{l-1})</script><p>上式的证明如下：</p><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial W_{pq}^{l}} = \sum\limits_i\sum\limits_j( \frac{\partial J(W,b)}{\partial z_{ij}^l} \times \frac{\partial z_{ij}^l}{\partial W_{pq}^l}) =\sum\limits_i\sum\limits_j (\delta_{ij}^l\times \frac{\partial z_{ij}^l}{\partial W_{pq}^l})</script><p>又因为：</p><script type="math/tex;mode=display">z_{ij}^l = \sum W_{pq}^l \times a_{i+p-1,j+q-1}^{l-1}</script><p>由于在$\frac{\partial J(W,b)}{\partial W_{pq}^{l}} $中可以<strong>将$p,q$视为常数</strong>，求$\frac{\partial z_{ij}^l}{\partial W_{pq}^l}$偏导的时候，$z_{ij}^l$中只有$ W_{pq}^l$项与之相关，所以在这种情况下，可以得到下式：</p><script type="math/tex;mode=display">\frac{\partial z_{ij}^l}{\partial W_{pq}^l} = a_{i+p-1,j+q-1}^{l-1}</script><p>假设我们输入$a$是4x4的矩阵，卷积核$W$是3x3的矩阵，输出$z$是2x2的矩阵,那么反向传播的$z$的梯度误差$\delta$也是2x2的矩阵。</p><p>那么根据上面的式子，我们有：</p><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial W_{11}^{l}} = \frac{\partial J}{\partial z_{11}} \frac{\partial z_{11}}{\partial W_{11}}+  \frac{\partial J}{\partial z_{12}}\frac{\partial z_{12}}{\partial W_{11}}+ \frac{\partial J}{\partial z_{21}}\frac{\partial z_{21}}{\partial W_{11}} + \frac{\partial J}{\partial z_{22}}\frac{\partial z_{22}}{\partial W_{11}} = a_{11}\delta_{11} + a_{12}\delta_{12} + a_{21}\delta_{21} +
a_{22}\delta_{22}</script><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial W_{12}^{l}} = \frac{\partial J}{\partial z_{11}} \frac{\partial z_{11}}{\partial W_{12}}+  \frac{\partial J}{\partial z_{12}}\frac{\partial z_{12}}{\partial W_{12}}+ \frac{\partial J}{\partial z_{21}}\frac{\partial z_{21}}{\partial W_{12}} + \frac{\partial J}{\partial z_{22}}\frac{\partial z_{22}}{\partial W_{12}} = a_{12}\delta_{11} + a_{13}\delta_{12} + a_{22}\delta_{21} +
a_{23}\delta_{22}</script><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial W_{13}^{l}} = a_{13}\delta_{11} + a_{14}\delta_{12} + a_{23}\delta_{21} +
a_{24}\delta_{22}</script><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial W_{21}^{l}} = a_{21}\delta_{11} + a_{22}\delta_{12} + a_{31}\delta_{21} +
a_{32}\delta_{22}</script><p>最终我们可以一共得到9个式子。整理成矩阵形式后可得：</p><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial W^{l}} =\left( \begin{array}{ccc} a_{11}&a_{12}&a_{13}&a_{14} \\ a_{21}&a_{22}&a_{23}&a_{24} \\ a_{31}&a_{32}&a_{33}&a_{34} \\ a_{41}&a_{42}&a_{43}&a_{44}
\end{array} \right) * \left( \begin{array}{ccc} \delta_{11}& \delta_{12} \\
\delta_{21}&\delta_{22} \end{array} \right) =a^{l-1} *\delta^l</script><p>从而可以清楚的看到这次我们为什么没有反转的原因。</p><p>而对于b,则稍微有些特殊，因为$\delta^l$是三维张量，而$b$只是一个向量，不能像DNN那样直接和$\delta^l$相等。通常的做法是将$\delta^l$的<strong>各个子矩阵的项分别求和</strong>(子矩阵即一个特征图)，得到一个误差向量，即为$b$的梯度：</p><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial b^{l}} = \sum\limits_{i,j}(\delta^l)_{i,j}</script><p>证明过程如下，因为对于CNN而言，输入特征经过一个卷积核输出一个特征图，每一个特征图对应一个偏置，而一个batch之内的相同位置特征图的偏置是同一个偏置。因此对于上面简单例子，如果加上偏置的话，最终得到的式子如下：</p><p>假设我们$l-1$层的输出$a^{l-1}$是一个3x3矩阵，第$l$层的卷积核$W^l$是一个2x2矩阵，采用1像素的步幅，则输出$z^{l}$是一个2x2的矩阵。此时$b^l$是一个标量,则有</p><script type="math/tex;mode=display">a^{l-1}*W^l + b^l= z^{l}</script><p>我们列出$a,W,z$的矩阵表达式如下：</p><script type="math/tex;mode=display">\left( \begin{array}{ccc}
a_{11}&a_{12}&a_{13} \\ a_{21}&a_{22}&a_{23}\\
a_{31}&a_{32}&a_{33} \end{array} \right) * \left( \begin{array}{ccc}
w_{11}&w_{12}\\ w_{21}&w_{22} \end{array} \right) + b = \left(
\begin{array}{ccc} z_{11}&z_{12}\\ z_{21}&z_{22} \end{array} \right)</script><p>利用卷积的定义，很容易得出：</p><script type="math/tex;mode=display">z_{11} = a_{11}w_{11} + a_{12}w_{12} + a_{21}w_{21} + a_{22}w_{22} + b</script><script type="math/tex;mode=display">z_{12} = a_{12}w_{11} + a_{13}w_{12} + a_{22}w_{21} + a_{23}w_{22} + b</script><script type="math/tex;mode=display">z_{21} = a_{21}w_{11} + a_{22}w_{12} + a_{31}w_{21} + a_{32}w_{22} + b</script><script type="math/tex;mode=display">z_{22} = a_{22}w_{11} + a_{23}w_{12} + a_{32}w_{21} + a_{33}w_{22} + b</script><p>此时，因为这个简单的例子中，只存在一个$b$的标量，$z_{11}、z_{12}、z_{21}、z_{22}$均包含的是同一个$b$，因此$\frac{\partial z}{\partial b}$可以看成是对每一个$z$分量对$b$求导<strong>在求和</strong>。</p><script type="math/tex;mode=display">\frac{\partial z}{\partial b} =\sum\limits_{i,j} \left(
\begin{array}{ccc} \frac{\partial z_{11}}{\partial b}&\frac{\partial z_{12}}{\partial b}\\ \frac{\partial z_{21}}{\partial b}&\frac{\partial z_{22}}{\partial b} \end{array} \right) =\sum\limits_{u,v} \left(
\begin{array}{ccc} 1&1\\ 1&1 \end{array} \right)</script><p>所以可以得到下面的式子：</p><script type="math/tex;mode=display">\frac{\partial J(W,b)}{\partial b^{l}} = \sum\limits_i\sum\limits_j \left(\frac{\partial J(W,b)}{z_{ij}^l} \frac{z_{ij}^l}{b_{ij}^l} \right) = \sum\limits_i\sum\limits_j \left(\frac{\partial J(W,b)}{z_{ij}^l} \frac{z_{ij}^l}{b^l} \right) \\
= \sum\limits_i\sum\limits_j \left(\frac{\partial J(W,b)}{z_{ij}^l} \times 1 \right)  = \sum\limits_{i,j}(\delta^l)_{i,j}</script><h2 id="CNN反向传播算法总结"><a href="#CNN反向传播算法总结" class="headerlink" title="CNN反向传播算法总结"></a>CNN反向传播算法总结</h2><p>现在我们总结下CNN的反向传播算法，以最基本的批量梯度下降法为例来描述反向传播算法。</p><p>输入：m个图片样本，CNN模型的层数L和所有隐藏层的类型，对于卷积层，要定义卷积核的大小K，卷积核子矩阵的维度F，填充大小P，步幅S。对于池化层，要定义池化区域大小k和池化标准（MAX或Average），对于全连接层，要定义全连接层的激活函数（输出层除外）和各层的神经元个数。梯度迭代参数迭代步长$\alpha$,最大迭代次数MAX与停止迭代阈值$\epsilon$</p><p>输出：CNN模型各隐藏层与输出层的$W,b$</p><p>1) 初始化各隐藏层与输出层的各$W,b$的值为一个随机值。</p><p>2）for iter to 1 to MAX：</p><p>　　2-1) for i =1 to m：</p><p>　　　　a) 将CNN输入$a^1$设置为$x_i$对应的张量</p><p>　　　　b) for $l$=2 to L-1，根据下面3种情况进行前向传播算法计算：</p><p>　　　　　　b-1) 如果当前是全连接层：则有$a^{i,l} = \sigma(z^{i,l}) = \sigma(W^la^{i,l-1} + b^{l})$</p><p>　　　　　　b-2) 如果当前是卷积层：则有$a^{i,l} = \sigma(z^{i,l}) = \sigma(W^l*a^{i,l-1} + b^{l})$<br>　　　　<br> 　　　　b-3) 如果当前是池化层：则有$ a^{i,l}= pool(a^{i,l-1})$,这里的pool指按照池化区域大小k和池化标准将输入张量缩小的过程。</p><p>　　　　c) 对于输出层第L层: $ a^{i,L}= softmax(z^{i,L}) = softmax(W^{L}a^{i,L-1} +b^{L})$</p><p>　　　　d) 通过损失函数计算输出层的$\delta^{i,L}$</p><p>　　　　e) for $l$= L-1 to 2, 根据下面3种情况进行进行反向传播算法计算:</p><p>　　　　　　e-1) 如果当前是全连接层：$\delta^{i,l} = (W^{l+1})^T\delta^{i,l+1}\odot \sigma^{‘}(z^{i,l})$</p><p>　　　　　　e-2) 如果当前是卷积层：$\delta^{i,l} = \delta^{i,l+1}*rot180(W^{l+1}) \odot<br>\sigma^{‘}(z^{i,l}) $</p><p>　　　　　　e-3) 如果当前是池化层：$\delta^{i,l} = upsample(\delta^{i,l+1})<br>\odot \sigma^{‘}(z^{i,l})$</p><p>　　2-2) for $l$ = 2 to L，根据下面2种情况更新第$l$层的$W^l,b^l$:</p><p>　　　　2-2-1) 如果当前是全连接层：$W^l = W^l -\alpha \sum\limits_{i=1}^m \delta^{i,l}(a^{i,l-1})^T $， $b^l = b^l -\alpha \sum\limits_{i=1}^m \delta^{i,l}$</p><p>　　　　2-2-2) 如果当前是卷积层，对于每一个卷积核有：$W^l = W^l -\alpha \sum\limits_{i=1}^m　\delta^{i,l}*rot180(a^{i, l-1}) $， $b^l = b^l -\alpha \sum\limits_{i=1}^m　\sum\limits_{u,v}(\delta^{i,l})_{u,v}$</p><p>　　2-3) 如果所有$W，b$的变化值都小于停止迭代阈值$\epsilon$，则跳出迭代循环到步骤3。</p><p>3）输出各隐藏层与输出层的线性关系系数矩阵$W$和偏倚向量$b$。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.cnblogs.com/pinard/p/6494810.html" target="_blank" rel="noopener">卷积神经网络(CNN)反向传播算法</a><br><a href="http://jermmy.xyz/2017/12/16/2017-12-16-cnn-back-propagation/" target="_blank" rel="noopener">CNN的反向传播</a><br><a href="https://blog.csdn.net/qq_29381089/article/details/80374820" target="_blank" rel="noopener">yolo反向传播源码分析</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/" title="卷积神经网络前向与反向传播">https://www.zdaiot.com/MachineLearning/卷积神经网络/卷积神经网络前向与反向传播/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/CNN/" rel="tag"><i class="fa fa-tag"></i> CNN</a><a href="/tags/反向传播/" rel="tag"><i class="fa fa-tag"></i> 反向传播</a></div><div class="post-nav"><div class="post-nav-item"><a href="/MachineLearning/神经网络/深度神经网络DNN/" rel="prev" title="深度神经网络DNN"><i class="fa fa-chevron-left"></i> 深度神经网络DNN</a></div><div class="post-nav-item"> <a href="/Math/矩阵求导法则与性质/" rel="next" title="矩阵求导法则与性质">矩阵求导法则与性质<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾CNN的结构"><span class="nav-number">1.</span> <span class="nav-text">回顾CNN的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CNN输入层前向传播到卷积层"><span class="nav-number">2.</span> <span class="nav-text">CNN输入层前向传播到卷积层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐藏层前向传播到卷积层"><span class="nav-number">3.</span> <span class="nav-text">隐藏层前向传播到卷积层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐藏层前向传播到池化层"><span class="nav-number">4.</span> <span class="nav-text">隐藏层前向传播到池化层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐藏层前向传播到全连接层"><span class="nav-number">5.</span> <span class="nav-text">隐藏层前向传播到全连接层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CNN前向传播算法小结"><span class="nav-number">6.</span> <span class="nav-text">CNN前向传播算法小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾DNN的反向传播算法"><span class="nav-number">7.</span> <span class="nav-text">回顾DNN的反向传播算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CNN的反向传播算法思想"><span class="nav-number">8.</span> <span class="nav-text">CNN的反向传播算法思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#已知池化层的-delta-l-，推导上一隐藏层的-delta-l-1"><span class="nav-number">9.</span> <span class="nav-text">已知池化层的$\delta^l$，推导上一隐藏层的$\delta^{l-1}$</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#已知卷积层的-delta-l-，推导上一隐藏层的-delta-l-1"><span class="nav-number">10.</span> <span class="nav-text">已知卷积层的$\delta^l$，推导上一隐藏层的$\delta^{l-1}$</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#已知卷积层的-delta-l-，推导该层的-W-b-的梯度"><span class="nav-number">11.</span> <span class="nav-text">已知卷积层的$\delta^l$，推导该层的$W,b$的梯度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CNN反向传播算法总结"><span class="nav-number">12.</span> <span class="nav-text">CNN反向传播算法总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料："><span class="nav-number">13.</span> <span class="nav-text">参考资料：</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">305</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">364</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">30:07</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '6c108197b7c70b3ec7744a777ddabe76',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>