<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="以下内容大部分转载从图(Graph)到图卷积(Graph Convolution)：漫谈图神经网络模型 (一)。觉得这篇文章写得很好，先摘抄过来，用于日后添加个人理解。 历史脉络在开始正文之前，笔者先带大家回顾一下图神经网络的发展历史。不过，因为图神经网络的发展分支非常之多，笔者某些叙述可能并不全面，一家之言仅供各位读者参考：  图神经网络的概念最早在2005年提出。2009年Franco博士在其"><meta name="keywords" content="GNN,GGNN"><meta property="og:type" content="article"><meta property="og:title" content="图神经网络"><meta property="og:url" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="以下内容大部分转载从图(Graph)到图卷积(Graph Convolution)：漫谈图神经网络模型 (一)。觉得这篇文章写得很好，先摘抄过来，用于日后添加个人理解。 历史脉络在开始正文之前，笔者先带大家回顾一下图神经网络的发展历史。不过，因为图神经网络的发展分支非常之多，笔者某些叙述可能并不全面，一家之言仅供各位读者参考：  图神经网络的概念最早在2005年提出。2009年Franco博士在其"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-1-image-and-graph.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-2-state-update-function.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-4-state-flow.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-6-gnn-example.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-3-contraction-map.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-5-gnn-rnn.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-9-over-smooth.gif"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-7-ggnn.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-8-ggnn-example2.png"><meta property="og:updated_time" content="2020-02-29T08:04:58.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="图神经网络"><meta name="twitter:description" content="以下内容大部分转载从图(Graph)到图卷积(Graph Convolution)：漫谈图神经网络模型 (一)。觉得这篇文章写得很好，先摘抄过来，用于日后添加个人理解。 历史脉络在开始正文之前，笔者先带大家回顾一下图神经网络的发展历史。不过，因为图神经网络的发展分支非常之多，笔者某些叙述可能并不全面，一家之言仅供各位读者参考：  图神经网络的概念最早在2005年提出。2009年Franco博士在其"><meta name="twitter:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/o_image-1-image-and-graph.png"><link rel="canonical" href="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>图神经网络 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 图神经网络<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/MachineLearning/图神经网络/图神经网络.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-02-29 16:04:58" itemprop="dateCreated datePublished" datetime="2020-02-29T16:04:58+08:00">2020-02-29</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/图神经网络/" itemprop="url" rel="index"><span itemprop="name">图神经网络</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>2.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>以下内容大部分转载<a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_1.html" target="_blank" rel="noopener">从图(Graph)到图卷积(Graph Convolution)：漫谈图神经网络模型 (一)</a>。觉得这篇文章写得很好，先摘抄过来，用于日后添加个人理解。</p><h2 id="历史脉络"><a href="#历史脉络" class="headerlink" title="历史脉络"></a>历史脉络</h2><p>在开始正文之前，笔者先带大家回顾一下图神经网络的发展历史。不过，因为图神经网络的发展分支非常之多，笔者某些叙述可能并不全面，一家之言仅供各位读者参考：</p><ol><li>图神经网络的概念最早在2005年提出。2009年Franco博士在其论文 [2]中定义了图神经网络的理论基础，笔者呆会要讲的第一种图神经网络也是基于这篇论文。</li><li>最早的GNN主要解决的还是如分子结构分类等严格意义上的图论问题。但实际上欧式空间(比如像图像 Image)或者是序列(比如像文本 Text)，许多常见场景也都可以转换成图(Graph)，然后就能使用图神经网络技术来建模。</li><li>2009年后图神经网络也陆续有一些相关研究，但没有太大波澜。直到2013年，在图信号处理(Graph Signal Processing)的基础上，Bruna(这位是LeCun的学生)在文献 [3]中首次提出图上的基于频域(Spectral-domain)和基于空域(Spatial-domain)的卷积神经网络。</li><li>其后至今，学界提出了很多基于空域的图卷积方式，也有不少学者试图通过统一的框架将前人的工作统一起来。而基于频域的工作相对较少，只受到部分学者的青睐。</li><li>值得一提的是，图神经网络与图表示学习(Represent Learning for Graph)的发展历程也惊人地相似。2014年，在word2vec [4]的启发下，Perozzi等人提出了DeepWalk [5]，开启了深度学习时代图表示学习的大门。更有趣的是，就在几乎一样的时间，Bordes等人提出了大名鼎鼎的TransE [6]，为知识图谱的分布式表示(Represent Learning for Knowledge Graph)奠定了基础。</li></ol><h2 id="图神经网络-Graph-Neural-Network"><a href="#图神经网络-Graph-Neural-Network" class="headerlink" title="图神经网络(Graph Neural Network)"></a>图神经网络(Graph Neural Network)</h2><p>首先要澄清一点，除非特别指明，本文中所提到的图均指<strong>图论中的图</strong>(Graph)。它是一种由若干个<strong>结点</strong>(Node)及连接两个结点的<strong>边</strong>(Edge)所构成的图形，用于刻画不同结点之间的关系。下面是一个生动的例子，图片来自论文[7]:</p><p><img src="/MachineLearning/图神经网络/图神经网络/o_image-1-image-and-graph.png" alt="图像与图示例" style="zoom:80%"></p><h3 id="状态更新与输出"><a href="#状态更新与输出" class="headerlink" title="状态更新与输出"></a>状态更新与输出</h3><p>最早的图神经网络起源于Franco博士的论文[2], 它的理论基础是<strong>不动点</strong>理论。给定一张图 $G$，每个结点都有其自己的特征(feature), 本文中用$\mathbf{x}_v$表示结点v的特征；连接两个结点的边也有自己的特征，本文中用$\mathbf{x}_{(v,u)}$表示结点v与结点u之间边的特征；GNN的学习目标是获得每个结点的图感知的隐藏状态 $\mathbf{h}_v$(state embedding)，这就意味着：对于每个节点，它的隐藏状态包含了来自邻居节点的信息。那么，如何让每个结点都感知到图上其他的结点呢？GNN通过<strong>迭代式更新</strong>所有结点的隐藏状态来实现，在$t+1$时刻，结点$v$的隐藏状态按照如下方式更新：</p><script type="math/tex;mode=display">
𝐡^{t+1}_𝑣=𝑓(𝐱_𝑣,𝐱_𝑐𝑜[𝑣],𝐡^{t}_𝑛𝑒[𝑣] ,𝐱_𝑛𝑒[𝑣]),</script><p>上面这个公式中的 $f$ 就是隐藏状态的<strong>状态更新</strong>函数，在论文中也被称为<strong>局部转移函数</strong>(local transaction function)。公式中的$𝐱_𝑐𝑜[𝑣]$指的是与结点$v$相邻的边的特征，$𝐱_𝑛𝑒[𝑣]$指的是结点$v$的邻居结点的特征，$𝐡^t_𝑛𝑒[𝑣]$则指邻居结点在$t$时刻的隐藏状态。注意 $f$ 是对所有结点都成立的，是一个全局共享的函数。那么怎么把它跟深度学习结合在一起呢？聪明的读者应该想到了，那就是利用神经网络(Neural Network)来拟合这个复杂函数 $f$。值得一提的是，虽然看起来 $f$ 的输入是不定长参数，但在 $f$ 内部我们可以先将不定长的参数通过一定操作变成一个固定的参数，比如说用所有隐藏状态的加和来代表所有隐藏状态。我们举个例子来说明一下：</p><p><img src="/MachineLearning/图神经网络/图神经网络/o_image-2-state-update-function.png" alt="更新公式示例" style="zoom:50%"></p><p>假设结点$5$为中心结点，其隐藏状态的更新函数如图所示。这个更新公式表达的思想自然又贴切：不断地利用当前时刻邻居结点的隐藏状态作为部分输入来生成下一时刻中心结点的隐藏状态，直到每个结点的隐藏状态变化幅度很小，整个图的信息流动趋于平稳。至此，每个结点都“知晓”了其邻居的信息。状态更新公式仅描述了如何获取每个结点的隐藏状态，除它以外，我们还需要另外一个函数 $g$ 来描述如何适应下游任务。举个例子，给定一个社交网络，一个可能的下游任务是判断各个结点是否为水军账号。</p><script type="math/tex;mode=display">
𝐨_𝑣=𝑔(𝐡_𝑣,𝐱_𝑣)</script><p>在原论文中，$g$ 又被称为<strong>局部输出函数</strong>(local output function)，与 $f$ 类似，$g$ 也可以由一个神经网络来表达，它也是一个全局共享的函数。那么，整个流程可以用下面这张图表达：</p><p><img src="/MachineLearning/图神经网络/图神经网络/o_image-4-state-flow.png" alt="更新公式示例" style="zoom:50%"></p><p>仔细观察两个时刻之间的连线，它与图的连线密切相关。比如说在 $T_1$ 时刻，结点 1 的状态接受来自结点 3 的上一时刻的隐藏状态，因为结点 1 与结点 3相邻。直到 $T_n$ 时刻，各个结点隐藏状态收敛，每个结点后面接一个 $g$ 即可得到该结点的输出 $\mathbf{o}$。</p><p>对于不同的图来说，收敛的时刻可能不同，因为收敛是通过两个时刻$p$-范数的差值是否小于某个阈值 $\epsilon$来判定的，比如：</p><script type="math/tex;mode=display">
||\mathbf{H}^{t+1}||_{2}-||\mathbf{H}^{t}||_{2}<\epsilon</script><h3 id="实例-化合物分类"><a href="#实例-化合物分类" class="headerlink" title="实例:化合物分类"></a>实例:化合物分类</h3><p>下面让我们举个实例来说明图神经网络是如何应用在实际场景中的，这个例子来源于论文[2]。假设我们现在有这样一个任务，给定一个环烃化合物的分子结构(包括原子类型，原子键等)，模型学习的目标是判断其是否有害。这是一个典型的二分类问题，一个训练样本如下图所示：</p><p><img src="/MachineLearning/图神经网络/图神经网络/o_image-6-gnn-example.png" alt="化合物分子结构" style="zoom:50%"></p><p>由于化合物的分类实际上需要对整个图进行分类，在论文中，作者将化合物的<strong>根结点</strong>的表示作为整个图的表示，如图上红色的结点所示。Atom feature 中包括了每个原子的类型(Oxygen, 氧原子)、原子自身的属性(Atom Properties)、化合物的一些特征(Global Properties)等。把每个原子看作图中的结点，原子键视作边，一个分子(Molecule)就可以看作一张图。在不断迭代得到根结点氧原子收敛的隐藏状态后，在上面接一个前馈神经网络作为输出层(即$g$函数)，就可以对整个化合物进行二分类了。</p><blockquote><p>当然，在同构图上根据策略选择同一个根结点对结果也非常重要。但在这里我们不关注这部分细节，感兴趣的读者可以阅读原文。</p></blockquote><h3 id="不动点理论"><a href="#不动点理论" class="headerlink" title="不动点理论"></a>不动点理论</h3><p>在本节的开头我们就提到了，GNN的理论基础是<strong>不动点</strong>(the fixed point)理论，这里的不动点理论专指<strong>巴拿赫不动点定理</strong>(Banach’s Fixed Point Theorem)。首先我们用 $F$ 表示若干个 $f$ 堆叠得到的一个函数，也称为<strong>全局更新</strong>函数，那么图上所有结点的状态更新公式可以写成：</p><script type="math/tex;mode=display">
𝐇^{𝑡+1}=F(𝐇^𝑡,𝐗)</script><p>不动点定理指的就是，不论$\mathbf{H}^0$是什么，只要 $F$ 是个<strong>压缩映射</strong>(contraction map)，$\mathbf{H}^{0}$经过不断迭代都会收敛到某一个固定的点，我们称之为不动点。那压缩映射又是什么呢，一张图可以解释得明明白白：</p><p><img src="/MachineLearning/图神经网络/图神经网络/o_image-3-contraction-map.png" alt="更新公式示例" style="zoom:50%"></p><p>上图的实线箭头就是指映射 $F$, 任意两个点 $x,y$ 在经过 $F$ 这个映射后，分别变成了 $F(x),F(y)$。压缩映射就是指，$𝑑(𝐹(𝑥),𝐹(𝑦))≤𝑐𝑑(𝑥,𝑦), 0≤𝑐&lt;1$。也就是说，经过 $F$ 变换后的新空间一定比原先的空间要小，原先的空间被压缩了。<strong>想象这种压缩的过程不断进行，最终就会把原空间中的所有点映射到一个点上。</strong></p><p>那么肯定会有读者心存疑问，既然 $f$ 是由神经网络实现的，我们该如何实现它才能保证它是一个压缩映射呢？我们下面来谈谈 $f$ 的具体实现。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>在具体实现中， $f$ 其实通过一个简单的<strong>前馈神经网络</strong>(Feed-forward Neural Network)即可实现。比如说，一种实现方法可以是把每个邻居结点的特征、隐藏状态、每条相连边的特征以及结点本身的特征简单拼接在一起，在经过前馈神经网络后做一次简单的加和。</p><script type="math/tex;mode=display">
𝐡_𝑣^{𝑡+1}=𝑓(𝐱_𝑣,𝐱_𝑐𝑜[𝑣] ,𝐡^t_𝑛𝑒[𝑣] ,𝐱_𝑛𝑒[𝑣]) \\
=\sum_{𝑢∈𝑛𝑒[𝑣]} FNN([𝐱_𝑣;𝐱_{(𝑢,𝑣)};𝐡_𝑢^𝑡;𝐱_𝑢])</script><p>那我们如何保证 $f$ 是个压缩映射呢，其实是通过限制 $f$ 对 $\mathbf{H}$ 的偏导数矩阵的大小，这是通过一个对<strong>雅可比矩阵</strong>(Jacobian Matrix)的<strong>惩罚项</strong>(Penalty)来实现的。在代数中，有一个定理是: $f$ 为压缩映射的等价条件是 $f$ 的梯度/导数要小于1。这个等价定理可以从压缩映射的形式化定义导出，我们这里使用 $||x||$ 表示 $x$ 在空间中的<strong>范数</strong>(norm)。范数是一个标量，它是向量的长度或者模，$||x||$ 是 $x$ 在有限空间中坐标的连续函数。这里把 $x$ 简化成1维的，坐标之间的差值可以看作向量在空间中的距离，根据压缩映射的定义，可以导出：</p><script type="math/tex;mode=display">
||F(x)-F(y)||{\leq}c||x-y||, 0\ {\leq}c<1</script><script type="math/tex;mode=display">
\frac{||F(x)-F(y)||}{||x-y||}{\leq}c</script><script type="math/tex;mode=display">
\frac{||F(x)-F(x-{\Delta}x)||}{||{\Delta}x||}{\leq}c</script><script type="math/tex;mode=display">
||F'(x)||=||\frac{ \partial F(x)}{\partial x}||{\leq}c</script><p>推广一下，即得到雅可比矩阵的罚项需要满足其范数小于等于$c$等价于压缩映射的条件。根据拉格朗日乘子法，将有约束问题变成带罚项的无约束优化问题，训练的目标可表示成如下形式：</p><script type="math/tex;mode=display">
J = Loss + \lambda \cdot \max({\frac{||{\partial}FNN||}{||{\partial}\mathbf{h}||}}−c,0), c\in(0,1)</script><p>其中$\lambda$是超参数，与其相乘的项即为雅可比矩阵的罚项。</p><h3 id="模型学习"><a href="#模型学习" class="headerlink" title="模型学习"></a>模型学习</h3><p>上面我们花一定的篇幅搞懂了如何让 $f$ 接近压缩映射，下面我们来具体叙述一下图神经网络中的损失 $Loss$ 是如何定义，以及模型是如何学习的。</p><p>仍然以社交网络举例，虽然每个结点都会有隐藏状态以及输出，但并不是每个结点都会有<strong>监督信号</strong>(Supervision)。比如说，社交网络中只有部分用户被明确标记了是否为水军账号，这就构成了一个典型的结点二分类问题。</p><p>那么很自然地，模型的损失即通过这些有监督信号的结点得到。假设监督结点一共有 $p$ 个，模型损失可以形式化为：</p><script type="math/tex;mode=display">
L𝑜𝑠𝑠=∑_{𝑖=1}^𝑝{(𝐭_𝑖−𝐨_𝑖)}</script><p>那么，模型如何学习呢？根据<strong>前向传播计算损失</strong>的过程，不难推出<strong>反向传播计算梯度</strong>的过程。在前向传播中，模型：</p><ol><li>调用 $f$ 若干次，比如 $T_n$次，直到 $\mathbf{h}^{T_{n}}_v$ 收敛。</li><li>此时每个结点的隐藏状态接近不动点的解。</li><li>对于有监督信号的结点，将其隐藏状态通过 $g$ 得到输出，进而算出模型的损失。</li></ol><p>根据上面的过程，在反向传播时，我们可以直接求出 $f$ 和 $g$ 对最终的隐藏状态 $\mathbf{h}^{T_{n}}_v$ 的梯度。然而，因为模型递归调用了 $f$ 若干次，为计算 $f$ 和 $g$ 对最初的隐藏状态 $\mathbf{h}_v^0$ 的梯度，我们需要同样递归式/迭代式地计算 $T_n$ 次梯度。最终得到的梯度即为 $f$ 和 $g$ 对 $\mathbf{h}_v^0$ 的梯度，然后该梯度用于更新模型的参数。这个算法就是 Almeida-Pineda 算法[9]。</p><blockquote><p>之所以要求 $f$ 为压缩映射，也是因为只有 $f$ 为压缩映射时，AP 才能得到一个收敛的梯度。</p></blockquote><h3 id="GNN与RNN"><a href="#GNN与RNN" class="headerlink" title="GNN与RNN"></a>GNN与RNN</h3><p>相信熟悉 RNN/LSTM/GRU 等循环神经网络的同学看到这里会有一点小困惑，因为图神经网络不论是前向传播的方式，还是反向传播的优化算法，与循环神经网络都有点相像。这并不是你的错觉，实际上，图神经网络与到循环神经网络确实很相似。为了清楚地显示出它们之间的不同，我们用一张图片来解释这两者设计上的不同：</p><p><img src="/MachineLearning/图神经网络/图神经网络/o_image-5-gnn-rnn.png" alt="GNN与RNN的区别" style="zoom:50%"></p><p>假设在GNN中存在三个结点$x_1$,$x_2$,$x_3$，相应地，在RNN中有一个序列$(x_1,x_2,x_3)$。笔者认为，GNN与RNN的区别主要在于4点：</p><ul><li>GNN的基础理论是不动点理论，这就意味着GNN沿时间展开的长度是动态的，是<strong>根据收敛条件</strong>确定的，而RNN沿时间展开的长度就等于<strong>序列本身的长度</strong>。</li><li>GNN每次时间步的输入都是所有结点 $v$ 的特征，而RNN每次时间步的输入是该时刻对应的输入。同时，时间步之间的信息流也不相同，前者由边决定，后者则由序列的读入顺序决定。</li><li>GNN采用 AP 算法反向传播优化，而RNN使用<strong>BPTT</strong>(Back Propogation Through Time)优化。前者对收敛性有要求，而后者对收敛性是没有要求的。</li><li>GNN循环调用 $f$ 的目标是得到每个结点稳定的隐藏状态，所以只有在隐藏状态收敛后才能输出；而RNN的每个时间步上都可以输出，比如语言模型。</li></ul><p>不过鉴于初代GNN与RNN结构上的相似性，一些文章中也喜欢把它称之为 Recurrent-based GNN，也有一些文章会把它归纳到 Recurrent-based GCN中。之后读者在了解 GCN后会理解为什么人们要如此命名。</p><h3 id="GNN的局限"><a href="#GNN的局限" class="headerlink" title="GNN的局限"></a>GNN的局限</h3><p>初代GNN，也就是基于循环结构的图神经网络的核心是不动点理论。它的核心观点是<strong>通过结点信息的传播使整张图达到收敛，在其基础上再进行预测</strong>。收敛作为GNN的内核，同样局限了其更广泛的使用，其中最突出的是两个问题：</p><ul><li>GNN只将边作为一种传播手段，但并未区分不同边的功能。虽然我们可以在特征构造阶段($\mathbf{x}_{(u,v)}$)为不同类型的边赋予不同的特征，但相比于其他输入，边对结点隐藏状态的影响实在有限。并且GNN没有为边设置独立的可学习参数，也就意味着无法通过模型学习到边的某些特性。</li><li>如果把GNN应用在<em>图表示</em>的场景中，使用不动点理论并不合适。这主要是因为基于不动点的收敛会导致结点之间的隐藏状态间存在较多信息共享，从而导致结点的状态太<strong>过光滑</strong>(Over Smooth)，并且属于结点自身的特征<strong>信息匮乏</strong>(Less Informative)。</li></ul><p>下面这张来自维基百科[13]的图可以形象地解释什么是 Over Smooth，其中我们把整个布局视作一张图，每个像素点与其上下左右以及斜上下左右8个像素点相邻，这决定了信息在图上的流动路径。初始时，蓝色表示没有信息量，如果用向量的概念表达即为空向量；绿色，黄色与红色各自有一部分信息量，表达为非空的特征向量。在图上，信息主要从三块有明显特征的区域向其邻接的像素点流动。一开始<strong>不同像素点的区分非常明显</strong>，但在向不动点过渡的过程中，所有像素点都取向一致，最终整个系统形成均匀分布。这样，虽然每个像素点都感知到了全局的信息，<strong>但我们无法根据它们最终的隐藏状态区分它们</strong>。比如说，根据最终的状态，我们是无法得知哪些像素点最开始时在绿色区域。</p><p><img src="/MachineLearning/图神经网络/图神经网络/o_image-9-over-smooth.gif" alt="OverSmooth"></p><p>在这里笔者再多说几句。事实上，上面这个图与GNN中的信息流动并不完全等价。从笔者来看，如果我们用物理模型来描述它，上面这个图代表的是初始时有3个热源在散发热量，而后就让它们自由演化；但实际上，GNN在每个时间步都会将结点的特征作为输入来更新隐藏状态，这就好像是放置了若干个永远不灭的热源，热源之间会有互相干扰，但最终不会完全一致。</p><h2 id="门控图神经网络-Gated-Graph-Neural-Network"><a href="#门控图神经网络-Gated-Graph-Neural-Network" class="headerlink" title="门控图神经网络(Gated Graph Neural Network)"></a>门控图神经网络(Gated Graph Neural Network)</h2><p>我们上面细致比较了GNN与RNN，可以发现它们有诸多相通之处。那么，我们能不能直接用类似RNN的方法来定义GNN呢? 于是乎，<strong>门控图神经网络</strong>(Gated Graph Neural Network, GGNN) [10]就出现了。虽然在这里它们看起来类似，但实际上，它们的区别非常大，其中最核心的不同即是<strong>门控神经网络不以不动点理论为基础</strong>。这意味着：$f$ 不再需要是一个压缩映射；迭代不需要到收敛才能输出，可以迭代固定步长；优化算法也从 AP 算法转向 BPTT。</p><h3 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h3><p>与图神经网络定义的范式一致，GGNN也有两个过程：状态更新与输出。相比GNN而言，它主要的区别来源于状态更新阶段。具体地，GGNN参考了GRU的设计，把邻居结点的信息视作输入，结点本身的状态视作隐藏状态，其状态更新函数如下:</p><script type="math/tex;mode=display">
\mathbf{h}^{t+1}_v=\text{GRU}(\mathbf{h}^{t}_v,\sum_{𝑢∈𝑛𝑒[𝑣]} \mathbf{W}_{edge}𝐡_𝑢^𝑡)</script><p>如果读者对GRU的更新公式熟悉的话，对上式应该很好理解。仔细观察上面这个公式，除了GRU式的设计外，GGNN还针对不同类型的边引入了可学习的参数$\mathbf{W}$。每一种 $edge$ 对应一个 $\mathbf{W}_{edge}$，这样它就可以处理异构图。</p><p>但是，仔细对比GNN的GGNN的状态更新公式，细心的读者可能会发现：在GNN里需要作为输入的结点特征 $\mathbf{x}_v$ 没有出现在GGNN的公式中! 但实际上，这些结点特征对我们的预测至关重要，因为它才是各个结点的根本所在。</p><p>为了处理这个问题，GGNN将结点特征作为隐藏状态初始化的一部分。那么重新回顾一下GGNN的流程，其实就是这样：</p><ul><li>用结点特征初始化各个结点的(部分)隐藏状态。</li><li>对整张图，按照上述状态更新公式固定迭代若干步。</li><li>对部分有监督信号的结点求得模型损失，利用BPTT算法反向传播求得$\mathbf{W}_{edge}$和GRU参数的梯度。</li></ul><h3 id="实例1-到达判断"><a href="#实例1-到达判断" class="headerlink" title="实例1:到达判断"></a>实例1:到达判断</h3><p>为了便于理解，我们举个来自论文[10]的例子。比如说给定一张图$G$，开始结点 $S$，对于任意一个结点 $E$，模型判断开始结点是否可以通过图游走至该结点。同样地，这也可以转换成一个对结点的二分类问题，即<code>可以到达</code>和<code>不能到达</code>。下图即描述了这样的过程：</p><p><img src="/MachineLearning/图神经网络/图神经网络/o_image-7-ggnn.png" alt="GGNN实例" style="zoom:67%"></p><p>图中的红色结点即开始结点$S$，绿色结点是我们希望判断的结点$E$，我们这里称其为结束结点。那么相比于其他结点，这两个结点具有一定特殊性。那我们就可以使用第1维为1来表示开始结点，第2维为1来表示结束结点。最后在对结束结点分类时，如果其隐藏状态的第1维被赋予得到了一个非0的实数值，那意味着它可以到达。</p><p>从初始化的流程我们也可以看出GNN与GGNN的区别：GNN依赖于不动点理论，所以每个结点的隐藏状态即使使用<strong>随机初始化都会收敛到不动点</strong>；GGNN则不同，不同的初始化对GGNN最终的结果影响很大。</p><h3 id="实例2-语义解析"><a href="#实例2-语义解析" class="headerlink" title="实例2:语义解析"></a>实例2:语义解析</h3><p>上面这个例子非常简单形象地说明了GNN与GGNN的不同，由于笔者比较关注Semantic Parsing(语义解析)相关的工作，所以下面我们借用ACL 2019的一篇论文[11]来讲一下GGNN在实际中如何使用，以及它适用于怎样的场景。</p><p>首先为不了解语义解析的读者科普一下，语义解析的主要任务是将自然语言转换成机器语言，在这里笔者特指的是SQL(结构化查询语言，Structured Query Language)，它就是大家所熟知的数据库查询语言。这个任务有什么用呢？它可以让小白用户也能从数据库中获得自己关心的数据。正是因为有了语义解析，用户不再需要学习SQL语言的语法，也不需要有编程基础，可以直接通过自然语言来查询数据库。事实上，语义解析放到今天仍然是一个非常难的任务。除去自然语言与程序语言在语义表达上的差距外，很大一部分性能上的损失是因为任务本身，或者叫SQL语言的语法太复杂。比如我们有两张表格，一张是学生的学号与其性别，另一张表格记录了每个学生选修的课程。那如果想知道有多少女生选修了某门课程，我们需要先将两张表格联合(JOIN)，再对结果进行过滤(WHERE)，最后进行聚合统计(COUNT)。这个问题在多表的场景中尤为突出，每张表格互相之间通过外键相互关联。其实呢，如果我们把表格中的Header看作各个结点，表格内的结点之间存在联系，而外键可以视作一种特殊的边，这样就可以构成一张图，正如下图中部所示：</p><p><img src="/MachineLearning/图神经网络/图神经网络/o_image-8-ggnn-example2.png" alt="GGNN语义解析实例" style="zoom:80%"></p><p>论文[11]就是利用了表格这样的特性，利用GGNN来解决多表问题。下面我们先介绍一下一般的语义解析方法，再介绍[11]是如何将图跟语义解析系统联系在一起的。就笔者知道的而言，目前绝大部分语义解析会遵循Seq2seq(序列到序列，Sequence to sequence)的框架，输入是一个个自然语言单词，输出是一个个SQL单词。但这样的框架完全没有考虑到表格对SQL输出暗含的约束。比如说，在单个SELECT子句中，我们选择的若干Header都要来自同一张表。再举个例子，能够JOIN的两张表一定存在外键的联系，就像我们刚刚举的那个学生选课的例子一样。</p><p>那么，GGNN该如何结合到传统的语义解析方法中去呢？在论文[11]中，是通过三步来完成的：</p><ol><li>首先，通过表格建立对应的Graph。再利用GGNN的方法计算每个Header的隐藏状态。</li><li>然后，在Seq2seq模型的编码阶段(Encoding)，用每个输入的自然语言单词的词向量对表格所有Header的隐藏状态算一个Attention，利用Attention作为权重得到了每个自然语言单词的图感知的表示。</li><li>在解码阶段(Decoding)，如果输出的是表格中的Header/Table这类词，就用输出的向量与表格所有Header/Table的隐藏状态算一个分数，这个分数由$F$提供的。$F$实际上是一个全连接层，它的输出实际上是SQL单词与表格中各个Header/Table的联系程度。为了让SQL的每个输出都与历史的信息一致，每次输出时都用之前输出的Header/Table对候选集中的Header/Table打分，这样就利用到了多表的信息。</li></ol><p>最终该论文在多表上的效果也确实很好，下面放一个在Spider[12]数据集上的性能对比：</p><div class="table-container"><table><thead><tr><th>Model</th><th>Acc</th><th>Single</th><th>Multi</th></tr></thead><tbody><tr><td>No GNN</td><td>34.9%</td><td>52.3%</td><td>14.6%</td></tr><tr><td>GNN</td><td><strong>40.7%</strong></td><td>52.2%</td><td><strong>26.8%</strong></td></tr></tbody></table></div><h3 id="GNN与GGNN"><a href="#GNN与GGNN" class="headerlink" title="GNN与GGNN"></a>GNN与GGNN</h3><p>GGNN目前得到了广泛的应用，相比于GNN，其最大的区别在于不再以不动点理论为基础，虽然这意味着不再需要迭代收敛，但同时它也意味着GGNN的初始化很重要。从笔者阅读过的文献来看，GNN后的大部分工作都转向了将GNN向传统的RNN/CNN靠拢，可能的一大好处是这样可以不断吸收来自这两个研究领域的改进。但基于原始GNN的基于不动点理论的工作非常少，至少在笔者看文献综述的时候并未发现很相关的工作。</p><p>但从另一个角度来看，虽然GNN与GGNN的理论不同，但从设计哲学上来看，它们都与循环神经网络的设计类似。</p><ul><li>循环神经网络的好处在于能够处理任意长的序列，但它的计算必须是串行计算若干个时间步，时间开销不可忽略。所以，上面两种基于循环的图神经网络在更新隐藏状态时不太高效。如果借鉴深度学习中堆叠多层的成功经验，我们有足够的理由相信，<strong>多层图神经网络</strong>能达到同样的效果。</li><li>基于循环的图神经网络每次迭代时都共享同样的参数，而多层神经网络每一层的参数不同，可以看成是一个<strong>层次化特征抽取</strong>(Hierarchical Feature Extraction)的方法。</li></ul><p>而在下一篇博客中，我们将介绍图卷积神经网络。它<strong>摆脱了基于循环的方法</strong>，开始走向<strong>多层图神经网络</strong>。在多层神经网络中，<strong>卷积神经网络</strong>(比如152层的ResNet)的大获成功又验证了其在堆叠多层上训练的有效性，所以近几年图卷积神经网络成为研究热点。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]. A Comprehensive Survey on Graph Neural Networks, <a href="https://arxiv.org/abs/1901.00596" target="_blank" rel="noopener">https://arxiv.org/abs/1901.00596</a><br>[2]. The graph neural network model, <a href="https://persagen.com/files/misc/scarselli2009graph.pdf" target="_blank" rel="noopener">https://persagen.com/files/misc/scarselli2009graph.pdf</a><br>[3]. Spectral networks and locally connected networks on graphs, <a href="https://arxiv.org/abs/1312.6203" target="_blank" rel="noopener">https://arxiv.org/abs/1312.6203</a><br>[4]. Distributed Representations of Words and Phrases and their Compositionality, <a href="http://papers.nips.cc/paper/5021-distributed-representations-of-words-andphrases" target="_blank" rel="noopener">http://papers.nips.cc/paper/5021-distributed-representations-of-words-andphrases</a><br>[5]. DeepWalk: Online Learning of Social Representations, <a href="https://arxiv.org/abs/1403.6652" target="_blank" rel="noopener">https://arxiv.org/abs/1403.6652</a><br>[6]. Translating Embeddings for Modeling Multi-relational Data, <a href="https://papers.nips.cc/paper/5071-translating-embeddings-for-modeling-multi-relational-data" target="_blank" rel="noopener">https://papers.nips.cc/paper/5071-translating-embeddings-for-modeling-multi-relational-data</a><br>[7]. Deep Learning on Graphs: A Survey, <a href="https://arxiv.org/abs/1812.04202" target="_blank" rel="noopener">https://arxiv.org/abs/1812.04202</a><br>[8]. 如何理解Graph Convolutional Network（GCN）? <a href="https://www.zhihu.com/question/54504471" target="_blank" rel="noopener">https://www.zhihu.com/question/54504471</a><br>[9]. Almeida–Pineda recurrent backpropagation, <a href="https://www.wikiwand.com/en/Almeida%E2%80%93Pineda_recurrent_backpropagation" target="_blank" rel="noopener">https://www.wikiwand.com/en/Almeida%E2%80%93Pineda_recurrent_backpropagation</a><br>[10]. Gated graph sequence neural networks, <a href="https://arxiv.org/abs/1511.05493" target="_blank" rel="noopener">https://arxiv.org/abs/1511.05493</a><br>[11]. Representing Schema Structure with Graph Neural Networks for Text-to-SQL Parsing, <a href="https://arxiv.org/abs/1905.06241" target="_blank" rel="noopener">https://arxiv.org/abs/1905.06241</a><br>[12]. Spider1.0 Yale Semantic Parsing and Text-to-SQL Challenge, <a href="https://yale-lily.github.io/spider" target="_blank" rel="noopener">https://yale-lily.github.io/spider</a><br>[13]. <a href="https://www.wikiwand.com/en/Laplacian_matrix" target="_blank" rel="noopener">https://www.wikiwand.com/en/Laplacian_matrix</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/" title="图神经网络">https://www.zdaiot.com/MachineLearning/图神经网络/图神经网络/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/GNN/" rel="tag"><i class="fa fa-tag"></i> GNN</a><a href="/tags/GGNN/" rel="tag"><i class="fa fa-tag"></i> GGNN</a></div><div class="post-nav"><div class="post-nav-item"><a href="/MachineLearning/机器学习/半监督学习/" rel="prev" title="半监督学习"><i class="fa fa-chevron-left"></i> 半监督学习</a></div><div class="post-nav-item"> <a href="/DataStructureAlgorithm/00个人总结/" rel="next" title="00个人总结">00个人总结<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#历史脉络"><span class="nav-number">1.</span> <span class="nav-text">历史脉络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图神经网络-Graph-Neural-Network"><span class="nav-number">2.</span> <span class="nav-text">图神经网络(Graph Neural Network)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#状态更新与输出"><span class="nav-number">2.1.</span> <span class="nav-text">状态更新与输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-化合物分类"><span class="nav-number">2.2.</span> <span class="nav-text">实例:化合物分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不动点理论"><span class="nav-number">2.3.</span> <span class="nav-text">不动点理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体实现"><span class="nav-number">2.4.</span> <span class="nav-text">具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模型学习"><span class="nav-number">2.5.</span> <span class="nav-text">模型学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GNN与RNN"><span class="nav-number">2.6.</span> <span class="nav-text">GNN与RNN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GNN的局限"><span class="nav-number">2.7.</span> <span class="nav-text">GNN的局限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#门控图神经网络-Gated-Graph-Neural-Network"><span class="nav-number">3.</span> <span class="nav-text">门控图神经网络(Gated Graph Neural Network)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#状态更新"><span class="nav-number">3.1.</span> <span class="nav-text">状态更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例1-到达判断"><span class="nav-number">3.2.</span> <span class="nav-text">实例1:到达判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例2-语义解析"><span class="nav-number">3.3.</span> <span class="nav-text">实例2:语义解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GNN与GGNN"><span class="nav-number">3.4.</span> <span class="nav-text">GNN与GGNN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">4.</span> <span class="nav-text">参考文献</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">318</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">54</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">374</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2.4m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">36:17</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : 'f520e0bbedf0a616fba15a15e9bf1f0a',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>