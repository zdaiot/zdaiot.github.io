<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="大概一个月前，老师给我分的方向是图神经网络。研一已经快过完了，我自己还没有确定好自己的研究方向。只知道自己想做技术，但是具体什么技术并没有想法，既然老师给分了这个方向，再加上自身也觉得图神经网络在推荐系统、半监督学习等领域有很大的发展前景，所以扎深这个领域也没什么。个人感觉研究生不像博士，没有那么专一，可以接触的范围广点，关键在于构建起自己的知识体系吧和思考吧。 看图神经网络已经一个星期了，还处于"><meta name="keywords" content="GCN,Laplace,傅里叶变换"><meta property="og:type" content="article"><meta property="og:title" content="图卷积神经网络"><meta property="og:url" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="大概一个月前，老师给我分的方向是图神经网络。研一已经快过完了，我自己还没有确定好自己的研究方向。只知道自己想做技术，但是具体什么技术并没有想法，既然老师给分了这个方向，再加上自身也觉得图神经网络在推荐系统、半监督学习等领域有很大的发展前景，所以扎深这个领域也没什么。个人感觉研究生不像博士，没有那么专一，可以接触的范围广点，关键在于构建起自己的知识体系吧和思考吧。 看图神经网络已经一个星期了，还处于"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-85d93d60cb11dddd64a288bff6688cfc_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-f940bce70fb412c75c43ec239b76ee88_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-22e5b58b959d22eaf838ed4238ec2716_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/o_image-12-basic-spatial-conv.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/o_image-13-mpnn.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/o_image-14-graphsage.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/o_image-14-pathcy-san-framework.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/o_image-15-pathcy-san-detail.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-5f9cf5fdeed19b63e1079ed2b87617b4_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/1364088-20200117161036130-648804868.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/1364088-20200117161108593-2145587323.png"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-87d2a1539a2976e3b9f70119427e9d2a_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/b0f16185-12ef-4d65-b34c-cf8106362af5.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-e9e00533154bfdad940e966e7eca5075_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-5f756da1ce39f38d408bd771a15c8ad3_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-a13b82907a364c3707a18bb8572b3a63_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-8e9abf0e99e3a51d07a3c3c59a4cc15a_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-ea7c50ca7a5fb372edd3d9b869301558343704149.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-50175241818d6ec0c069c983eaffed71_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-816cd07215512d99c1034e40848829fb_hd.jpg"><meta property="og:updated_time" content="2020-02-28T10:06:58.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="图卷积神经网络"><meta name="twitter:description" content="大概一个月前，老师给我分的方向是图神经网络。研一已经快过完了，我自己还没有确定好自己的研究方向。只知道自己想做技术，但是具体什么技术并没有想法，既然老师给分了这个方向，再加上自身也觉得图神经网络在推荐系统、半监督学习等领域有很大的发展前景，所以扎深这个领域也没什么。个人感觉研究生不像博士，没有那么专一，可以接触的范围广点，关键在于构建起自己的知识体系吧和思考吧。 看图神经网络已经一个星期了，还处于"><meta name="twitter:image" content="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/v2-85d93d60cb11dddd64a288bff6688cfc_hd.jpg"><link rel="canonical" href="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>图卷积神经网络 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 图卷积神经网络<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/MachineLearning/图神经网络/图卷积神经网络.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-05-18 14:41:55" itemprop="dateCreated datePublished" datetime="2019-05-18T14:41:55+08:00">2019-05-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-28 18:06:58" itemprop="dateModified" datetime="2020-02-28T18:06:58+08:00">2020-02-28</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MachineLearning/图神经网络/" itemprop="url" rel="index"><span itemprop="name">图神经网络</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>26k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>大概一个月前，老师给我分的方向是图神经网络。研一已经快过完了，我自己还没有确定好自己的研究方向。只知道自己想做技术，但是具体什么技术并没有想法，既然老师给分了这个方向，再加上自身也觉得图神经网络在推荐系统、半监督学习等领域有很大的发展前景，所以扎深这个领域也没什么。个人感觉研究生不像博士，没有那么专一，可以接触的范围广点，关键在于构建起自己的知识体系吧和思考吧。</p><p>看图神经网络已经一个星期了，还处于不知道所以云的地步，但是俗话说：“无用之用。”在研究图神经网络路上，本身对傅里叶分析、数字信号处理、卷积操作有了更加深刻的理解。</p><p>不说那么多了，边总结(复制)边学习图神经网络吧。下面的主要内容均来自网上，加上自身的一些思考。</p><h2 id="CNN中的卷积"><a href="#CNN中的卷积" class="headerlink" title="CNN中的卷积"></a>CNN中的卷积</h2><p>了解GCN之前必须对离散卷积（或者说CNN中的卷积）有一个明确的认识：</p><p>在之前我们讨论过：离散卷积的运算本质为<strong>加权求和</strong>；从频域来看，实质为<strong>是提取图像不同『频段』的特征。</strong></p><p>那么卷积核的系数如何确定的呢？是随机化初值，然后根据误差函数通过反向传播梯度下降进行迭代优化。这是一个关键点，<strong>卷积核的参数通过优化求出才能实现特征提取的作用，GCN的理论很大一部分工作就是为了引入可以优化的卷积参数。</strong></p><h2 id="为什么要研究GCN"><a href="#为什么要研究GCN" class="headerlink" title="为什么要研究GCN"></a>为什么要研究GCN</h2><p>CNN是Computer Vision里的大法宝，效果为什么好呢？原因为CNN可以很有效地提取空间特征。但是有一点需要注意：<strong>CNN处理的图像或者视频数据中像素点（pixel）是排列成成很整齐的矩阵</strong>（如下图所示，也就是很多论文中所提到的Euclidean Structure）。</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-85d93d60cb11dddd64a288bff6688cfc_hd.jpg" alt></p><p>与之相对应，科学研究中还有很多Non Euclidean Structure的数据，如下图所示。社交网络、信息网络中有很多类似的结构。</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-f940bce70fb412c75c43ec239b76ee88_hd.jpg" alt></p><p>实际上，这样的网络结构（Non Euclidean Structure）就是图论中抽象意义上的拓扑图。</p><p>所以，<strong>Graph Convolutional Network中的Graph是指数学（图论）中的用顶点和边建立相应关系的拓扑图。</strong></p><p>那么为什么要研究GCN？原因有三：</p><p><strong>(1)</strong>CNN无法处理Non Euclidean Structure的数据，学术上的表达是传统的离散卷积（如问题1中所述）<strong>在Non Euclidean Structure的数据上无法保持平移不变性</strong>。通俗理解就是在拓扑图中每个顶点的相邻顶点数目都可能不同，那么当然无法用一个同样尺寸的卷积核来进行卷积运算。</p><p><strong>(2)</strong>由于CNN无法处理Non Euclidean Structure的数据，又<strong>希望在这样的数据结构（拓扑图）上有效地提取空间特征来进行机器学习</strong>，所以GCN成为了研究的重点。</p><p><strong>(3)</strong>读到这里大家可能会想，自己的研究问题中没有拓扑结构的网络，那是不是根本就不会用到GCN呢？其实不然，<strong>广义上来讲任何数据在赋范空间内都可以建立拓扑关联，谱聚类就是应用了这样的思想</strong>（<a href="https://www.cnblogs.com/pinard/p/6221564.html" target="_blank" rel="noopener">谱聚类（spectral clustering）原理总结</a>）。<strong>所以说拓扑连接是一种广义的数据结构，GCN有很大的应用空间。</strong></p><p>综上所述，GCN是要为除CV、NLP之外的任务提供一种处理、研究的模型。</p><h2 id="提取拓扑图空间特征的两种方式"><a href="#提取拓扑图空间特征的两种方式" class="headerlink" title="提取拓扑图空间特征的两种方式"></a>提取拓扑图空间特征的两种方式</h2><p><strong>GCN的本质目的就是用来寻找适用于图的可学习卷积核提取拓扑图的空间特征</strong>，那么实现这个目标只有graph convolution这一种途径吗？当然不是，在vertex domain(spatial domain，空域)和spectral domain(频域)实现目标是两种最主流的方式。通俗点解释，空域可以类比到直接在图片的像素点上进行卷积，而频域可以类比到对图片进行傅里叶变换后，再进行卷积。</p><p>基于空域卷积的方法直接将卷积操作定义在每个结点的连接关系上，它跟传统的卷积神经网络中的卷积更相似一些。在这个类别中比较有代表性的方法有 Message Passing Neural Networks(MPNN), GraphSage, Diffusion Convolution Neural Networks(DCNN), PATCHY-SAN[4]等。</p><p>基于频域卷积的方法则从图信号处理起家，包括 Spectral CNN, Cheybyshev Spectral CNN(ChebNet), 和 First order of ChebNet(1stChebNet)等。</p><h2 id="vertex-domain-spatial-domain，空域"><a href="#vertex-domain-spatial-domain，空域" class="headerlink" title="vertex domain(spatial domain，空域)"></a>vertex domain(spatial domain，空域)</h2><p><strong>vertex domain</strong>(spatial domain，空域)是非常直观的一种方式。从设计理念上看，空域卷积与深度学习中的卷积的应用方式类似，其核心在于<strong>聚合邻居结点的信息</strong>。</p><p>顾名思义：提取拓扑图上的空间特征，那么就把每个顶点相邻的neighbors找出来。这里面蕴含的科学问题有二：</p><ul><li>按照什么条件去找中心vertex的neighbors，也就是如何确定receptive field？</li><li>确定receptive field，按照什么方式处理包含不同数目neighbors的特征？</li></ul><p>根据这两个问题设计算法，就可以实现目标了。推荐阅读这篇文章<a href="http://proceedings.mlr.press/v48/niepert16.pdf" target="_blank" rel="noopener">Learning Convolutional Neural Networks for Graphs</a>（下面是其中一张图片，可以看出大致的思路）。</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-22e5b58b959d22eaf838ed4238ec2716_hd.jpg" alt></p><p>这种方法主要的缺点如下：</p><ul><li>每个顶点提取出来的neighbors不同，使得计算处理必须针对每个顶点</li><li>提取特征的效果可能没有卷积好</li></ul><p>再比如说，一种最简单的<strong>无参卷积</strong>方式可以是：将所有直连邻居结点的隐藏状态加和，来更新当前结点的隐藏状态。</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/o_image-12-basic-spatial-conv.png" alt="最简单的空域卷积" style="zoom:67%"></p><blockquote><p>这里非参式的卷积只是为了举一个简单易懂的例子，<strong>实际上图卷积在建模时需要的都是带参数、可学习的卷积核。</strong></p></blockquote><h3 id="消息传递网络-Message-Passing-Neural-Network"><a href="#消息传递网络-Message-Passing-Neural-Network" class="headerlink" title="消息传递网络(Message Passing Neural Network)"></a>消息传递网络(Message Passing Neural Network)</h3><p>严格意义上讲，MPNN不是一种具体的模型，而是一种空域卷积的形式化框架。它将空域卷积分解为两个过程：<strong>消息传递</strong>与<strong>状态更新</strong>操作，分别由$M_{l}(\cdot)$和$U_{l}(\cdot)$函数完成。将结点$v$的特征$\mathbf{x}_v$作为其隐藏状态的初始态$\mathbf{h}_{v}^0$后，空域卷积对隐藏状态的更新由如下公式表示：</p><script type="math/tex;mode=display">
\mathbf{h}_{v}^{l+1}=U_{l+1}(\mathbf{h}_v,\sum_{u{\in}ne[v]}M_{l+1}(\mathbf{h}_v^l,\mathbf{h}_u^l,\mathbf{x}_{v},\mathbf{x}_{u}))</script><p><strong>其中$l$代表图卷积的第$l$层，</strong>上式的物理意义是：收到来自每个邻居的的消息$M_{l+1}$后，每个结点如何更新自己的状态。</p><p>你可能会觉得这个公式与GGNN的公式很像。实际上，它们是截然不同的两种方式：<strong>GCN中通过级联的层捕捉邻居的消息，GNN通过级联的时间来捕捉邻居的消息；前者层与层之间的参数不同，后者可以视作层与层之间共享参数。</strong>MPNN的示意图如下：</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/o_image-13-mpnn.png" alt="MPNN网络模型" style="zoom:80%"></p><h3 id="图采样与聚合-Graph-Sample-and-Aggregate"><a href="#图采样与聚合-Graph-Sample-and-Aggregate" class="headerlink" title="图采样与聚合(Graph Sample and Aggregate)"></a>图采样与聚合(Graph Sample and Aggregate)</h3><p>MPNN很好地概括了空域卷积的过程，但定义在这个框架下的所有模型都有一个共同的缺陷：卷积操作针对的对象是<strong>整张图</strong>，也就意味着要将所有结点放入内存/显存中，才能进行卷积操作。但对实际场景中的大规模图而言，整个图上的卷积操作并不现实。GraphSage提出的动机之一就是解决这个问题。从该方法的名字我们也能看出，区别于传统的全图卷积，GraphSage利用<strong>采样</strong>(Sample)部分结点的方式进行学习。当然，即使不需要整张图同时卷积，GraphSage仍然需要聚合邻居结点的信息，即论文中定义的<em>aggregate</em>的操作。这种操作类似于MPNN中的<strong>消息传递</strong>过程。</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/o_image-14-graphsage.jpg" alt="GraphSage采样过程" style="zoom:80%"></p><p>具体地，GraphSage中的采样过程分为三步:</p><ol><li>在图中随机采样若干个结点，结点数为传统任务中的<code>batch_size</code>。对于每个结点，随机选择固定数目的邻居结点(这里邻居不一定是一阶邻居，也可以是二阶邻居)构成进行卷积操作的图。</li><li>将邻居结点的信息通过$aggregate$函数聚合起来更新刚才采样的结点。</li><li>计算采样结点处的损失。如果是无监督任务，我们希望图上邻居结点的编码相似；如果是监督任务，即可根据具体结点的任务标签计算损失。</li></ol><p>最终，GraphSage的状态更新公式如下：</p><script type="math/tex;mode=display">
\mathbf{h}_{v}^{l+1}=\sigma(\mathbf{W}^{l+1}\cdot aggregate(\mathbf{h}_v^l,\{\mathbf{h}_u^l\}),{\forall}u{\in}ne[v])</script><p>GraphSage的设计重点就放在了$aggregate$函数的设计上。它可以是不带参数的$max$, $mean$, 也可以是带参数的如$LSTM$等神经网络。核心的原则仍然是，它需要可以处理变长的数据。卷积神经网络中针对图任务的<code>ReadOut</code>操作，$aggregate$函数的设计与其有异曲同工之妙，此处就不展开叙述了。</p><h3 id="图结构序列化-PATCHY-SAN"><a href="#图结构序列化-PATCHY-SAN" class="headerlink" title="图结构序列化(PATCHY-SAN)"></a>图结构序列化(PATCHY-SAN)</h3><p>之前曾提到卷积神经网络不能应用在图结构上是因为图是非欧式空间，所以大部分算法都沿着<strong>找到适用于图</strong>的卷积核这个思路来走。而 PATCHY-SAN 算法另辟蹊径，它将图结构转换成了序列结构，然后直接利用卷积神经网络在转化成的序列结构上做卷积。由于 PATCHY-SAN在其论文中主要用于图的分类任务，下面的计算过程也主要针对图分类问题(例如，判断某个社群的职业)。</p><p>那么，图结构转换成序列结构最主要的挑战在何处呢，如果简单的话，为什么以前的工作没有尝试把图转成序列结构呢？就笔者个人的观点来看，这种序列转换要保持图结构的两个特点：1. 同构的性质。 2. 邻居结点的连接关系。对于前者而言，意味着当我们把图上结点的标号随机打乱，得到的仍应是一样的序列。简单来说就是，同构图产生的序列应当相似，甚至一样；对于后者，则意味着我们要保持邻居结点与目标结点的距离关系，如在图中的三阶邻居在序列中不应该成为一阶邻居等。</p><p>PATCHY-SAN 通过以下三个步骤来解决这两个问题：</p><ol><li><strong>结点选择(Node Squenece Selection)</strong>。该过程旨在与通过一些人为定义的规则(如度大的结点分数很高，邻居的度大时分数较高等)为每个结点指定一个在图中的排序。在完成排序后，取出前 $\omega$ 个结点作为整个图的代表。</li><li><strong>邻居结点构造(Neighborhood graph construction)</strong>。在完成结点排序后，以第1步选择的结点为中心，得到它们的邻居(这里的邻居可以是第一阶邻居，也可以是二阶邻居)结点，就构成了 $\omega$ 个团。根据第1步得到的结点排序对每个团中的邻居结点进行排序，再取前 $k$ 个邻居结点按照顺序排列，即组成 $\omega$ 个有序的团。</li><li><strong>图规范化(Graph Noermalization)</strong>。按照每个团中的结点顺序可将所有团转换成固定长度的序列($k+1$)，再将它们按照中心结点的排序从前到后依次拼接，即可得到一个长度为 ${\omega}*(k+1)$ 的代表整张图的序列。这样，我们就可以直接使用带1D的卷积神经网络对该序列建模，比如图分类(可类比文本序列分类)。值得注意的一点是，在第1步和第2步中，如果取不到 $\omega$ 或 $k$ 个结点时，要使用空结点作填充(padding)。</li></ol><p>一个形象的流程图如下所示：</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/o_image-14-pathcy-san-framework.png" alt="Pathcy-san framework"></p><p>下图可能可以帮助读者更好地理解这种算法。</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/o_image-15-pathcy-san-detail.png" alt="Patchy-san 具体样例" style="zoom:67%"></p><h2 id="spectral-domain"><a href="#spectral-domain" class="headerlink" title="spectral domain"></a>spectral domain</h2><p>空域卷积非常直观地借鉴了图像里的卷积操作，但它缺乏一定的理论基础。而频域卷积则不同，相比于空域卷积而言，它主要利用的是<strong>图傅里叶变换(Graph Fourier Transform)</strong>实现卷积。简单来讲，它利用图的<strong>拉普拉斯矩阵(Laplacian matrix)</strong>导出其频域上的的拉普拉斯算子，再类比频域上的欧式空间中的卷积，导出图卷积的公式。虽然公式的形式与空域卷积非常相似，但频域卷积的推导过程却有些艰深晦涩。</p><p><strong>spectral domain</strong>就是GCN的理论基础了。这种思路就是希望借助图谱的理论来实现拓扑图上的卷积操作。从整个研究的时间进程来看：首先研究GSP（graph signal processing）的学者定义了graph上的Fourier Transformation，进而定义了graph上的convolution，最后与深度学习结合提出了Graph Convolutional Network。</p><p>认真读到这里，脑海中应该会浮现出一系列问题：</p><p>Q1 什么是spectral（谱）</p><p>个人理解谱就是拉普拉斯矩阵的特征值。在数值分析中也学到过，矩阵$A_{n \times n}$的特征值为$\lambda_i(i=1,2,…,n)$，称$\rho (A)=max_{1 \leq i \leq n }\mid \lambda_i \mid$为$A$的谱半径，即$A$的谱半径为其最大特征值。</p><p>Q2 什么是spectral domain？</p><p>个人理解spectral domain为拉普拉斯矩阵$n$个线性无关的特征向量组成的空间。</p><p>Q2 什么是Spectral graph theory？</p><p><a href="https://en.wikipedia.org/wiki/Spectral_graph_theory" target="_blank" rel="noopener">Spectral graph theory</a>请参考这个，简单的概括就是<strong>借助于图的拉普拉斯矩阵的特征值和特征向量来研究图的性质。</strong>个人理解为将拓扑图空间域(spatial domain)映射到谱域，类似于傅里叶变换将时域映射到频域一样。实质方法为<strong>基变换（分解）</strong>。</p><p>Q3 GCN为什么要利用Spectral graph theory？</p><p>这应该是看论文过程中读不懂的核心问题了，要理解这个问题需要大量的数学定义及推导，没有一定的数学功底难以驾驭（我也才疏学浅，很难回答好这个问题）。</p><p>所以，先绕过这个问题，来看Spectral graph实现了什么，再进行探究为什么？</p><h2 id="拉普拉斯矩阵"><a href="#拉普拉斯矩阵" class="headerlink" title="拉普拉斯矩阵"></a>拉普拉斯矩阵</h2><p>Graph Fourier Transformation及Graph Convolution的定义都用到图的拉普拉斯矩阵，那么首先来介绍一下拉普拉斯矩阵。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于一个图$G$，我们一般用点的集合$V$和边的集合$E$来描述。即为$G(V,E)$。其中$V$即为我们数据集里面所有的<strong>点</strong>$(v_1,v_2,…v_n)$。对于$V$中的任意两个点，可以有边连接，也可以没有边连接。我们定义权重$A_{ij}$为点$v_i$和点$v_j$之间的权重。若为无向图，则$A_{ij}=A_{ji}$。 对于有边连接的两个点$v_i$和$v_j$，$A_{ij} &gt; 0$，对于没有边连接的两个点$v_i$和$v_j$，$A_{ij} =0$。对于图中的任意一个点$v_i$，它的<strong>度$d_i$</strong>定义为和它相连的所有边的权重之和，即</p><script type="math/tex;mode=display">
\begin{eqnarray}d_i =\sum\limits_{j=1}^{n}A_{ij}\end{eqnarray}</script><p>利用每个点度的定义，我们可以得到一个$n \times n$<strong>的度矩阵$D$</strong>,它是一个<strong>对角矩阵</strong>，只有主对角线有值，对应第$i$行的第$i$个点的度数，定义如下：</p><script type="math/tex;mode=display">
\begin{eqnarray}\mathbf{D} = \left( \begin{array}{ccc} d_1 & \ldots & \ldots \\ \ldots & d_2 & \ldots \\   \vdots & \vdots & \ddots \\   \ldots & \ldots & d_n \end{array} \right)\end{eqnarray}</script><p>利用所有点之间的权重值，我们可以得到<strong>图的邻接矩阵$A$</strong>，它也是一个$n \times n$的矩阵，第$i$行的第$j$个值对应我们的权重$A_{ij}$。</p><p>图$G$的Laplacian 矩阵的定义为$L=D-A$，其中 $L$ 是Laplacian 矩阵，$D$ 是顶点的度矩阵（对角矩阵），对角线上元素依次为各个顶点的度， $A$ 是图的邻接矩阵。看下图的示例，就能很快知道Laplacian 矩阵的计算方法。</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-5f9cf5fdeed19b63e1079ed2b87617b4_hd.jpg" alt></p><p>这里要说明的是：<strong>常用的拉普拉斯矩阵实际有三种：</strong></p><p>No.1 $L=D-A$定义的Laplacian 矩阵更专业的名称叫<strong>Combinatorial Laplacian</strong>。该矩阵是对称矩阵。</p><p>No.2 $L^{sys}=D^{-1/2}LD^{-1/2}=I-D^{-1/2}AD^{-1/2}$ 定义的叫<strong>Symmetric normalized Laplacian</strong>，很多GCN的论文中应用的是这种拉普拉斯矩阵。也就是说该拉普拉斯矩阵是对称矩阵，其中的元素可以由下面公式计算可得：</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/1364088-20200117161036130-648804868.png" alt="img"></p><p>No.3 $L^{rw}=D^{-1}L$定义的叫<strong>Random walk normalized Laplacian</strong>，有读者的留言说看到了<strong>Graph Convolution与Diffusion相似之处</strong>，当然从Random walk normalized Laplacian就能看出了两者确有相似之处（<strong>其实两者只差一个相似矩阵的变换</strong>，可以参考<a href="https://arxiv.org/abs/1511.02136" target="_blank" rel="noopener">Diffusion-Convolutional Neural Networks</a>，以及下图）。也就是说该拉普拉斯矩阵不是对称矩阵，其中的元素可以由下面公式计算可得：</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/1364088-20200117161108593-2145587323.png" alt="img"></p><p><strong>不需要相关内容的读者可以略过此部分</strong></p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-87d2a1539a2976e3b9f70119427e9d2a_hd.jpg" alt></p><p>其实维基本科对<a href="https://en.wikipedia.org/wiki/Laplacian_matrix" target="_blank" rel="noopener">Laplacian matrix</a>的定义上写得很清楚，<strong>国内的一些介绍中只有第一种定义</strong>。这让我在最初看文献的过程中感到一些的困惑，特意写下来，帮助大家避免再遇到类似的问题。</p><h3 id="为什么要使用拉普拉斯矩阵"><a href="#为什么要使用拉普拉斯矩阵" class="headerlink" title="为什么要使用拉普拉斯矩阵"></a>为什么要使用拉普拉斯矩阵</h3><p>以下均是我的或者网上一些理解，当然严格意义上，拉普拉斯矩阵应用于GCN有严谨的数学推导与证明。</p><h4 id="物理含义角度"><a href="#物理含义角度" class="headerlink" title="物理含义角度"></a>物理含义角度</h4><p>要探究拉普拉斯矩阵的物理含义，需要从他的方程式入手，以$L=D-A$为例，解释为何拉普拉斯矩阵为何要这么定义。</p><p>拉普拉斯算子数学定义是这样的：</p><script type="math/tex;mode=display">
\begin{eqnarray}\triangle = \sum_i\frac {\delta^2} {\delta x_i^2}\end{eqnarray}</script><p>其含义很明确，是<strong>非混合二阶偏导数的和</strong>！</p><blockquote><p>混合偏导：如二元函数，则先对第一个变量求导，其结果再对第二个变量求导，就可以得到混合偏导数。而非混合偏导：如二元函数，只针对某个变量求二次偏导。</p></blockquote><p>要明白这个是其严谨的数学定义，所有的其他拉普拉斯算子都是其一个特例，或是某种情况下的一种近似。</p><p>我们首先看看图像上怎么近似的，图像是一种离散数据，那么其拉普拉斯算子必然要进行离散化。</p><p>从导数定义说起</p><script type="math/tex;mode=display">
\begin{eqnarray}\begin{aligned} f'(x) &= \frac {\delta f(x)}{\delta x}\\ &\approx f(x+1)-f(x)\\ \end{aligned}\end{eqnarray}</script><p>那么:</p><script type="math/tex;mode=display">
\begin{eqnarray}\begin{aligned} \frac {\delta^2 f(x)}{\delta x^2} &= f''(x) \\ &\approx f'(x)-f'(x-1) \\ &\approx f(x+1)-f(x) - (f(x) - f(x-1))\\ &=f(x+1)+f(x-1)-2f(x) \end{aligned}\end{eqnarray}</script><p><strong>结论1：二阶导数近似等于其二阶差分。</strong></p><p><strong>结论2：二阶导数等于其在所有自由度上微扰之后获得的增益。</strong>一维函数其自由度可以理解为2，分别是+1和-1两个方向。</p><p>对于二维的图像来说，其有两个方向（4个自由度）可以变化，即如果对$(x,y)$处的像素进行扰动，其可以变为四种状态$(x+1,y)，(x-1,y)，(x,y+1)，(x,y-1)$。当然了，如果将对角线方向也认为是一个自由度的话，会再增加几种状态$(x+1,y+1)，(x+1,y-1)，(x-1,y+1)，(x-1,y-1)$，事实上图像处理上正是这种。再当然了，如果你认为对一个像素进行微扰可能变为任何一个像素，那它的自由度就是整个图片的像素数（不过这还叫微扰吗？）。其实结论差不多，就讨论第一种吧。</p><script type="math/tex;mode=display">
\begin{eqnarray}\begin{aligned} \triangle &=\frac {\delta^2 f(x,y)}{\delta x^2} + \frac {\delta^2 f(x,y)}{\delta y^2} \\ &\approx f(x+1,y)+f(x-1,y)-2f(x,y) + [f(x,y+1)+f(x,y-1)-2f(x,y)]\\ &= f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y) \end{aligned}\end{eqnarray}</script><p>上式可以理解为，在图像上某一点，其拉普拉斯算子的值，即为对其进行扰动，使其变化到相邻像素后得到的增益。</p><p>图像处理中的拉普拉斯算子写成矩阵形式，更加方便理解。</p><script type="math/tex;mode=display">
\left[ \begin{array} { c c c } { 0} & { - 1 } & { 0} \\ { -1 } & { 4 } & { - 1 } \\ { 0 } & { - 1 } & { 0 } \end{array} \right]</script><p>这给我们一种形象的结论：<strong>图像处理中的拉普拉斯算子就是某一点在所有自由度上进行微小变化后获得的增益。</strong></p><p>讨论过图像上的拉普拉斯算子的物理含义后，我们扩展到graph，探索在graph上拉普拉斯算子的物理含义。</p><p>那么推广到Graph，对于有$V$个节点的Graph，就设节点为 $1,…,V$吧，且其邻接矩阵为$A$。</p><p>这个Graph的自由度是多少呢？<strong>答案是最多为$V$</strong>。</p><p>因为如果该图是一个完全图，即任意两个节点之间都有一条边，那么对一个节点进行微扰，<strong>它可能变成任意一个节点。</strong></p><p>那么上面的函数$f$就理所当然是一个$V$维的向量，即：</p><script type="math/tex;mode=display">
\begin{eqnarray}f = (f_1,...,f_V)\end{eqnarray}</script><p>其中$f_i$即表示函数$f$在节点$i$的值。类比$f(x,y)$即为$f$在$(x,y)$处的值。</p><p>对于任意节点$i$进行微扰，它可能变为任意一个与他相邻的节点$j\in\mathcal{N_i}$，其中$\mathcal{N_i}$表示节点i的一阶邻域节点。</p><p>我们上面结论说了，拉普拉斯算子就是在所有自由度上进行微小变化后获得的增益。</p><p>但是对于Graph，从节点$i$变化到节点$j$增益是多少呢？即$f_j-f_i$是多少呢？最容易想到就是和他们之间的边权相关。那就姑且当成$A_{ij}$吧！</p><p><strong>那么，对于节点i来说，其变化的增益就是</strong> $\sum_{j\in\mathcal{N}_i}A_{ij}[f_j-f_i]$</p><p>所以，对于Graph来说，其拉普拉斯算子如下：</p><script type="math/tex;mode=display">
\begin{eqnarray}\begin{aligned} (\triangle f)_i &=\sum_i \frac {\delta^2 f} {\delta i^2}\\ &\approx \sum_{j\in\mathcal{N}_i}A_{ij}[f_j-f_i] \end{aligned}\end{eqnarray}</script><p>上式 $j\in\mathcal{N}_i$可以去掉，因为节点$i$和$j$不直接相邻的话，$A_{ij} = 0$;</p><p>继续化简一下：</p><script type="math/tex;mode=display">
\begin{eqnarray}\begin{aligned} \sum_{j\in\mathcal{N}_i}A_{ij}[f_j-f_i]&=\sum_{j}A_{ij}f_j - \sum_{j}A_{ij}f_i\\ &=(Af)_i - (Df)_i \\ &=[(A-D)f]_i \end{aligned}\end{eqnarray}</script><p>即:</p><script type="math/tex;mode=display">
\begin{eqnarray} (\triangle f)_i =[(A-D)f]_i \end{eqnarray}</script><p>对于任意的$i$成立，那么也就是：</p><script type="math/tex;mode=display">
\begin{eqnarray}\triangle f \equiv(A-D)f\end{eqnarray}</script><p><strong>也就是图上的拉普拉斯算子应该定义为$A-D$!</strong></p><blockquote><p>注: 以上没有特别严谨的数学推导，甚至数学表达式都不太严谨，主要源于类比+简单推导，主要想说清楚图上拉普拉斯算子为啥这么定义。另外为何是$A-D$而不是$D-A$，我也不是很明白。</p></blockquote><p>关于<strong>Symmetric normalized Laplacian</strong>：$L^{sys}=D^{-1/2}LD^{-1/2}=I-D^{-1/2}AD^{-1/2}$。观察<strong>Combinatorial Laplacian</strong>$L$的形式，可以看出来，每一行$i$之和均为0，且最大元素为$D_i$，所以使用$L$左乘和右乘对角矩阵$D^{-1/2}$相当于对$L$进行归一化。这样做的好处是<strong>防止梯度弥散或者梯度爆炸</strong>。<strong>Random walk normalized Laplacian</strong>：$L^{rw}=D^{-1}L$同理。</p><p><strong>总结：</strong></p><ul><li>从拉普拉斯算子的定义形式来看，$D$为拓扑图的度矩阵，而$A$为邻接矩阵，拉普拉斯矩阵$D-L$综合了两个矩阵的信息，更能从空间的表现出拓扑图的结构。<del>类似于信号与系统中使用$f(t)$表示信号时域特征，我们可以使用拉普拉斯矩阵$L$表征graph的拓扑结构。</del></li><li>拉普拉斯矩阵就是某一点在所有自由度上进行微小变化后获得的增益，对于图神经网络而言，最重要的是利用节点之间的关系去相互影响，所以拉普拉斯矩阵也比较适合用来描述图节点之间的相互作用关系。</li></ul><h4 id="数学角度"><a href="#数学角度" class="headerlink" title="数学角度"></a>数学角度</h4><p>拉普拉斯矩阵有一些很好的性质如下：</p><ul><li>拉普拉斯矩阵是对称矩阵，这可以由$D$和$A$（无向图）都是对称矩阵而得。对称矩阵一定<strong>有$n$个线性无关的特征向量</strong>，特征向量相互正交，即所有特征向量构成的矩阵为正交矩阵。因此可以将<strong>图的$n$个顶点上的值进行特征分解（谱分解）</strong>，这就和GCN的spectral domain对应上了。</li><li>拉普拉斯矩阵只在<del>中心</del>顶点和一阶相连的顶点上（1-hop neighbor）有非0元素，其余之处均为0</li><li>由于拉普拉斯矩阵是对称矩阵，则它的所有的特征值都是实数。</li></ul><p><img src="/MachineLearning/图神经网络/图卷积神经网络/b0f16185-12ef-4d65-b34c-cf8106362af5.jpg" alt></p><ul><li>对于任意的向量$f$,我们有</li></ul><script type="math/tex;mode=display">
\begin{eqnarray}f^TLf =\frac{1}{2}\sum\limits_{i,j=1}^{n}w_{ij}(f_i- f_j)^2\end{eqnarray}</script><p>这个利用拉普拉斯矩阵的定义很容易得到如下：</p><script type="math/tex;mode=display">
\begin{eqnarray}\begin{aligned} f^TLf = f^TDf - f^TWf = \sum\limits_{i=1}^{n}d_if_i^2 -\sum\limits_{i,j=1}^{n}w_{ij}f_if_j\\=\frac{1}{2}(
\sum\limits_{i=1}^{n}d_if_i^2 - 2 \sum\limits_{i,j=1}^{n}w_{ij}f_if_j +
\sum\limits_{j=1}^{n}d_jf_j^2) = \frac{1}{2}\sum\limits_{i,j=1}^{n}w_{ij}(f_i-f_j)^2\end{aligned}\end{eqnarray}</script><ul><li>拉普拉斯矩阵是半正定的，且对应的n个实数特征值都大于等于0，即$0 =\lambda_1 \leq \lambda_2 \leq… \leq \lambda_n$， 且最小的特征值为0，这个由性质3很容易得出。</li></ul><h2 id="拉普拉斯矩阵的谱分解（特征分解）"><a href="#拉普拉斯矩阵的谱分解（特征分解）" class="headerlink" title="拉普拉斯矩阵的谱分解（特征分解）"></a>拉普拉斯矩阵的谱分解（特征分解）</h2><p>GCN的核心基于拉普拉斯矩阵的谱分解，文献中对于这部分内容没有讲解太多，初学者可能会遇到不少误区，所以先了解一下特征分解。</p><p><strong>矩阵的谱分解，特征分解，对角化都是同一个概念</strong>（<a href="https://baike.baidu.com/item/%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3/12522621?fr=aladdin" target="_blank" rel="noopener">特征分解_百度百科</a>）。</p><p><strong>不是所有的矩阵都可以特征分解</strong>，其充要条件为$n$阶方阵存在$n$个线性无关的特征向量。</p><p><strong>但是拉普拉斯矩阵是半正定对称矩阵</strong>（半正定矩阵本身就是对称矩阵，<a href="https://baike.baidu.com/item/%E5%8D%8A%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5/2152711?fr=aladdin" target="_blank" rel="noopener">半正定矩阵_百度百科</a>，此处这样写为了和下面的性质对应，避免混淆），有如下三个性质：</p><ul><li><strong>对称矩阵一定n个线性无关的特征向量</strong></li><li><strong>半正定矩阵的特征值一定非负</strong></li><li><strong>对阵矩阵的特征向量相互正交，即所有特征向量构成的矩阵为正交矩阵。</strong></li></ul><p>由上可以知道拉普拉斯矩阵一定可以谱分解，且分解后有特殊的形式。</p><p>对于拉普拉斯矩阵其谱分解为：</p><script type="math/tex;mode=display">
\begin{eqnarray} L= U\left(\begin{matrix}\lambda_1 & \\&\ddots \\ &&\lambda_n \end{matrix}\right) U^{-1}\end{eqnarray}</script><p>其中$U=(\vec{u_1},\vec{u_2},\cdots,\vec{u_n})$，是<strong>列向量</strong>为单位特征向量的矩阵，<strong>也就说$\vec{u_l}$ 是单位列向量</strong>。</p><p>$\left(\begin{matrix}\lambda_1 &amp; \\&amp;\ddots \\ &amp;&amp;\lambda_n \end{matrix}\right)$ 是$n$个特征值构成的对角阵。</p><p>由于$U$正交矩阵，即$UU^{T}=E$</p><p>所以特征分解又可以写成：</p><script type="math/tex;mode=display">
\begin{eqnarray}L= U\left(\begin{matrix}\lambda_1 & \\&\ddots \\ &&\lambda_n \end{matrix}\right) U^{T}\end{eqnarray}</script><p><strong>文献中都是最后导出的这个公式，但大家不要误解，特征分解最右边的是特征矩阵的逆，只是拉普拉斯矩阵的性质才可以写成特征矩阵的转置。</strong></p><p>其实从上可以看出：整个推导用到了很多数学的性质，在这里写得详细一些，避免大家形成错误的理解。</p><h2 id="推广傅里叶变换、卷积"><a href="#推广傅里叶变换、卷积" class="headerlink" title="推广傅里叶变换、卷积"></a>推广傅里叶变换、卷积</h2><p><strong>把传统的傅里叶变换以及卷积迁移到Graph上来，核心工作其实就是把拉普拉斯算子的特征函数$e^{-i\omega t}$ 变为Graph对应的拉普拉斯矩阵的特征向量</strong>。</p><h3 id="推广傅里叶变换"><a href="#推广傅里叶变换" class="headerlink" title="推广傅里叶变换"></a>推广傅里叶变换</h3><p>想亲自躬行的读者可以阅读<a href="https://arxiv.org/abs/1211.0053" target="_blank" rel="noopener">The Emerging Field of Signal Processing on Graphs: Extending High-Dimensional Data Analysis to Networks and Other Irregular Domains</a>这篇论文，下面是我的理解与提炼：</p><h4 id="Graph上的傅里叶变换"><a href="#Graph上的傅里叶变换" class="headerlink" title="Graph上的傅里叶变换"></a>Graph上的傅里叶变换</h4><p>传统的傅里叶变换定义为：</p><script type="math/tex;mode=display">
\begin{eqnarray}F(\omega)=\mathcal{F}[f(t)]=\int_{}^{}f(t)e^{-i\omega t} dt\end{eqnarray}</script><p>信号$f(t)$与基函数$e^{-i\omega t}$的积分，<strong>那么为什么要找$e^{-i\omega t}$ 作为基函数呢？从数学上看， $e^{-i\omega t}$ 是拉普拉斯算子$\triangle$的本征函数（满足本征方程）, $\omega$ 就和特征值有关。</strong></p><p>广义的本征方程定义为：</p><script type="math/tex;mode=display">
\begin{eqnarray} A V=\lambda V\end{eqnarray}</script><p>其中$A$ 是一种线性变换，$V$是本征函数（当$A$为矩阵时，$V$为特征向量），$\lambda$是特征值。</p><p>$e^{-i\omega t}$满足：</p><script type="math/tex;mode=display">
\begin{eqnarray} \Delta e^{-i\omega t}=\frac{\partial^{2}}{\partial t^{2}} e^{-i\omega t}=-\omega^{2} e^{-i\omega t}\end{eqnarray}</script><p><strong>当然$e^{-i\omega t}$ 就是拉普拉斯变换$\Delta$的特征函数，</strong> $\omega$ 和特征值密切相关<strong>。</strong></p><p>另外，考虑到广义上的内积是一种投影，则式子$({16})$还可以写成下面内积的形式：</p><script type="math/tex;mode=display">
\begin{eqnarray}F(w) = \frac{\left\langle f(t),e^{jwt} \right>}{\left< e^{jwt},e^{jwt}\right>}\end{eqnarray}</script><blockquote><p>这里不给出证明，因为暂时我还不清楚积分区间$[-\infty,\infty]$的函数内积的定义。</p></blockquote><p>那么，可以联想了，<strong>处理Graph问题的时候，用到拉普拉斯矩阵</strong>（拉普拉斯矩阵就是离散拉普拉斯算子，想了解更多可以参考<a href="https://en.wikipedia.org/wiki/Discrete_Laplace_operator" target="_blank" rel="noopener">Discrete Laplace operator</a>），<strong>自然就去找拉普拉斯矩阵的特征向量了。</strong></p><blockquote><p>其实，在之前我们对傅里叶变换的深层次思考之后，得到结论所谓傅里叶变换就是将时域信号分解到一组完备正交基上，而式子$({16})$就是分解到完备正交基的系数。所以推广到图领域，Graph上的顶点，类似于我们的时域信号，现在要找到一组完备正交基将其分解，而拉普拉斯矩阵的$n$个特征向量恰好可以组成<strong>Graph上$n$维空间</strong>的一组完备正交基。将拉普拉斯矩阵分解到谱域之后，可以利用时域卷积等于谱域相乘的性质，首先定义谱域中的相乘，然后使用逆傅里叶变换得到时域的卷积。</p></blockquote><p>$L$是拉普拉斯矩阵， $V$是其特征向量，自然满足下式</p><script type="math/tex;mode=display">
\begin{eqnarray} LV=\lambda V\end{eqnarray}</script><p><strong>离散积分就是一种内积形式，仿上定义Graph上的傅里叶变换：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray}F(\lambda_l) = \frac{\left\langle f,u_l^*\right>}{\left< u_l^*,u_l^*\right>}\end{eqnarray}</script><p>因为$u_l^*$为单位列向量，所以分母为1，也就可以写成下式。</p><script type="math/tex;mode=display">
\begin{eqnarray} F(\lambda_l)=\hat{f}(\lambda_l)=\sum_{i=1}^{N}{f(i) u_l^*(i)}\end{eqnarray}</script><p><strong>$f$是Graph上的 $N$维向量，$f(i)$与Graph的顶点一一对应，</strong> $u_l(i)$<strong>表示第$l$个特征向量的第$i$ 个分量。那么特征值（频率）$\lambda_l$下的，$f$的Graph 傅里叶变换就是与 $\lambda_l$对应的特征向量$u_l$ 进行内积运算。</strong></p><p>注：上述的内积运算是在<strong>复数空间</strong>中定义的，<strong>所以采用了$u_l^*(i)$，也就是特征向量$u_l$的共轭。</strong>Inner product更多可以参考<a href="https://en.wikipedia.org/wiki/Inner_product_space" target="_blank" rel="noopener">Inner product space</a>。</p><p><strong>利用矩阵乘法将Graph上的傅里叶变换推广到矩阵形式：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} \left(\begin{matrix} \hat{f}(\lambda_1)\\ \hat{f}(\lambda_2) \\ \vdots \\\hat{f}(\lambda_N) \end{matrix}\right)=\left(\begin{matrix}\ u_1(1) &u_1(2)& \dots &u_1(N) \\u_2(1) &u_2(2)& \dots &u_2(N)\\ \vdots &\vdots &\ddots & \vdots\\ u_N(1) &u_N(2)& \dots &u_N(N) \end{matrix}\right)\left(\begin{matrix}f(1)\\ f(2) \\ \vdots \\f(N) \end{matrix}\right)\end{eqnarray}</script><p><strong>即 $f$ 在Graph上傅里叶变换的矩阵形式为</strong>：</p><script type="math/tex;mode=display">
\begin{eqnarray} \hat{f}=U^Tf \end{eqnarray}</script><p>式中： $U^T$的定义与第五节中的相同，$f$和$\hat f$均为$N \times 1$的列向量。</p><h4 id="Graph上的傅里叶逆变换"><a href="#Graph上的傅里叶逆变换" class="headerlink" title="Graph上的傅里叶逆变换"></a>Graph上的傅里叶逆变换</h4><p>类似地，<strong>传统的傅里叶逆变换是对频率$\omega$求积分：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} \mathcal{F}^{-1}[F(\omega)]=\frac{1}{2\Pi}\int_{}^{}F(\omega)e^{i\omega t} d\omega\end{eqnarray}</script><p><strong>迁移到Graph上变为对特征值$\lambda_l$求和：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} f(i)=\sum_{l=1}^{N}{\hat{f}(\lambda_l) u_l(i)}\end{eqnarray}</script><p><strong>利用矩阵乘法将Graph上的傅里叶逆变换推广到矩阵形式：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} \left(\begin{matrix}f(1)\\ f(2) \\ \vdots \\f(N) \end{matrix}\right)= \left(\begin{matrix}\ u_1(1) &u_2(1)& \dots &u_N(1) \\u_1(2) &u_2(2)& \dots &u_N(2)\\ \vdots &\vdots &\ddots & \vdots\\ u_1(N) &u_2(N)& \dots &u_N(N) \end{matrix}\right) \left(\begin{matrix} \hat{f}(\lambda_1)\\ \hat{f}(\lambda_2) \\ \vdots \\\hat{f}(\lambda_N) \end{matrix}\right)\end{eqnarray}</script><p><strong>即$f$在Graph上傅里叶逆变换的矩阵形式为：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} f=U\hat{f} \end{eqnarray}</script><p>式中： $U$的定义与第五节中的相同，$f$和$\hat f$均为$N \times 1$的列向量。</p><h3 id="推广卷积"><a href="#推广卷积" class="headerlink" title="推广卷积"></a>推广卷积</h3><p>在上面的基础上，利用<strong>卷积定理</strong>类比来将卷积运算，推广到Graph上。</p><p><strong>卷积定理：函数卷积的傅里叶变换是函数傅立叶变换的乘积，即对于函数</strong> $f(t)$ 与$h(t)$<strong>两者的卷积是其函数傅立叶变换乘积的逆变换：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} f*h=\mathcal{F}^{-1}\left[ \hat{f}(\omega)\hat{h}(\omega) \right]=\frac{1}{2\Pi}\int_{}^{} \hat{f}(\omega)\hat{h}(\omega)e^{i\omega t} d\omega\end{eqnarray}</script><p><strong>类比到Graph上并把傅里叶变换的定义带入， $f$与卷积核$h$ 在Graph上的卷积可按下列步骤求出：</strong></p><p>$f$的傅里叶变换为 $\hat{f}=U^Tf$</p><p><strong>卷积核$h$的傅里叶变换</strong>写成对角矩阵的形式即为：</p><script type="math/tex;mode=display">
\begin{eqnarray} \left(\begin{matrix}\hat h(\lambda_1) & \\&\ddots \\ &&\hat h(\lambda_n) \end{matrix}\right) \end{eqnarray}</script><p>其中，$\hat{h}(\lambda_l)=\sum_{i=1}^{N}{h(i) u_l^<em>(i)}$ 是<em>*根据需要设计的卷积核$h$（大小为$N \times 1$）在Graph上的傅里叶变换。这里将$U^Tg$ 整体看作可学习的卷积核</em></em>。</p><p>两者的傅立叶变换乘积即为：$ \left(\begin{matrix}\hat h(\lambda_1) &amp; \\&amp;\ddots \\ &amp;&amp;\hat h(\lambda_n) \end{matrix}\right)U^Tf$</p><p>再乘以$U$求两者傅立叶变换乘积的逆变换，则求出卷积：</p><script type="math/tex;mode=display">
\begin{eqnarray} (f*h)_G= U\left(\begin{matrix}\hat h(\lambda_1) & \\&\ddots \\ &&\hat h(\lambda_n) \end{matrix}\right) U^Tf \end{eqnarray}</script><p>式中： $U$及$U^{T}$的定义与第五节中的相同</p><p><strong>注：很多论文中的Graph卷积公式为：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} (f*h)_G=U((U^Th)\odot(U^Tf)) \end{eqnarray}</script><p>$\odot$表示hadamard product（哈达马积），对于两个向量，就是进行内积运算；对于维度相同的两个矩阵，就是对应元素的乘积运算。</p><p><strong>其实式(31)与式(32)是完全相同的。</strong></p><p><strong>因为</strong> $\left(\begin{matrix}\hat h(\lambda_1) &amp; \\&amp;\ddots \\ &amp;&amp;\hat h(\lambda_n) \end{matrix}\right)$<strong>与</strong> <strong>$U^Th$都是 $h$ 在Graph上的傅里叶变换</strong></p><p><strong>而根据矩阵乘法的运算规则：对角矩阵</strong> $\left(\begin{matrix}\hat h(\lambda_1) &amp; \\&amp;\ddots \\ &amp;&amp;\hat h(\lambda_n) \end{matrix}\right)$<strong>与 $U^Tf$ 的乘积和$U^Th$ 与 $U^Tf$进行对应元素的乘积运算是完全相同的。</strong></p><p><strong>这里主要推$({31})$式是为了和后面的deep learning相结合。</strong></p><blockquote><p>这部分理论感觉缺乏很严谨的证明，大部分都是按照类比的概念推广的。例如拉普拉斯变换(二阶导)和傅里叶变换有什么关联，为啥拉普拉斯变换的特征函数就可以作为傅里叶变换的基？Graph上的傅里叶逆变换和Graph上的卷积定理均缺乏推导。现在只是大概介绍一下思路，具体细节需要日后再做钻研。</p></blockquote><h2 id="为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？特征值表示频率？"><a href="#为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？特征值表示频率？" class="headerlink" title="为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？特征值表示频率？"></a>为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？特征值表示频率？</h2><h3 id="为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？"><a href="#为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？" class="headerlink" title="为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？"></a>为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？</h3><p>傅里叶变换一个本质理解就是：<strong>把任意一个函数表示成了若干个正交函数（由sin,cos 构成）的线性组合。</strong></p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-e9e00533154bfdad940e966e7eca5075_hd.jpg" alt></p><p>通过第六节中式$({28})$也能看出，<strong>graph傅里叶变换也把graph上定义的任意向量$f$，表示成了拉普拉斯矩阵特征向量的线性组合，即：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} f=\hat{f}(\lambda_1)u_1+\hat{f}(\lambda_2)u_2+\cdots +\hat{f}(\lambda_n)u_n \end{eqnarray}</script><p>那么<strong>：为什么graph上任意的向量$f$都可以表示成这样的线性组合？</strong></p><p><strong>原因在于$(\vec{u_1},\vec{u_2},\cdots,\vec{u_n})$是graph上$n$维空间中的$n$ 个线性无关的正交向量</strong>（原因参看第五节中拉普拉斯矩阵的性质），由线性代数的知识可以知道：$n$维空间中$n$个线性无关的向量可以构成空间的一组基，而且拉普拉斯矩阵的特征向量还是一组<strong>标准正交基</strong>。</p><h3 id="怎么理解拉普拉斯矩阵的特征值表示频率"><a href="#怎么理解拉普拉斯矩阵的特征值表示频率" class="headerlink" title="怎么理解拉普拉斯矩阵的特征值表示频率"></a>怎么理解拉普拉斯矩阵的特征值表示频率</h3><p>在<strong>graph空间上无法可视化展示“频率”</strong>这个概念，那么从<strong>本征方程</strong>上来抽象理解。</p><p>将拉普拉斯矩阵$L$ 的$n$个<strong>非负实特征值，从小到大排列为</strong>$\lambda_1 \le \lambda_2 \le \cdots \le \lambda_n$ ，而且最小的特征值$\lambda_1=0$，因为$n$维的全1向量对应的特征值为0。</p><blockquote><p>虽然矩阵的特征向量不唯一，但是特征值是唯一的。也就是说虽然我们相互正交的特征向量不一定包含全1向量，但是矩阵的特征值一定包含全1向量对应的特征值。</p></blockquote><p><strong>证明：</strong></p><p>$L$的定义为$L=D-A$，其中$D$为度矩阵，其每一个元素$d_i =\sum\limits_{j=1}^{n}A_{ij}$。而$A$为邻接矩阵，因为我们这里讨论的是简单图，即没有自身到自身的连接，所以对角线为0。从而可以看出$L$的每一行之和均为0。所以可得：</p><script type="math/tex;mode=display">
\begin{eqnarray} L \left(\begin{matrix}1\\ 1 \\ \vdots \\1 \end{matrix}\right)=\vec0 \end{eqnarray}</script><p>得证。</p><p><strong>从中可以看出，拉普拉斯矩阵特征值$\lambda_1=0$的时候，特征向量的分一个分量均为常数，变化幅度为0；我们不加证明的给出，越大的特征值对应的特征向量各个分量变化范围越大。在一般的信号傅里叶变换中，基为$e^{-jwt}$，其中的$w$可以表示频率，$w$越大，基的变化越快。类比到图傅里叶变换，特征值表示频率，特征值越大，基$u_l$的变化越快。</strong></p><p><strong>从本征方程的数学理解来看：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} Lu=\lambda u \end{eqnarray}</script><p><strong>在由Graph确定的$n$维空间中，越小的特征值$\lambda_l$表明：拉普拉斯矩阵$L$其所对应的基$u_l$上的分量、“信息”越少，那么当然就是可以忽略的低频部分了。</strong></p><p>其实<strong>图像压缩</strong>就是这个原理<strong>，把像素矩阵特征分解后，把小的特征值（低频部分）全部变成0，PCA降维</strong>也是同样的，<strong>把协方差矩阵特征分解后，按从大到小取出前K个特征值对应的特征向量作为新的“坐标轴”。</strong></p><p>Graph Convolution的理论告一段落了，下面开始Graph Convolution Network</p><h2 id="Deep-Learning中的Graph-Convolution"><a href="#Deep-Learning中的Graph-Convolution" class="headerlink" title="Deep Learning中的Graph Convolution"></a>Deep Learning中的Graph Convolution</h2><p>Deep learning 中的Graph Convolution直接看上去会和第6节推导出的图卷积公式有很大的不同，但是万变不离其宗，$({31})$式是推导的本源。</p><p><strong>第1节的内容已经解释得很清楚：Deep learning 中的Convolution就是要设计含有trainable共享参数的kernel，从$({31})$式看很直观：graph convolution中的卷积参数就是</strong> $diag(\hat h(\lambda_l) )$。</p><h3 id="第一代GCN"><a href="#第一代GCN" class="headerlink" title="第一代GCN"></a>第一代GCN</h3><p><a href="https://arxiv.org/abs/1312.6203" target="_blank" rel="noopener">Spectral Networks and Locally Connected Networks on Graphs</a>中<strong>简单粗暴地把$diag(\hat h(\lambda_l) )$变成了卷积核$diag(\theta_l )$</strong>，也就是：</p><script type="math/tex;mode=display">
\begin{eqnarray} y_{output}=\sigma \left(U g_\theta(\Lambda) U^T x \right) \end{eqnarray}</script><p>其中，$g_\theta(\Lambda)=\left(\begin{matrix}\theta_1 &amp;\\&amp;\ddots \\ &amp;&amp;\theta_n \end{matrix}\right)$，$\Lambda$仅仅表示对角矩阵，没有特殊的含义。</p><p><strong>式$({36})$就是标准的第一代GCN中的layer了，其中$\sigma(\cdot)$是激活函数，$\Theta=({\theta_1},{\theta_2},\cdots,{\theta_n})$就跟三层神经网络中的weight一样是任意的参数，通过初始化赋值然后利用误差反向传播进行调整，$x$就是graph上对应于每个顶点的feature vector（由特数据集提取特征构成的向量）。</strong></p><p><strong>第一代的参数方法存在着一些弊端：主要在于：</strong></p><p><strong>（1）每一次前向传播，都要计算 $U$,$diag(\theta_l )$ 及$U^T$三者的矩阵乘积，特别是对于大规模的graph，计算的代价较高，也就是论文中$\mathcal{O}(n^2)$的计算复杂度</strong></p><p><strong>（2）卷积核的spatial localization不好（这个在第9节中进一步阐述）</strong></p><p><strong>（3）卷积核需要$n$个参数</strong></p><p>由于以上的缺点第二代的卷积核设计应运而生。</p><h3 id="第二代GCN"><a href="#第二代GCN" class="headerlink" title="第二代GCN"></a>第二代GCN</h3><p>(<a href="http://papers.nips.cc/paper/6081-convolutional-neural-networks-on-graphs-with-fast-localized-spectral-filtering" target="_blank" rel="noopener">Convolutional Neural Networks on Graphs with Fast Localized Spectral Filtering</a>)，把 $\hat h(\lambda_l)$<strong>巧妙地设计成了</strong> $\sum_{j=0}^K \alpha_j \lambda^j_l$（原始定义为：$\hat{h}(\lambda_l)=\sum_{i=1}^{N}{h(i) u_l^*(i)}$），也就是：</p><script type="math/tex;mode=display">
\begin{eqnarray} y_{output}=\sigma \left(U  g_\theta(\Lambda)  U^T x \right)\end{eqnarray}</script><p>其中，$ g_\theta(\Lambda)=\left(\begin{matrix}\sum_{j=0}^K \alpha_j \lambda^j_1 &amp;\\&amp;\ddots \\ &amp;&amp; \sum_{j=0}^K \alpha_j \lambda^j_n \end{matrix}\right)$，$\Lambda$仅仅表示对角矩阵，没有特殊的含义。$\lambda_l^j$表示特征值$\lambda_l$的$j$次方。</p><p>上面的公式仿佛还什么都看不出来，下面利用矩阵乘法进行变换，来一探究竟。</p><script type="math/tex;mode=display">
\begin{eqnarray} \left(\begin{matrix}\sum_{j=0}^K \alpha_j \lambda^j_1 &\\&\ddots \\ && \sum_{j=0}^K \alpha_j \lambda^j_n \end{matrix}\right)=\sum_{j=0}^K \alpha_j \Lambda^j \end{eqnarray}</script><p>其中，$\Lambda$为对角矩阵，对角线元素分别为$\lambda_1,\lambda_2,…,\lambda_n$，而$\Lambda^j$也为对角矩阵，每一个元素分别为$\lambda_1,\lambda_2,…,\lambda_n$的$j$次方。而前面$\sum_{j=0}^K \alpha_j$为常数，两者相乘的结果为该常数乘以矩阵的每一个值，所以等于左边。</p><p>进而可以导出：</p><script type="math/tex;mode=display">
\begin{eqnarray} U \sum_{j=0}^K \alpha_j \Lambda^j U^T =\sum_{j=0}^K \alpha_j U\Lambda^j U^T = \sum_{j=0}^K \alpha_j L^j \end{eqnarray}</script><p>上式成立是因为$L^2=U \Lambda U^TU \Lambda U^T=U \Lambda^2 U^T $ 且 $U^T U=E$，由此可以扩展到$L^j$的情况。</p><p>各符号的定义都同第五节。</p><p>式$({40})$就变成了：</p><script type="math/tex;mode=display">
\begin{eqnarray} y_{output}=\sigma \left( \sum_{j=0}^K \alpha_j L^j x \right) \end{eqnarray}</script><p><strong>其中$({\alpha_1},{\alpha_2},\cdots,{\alpha_K})$ 是任意的参数，通过初始化赋值然后利用误差反向传播进行调整；$L^j$为矩阵$L$的$j$次方。</strong></p><p><strong>式$({40})$所设计的卷积核其优点在于在于：</strong></p><p><strong>（1）卷积核只有$K$个参数，一般 $K$远小于 $n$，参数的复杂度被大大降低了。</strong></p><p><strong>（2）矩阵变换后，神奇地发现不需要做特征分解了，直接用拉普拉斯矩阵$L$进行变换。然而由于要计算$L^j$，计算复杂度还是$\mathcal{O}(n^2)$</strong></p><p><strong>（3）卷积核具有很好的spatial localization，特别地，$K$就是卷积核的receptive field，也就是说每次卷积会将中心顶点K-hop neighbor上的feature进行加权求和，权系数就是$\alpha_k$</strong></p><p><strong>更直观地看，</strong> <strong>_K_=1就是对每个顶点和其一阶neighbor的feature进行加权求和，如下图所示：</strong></p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-5f756da1ce39f38d408bd771a15c8ad3_hd.jpg" alt></p><p><strong>说明：</strong>因为当$K=1$的时候，卷积部分就相当于$\alpha L x$，而从$L$矩阵的形式，可以看出拉普拉斯矩阵只在<del>中心</del>顶点和一阶相连的顶点上（1-hop neighbor）有非0元素，其余之处均为0。<strong>所以就相当于对每个顶点和其一阶neighbor的feature进行加权求和，也就有了局部感知的能力。<del>另外，拉普拉斯矩阵每一行之和均为0，对角线上的元素等于同一行其余元素之和，这可以看出Graph上的卷积本质：某一顶点在所有相邻节点上进行微小变化后获得的增益。</del>因为卷积中有参数$\alpha$是可以通过反向传播计算出来的，所以$L$中的系数并不能说明什么，只是不管乘以什么形式的$\alpha$其0元素的位置始终为0元素。</strong></p><p>同理，<strong>_K_=2的情形如下图所示：</strong></p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-a13b82907a364c3707a18bb8572b3a63_hd.jpg" alt></p><p><strong>说明：</strong></p><script type="math/tex;mode=display">
\begin{eqnarray} L+L^2=\left[\begin{array} { r c c c c c } { 8 } & { - 5 } & { 1 } & { 1 } & { - 5 } & { 0 } \\ { - 5 } & { 15 } & { - 6 } & { 2 } & { - 6 } & { 0 } \\ { 1 } & { - 6 } & { 8 } & { - 6 } & { 2 } & { 1 } \\ { 1 } & { 2 } & { - 6 } & { 15 } & { - 7 } & { - 5 } \\ { - 5 } & { - 6 } & { 2 } & { - 7 } & { 15 } & { 1 } \\ { 0 } & { 0 } & { 1 } & { - 5 } & { 1 } & { 3 } \end{array}\right] \end{eqnarray}</script><p>所以当$K=2$的时候，卷积部分相当于$\left( \sum_{j=0}^2 \alpha_j L^j x \right)$，从上面的$L+L^2$可以看出，只有其顶点和二阶相连的顶点上（2-hop neighbor）有非0元素，其余之处均为0。<strong>所以就相当于对每个顶点和其二阶neighbor的feature进行加权求和，也就有了局部感知的能力。因为卷积中有参数$\alpha$是可以通过反向传播计算出来的，所以$L+L^2$中的系数并不能说明什么，只是不管乘以什么形式的$\alpha$其0元素的位置始终为0元素。</strong></p><blockquote><p>上图只是以一个顶点作为实例，GCN<strong>每一次卷积对所有的顶点</strong>都完成了图示的操作。spatial convolution, 就是图上node只和邻接点加权，但是这里主要讨论的是spectral convolution，是在无向图的spectral space 做卷积，signal是长度为n的vector, filter也是长度为n的vector。</p></blockquote><h3 id="利用Chebyshev多项式递归计算卷积核"><a href="#利用Chebyshev多项式递归计算卷积核" class="headerlink" title="利用Chebyshev多项式递归计算卷积核"></a>利用Chebyshev多项式递归计算卷积核</h3><p>在第二代GCN中， $L$ 是 $n\times n$ 的矩阵，所以$L^j$ 的计算还是 $\mathcal{O}(n^2) $复杂的，<a href="https://www.sciencedirect.com/science/article/pii/S1063520310000552" target="_blank" rel="noopener">Wavelets on graphs via spectral graph theory</a>提出了利用Chebyshev多项式拟合卷积核的方法，来降低计算复杂度。<strong>卷积核 $g_\theta(\Lambda)$ 可以利用截断（truncated）的shifted Chebyshev多项式来逼近。</strong>（这里本质上应该寻找Minimax Polynomial Approximation，但是作者说直接利用Chebyshev Polynomial的效果也很好）</p><script type="math/tex;mode=display">
\begin{eqnarray} g_\theta(\Lambda)\approx\sum_{k=0}^{K-1}{\beta_k T_k (\tilde{\Lambda})} \end{eqnarray}</script><p>$\beta\in \mathbb{R}^{K} $表示一个切比雪夫向量，$\beta_k$ 是Chebyshev多项式的系数（标量）；$T_k(\tilde{\Lambda})$ 是取 $\tilde{\Lambda}=2\Lambda/\lambda_{max}-I$ 的Chebyshev多项式，进行这个shift变换的原因是<strong>Chebyshev多项式的输入要在 $\left[ -1,1\right]$ 之间。</strong></p><p>由Chebyshev多项式的性质，可以得到如下的递推公式</p><script type="math/tex;mode=display">
\begin{eqnarray} T_k (\tilde{\Lambda})x=2\tilde{\Lambda}T_{k-1} (\tilde{\Lambda})x-T_{k-2} (\tilde{\Lambda})x \end{eqnarray}</script><script type="math/tex;mode=display">
\begin{eqnarray} T_{0} (\tilde{\Lambda})=I,T_{1} (\tilde{\Lambda})=\tilde{\Lambda} \end{eqnarray}</script><p>其中, $x$ 的定义同上，是$ n$ 维的由每个顶点的特征构成的向量（当然，也可以是$ n*m $的特征矩阵，这时每个顶点都有 $m $个特征，但是$ m $通常远小于$ n$ ）。</p><p>这个时候不难发现：式$({42})$的运算不再有矩阵乘积了，只需要计算矩阵与向量的乘积即可。计算一次$ T_k (\tilde{\Lambda})x $的复杂度是$ \mathcal{O}(\left| E \right|)$ ，$ E $是图中边的集合，则整个运算的复杂度是$ \mathcal{O}(K\left | E \right|) $。当Graph是稀疏图的时候，计算加速尤为明显，这个时候复杂度远低于$ \mathcal{O}(n^2)$</p><p>$T_{k}(\tilde{\Lambda})$是 $\Lambda$的$k$ 阶多项式，且$UU^T=I$，所以有</p><script type="math/tex;mode=display">
\begin{eqnarray}\begin{aligned}U\tilde{\Lambda}^{k}U^{T}&=\overbrace{U\tilde{\Lambda}U^{T}\cdots U\tilde{\Lambda}U^{T}}^k=(U\tilde{\Lambda}U^{T})^{k}\\&=\left(U(\frac{2\Lambda}{\lambda_{max}}-I)U^T\right)^k=\left(U\frac{2\Lambda}{\lambda_{max}}U^T-UIU^T\right)^k\\&=\left(\frac{2}{\lambda_{max}}U\Lambda U^T-I\right)^k=\left(\frac{2}{\lambda_{max}}L-I\right)^k=\tilde{L}^{k} \end{aligned}\end{eqnarray}</script><p>其中， $\tilde{L}=\frac{2}{\lambda_{max}}L-I$ 。</p><blockquote><p>$k$阶多项式表达式：$f(x, \theta)=\sum_{k=0}^{K} x^{k} \theta_{k}=\phi(x)^{T} \theta$，其中$\phi(x)=\left[1, x, x^{2}, \cdots, x^{K}\right]^{T} \in \mathbb{R}^{K+1}$，$\theta=\left[\theta_{0}, \cdots, \theta_{K}\right]^{T} \in \mathbb{R}^{K+1}$。</p></blockquote><p>可以看出来，对于$k$ 阶多项式$T_{k}(\tilde{\Lambda})$中的第$k$项左乘矩阵$U$右乘矩阵$U^T$都对应$k$ 阶多项式$T_{k}(\tilde{L})$中的第$k$项，所以可以得到Graph卷积式子：</p><script type="math/tex;mode=display">
\begin{eqnarray}g_{\theta}(\Lambda) * x \approx U \sum_{k=0}^{K} \beta_k  T_{k}(\tilde{\Lambda}) U^{T} x=\sum_{k=0}^{K} \beta_k  U T_{k}(\tilde{\Lambda}) U^{T} x = \sum_{k=0}^{K} \beta_k  T_{k}(\tilde{L}) x\end{eqnarray}</script><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的讲述是GCN最基础的思路，均是<strong>改变了卷积核的傅里叶变换的形式</strong>。很多论文中的GCN结构是在上述思路的基础上进行了一些简单数学变换。理解了上述内容，就可以做到“万变不离其宗”。</p><h2 id="GCN中的Local-Connectivity和Parameter-Sharing"><a href="#GCN中的Local-Connectivity和Parameter-Sharing" class="headerlink" title="GCN中的Local Connectivity和Parameter Sharing"></a>GCN中的Local Connectivity和Parameter Sharing</h2><p><strong>CNN中有两大核心思想：网络局部连接，卷积核参数共享。</strong></p><p>那么我们不禁会联想：这两点在GCN中是怎样的呢？以下图的graph结构为例来探究一下</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-8e9abf0e99e3a51d07a3c3c59a4cc15a_hd.jpg" alt></p><h3 id="GCN中的Local-Connectivity"><a href="#GCN中的Local-Connectivity" class="headerlink" title="GCN中的Local Connectivity"></a>GCN中的Local Connectivity</h3><p>(a)如果利用第一代GCN，根据式$({36})$卷积核即为</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-ea7c50ca7a5fb372edd3d9b869301558343704149.jpg" alt></p><p>这个时候，可以发现这个卷积核没有<strong>local的性质，因为所有位置上都有非0元素。以第一个顶点为例，如果考虑一阶local关系的话，那么卷积核中第一行应该只有$[1,1],[1,2],[1,5]$这三个位置的元素非0。换句话说，这是一个global全连接的卷积核。</strong></p><p>如果是第二代GCN，根据式$({40})$当$K=1$积核即为</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-50175241818d6ec0c069c983eaffed71_hd.jpg" alt></p><p>当 $K=2$卷积核即为</p><p><img src="/MachineLearning/图神经网络/图卷积神经网络/v2-816cd07215512d99c1034e40848829fb_hd.jpg" alt></p><p><strong>看一下图的邻接结构，卷积核的非0元素都在localize的位置上。</strong></p><h3 id="GCN中的Parameter-Sharing"><a href="#GCN中的Parameter-Sharing" class="headerlink" title="GCN中的Parameter Sharing"></a>GCN中的Parameter Sharing</h3><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>和图像中的离散卷积运算本质为加权求和相同，在Graph上的运算本质也为加权求和；而图像中的离散卷积物理含义是提取图像不同『频段』的特征。，而在Graph上的物理含义<del>为某一顶点在所有相邻节点上进行微小变化后获得的增益（从拉普拉斯矩阵$L$的每一行之和均为零和Graph上卷积的表达式可以看出来</del>）。</p><h2 id="其他GCN"><a href="#其他GCN" class="headerlink" title="其他GCN"></a>其他GCN</h2><h3 id="关于有向图的问题"><a href="#关于有向图的问题" class="headerlink" title="关于有向图的问题"></a>关于有向图的问题</h3><p>前面的叙述都是<strong>关于无向图</strong>的GCN<strong>，</strong>如果是<strong>有向图问题，最大的区别就是邻接矩阵会变成非对称矩阵，</strong>这个时候不能直接定义<strong>拉普利矩阵及其谱分解（拉普拉斯矩阵本身是定义在无向图上的）。这个时候有两条思路解决问题。</strong></p><p><strong>（a）重新定义图的邻接关系，保持对称性</strong></p><p>比如<a href="https://arxiv.org/abs/1802.01572" target="_blank" rel="noopener">MotifNet: a motif-based Graph Convolutional Network for directed graphs</a> 提出利用<strong>Graph Motifs定义图的邻接关系。</strong></p><p><strong>（b）绕开利用拉普利矩阵计算GCN的方法</strong></p><h3 id="关于边特征处理"><a href="#关于边特征处理" class="headerlink" title="关于边特征处理"></a>关于边特征处理</h3><p>大多数都是针对node feature进行处理，而如果要处理edge feature，查看<strong>THOMAS KIPF的论文</strong></p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ul><li>CNN中的平移不变形</li><li>拉普拉斯变换(二阶导)和傅里叶变换有什么关联，为啥拉普拉斯变换的特征函数就可以作为傅里叶变换的基？</li><li>Graph上的傅里叶逆变换和Graph上的卷积定理均缺乏推导</li><li>Graph上的频率的含义，与特征值之间的关系</li><li>式子$({36})$中$x$的具体含义</li><li>Graph上卷积的物理含义</li><li>切比雪夫的递推公式</li><li>卷积核的傅里叶变换为何是矩阵，不应该是向量么？</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/50742283" target="_blank" rel="noopener">图拉普拉斯算子为何定义为D-W</a><br><a href="https://zhidao.baidu.com/question/400689896.html" target="_blank" rel="noopener">混合偏导数怎么算?</a><br><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">正交矩阵</a><br><a href="http://tkipf.github.io/graph-convolutional-networks/" target="_blank" rel="noopener">GRAPH CONVOLUTIONAL NETWORKS</a><br><a href="https://zhuanlan.zhihu.com/p/31067515" target="_blank" rel="noopener">《Semi-Supervised Classification with Graph Convolutional Networks》阅读笔记</a><br><a href="https://blog.csdn.net/h763247747/article/details/84485158" target="_blank" rel="noopener">（含Python源码）Python实现K阶多项式的5种回归算法（regression）</a><br><a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_1.html" target="_blank" rel="noopener">从图(Graph)到图卷积(Graph Convolution)：漫谈图神经网络模型 (一)</a><br><a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_2.html" target="_blank" rel="noopener">从图(Graph)到图卷积(Graph Convolution)：漫谈图神经网络模型 (二)</a><br><a href="https://www.cnblogs.com/KrianJ/p/12206413.html" target="_blank" rel="noopener">laplacian matrix的几种形式</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/" title="图卷积神经网络">https://www.zdaiot.com/MachineLearning/图神经网络/图卷积神经网络/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/GCN/" rel="tag"><i class="fa fa-tag"></i> GCN</a><a href="/tags/Laplace/" rel="tag"><i class="fa fa-tag"></i> Laplace</a><a href="/tags/傅里叶变换/" rel="tag"><i class="fa fa-tag"></i> 傅里叶变换</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Math/如何理解特征值和特征向量/" rel="prev" title="如何理解特征值和特征向量"><i class="fa fa-chevron-left"></i> 如何理解特征值和特征向量</a></div><div class="post-nav-item"> <a href="/MachineLearning/卷积神经网络/CNN的平移不变形/" rel="next" title="CNN的平移不变形">CNN的平移不变形<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CNN中的卷积"><span class="nav-number">1.</span> <span class="nav-text">CNN中的卷积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要研究GCN"><span class="nav-number">2.</span> <span class="nav-text">为什么要研究GCN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提取拓扑图空间特征的两种方式"><span class="nav-number">3.</span> <span class="nav-text">提取拓扑图空间特征的两种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vertex-domain-spatial-domain，空域"><span class="nav-number">4.</span> <span class="nav-text">vertex domain(spatial domain，空域)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递网络-Message-Passing-Neural-Network"><span class="nav-number">4.1.</span> <span class="nav-text">消息传递网络(Message Passing Neural Network)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图采样与聚合-Graph-Sample-and-Aggregate"><span class="nav-number">4.2.</span> <span class="nav-text">图采样与聚合(Graph Sample and Aggregate)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图结构序列化-PATCHY-SAN"><span class="nav-number">4.3.</span> <span class="nav-text">图结构序列化(PATCHY-SAN)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spectral-domain"><span class="nav-number">5.</span> <span class="nav-text">spectral domain</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拉普拉斯矩阵"><span class="nav-number">6.</span> <span class="nav-text">拉普拉斯矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用拉普拉斯矩阵"><span class="nav-number">6.2.</span> <span class="nav-text">为什么要使用拉普拉斯矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#物理含义角度"><span class="nav-number">6.2.1.</span> <span class="nav-text">物理含义角度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数学角度"><span class="nav-number">6.2.2.</span> <span class="nav-text">数学角度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拉普拉斯矩阵的谱分解（特征分解）"><span class="nav-number">7.</span> <span class="nav-text">拉普拉斯矩阵的谱分解（特征分解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#推广傅里叶变换、卷积"><span class="nav-number">8.</span> <span class="nav-text">推广傅里叶变换、卷积</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#推广傅里叶变换"><span class="nav-number">8.1.</span> <span class="nav-text">推广傅里叶变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Graph上的傅里叶变换"><span class="nav-number">8.1.1.</span> <span class="nav-text">Graph上的傅里叶变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Graph上的傅里叶逆变换"><span class="nav-number">8.1.2.</span> <span class="nav-text">Graph上的傅里叶逆变换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推广卷积"><span class="nav-number">8.2.</span> <span class="nav-text">推广卷积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？特征值表示频率？"><span class="nav-number">9.</span> <span class="nav-text">为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？特征值表示频率？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？"><span class="nav-number">9.1.</span> <span class="nav-text">为什么拉普拉斯矩阵的特征向量可以作为傅里叶变换的基？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么理解拉普拉斯矩阵的特征值表示频率"><span class="nav-number">9.2.</span> <span class="nav-text">怎么理解拉普拉斯矩阵的特征值表示频率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deep-Learning中的Graph-Convolution"><span class="nav-number">10.</span> <span class="nav-text">Deep Learning中的Graph Convolution</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一代GCN"><span class="nav-number">10.1.</span> <span class="nav-text">第一代GCN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二代GCN"><span class="nav-number">10.2.</span> <span class="nav-text">第二代GCN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用Chebyshev多项式递归计算卷积核"><span class="nav-number">10.3.</span> <span class="nav-text">利用Chebyshev多项式递归计算卷积核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">10.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCN中的Local-Connectivity和Parameter-Sharing"><span class="nav-number">11.</span> <span class="nav-text">GCN中的Local Connectivity和Parameter Sharing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GCN中的Local-Connectivity"><span class="nav-number">11.1.</span> <span class="nav-text">GCN中的Local Connectivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCN中的Parameter-Sharing"><span class="nav-number">11.2.</span> <span class="nav-text">GCN中的Parameter Sharing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">12.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他GCN"><span class="nav-number">13.</span> <span class="nav-text">其他GCN</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于有向图的问题"><span class="nav-number">13.1.</span> <span class="nav-text">关于有向图的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于边特征处理"><span class="nav-number">13.2.</span> <span class="nav-text">关于边特征处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#疑惑"><span class="nav-number">14.</span> <span class="nav-text">疑惑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">15.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">324</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">56</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">381</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2.3m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">34:13</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '77310f98385ddc6fa071ffa151b2739e',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>