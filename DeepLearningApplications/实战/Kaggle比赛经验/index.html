<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="基本知识 反馈的分数是基于测试集的一部分计算的，剩下的另一部分会被用于计算最终的结果。所以最后排名会变动。 LB 指的就是在 Leaderboard 得到的分数，由上，有 Public LB 和 Private LB 之分。 自己做的 Cross Validation 得到的分数一般称为 CV 或是 Local CV。一般来说 CV 的结果比 LB 要可靠。  数据标准化数据需要进行归一化或者标准"><meta name="keywords" content="Kaggle,调参经验,集成"><meta property="og:type" content="article"><meta property="og:title" content="Kaggle比赛经验"><meta property="og:url" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="基本知识 反馈的分数是基于测试集的一部分计算的，剩下的另一部分会被用于计算最终的结果。所以最后排名会变动。 LB 指的就是在 Leaderboard 得到的分数，由上，有 Public LB 和 Private LB 之分。 自己做的 Cross Validation 得到的分数一般称为 CV 或是 Local CV。一般来说 CV 的结果比 LB 要可靠。  数据标准化数据需要进行归一化或者标准"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/v2-256cf7b3f44877272b71dce789dc3ebc_hd.jpg"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/lr.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/art2_explode.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/TNN4.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/TNN3.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/TNN8.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/TNN6-1576893231601.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/art2_courbe_lr.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/art2_loss_vs_lr.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/lr_finder.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/stepdecay.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/1576862729531.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/Screen-Shot-2018-02-25-at-8.44.49-PM.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/Saddle_point.svg.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/sharp_minima.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/cosine_annealing.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/Screen-Shot-2018-02-26-at-9.12.57-PM.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/UnderfittingOverfitting.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/HPO6.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/RL1.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/RL3.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/Screenshot_20from_202018-10-29_2008-51-34.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/Screenshot_20from_202018-10-29_2008-52-11.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/TIM_u622A_u56FE20181029201756.jpg"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/TIM_u622A_u56FE20181029202242.jpg"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/TIM_u622A_u56FE20181029203032.jpg"><meta property="og:image" content="https://srdas.github.io/DLBook/DL_images/TNN6.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/39f9889b-30a3-4cb4-8972-113d944bb236.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/learning_rate_and_batch___.PNG"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/learning_rate_and_batch_size.PNG"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/TIM_u622A_u56FE20181023094604.jpg"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/grid_search.gif"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/random_search.gif"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/grid_vs_random-1024x553.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/cabd979c-84c0-4544-afca-33f3b9c96fb7.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/20150806140556146"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/kaggle-guide-stacking-diagram.jpg"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/_u65E0_u6807_u9898.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/9ce664c1-3db5-41bd-915c-3b262633ef4a.jpg"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/3dd87f1c-f2bb-4976-b479-20023248a6d9.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/quesbase64153148112917172596.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/quesbase64153148115267426581.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/20180804174128743.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/5-2.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/quesbase6415314827826172363.png"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/20180805010136131.png"><meta property="og:updated_time" content="2019-09-15T03:40:49.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Kaggle比赛经验"><meta name="twitter:description" content="基本知识 反馈的分数是基于测试集的一部分计算的，剩下的另一部分会被用于计算最终的结果。所以最后排名会变动。 LB 指的就是在 Leaderboard 得到的分数，由上，有 Public LB 和 Private LB 之分。 自己做的 Cross Validation 得到的分数一般称为 CV 或是 Local CV。一般来说 CV 的结果比 LB 要可靠。  数据标准化数据需要进行归一化或者标准"><meta name="twitter:image" content="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/v2-256cf7b3f44877272b71dce789dc3ebc_hd.jpg"><link rel="canonical" href="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Kaggle比赛经验 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Kaggle比赛经验<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/DeepLearningApplications/实战/Kaggle比赛经验.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-25 17:41:57" itemprop="dateCreated datePublished" datetime="2019-07-25T17:41:57+08:00">2019-07-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-09-15 11:40:49" itemprop="dateModified" datetime="2019-09-15T11:40:49+08:00">2019-09-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DeepLearningApplications/" itemprop="url" rel="index"><span itemprop="name">DeepLearningApplications</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DeepLearningApplications/实战/" itemprop="url" rel="index"><span itemprop="name">实战</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>32k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>29 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ul><li>反馈的分数是基于测试集的一部分计算的，剩下的另一部分会被用于计算最终的结果。所以最后排名会变动。</li><li>LB 指的就是在 Leaderboard 得到的分数，由上，有 Public LB 和 Private LB 之分。</li><li>自己做的 Cross Validation 得到的分数一般称为 CV 或是 Local CV。一般来说 CV 的结果比 LB 要可靠。</li></ul><h2 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h2><p>数据需要进行归一化或者标准化的重要性就不再提了，想必大家都知道。在Pytorch中，对于图像数据，通常使用<code>totensor</code>方法进行归一化，然后使用<code>normalize</code>方法进行标准化。另外，在使用ImageNet预训练权重的时候，均值和方差也尽量使用ImageNet数据的均值和方差。在<a href="https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation" target="_blank" rel="noopener">siim-acr-pneumothorax-segmentation</a>比赛中，数据为胸部放射图像，使用ImageNet数据的均值方差比使用该数据集的均值方差效果好。一种解释是，网络本质学习的是数据的分布，使用ImageNet的均值和方差可以保证得到的数据分布和预训练权重学习到的数据分布相差不大。当然，使用ImageNet数据的均值方差不一定一定比特定数据集的均值方差好，这需要实验。</p><h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><p>图像比赛的一个重头戏就是数据增强，我们为什么要做数据增强呢？</p><p><strong>我们的训练模型是为了拟合原样本的分布，但如果训练集的样本数和多样性不能很好地代表实际分布，那就容易发生过拟合训练集的现象。数据增强使用人类先验，尽量在原样本分布中增加新的样本点，是缓解过拟合的一个重要方法。</strong></p><p>需要小心的是，<strong>数据增强的样本点最好不要将原分布的变化范围扩大</strong>，比如训练集以及测试集的光照分布十分均匀，就不要做光照变化的数据增强，因为这样只会增加拟合新训练集的难度，对测试集的泛化性能提升却比较小。另外，<strong>新增加的样本点最好和原样本点有较大不同</strong>，不能随便换掉几个像素就说是一个新的样本，这种变化对大部分模型来说基本是可以忽略的。</p><p>一些常见的图像数据增强方式有：</p><ul><li>亮度，饱和度，对比度的随机变化</li><li>随机裁剪（Random Crop）</li><li>随机缩放（Random Resize）</li><li>水平/垂直翻转（Horizontal/Vertiacal Filp）</li><li>旋转（Rotation）</li><li>加模糊（Blurring）</li><li>加高斯噪声（Gaussian Noise）</li></ul><p>对于这个卫星图像识别的任务来说，最好的数据增强方法是什么呢？显然是旋转和翻转。具体来说，我们对这个数据集一张图片先进行水平翻转得到两种表示，再配合0度，90度，180度，270度的旋转，可以获得一张图的八种表示。以人类的先验来看，新的图片与原来的图片是属于同一个分布的，标签也不应该发生任何变化，而对于一个卷积神经网络来说，它又是8张不同的图片。比如下图就是某张图片的八个方向，光看这些我们都没办法判断哪张图是原图，但显然它们拥有相同的标签。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/v2-256cf7b3f44877272b71dce789dc3ebc_hd.jpg" alt></p><p>其他的数据增强方法就没那么好用了，我们挑几个分析：</p><ul><li>亮度，饱和度，对比度随机变化：在这个比赛的数据集中，官方已经对图片进行了比较好的预处理，亮度、饱和度、对比度的波动都比较小，所以在这些属性上进行数据增强没有什么好处。</li><li>随机缩放：根据比赛在<a href="https://www.kaggle.com/c/planet-understanding-the-amazon-from-space/overview" target="_blank" rel="noopener">Overview</a>和<a href="https://www.kaggle.com/c/planet-understanding-the-amazon-from-space/data" target="_blank" rel="noopener">Data</a>部分的信息。这些图片中的一个像素宽大概对应3.7米，也不应该有太大的波动，所以随机缩放不会有立竿见影的增强效果。</li><li>随机裁剪：观察<a href="https://www.kaggle.com/c/planet-understanding-the-amazon-from-space/data" target="_blank" rel="noopener">Data</a>，有些图片因为边上出现了一小片云朵，被标注了partly cloudy，如果随机裁剪有可能把这块云朵裁掉，但是label却仍然有partly cloudy，这显然是在引入错误的标注样本，有百害而无一利。同样的例子也出现在别的类别上，说明随机裁剪的方法并不适合这个任务。</li></ul><p>一旦做了这些操作，新的图片会扩大原样本的分布，所以这些数据增强也就没有翻转、旋转那么优先。在最后的方案中，我们只用了旋转和翻转。并不是说其他数据增强完全没效果，只是相比旋转和翻转，它们带来的好处没那么直接。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>本来觉得，模型这部分没啥好记录的，都是因任务而异嘛。但是现在发现还是可以总结一些东西的。</p><ul><li>尽可能的使用预训练模型，即使自己的数据分布和ImageNet的数据分布可能相差很大。但是这些数据可能有一些相似的特性，比如纹理、边缘特征等，神经网络中浅层的一些滤波器可能负责提取这部分特征。所以使用预训练权重，一来可以提高精度，二来可以加快收敛速度。详细的讨论在<a href="https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation/discussion/103001593596" target="_blank" rel="noopener">这个帖子</a></li><li><a href="https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation/discussion/103001593596" target="_blank" rel="noopener">这个帖子</a>讨论了在图像分辨率更高的情况下，使用更宽(通道，channel)的模型比使用更深的模型效果更好。</li></ul><h2 id="如何挑选合适学习率"><a href="#如何挑选合适学习率" class="headerlink" title="如何挑选合适学习率"></a>如何挑选合适学习率</h2><h3 id="学习率的影响"><a href="#学习率的影响" class="headerlink" title="学习率的影响"></a>学习率的影响</h3><h4 id="一维损失"><a href="#一维损失" class="headerlink" title="一维损失"></a>一维损失</h4><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/lr.png" alt="lr"></p><p><strong>如上图所示，如果学习率太慢，网络需要很多次迭代才会收敛；而如果学习率过大，会导致每一次迭代均跳过最小点，永远不会得到可接受的loss。更糟糕的是，更高的学习率会导致loss增加直到Nan。</strong></p><p>这是为什么呢？如果梯度比较大，较高的学习率会导致loss远离最小值，设置可能比之前的loss更大。如下面简单的抛物线，看看高学习率是如何迅速让你越来越远离极小值的。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/art2_explode.png" alt="img" style="zoom:50%"></p><p>如上面所示，当loss处于$a_0$时，较高的学习率会导致loss跑到$a_1$点，此时loss反而上升了；当loss在$a_1$点时，较高的学习率会导致loss跑到$a_2$点，此时loss又进一步上升了。</p><h4 id="多维损失"><a href="#多维损失" class="headerlink" title="多维损失"></a>多维损失</h4><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/TNN4.png" alt="Gradient Descent Down a Narrow Steep Valley"></p><ol><li><p>如果梯度下降法工作在多维损失，那么还会出现其它问题。其中一种情况如上面图所示。该图展示了一个二维场景，其中损失函数在一个维度上的斜率特别陡峭，而在另外一个维度上斜率很小；即它的形状为狭窄陡峭的山谷。</p><p>如果我们在这种情况下使用梯度下降，我们将得到上图中所示的行为（这是一维图中行为的二维模拟）。沿着目标函数陡峭部分的参数在山谷斜坡之间来回振荡，而沿着损失函数较浅部分的参数沿山谷缓慢移动。这样做的最终结果是收敛非常缓慢。图的右侧显示了更理想的收敛行为。</p></li><li><p>当梯度下降在多维空间中作用时，出现的另一个问题是鞍点。这些被定义为损失函数表面上的区域，当<strong>沿着一个维度观察时是一个极小值，当沿着另一个维度观察时同时是一个极大值</strong>。下图中的二维情况说明了这一点。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/TNN3.png" alt="Saddle Points"></p><p>当迭代从上面接近鞍点时，即使它不是最小值，它的斜率也会达到零。其结果是迭代过程停止，算法陷入一个非最优点。这个bevavior在下图中进一步说明。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/TNN8.png" alt="Getting Stuck at a Saddle Point" style="zoom:67%"></p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如前所述，学习速率参数对梯度下降算法的有效性有很大的影响。如果它被设置为一个大的值，那么算法在迭代开始时快速收敛，但是大的学习率在系统接近最小值时，会导致参数超调，这可能导致振荡。如果学习率过小，则算法收敛性好，但可能需要很长时间。因此理想的学习率应设置自适应，这样在初始优化阶段较大，并且随着逐渐变得越来越小。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/TNN6-1576893231601.png" alt="Effect of Learning Rate on the Loss Function"></p><p>上图说明了<strong>训练过程中学习率对损失函数的影响</strong>，可用于快速检查正在使用的学习率的适用性，注意这是在<strong>训练集</strong>上的损失曲线：</p><ul><li>一个非常高的学习率会导致损失函数在几次迭代后开始增加</li><li>一个偏高的学习率会导致损失在最初的快速下降后以一个较高的值进入平稳期</li><li>一个非常低的学习率在训练阶段导致损失函数缓慢收敛</li><li><strong>合适的学习率结合了初始阶段的快速下降和较低的平稳值</strong></li></ul><p>另外，如果在<strong>验证集</strong>上的损失曲线<strong>先下降或上升，则是过拟合</strong>。造成这种现象的原因是因为模型容量与数据复杂度不匹配或者训练数据集造成的。<strong>个人觉得跟学习率大小没有过大的关联。</strong></p><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>所以我们如何挑选合适的学习率呢？在<a href="https://arxiv.org/abs/1506.01186" target="_blank" rel="noopener">这篇文章</a>中，提供了一个可行的方法。以SGD优化器为例，<strong>对于一个epoch</strong>，初始学习率特别低（例如$10^{-8}$），然后在每一个mini-batch均乘上一个因子改变学习率，直到它达到一个特别高的值（例如1或者10）。然后在每一次迭代均记录损失值，画出<strong>训练过程中loss关于学习率</strong>（取log后）的曲线，例如下面所示：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/art2_courbe_lr.png" alt="Plot of the loss against the learning rate"></p><p>如上图所示，loss在一开始一直下降，然后停止下降，最后开始上升。这会因为，使用非常低的学习率时，我们的结果越来越好，特别是当我们增加学习率时。当学习率达到特别高的值时，loss开始增加。那么最好的学习率是什么呢？令你想不到的是，不是最低loss对应的学习率。</p><p>这是为什么呢？最低loss对应的学习率其实已经开始有点太高了，因为我们处于改进和退步之间的边缘。我们在这个值之前取一个值，那么这个值仍然可以用来快速训练，并且仍然是安全的，不会出现梯度爆炸。如上图所示，我们选择的是$10^{-2}$，而不是$10^{-1}$。</p><p>该方法可以应用于SGD的任何变体，也可以应用于任何类型的网络。我们只需要经历一个epoch(通常更短)，并记录我们损失值，就可以为选出合适的学习率。</p><blockquote><p>实际我使用的时候，感觉并不是很适用。在画这个曲线的时候，是否应该将所有的数据增强、数据多尺度均关闭？这个问题暂时没有解决。另外，这种方法得到的学习率偏大，可以考虑设置为它的四分之一左右。</p></blockquote><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>在实践中，我们通常不会会出每一个mini-batch的loss曲线，而是它的平滑版本。如果非要画出每一个mini-batch的loss曲线，我们将会得到像下面这样的图：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/art2_loss_vs_lr.png" alt="Plot of the loss against the learning rate"></p><p>即使我们可以看到总体趋势(这是因为我截断了右边上升到无穷远的部分)，它也不像上一张图那样清晰。为了平滑损失，我们将采用<strong>指数加权平均</strong>。它的定义和SGD动量变体其实是完全相同的，对于每一个mini-batch，平均损失定义为：</p><script type="math/tex;mode=display">
\begin{equation*}
\hbox{avg loss} = \beta * \hbox{old avg loss} + (1-\beta) * \hbox{loss}
\end{equation*}</script><p>其中，$\beta$为0到1之间的参数。这样，平均损失会减少噪声，给我们一个更平滑的曲线，我们肯定能看到整体趋势。这也解释了为什么当我们在第一条曲线上达到最小值时为时已晚：当我们的损失开始爆炸时，平均损失将保持在较低的水平，而且需要一段时间才能开始真正增加。</p><p>为什么你看不到指数加权平均呢？这是因为它隐藏在我们的递归公式中，如果我们的loss是$l_{0},\dots,l_{n}$，那么第$i$个指数加权损失为：</p><script type="math/tex;mode=display">
\begin{align*}
\hbox{avg loss}_{i} &= \beta \hbox{avg loss}_{i-1} + (1-\beta) l_{i} = \beta^{2} \hbox{avg loss}_{i-2} + \beta(1-\beta) l_{i-1} +  \beta l_{i} \\
&= \beta^{3} \hbox{avg loss}_{i-3} + \beta^{2}(1-\beta) l_{i-2} + \beta(1-\beta) l_{i-1} +  \beta l_{i} \\
&\vdots \\
&= (1-\beta) \beta^{i} l_{0} + (1-\beta) \beta^{i-1} l_{1} + \cdots + (1-\beta) \beta l_{i-1} + (1-\beta) l_{i}
\end{align*}</script><p>权重均是$\beta$的幂。由等比求和公式，可以得到权重之和为：</p><script type="math/tex;mode=display">
\begin{equation*}
(1-\beta) \beta^{i} + (1-\beta) \beta^{i-1} + \cdots + (1-\beta) \beta + (1-\beta) = (1-\beta) * \frac{1-\beta^{i+1}}{1-\beta} = 1-\beta^{i+1}
\end{equation*}</script><p>因此，要想真正成为平均值，我们必须将平均损失除以这个因子。最后，我们要的损失是</p><script type="math/tex;mode=display">
\begin{equation*}
\hbox{smoothed loss}_{i} = \frac{\hbox{avg loss}_{i}}{1-\beta^{i+1}}.
\end{equation*}</script><p>当$i$很大时，$\beta^{i+1}$将收敛到0，但是对于$i$的第一个值，它可以确保我们获得更好的结果。</p><p>接下来还要改变一点是——我们可能不需要跑完一个epoch：如果损失开始爆发性增长，我们就不需要继续进行下去：</p><script type="math/tex;mode=display">
\begin{equation*}
\hbox{current smoothed loss} > 4 \times \hbox{minimum smoothed loss}
\end{equation*}</script><p>最后，我们仅仅需要一点点数学知识就可以计算出每一步的学习率乘积因子。如果我们初始学习率为$\hbox{lr}_{0}$，在每一步均乘上$q$，那么第$i$步学习率为：</p><script type="math/tex;mode=display">
\begin{equation*}
\hbox{lr}_{i} = \hbox{lr}_{0} \times q^{i}
\end{equation*}</script><p>现在已知初始学习率为$\hbox{lr}_{0}$，$N$步之后的学习率为$\hbox{lr}_{N-1}$，所以我们可以求解$q$：</p><script type="math/tex;mode=display">
\begin{equation*}
\hbox{lr}_{N-1} = \hbox{lr}_{0} \times q^{N-1} \quad \Longleftrightarrow \quad q^{N-1} = \frac{\hbox{lr}_{N-1}}{\hbox{lr}_{0}} \quad \Longleftrightarrow \quad q = \left ( \frac{\hbox{lr}_{N-1}}{\hbox{lr}_{0}}  \right )^{\frac{1}{N-1}}
\end{equation*}</script><p>为什么要这么麻烦，而不是将学习率的初始值和最终值之间的被等间隔的分开。我们需要记住的是，我们将在画出损失随着学习率对数的曲线，如果我们取$\hbox{lr}_{i}$的对数，那么得到下式</p><script type="math/tex;mode=display">
\begin{equation*}
\log(\hbox{lr}_{i}) = \log(\hbox{lr}_{0}) + i \log(q) = \log(\hbox{lr}_{0}) + i\frac{\log(\hbox{lr}_{N-1}) - \log(\hbox{lr}_{0})}{N-1},
\end{equation*}</script><p>上式表明，这<strong>在log尺度上</strong>我们学习率的初始值和最终值之间的被等间隔的分开。那样的话，我们的曲线上肯定会有等间距的点，通过下面式子：</p><script type="math/tex;mode=display">
\begin{equation*}
\hbox{lr}_{i} = \hbox{lr}_{0} + i \frac{\hbox{lr}_{N-1} - \hbox{lr}_{0}}{N-1}
\end{equation*}</script><p>我们的点集中在靠近末尾的地方（因为$\hbox{lr}_{N-1}$比$\hbox{lr}_{0}$大太多了）。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lr</span><span class="params">(trn_loader, optimizer, net, criterion, init_value=<span class="number">1e-8</span>, final_value=<span class="number">10.</span>, beta=<span class="number">0.98</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        trn_loader: 训练数据集的dataloader</span></span><br><span class="line"><span class="string">        optimizer: 优化器</span></span><br><span class="line"><span class="string">        net: 模型</span></span><br><span class="line"><span class="string">        criterion: 损失函数</span></span><br><span class="line"><span class="string">        init_value: float，学习率初始值</span></span><br><span class="line"><span class="string">        final_value: float，学习率最终值</span></span><br><span class="line"><span class="string">        beta: float，使用平滑平均计算损失时的系数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        log_lrs: list，从小到大的学习率</span></span><br><span class="line"><span class="string">        losses: list，对应于log_lrs学习率的损失</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note: 请根据param_groups的实际数量调整下面的初始化学习率以及更新学习率</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    num = len(trn_loader) - <span class="number">1</span></span><br><span class="line">    mult = (final_value / init_value) ** (<span class="number">1</span> / num)</span><br><span class="line"></span><br><span class="line">    lr = init_value</span><br><span class="line">    optimizer.param_groups[<span class="number">0</span>][<span class="string">'lr'</span>] = lr * <span class="number">0.1</span></span><br><span class="line">    optimizer.param_groups[<span class="number">1</span>][<span class="string">'lr'</span>] = lr</span><br><span class="line"></span><br><span class="line">    avg_loss, best_loss, batch_num = <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0</span></span><br><span class="line">    losses, log_lrs = [], []</span><br><span class="line"></span><br><span class="line">    tbar = tqdm.tqdm(train_loader)</span><br><span class="line">    <span class="keyword">for</span> _, inputs, labels <span class="keyword">in</span> tbar:</span><br><span class="line">        batch_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># As before, get the loss for this mini-batch of inputs/outputs</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute the smoothed loss</span></span><br><span class="line">        avg_loss = beta * avg_loss + (<span class="number">1</span> - beta) * loss.item()</span><br><span class="line">        smoothed_loss = avg_loss / (<span class="number">1</span> - beta ** batch_num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Stop if the loss is exploding</span></span><br><span class="line">        <span class="keyword">if</span> batch_num &gt; <span class="number">1</span> <span class="keyword">and</span> smoothed_loss &gt; <span class="number">4</span> * best_loss:</span><br><span class="line">            <span class="keyword">return</span> log_lrs, losses</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Record the best loss</span></span><br><span class="line">        <span class="keyword">if</span> smoothed_loss &lt; best_loss <span class="keyword">or</span> batch_num == <span class="number">1</span>:</span><br><span class="line">            best_loss = smoothed_loss</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Store the values</span></span><br><span class="line">        losses.append(smoothed_loss)</span><br><span class="line">        log_lrs.append(math.log10(lr))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Do the SGD step</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update the lr for the next step</span></span><br><span class="line">        lr *= mult</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意我这里有两组学习率</span></span><br><span class="line">        optimizer.param_groups[<span class="number">0</span>][<span class="string">'lr'</span>] = lr * <span class="number">0.1</span></span><br><span class="line">        optimizer.param_groups[<span class="number">1</span>][<span class="string">'lr'</span>] = lr</span><br><span class="line"></span><br><span class="line">        params_groups_lr = str()</span><br><span class="line">        <span class="keyword">for</span> group_ind, param_group <span class="keyword">in</span> enumerate(optimizer.param_groups):</span><br><span class="line">            params_groups_lr = params_groups_lr + <span class="string">'pg_%d'</span> % group_ind + <span class="string">': %.10f, '</span> % param_group[<span class="string">'lr'</span>]</span><br><span class="line"></span><br><span class="line">        descrip = params_groups_lr + <span class="string">'loss： &#123;&#125;'</span>.format(loss.item())</span><br><span class="line">        tbar.set_description(desc=descrip)</span><br><span class="line">    <span class="keyword">return</span> log_lrs, losses</span><br></pre></td></tr></table></figure><p>调用并画图可以采用下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log_lrs, losses = find_lr(train_loader, optimizer, model, criterion)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>))</span><br><span class="line">plt.plot(log_lrs, losses)</span><br><span class="line"><span class="comment"># plt.plot(log_lrs[10:-5], losses[10:-5])</span></span><br><span class="line">my_x_ticks = np.arange(<span class="number">-9</span>, <span class="number">1.4</span>, <span class="number">0.2</span>)</span><br><span class="line">plt.xticks(my_x_ticks)</span><br><span class="line">plt.savefig(<span class="string">'find_lr'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>实际跑出来的结果可能如下所示：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/lr_finder.png" alt="lr_finder"></p><p><strong>需要记住的是，最优学习率与下降幅度最大的点有关，也就是斜率最大的地方。上面选出的<code>optimal learning rate range</code>可以作为一些周期性学习率变化的最大值和最小值。</strong></p><h2 id="学习率衰减策略"><a href="#学习率衰减策略" class="headerlink" title="学习率衰减策略"></a>学习率衰减策略</h2><p>一般情况下从相对较高的学习率开始，然后在训练期间逐渐降低学习率。这种做法的直觉是使我们网络一开始快速遍历到一系列好的参数值。然后我们希望学习率足够小以便我们取探索“更深但是更窄的部分”（可以参考<a href="http://cs231n.github.io/neural-networks-3/#annealing-the-learning-rate" target="_blank" rel="noopener">这里</a>）。</p><h3 id="Step-Decay"><a href="#Step-Decay" class="headerlink" title="Step Decay"></a>Step Decay</h3><p>最受欢迎的学习率衰减策略一般是Step Decay，在经过一定数量的训练后，学习速率降低一定的百分比。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/stepdecay.png" alt="stepdecay"></p><p>更一般地说，我们可以确定，定义一个 learning rate schedule是有用的。根据这个learning rate schedule，学习率在训练期间根据特定的规则更新。</p><h3 id="Warm-up"><a href="#Warm-up" class="headerlink" title="Warm up"></a>Warm up</h3><p>若数据集分布和预训练权重的数据集分布较大或者没有预训练权重，建议先从较小的学习率慢慢上升到较高的学习率，然后再逐渐下降。这是因为在训练一开始，所有参数均是随机值，可能非常远离最优解。一开始就是用使用较大的学习率可能导致数值不稳定（可以参考<a href="http://openaccess.thecvf.com/content_CVPR_2019/html/He_Bag_of_Tricks_for_Image_Classification_with_Convolutional_Neural_Networks_CVPR_2019_paper.html" target="_blank" rel="noopener">这里</a>）。</p><p>这两种方式的对比如下所示：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/1576862729531.png" alt="1576862729531" style="zoom:80%"></p><h3 id="Cyclical-learning-rates"><a href="#Cyclical-learning-rates" class="headerlink" title="Cyclical learning rates"></a>Cyclical learning rates</h3><p>对于Cyclical learning rates的学习率，如下所示：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/Screen-Shot-2018-02-25-at-8.44.49-PM.png" alt="Screen-Shot-2018-02-25-at-8.44.49-PM"></p><p>背后的主要假设是<strong>“提高学习率可能会产生短期的负面影响，但却会获得长期的好处。”</strong>事实上，Smith的<a href="https://arxiv.org/abs/1506.01186" target="_blank" rel="noopener">论文</a>包括了几个损失函数变化的例子，与基准固定学习率相比，损失函数暂时偏离到更高的损失，但最终收敛到更低的损失。要理解为什么这种短期效应会产生长期的积极效应，理解我们的收敛最小值的理想特性是很重要的。最后，我们希望我们的网络能够从数据中学习，并将其推广到不可见的数据中。此外，具有良好泛化属性的网络应该是健壮的，因为对网络参数的微小更改不会导致性能的急剧变化。记住这一点，这是有道理的，<strong>急剧的极小值（<a href="https://arxiv.org/abs/1609.04836" target="_blank" rel="noopener">sharp minima</a>）会导致不好的泛化，因为参数值的微小变化可能导致更大的损失。通过允许我们的学习速度不时增加，我们可以“跳出”急剧的最小值，这将暂时增加我们的损失，但可能最终导致收敛到一个更理想的最小值。</strong></p><blockquote><p>注意:虽然“良好泛化的平坦极小值”被广泛接受，但您可以在<a href="https://arxiv.org/abs/1703.04933" target="_blank" rel="noopener">这里</a>阅读一个良好的反论点。</p></blockquote><p>此外，提高学习速度还可以“更快地遍历鞍点高原”。正如您在下图中所看到的，在<strong>鞍点处的梯度可能非常小。由于参数更新是梯度的函数，这导致我们的优化采取非常小的步骤；在这里增加学习率可以避免在鞍点上停留太久。</strong></p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/Saddle_point.svg.png" alt="Saddle point" style="zoom:50%"></p><p>注：根据定义，鞍点是一个临界点，其中一些维度观察到局部最小值，而其他维度观察到局部最大值。因为神经网络可以有数千甚至数百万个参数，我们不太可能在所有这些维度上观察到一个真正的局部最小值；鞍点更容易出现。当提到急剧的极小值（<a href="https://arxiv.org/abs/1609.04836" target="_blank" rel="noopener">sharp minima</a>）时，实际上我们应该描绘一个鞍点，其中最小维度非常陡峭，而最大维度非常宽(如下图所示)。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/sharp_minima.png" alt="sharp_minima"></p><h3 id="SGD-with-Warm-Restarts-SGDR"><a href="#SGD-with-Warm-Restarts-SGDR" class="headerlink" title="SGD with Warm Restarts (SGDR)"></a>SGD with Warm Restarts (SGDR)</h3><p>与上面相似的学习率衰减策略为SGD with Warm Restarts (SGDR)：定义了一个有效的退火计划并定时“重新启动”到原始的学习率。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/cosine_annealing.png" alt="cosine_annealing" style="zoom:80%"></p><p><strong>通过这种策略，大幅提高每次重新启动时的学习率，我们可以从本质上退出局部极小值，并继续探索损失情况。</strong></p><p><em>Neat idea:</em>：通过在每个周期结束时抓拍权重，研究人员能够根据单个模型的损失建立一个模型集合。这是因为网络从一个周期到另一个周期<em>“settles” on various local optima</em>，如下图所示。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/Screen-Shot-2018-02-26-at-9.12.57-PM.png" alt="Snapshot Ensembles: Train 1, get M for free"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>最常用的学习率衰减策略是StepLR，一开始可以采用ReduceLROnPlateau的学习率衰减方式确定在多少Epoch进行学习率衰减。</p><h2 id="训练-验证曲线"><a href="#训练-验证曲线" class="headerlink" title="训练/验证曲线"></a>训练/验证曲线</h2><p>在参加kaggle比赛之前，没有意识到训练/验证曲线会有多么重要，直到最近参加比赛，通过调节学习率，使得自己的名次上升了18名。下面进行一下总结：</p><h3 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h3><p>模型一旦经过训练，其真正的测试是它对以前没有见过的数据进行分类的能力，这也称为它的<strong>泛化能力</strong>。通常有两种问题会影响模型:</p><ul><li><p>即使对模型进行了充分的训练，使其<strong>训练误差很小</strong>，其<strong>测试错误率仍然很高</strong>。这就是所谓的过度拟合问题。</p></li><li><p>尽管经过了几个epoch的训练，但<strong>训练损失</strong>并没有减少。这就是所谓的欠拟合问题。</p></li></ul><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/UnderfittingOverfitting.png" alt="Illustration of Underfitting and Overfitting"></p><p>欠拟合和过拟合问题在回归问题中最直观，见上图。在该图中，<code>x</code>表示训练数据，而曲线表示模型，它试图拟合这些数据。如图所示，拟合数据的模型有三种：最左边为直线，中间为二次多项式，最右边为6次多项式。从左图可以看出，<strong>直线并不能在训练数据中拟合曲线</strong>，导致了欠拟合（Underfitting）的问题，即使我们增加更多的训练数据也无法减少误差。而通过二次多项式来增加模型的复杂度有很大帮助，如中间图所示。另一方面，如果我们使用一个六次多项式进一步增加模型的复杂性，那么它就会适得其反，如最右图所示。在这种情况下，<strong>曲线准确地拟合了所有的训练点，但是没有拟合测试数据点，这说明了过度拟合的问题。</strong></p><p>以下因素决定了模型从训练数据集到测试数据集的泛化程度:</p><ul><li><p>模型容量及其与数据复杂度的关系：通常，如果模型容量小于数据复杂度，则会导致欠拟合；反之，则会导致过拟合。因此，我们应该尝试选择与训练和测试数据集的复杂性相匹配的模型。</p></li><li><p>即使模型容量和数据复杂度匹配得很好，我们仍然会遇到过拟合问题。这是由于训练数据不足造成的。</p></li></ul><p>根据这些观察，一个有用的经验法则是：遇到过拟合问题的概率随着模型容量的增长而增加，但是随着更多的训练数据的增多而减少。注意，<strong>我们试图同时减少训练误差(以避免欠拟合问题)和测试误差(以避免过拟合问题)</strong>。这就导致了对模型容量的需求冲突，<strong>因为训练误差随着模型容量的增大而单调减小，但是当模型容量过高时，测试误差开始增大</strong>。一般情况下，如果我们绘制出测试损失值随模型容量的变化曲线，它会呈现出一个典型的U形曲<strong>线。理想的模型容量是测试误差值开始增加的点</strong>。该标准广泛用于深度学习中，以确定要使用的最佳超参数集。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/HPO6.png" alt="Model Capacity and its Effect on Underfitting and Overfitting" style="zoom:80%"></p><p>上图通过画出训练和测试损失随模型容量变化的函数，说明了模型容量与欠拟合和过拟合概念之间的关系。当模型容量较低时，训练误差和测试误差都较大。随着模型容量的增大，训练误差逐渐减小，但测试误差开始减小，之后由于过拟合而测试误差开始增大。因此，<strong>最优模型容量是测试误差最小的容量。</strong></p><p><strong>对深度学习模型泛化能力的讨论依赖于一个非常重要的假设，即训练数据集和测试数据集可以生成相同的概率模型</strong>。在实践中，这意味着我们训练模型来识别特定类型的物体，例如人脸，如果测试数据完全由猫脸组成，我们就不能期望它表现良好。有一个著名的结果叫做“没有免费的午餐”定理：训练和测试数据集的分布是没有约束关系的，那么每个分类算法在对未观测点进行分类时的错误率是相同的。因此，更好的方法是将训练和测试数据集限制为与所解决的问题相关的更窄的一类数据。</p><p><strong>那么如何分辨欠拟合呢？</strong></p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/RL1.png" alt="Model Underfitting"></p><p>如果一个模型表现出以下症状：<strong>它的训练损失不趋近于零，即使它训练了大量的epoch</strong>，它也显示出拟合不足的迹象。这意味着该模型的能力不够高，甚至不能以低错误概率对训练数据进行分类。也就是说，训练数据的非线性程度高于模型能够捕获的非线性程度。上图显示了一个遭受欠拟合的模型的输出示例。如图所示，训练误差和验证误差相互紧密跟踪，并且随着时间间隔的增加而趋于平缓，<strong>误差值很大</strong>。如果把训练和验证的精度绘制出来，它们也会表现出同步的扁平化行为，而只能获得较低的精度值。</p><p>为了纠正这种情况，建模者可以通过增加隐藏层的数量、为每个隐藏层添加更多的节点、更改正则化参或学习率来增加模型容量。如果这些步骤不能解决问题，那么它就指向了糟糕的训练数据。</p><p><strong>那么如何分辨过拟合呢？</strong></p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/RL3.png" alt="Detection of Overfitting"></p><p>过度拟合是困扰模型的主要问题之一。当这个问题发生时，这个模型与训练数据非常吻合，但是在以前没有接触过的数据下，它不能做出很好的预测。过度拟合的原因，可以归结为模型容量与数据复杂度不匹配和或训练数据不足。模型出现以下症状时（见上图）会发生过拟合：<strong>训练数据的分类精度随epoch的增加而增加，可能接近100%，但测试精度发散或者在较低的值平缓，从而两条曲线之间有很大的差距。</strong>即训练集损失远远小于验证集损失。</p><p>我们要清楚远远大于的概念，如果训练集损失只比验证集损失多一点点的话，同等数量级(例如0.8与0.9)这种情况下并不是过拟合的表现。我们一般遇到的过拟合应该是0.8(训练集损失)与2.0(验证集损失)这种不在一个量级的损失比。</p><h3 id="曲线分析"><a href="#曲线分析" class="headerlink" title="曲线分析"></a>曲线分析</h3><p>观察训练过程中各种参数的变化是非常重要的，首先最重要的当属损失曲线(loss curves)。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/Screenshot_20from_202018-10-29_2008-51-34.png" alt></p><p>上图所示是一个比较“完美”的损失曲线变化图，<strong>在训练开始阶段损失值下降幅度很大，说明学习率合适且进行梯度下降过程，在学习到一定阶段后，损失曲线趋于平稳，损失变化没有一开始那么明显。</strong>曲线中的<strong>毛刺是因为batch-size的关系</strong>，batch-size设置越大，毛刺越小，毕竟每个batch-size的数据相当于不同的个体。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/Screenshot_20from_202018-10-29_2008-52-11.png" alt></p><p>上图也是一个正确的损失曲线，虽然看到<strong>变化趋势并不是很明显，但仍然可以看出曲线在慢慢下降，这个过程其实是一个fune-turning的阶段</strong>。承接于上一幅图的损失曲线，这幅图的损失值已经很小了，虽然毛刺很多，但是总体趋势是对的。</p><p>那么什么才是有问题的去曲线呢？借用CS231n中的PPT：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/TIM_u622A_u56FE20181029201756.jpg" alt></p><p>上图中，左上角的图像是显然的学习不到任何东西(可能这样看起来比较困难，可以适当smooth一下)，而第二个则是典型的过拟合现象（训练loss已经很小了但是验证loss仍然很大，且不再下降）；第三个是更严重的过拟合；第四个损失值没有趋于平稳，很有可能是没有训练够；第五个经历了比较长的iterate才慢慢收敛，显然是初始化权重太小了，<strong>但是也有一种情况，那就是你的数据集中含有不正确的数据(比喻为老鼠屎)，比如猫的数据集中放了两种狗的图像，这样也会导致神经网络花费大量的时间去纠结</strong>；而最后一个越学习损失值越大，很有可能是“梯度向上”了。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/TIM_u622A_u56FE20181029202242.jpg" alt></p><p>上图则展示了更多的错误：左上一和二：没有对数据集进行洗牌，也就是每次训练都是采用同一个顺序对数据集进行读取（loss曲线周期性震荡）；右上一：训练的过程中突然发现曲线消失了，为什么？因为遇到了nan值(在图中是显示不出来的)，但我们要意识到这个问题，这个问题很有可能是模型设置的缘故；最后一个图显示较小比例的val集设置会导致统计不准确，比较好的val设置比例是0.2。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/TIM_u622A_u56FE20181029203032.jpg" alt></p><p>上图左边的曲线图可以明显看到，一共训练了五次(五条曲线)，但是在训练过程中却发现“很难”收敛，也就是神经网络学地比较困难。为什么呢？原因很简单，很有可能使我们在softmax层之前加入了非线性激活函数(比如RELU)，本来softmax函数希望我们输入负数或者正数(负数输入时Softmax期望输出比较小，而输入正数时softmax其实输出比较大)，但是relu只有正值，那么输入到softmax会造成信息的丢失，造成学习异常困难。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://srdas.github.io/DLBook/DL_images/TNN6.png" alt="Effect of Learning Rate on the Loss Function"></p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>在我们参加kaggle比赛的一个图像分割比赛时，碰见了loss上升，同时acc(这里为dice)也在上升的情况。如下图所示：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/39f9889b-30a3-4cb4-8972-113d944bb236.png" alt></p><p>查阅资料，可能是这样的情况：</p><ul><li>情况一：一些边界点预测结果变得更好，他们的输出类别变了。例如一张图的正确样本为猫，之前预测结果为0.4的可能性为猫，而0.6的可能性为马。现在预测结果为0.6的可能性为猫，而0.4的可能性为马。此时，精确度增加了，而损失减少了。</li><li>情况二：假设有两类——猫和马。对于我们的例子，正确的类是马。现在，Softmax的输出为<code>[0.9，0.1]</code>。对于这一损失约为0.37。分类器会预测它是一匹马。以Softmax输出为<code>[0.6，0.4]</code>的另一种情况为例，损失约0.6。分类器仍然会预测它是一匹马，但可以肯定的是，损失增加了，而正确率不变。</li></ul><p>当有很多样本的时候，若情况一减少的loss抵不过情况二的loss的上升，就会出现loss上升，且acc(这里为dice)也在上升的情况。说明你模型的正则化技术正在起作用，防止过拟合。此时，应该多跑一些epoch，观察loss的整体情况。</p><ul><li>若之后loss下降，acc上升，则没有问题</li><li>若之后loss商城，acc下降，则一般情况下说明学习率比较大</li></ul><p>总结下，如果你认为你的神经网络设计没有明显错误的，但损失曲线显示仍然很奇怪，那么很有可能：</p><ul><li>损失函数采用的有问题</li><li>训练的数据的载入方式可能有问题</li><li>优化器(optimizer)可能有问题</li><li>一些其他的超参数设置可能有问题</li></ul><p>总而言之，损失曲线是观察神经网络是否有问题的一大利器，我们在训练过程中非常有必要去观察我们的损失曲线的变化，越及时越好！</p><p>随机失活和权重衰减两个比较重要的超参数，这两个参数通过观察损失曲线观察是不明显滴，只有通过特定的<strong>评价标准曲线（例如图像分割中的dice指标曲线）</strong>，设置好标准再进行比较，才可以判断出是否需要添加<code>dropout</code>或者<code>weight decay</code>。</p><p>标准化可能已经是训练神经网络的一个标准流程了，不论是在<strong>数据中进行标准化处理</strong>还是<strong>在网络中添加批标准化层</strong>，都是一种标准化的方法(两种使用一种即可)。</p><p>但是标准化技术通常只用于分类(以及衍生的一些应用)，但并不适合与那种对输入图像大小比较敏感以及风格迁移生成类的任务，不要问为什么，结果会给你答案..</p><p>batch-normalization的好处：<a href="https://www.learnopencv.com/batch-normalization-in-deep-networks/" target="_blank" rel="noopener">https://www.learnopencv.com/batch-normalization-in-deep-networks/</a><br>相关讨论：<a href="https://www.zhihu.com/question/62599196" target="_blank" rel="noopener">https://www.zhihu.com/question/62599196</a></p><p>而我们也是通过观察准确率和损失值的曲线来判断是否需要加入标准化技术。</p><h2 id="Learning-Rate与Batch-Size的关系"><a href="#Learning-Rate与Batch-Size的关系" class="headerlink" title="Learning Rate与Batch Size的关系"></a>Learning Rate与Batch Size的关系</h2><p>一般来说，越大的batch-size使用越大的学习率。</p><p>原理很简单，越大的<code>batch-size</code>意味着我们学习的时候，收敛方向的<code>confidence</code>越大，我们前进的方向更加坚定，而小的<code>batch-size</code>则显得比较杂乱，毫无规律性，因为相比批次大的时候，批次小的情况下无法照顾到更多的情况，所以需要小的学习率来保证不至于出错。</p><p>可以看下图<code>损失Loss</code>与<code>学习率Lr</code>的关系：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/learning_rate_and_batch___.PNG" alt><br><img src="/DeepLearningApplications/实战/Kaggle比赛经验/learning_rate_and_batch_size.PNG" alt></p><p>上图来源于这篇文章：<a href="https://miguel-data-sc.github.io/2017-11-05-first/" target="_blank" rel="noopener">Visualizing Learning rate vs Batch size</a></p><p>当然我们也可以从上图中看出，<strong>当batchsize变大后，得到好的测试结果所能允许的lr范围在变小</strong>，也就是说，当batchsize很小时，比较容易找打一个合适的lr达到不错的结果，当batchsize变大后，可能需要精细地找一个合适的lr才能达到较好的结果，这也给实际的large batch分布式训练带来了困难。</p><p>所以说，在显存足够的条件下，最好采用较大的batch-size进行训练，找到合适的学习率后，可以加快收敛速度。另外，较大的batch-size可以避免batch normalization出现的一些小问题：<a href="https://github.com/pytorch/pytorch/issues/4534" target="_blank" rel="noopener">https://github.com/pytorch/pytorch/issues/4534</a></p><p>更多类似的问题可以在知乎找到相关答案：<a href="https://www.zhihu.com/question/64134994/answer/216895968" target="_blank" rel="noopener">https://www.zhihu.com/question/64134994/answer/216895968</a></p><h2 id="多尺度训练"><a href="#多尺度训练" class="headerlink" title="多尺度训练"></a>多尺度训练</h2><p>多尺度训练是一种<strong>直接有效</strong>的方法，通过输入不同尺度的图像数据集，因为神经网络卷积池化的特殊性，这样可以让神经网络充分地学习不同分辨率下图像的特征，可以提高机器学习的性能。</p><p>也可以用来处理过拟合效应，<strong>在图像数据集不是特别充足的情况下，可以先训练小尺寸图像，然后增大尺寸并再次训练相同模型</strong>，这样的思想在Yolo-v2的论文中也提到过：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/TIM_u622A_u56FE20181023094604.jpg" alt></p><p>需要注意的是：多尺度训练并不是适合所有的深度学习应用，多尺度训练可以算是特殊的数据增强方法，在图像大小这一块做了调整。如果有可能最好利用可视化代码将多尺度后的图像近距离观察一下，<strong>看看多尺度会对图像的整体信息有没有影响</strong>，如果对图像信息有影响的话，这样直接训练的话会误导算法导致得不到应有的结果。例如，对于有些数据集，本身目标在图像中大小基本一致，可能不是很有效。语义分割数据集(如城市景观)包含来自不同距离的对象，因此模型必须能够检测到不同尺度的对象，所以多尺度训练效果可能较好。</p><p>PS：在我们最近参加的<a href="https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation" target="_blank" rel="noopener">siim-acr-pneumothorax-segmentation</a>比赛中，项目方提供的大小为1024；若直接训练1024，一来训练速度太慢，二来batch size太小，导致网络中的batch norm操作不能使用正确的数据统计信息，三来结果不是很好。所以，第一阶段先在768大小上进行预训练，第二阶段在1024大小上进行fine-tuing，注意的是，在第二阶段的学习率要比第一阶段的小，且优化器不需要加载第一阶段的优化器，需要重新初始化。另外，若第一阶段使用512大小的数据预训练，效果并没有在768上预训练好，可能因为768的数据统计特性更接近1024分辨率的数据统计特性。最后，第一阶段不能训练过多的epoch，否则会导致在第一阶段就过拟合了，在进行第二阶段的fine-tuing时候，跳不出局部最优解。</p><blockquote><p>关于上面batchnorm操作的<a href="https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation/discussion/100736591271" target="_blank" rel="noopener">解释</a>: Gradient accumulation can solve this problem, no?</p><p>It can’t because the problem is not noisy gradients but the poor statistics that the batch norm will use (this is computed on the fly during forward pass and depends on batch size). Gradient accumulation can help you get better gradients and consequently allows you to use a higher learning rate but, unfortunately, it won’t help with the batch norm issue.</p><p>Other methods of normalization such as layer norm or instance norm do not depend on the batch size (they perform normalization image-wise). However, since they are non-stochastic by design, they do not help with regularization like BN does.</p><p>Group norm, on the other hands, maintains the batch independence whilst introducing some randomness since it uses groups of channels instead of all of them, similarly to the ResNeXt architecture family.</p></blockquote><h2 id="超参数搜索"><a href="#超参数搜索" class="headerlink" title="超参数搜索"></a>超参数搜索</h2><p>很多时候，模型搭建好了，但是随之而来的就是参数选择问题。参数选择我们一般大概分为两种方式，手动选择和自动选择。</p><ul><li><strong>手动选择</strong>就是我们利用对模型的理解和对结果的分析进行调参，手动选择参数，这样准确率稍高一些，但是时间长了我们会受不了，有时候真的会怀疑人生。</li><li><strong>自动选择</strong>就是设计一个自动调参工具，让程序自己跑就行了，当然这个对机子的要求高一些，相同情况下用GPU调参速度是用CPU的几十倍。</li></ul><p>接下来主要说一下自动选择的几个方式，程序利用Pytorch代码说明。</p><h3 id="网格搜索"><a href="#网格搜索" class="headerlink" title="网格搜索"></a>网格搜索</h3><p>网格搜索是我们最常用的超参数调参策略。我们把每个可能的超参数组合都写下来，进行尝试：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">style_weights = [0.1, 0.5, 1, 1.5, 2.5, 5, 10, 15, 20, 50, 100, 150, 200, 500, 1000,</span><br><span class="line">                 5000, 10000, 50000, 100000, 500000, 1000000]</span><br><span class="line">content_weights = [1, 5, 10, 100]</span><br></pre></td></tr></table></figure><p></p><p>比如上面的代码，我们有两个超参数，分别是<code>style_weight</code>和<code>content_weight</code>，我们列出这些参数可能的值，然后进行训练：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(content_weights)):</span><br><span class="line">    for j in range(len(style_weights)):</span><br><span class="line">        output = run_painterly_transfer(cnn, cnn_normalization_mean, cnn_normalization_std, style_img=style_image,content_img=content_image, mask_img=mask_image, tmask_img=tmask_image,style_weight=int(style_weights[j]), content_weight=int(content_weights[i]))</span><br></pre></td></tr></table></figure><p></p><p>代码很简单，通过循环将你觉得可能的参数都尝试了一遍，我们可以在程序执行的过程中把你觉得需要的中间结果和最终结果都保存到一个文件夹中，当训练完成后去查看分析即可。</p><p>整个过程就像下面的动图：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/grid_search.gif" style="zoom:67%"></p><h3 id="随机搜索"><a href="#随机搜索" class="headerlink" title="随机搜索"></a>随机搜索</h3><p>随机搜索就是利用分布函数来模拟随机数，然后利用随机数生成的参数来进行训练：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 我们利用numpy中的随机数生成器来生成随机数</span><br><span class="line">style_weights_rd = list(np.random.randint(0, 1000, size=20))</span><br><span class="line">content_weights_rd = list(np.random.randint(0, 10, size=5))</span><br></pre></td></tr></table></figure><p></p><p>同上面的参数一样，只不过换成了在特定范围的随机值，当然这个范围是我们自己定的。</p><p>然后将下面list换成随机list即可：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(content_weights_rd)):</span><br><span class="line">    for j in range(len(style_weights_rd)):</span><br><span class="line">        output = run_painterly_transfer(cnn, cnn_normalization_mean, cnn_normalization_std, style_img=style_image,content_img=content_image, mask_img=mask_image, tmask_img=tmask_image,style_weight=int(style_weights_rd[j]), content_weight=int(content_weights_rd[i]))</span><br></pre></td></tr></table></figure><p></p><p>整个过程动图分析如下：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/random_search.gif" style="zoom:67%"></p><p>在<a href="http://jmlr.csail.mit.edu/papers/volume13/bergstra12a/bergstra12a.pdf" target="_blank" rel="noopener">《Random Search for Hyper-Parameter Optimization》</a>这篇论文中提高了为什么我们经常使用随机搜索而不是用网格，其实上面的图很形象了，那就是实际中适合的参数往往在一个完整分布中的一小块部分，我们使用网络搜索并不能保证直接搜索到合适的超参数中，而随机搜索则大大提高了找到合适参数的可能性。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/grid_vs_random-1024x553.png" style="zoom:67%"></p><p>上图则表明重要参数和不重要的参数在不同方法下的搜索情况，我们给了两个超参数，网格搜索只能在我们设定的一小组范围内进行，而随机搜索中的每个超参数是独立的。也就是说网格搜索因为我们的设定，超参数之间是有些许联系的，并不是独一无二。研究表明随机搜索能够更快地减少验证集的误差。</p><p>下面的代码中，加入<code>content_weight</code>中的1和5对结果的影响不大，但是我们通过for循环组合，和<code>style_weights</code>中的所有值都进行了尝试了，显然浪费了时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">style_weights = [0.1, 0.5, 1, 1.5, 2.5, 5, 10, 15, 20, 50, 100, 150, 200, 500, 1000,</span><br><span class="line">                   5000, 10000, 50000, 100000, 500000, 1000000]</span><br><span class="line">content_weights = [1, 5, 10, 100]</span><br></pre></td></tr></table></figure><h2 id="Cross-Validation"><a href="#Cross-Validation" class="headerlink" title="Cross Validation"></a>Cross Validation</h2><p><a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics" target="_blank" rel="noopener">Cross Validation</a>) 是非常重要的一个环节。它让你知道你的 Model 有没有 Overfit，是不是真的能够 Generalize 到测试集上。在很多比赛中 <strong>Public LB</strong> 都会因为这样那样的原因而不可靠。当你改进了 Feature 或是 Model 得到了一个更高的 <strong>CV</strong> 结果，提交之后得到的 <strong>LB</strong> 结果却变差了，<strong>一般认为这时应该相信 CV 的结果</strong>。当然，最理想的情况是多种不同的 <strong>CV</strong> 方法得到的结果和 <strong>LB</strong> 同时提高，但这样的比赛并不是太多。</p><p>在数据的分布比较随机均衡的情况下，<strong>5-Fold CV</strong> 一般就足够了。如果不放心，可以提到 <strong>10-Fold</strong>。<strong>但是 Fold 越多训练也就会越慢，需要根据实际情况进行取舍。</strong></p><p>很多时候简单的 <strong>CV</strong> 得到的分数会不大靠谱，Kaggle 上也有很多关于如何做 <strong>CV</strong> 的讨论。比如<a href="https://www.kaggle.com/c/telstra-recruiting-network/forums/t/19277/what-is-your-cross-validation-method" target="_blank" rel="noopener">这个</a>。但总的来说，靠谱的 <strong>CV</strong> 方法是 Case By Case 的，需要在实际比赛中进行尝试和学习，这里就不再（也不能）叙述了。</p><p>如果数据出现Label不均衡情况，可以使用<strong>Stratified K-fold</strong>，这样得到的Train Set和Test Set的Label比例是大致相同。</p><blockquote><p>关键的是，随机划分结果要队伍内和方案间共享。不然的话，这个模型训练用的K折划分和那个模型训练用的K折划分不同，还怎么严格比较它们之间的优劣呢？而且这也是为后面数据分析和模型的Ensemble（集成）做准备。</p></blockquote><p>交叉验证的思考：</p><ul><li>比如分5fold，每次取一份作为验证，剩余的用于训练。由此可以得到<strong>同一个模型</strong>在不同fold上(即不同训练集上)的5个权重，对这5个权重分别在各自验证集上验证并挑选阈值，取这5个最优阈值的平均值作为<strong>最终阈值</strong>。另外，对5个权重分别对测试集进行测试，将测试结果进行<strong>平均</strong>或者依据5个权重在各自验证集上表现<strong>加权平均</strong>。如下图所示</li><li>但是折数越高，所需的运算量也较越多。</li></ul><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/cabd979c-84c0-4544-afca-33f3b9c96fb7.png" alt></p><p>另外，我们在上面的<code>交叉验证思考</code>部分说了，可以将对5个权重分别对测试集进行测试，将测试结果依据5个权重在各自验证集上表现<strong>加权平均</strong>。若直接使用上面所述的CV方法不是很严谨。因为每个模型均在自己的验证集上进行评估，权重受到交叉验证划分方法的影响较大。此时，我们可以采用从整个数据集中划出一部分作为holdout set，剩余部分做交叉验证。这样最终5个权重均在这个holdout set上进行测试，评估模型的泛化能力，然后进行加权。</p><h2 id="TTA-Test-Time-Augmentation"><a href="#TTA-Test-Time-Augmentation" class="headerlink" title="TTA(Test Time Augmentation)"></a>TTA(Test Time Augmentation)</h2><p>最初这个概念是在fastai课程中看到的，这个过程在训练阶段不会参与，是通过在验证和测试阶段进行的。具体过程是，对所要处理的图像进行几种随机的图像增强变化，然后对每种图像增强后的图像进行预测，对预测结果取平均值。</p><p>原理类似于模型平均，牺牲推断速度来实现推断精度的提升。</p><h2 id="Ensemble-Generation"><a href="#Ensemble-Generation" class="headerlink" title="Ensemble Generation"></a>Ensemble Generation</h2><p>机器学习的模型，必不可少地对数据非常依赖。然而，如果你不知道数据服从一个什么样的分布，或者你没有办法拿到所有可能的数据（肯定拿不到所有的），那么我们<strong>训练出来的模型和真实模型之间，就会存在不一致</strong>。这种不一致表现在两个方面。</p><ul><li>真实模型根本就没有包含在我们训练模型的模型空间中。比如本来是非线性模型，你非要拿线性模型去拟合数据，那么不论你怎么调整模型参数去选择模型，结果也是不对的。这就是<strong>偏差</strong>的来源。<strong>表现为模型不正确。</strong></li><li>不管真实模型在不在我们训练模型的空间中，由于我们不能拿到所有可能的数据，如果拿到的数据不是那么具有代表性，那么不同的数据训练出来的模型参数就会不同。然后用这个模型去做预测，结果也就会和真实值之间有差异。这就是<strong>方差</strong>的来源。<strong>表现为模型不稳定。</strong></li></ul><p>用打靶的例子来说明。偏差好比你的瞄准能力；方差好比你使用的枪的性能。</p><ul><li><p>瞄准的时候，正确的方式除了要考虑到三点一线，还要考虑到风向，子弹的速度和重力，距离的远近等等。如果你只会三点一线，那么就会带来偏差，因为你能力比较弱。</p></li><li><p>而枪的性能也很重要。好的枪精度高，只要你瞄的准，他都能打到瞄准点附近非常小的范围之内；而差的枪，比如你用弹弓，就算每次都瞄的准，但是它打到瞄准点附近的范围变化就比较大。</p></li></ul><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/20150806140556146" alt="这里写图片描述"></p><p>介绍完模型偏差和方差的基本概念，接着介绍模型的Ensemble Learning。</p><p><a href="https://en.wikipedia.org/wiki/Ensemble_learning" target="_blank" rel="noopener">Ensemble Learning</a> 是指将多个不同的 Base Model 组合成一个 Ensemble Model 的方法。它可以<strong>同时降低最终模型的 Bias 和 Variance</strong>（证明可以参考<a href="http://link.springer.com/chapter/10.1007%2F3-540-33019-4_19" target="_blank" rel="noopener">这篇论文</a>)，<strong>从而在提高分数的同时又降低 Overfitting 的风险</strong>。在现在的 Kaggle 比赛中要不用 Ensemble 就拿到奖金几乎是不可能的。</p><p>常见的 Ensemble 方法有这么几种：</p><ul><li>Bagging：使用训练数据的不同随机子集来训练每个 Base Model，最后进行每个 Base Model 权重相同的 Vote。也即 Random Forest 的原理。</li><li>Boosting：迭代地训练 Base Model，每次根据上一个迭代中预测错误的情况修改训练样本的权重。也即 Gradient Boosting 的原理。比 Bagging 效果好，但更容易 Overfit。</li><li>Blending：用不相交的数据训练不同的 Base Model，将它们的输出取（加权）平均。实现简单，但对训练数据利用少了。</li><li>Stacking：接下来会详细介绍。</li></ul><p>从理论上讲，Ensemble 要成功，有两个要素：</p><ul><li><strong>Base Model 之间的相关性要尽可能的小。</strong>这就是为什么非 Tree-based Model 往往表现不是最好但还是要将它们包括在 Ensemble 里面的原因。Ensemble 的 Diversity 越大，最终 Model 的 Bias 就越低。</li><li><strong>Base Model 之间的性能表现不能差距太大。</strong>这其实是一个 <strong>Trade-off</strong>，在实际中很有可能表现相近的 Model 只有寥寥几个而且它们之间相关性还不低。但是实践告诉我们即使在这种情况下 Ensemble 还是能大幅提高成绩。</li></ul><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p>Stacking是用<strong>新的模型（次学习器）去学习怎么组合那些基学习器</strong>，它的思想源自于<a href="http://www.machine-learning.martinsewell.com/ensembles/stacking/Wolpert1992.pdf" target="_blank" rel="noopener">Stacked Generalization</a>这篇论文。如果把Bagging看作是多个基分类器的线性组合，那么Stacking就是多个基分类器的非线性组合。</p><p>相比 Blending，Stacking 能更好地利用训练数据。以 5-Fold Stacking 为例，它的基本原理如图所示：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/kaggle-guide-stacking-diagram.jpg" alt></p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/_u65E0_u6807_u9898.png" alt></p><p>整个过程很像 Cross Validation。首先将训练数据分为 5 份，接下来一共 5 个迭代，每次迭代时，将 4 份数据作为 Training Set 对每个 Base Model 进行训练，然后在剩下一份 Hold-out Set 上进行预测。<strong>同时也要将其在测试数据上的预测保存下来。</strong>这样，每个 Base Model 在每次迭代时会对训练数据的其中 1 份做出预测，对测试数据的全部做出预测。5 个迭代都完成以后我们就获得了一个 <code>#训练数据行数 x #Base Model 数量</code> 的矩阵(称为out-of-fold)，这个矩阵接下来就作为第二层的 Model 的训练数据。当第二层的 Model 训练完以后，将之前保存的 Base Model 对测试数据的预测（<strong>因为每个 Base Model 被训练了 5 次，对测试数据的全体做了 5 次预测，所以对这 5 次求一个平均值，从而得到一个形状与第二层训练数据相同的矩阵，如上面第一幅图所示；当然也可以用所有的Training Data重新训练一个新模型来预测Test Data，从而得到一个形状与第二层训练数据相同的矩阵，如上面第二幅图所示</strong>）拿出来让它进行预测，就得到最后的输出。</p><p>这里给出我的实现代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ensemble</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_folds, stacker, base_models)</span>:</span></span><br><span class="line">        self.n_folds = n_folds</span><br><span class="line">        self.stacker = stacker</span><br><span class="line">        self.base_models = base_models</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_predict</span><span class="params">(self, X, y, T)</span>:</span></span><br><span class="line">        X = np.array(X)</span><br><span class="line">        y = np.array(y)</span><br><span class="line">        T = np.array(T)</span><br><span class="line"></span><br><span class="line">        folds = list(KFold(len(y), n_folds=self.n_folds, shuffle=<span class="literal">True</span>, random_state=<span class="number">2016</span>))</span><br><span class="line"></span><br><span class="line">        S_train = np.zeros((X.shape[<span class="number">0</span>], len(self.base_models)))</span><br><span class="line">        S_test = np.zeros((T.shape[<span class="number">0</span>], len(self.base_models)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, clf <span class="keyword">in</span> enumerate(self.base_models):</span><br><span class="line">            S_test_i = np.zeros((T.shape[<span class="number">0</span>], len(folds)))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j, (train_idx, test_idx) <span class="keyword">in</span> enumerate(folds):</span><br><span class="line">                X_train = X[train_idx]</span><br><span class="line">                y_train = y[train_idx]</span><br><span class="line">                X_holdout = X[test_idx]</span><br><span class="line">                <span class="comment"># y_holdout = y[test_idx]</span></span><br><span class="line">                clf.fit(X_train, y_train)</span><br><span class="line">                y_pred = clf.predict(X_holdout)[:]</span><br><span class="line">                S_train[test_idx, i] = y_pred</span><br><span class="line">                S_test_i[:, j] = clf.predict(T)[:]</span><br><span class="line"></span><br><span class="line">            S_test[:, i] = S_test_i.mean(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.stacker.fit(S_train, y)</span><br><span class="line">        y_pred = self.stacker.predict(S_test)[:]</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure><p></p><p>获奖选手往往会使用比这复杂得多的 Ensemble，会出现三层、四层甚至五层，不同的层数之间有各种交互，还有将经过不同的 Preprocessing 和不同的 Feature Engineering 的数据用 Ensemble 组合起来的做法。但对于新手来说，稳稳当当地实现一个正确的 5-Fold Stacking 已经足够了。</p><blockquote><p>做stacking ensemble的时候需要固定k-fold，成员之间也需要固定k-fold，否则容易出现过拟合。</p></blockquote><h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p>XGBoost一直在竞赛江湖里被传为神器，比如时不时某个Kaggle/天池比赛中，某人用XGBoost于千军万马中斩获冠军。</p><p>而我们的机器学习课程里也必讲XGBoost，如寒所说：“ <strong>RF(随机森林)和GBDT(梯度提升决策树)</strong> 是工业界大爱的模型，XGBoost是大杀器包裹，Kaggle各种Top排行榜曾一度呈现XGBoost一统江湖的局面，另外某次滴滴比赛第一名的改进也少不了XGBoost的功劳”。</p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>举个例子，集训营某一期有100多名学员，假定给你一个任务，要你统计男生女生各多少人，当一个一个学员依次上台站到你面前时，你会怎么区分谁是男谁是女呢？</p><p>很快，你考虑到男生的头发一般很短，女生的头发一般比较长，所以你通过头发的长短将这个班的所有学员分为两拨，长发的为“女”，短发为“男”。</p><p>相当于你依靠一个指标“头发长短”将整个班的人进行了划分，于是形成了一个简单的决策树，而划分的依据是头发长短。</p><p>这时，有的人可能有不同意见了：为什么要用“头发长短”划分呀，我可不可以用“穿的鞋子是否是高跟鞋”，“有没有喉结”等等这些来划分呢，答案当然是可以的。</p><p><strong>但究竟根据哪个指标划分更好呢？很直接的判断是哪个分类效果更好则优先用哪个。</strong>所以，这时就需要一个评价标准来量化分类效果了。</p><p>怎么判断“头发长短”或者“是否有喉结”是最好的划分方式，效果怎么量化呢？直观上来说，如果根据某个标准分类人群后，纯度越高效果越好，比如说你分为两群，“女”那一群都是女的，“男”那一群全是男的，那这个效果是最好的。但有时实际的分类情况不是那么理想，所以只能说越接近这种情况，我们则认为效果越好。</p><p>量化分类效果的方式有很多，比如信息增益（ID3）、信息增益率（C4.5）、基尼系数（CART）等等。</p><p><strong>这里介绍下信息增益的度量标准：熵</strong></p><p>ID3算法的核心思想就是以信息增益度量属性选择，<strong>选择分裂后信息增益最大的属性进行分裂。</strong></p><p>什么是信息增益呢？为了精确地定义信息增益，我们先定义信息论中广泛使用的一个度量标准，称为<strong>熵（entropy），它刻画了任意样例集的纯度（purity）</strong>。给定包含关于某个目标概念的正反样例的样例集S，那么S相对这个布尔型分类的熵为：</p><script type="math/tex;mode=display">Entropy(s)=-p_{\oplus}log_2p_{\oplus}-p_{\ominus}log_2p_{\ominus}</script><p>在上式中，$p_{\oplus}$代表正样例，比如在本文开头第二个例子中代表男生，而$p_{\ominus}$表示负样例，女生。在有关熵的计算中所有$0log0=0$。</p><p>举例来说，假设S是一个关于布尔概念的有14个样例的集合，它包括9个正例和5个反例（我们采用记号<code>[9+，5-]</code>来概括这样的数据样例），那么S相对于这个布尔样例的熵为：</p><script type="math/tex;mode=display">Entropy（[9+，5-]）=-（9/14）log_2（9/14）-（5/14）log_2（5/14）=0.940</script><p>So，根据上述这个公式，我们可以得到：</p><ul><li>如果S的所有成员属于同一类，则$Entropy(S)=0$；</li><li>如果S的正反样例数量相等，则$Entropy(S)=1$；</li><li>如果S的正反样例数量不等，则熵介于0，1之间</li></ul><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/9ce664c1-3db5-41bd-915c-3b262633ef4a.jpg" alt></p><p>看到没，<strong>通过Entropy的值，你就能评估当前分类树的分类效果好坏了。</strong></p><p>更多细节如剪枝、过拟合、优缺点、可以参考此文<a href="https://blog.csdn.net/v_july_v/article/details/7577684" target="_blank" rel="noopener">决策树学习</a>。</p><p>所以，现在决策树的灵魂已经有了，即<strong>依靠某种指标进行树的分裂达到分类/回归的目的，总是希望纯度越高越好。</strong></p><h3 id="回归树与集成学习"><a href="#回归树与集成学习" class="headerlink" title="回归树与集成学习"></a>回归树与集成学习</h3><p>如果用一句话定义XGBoost，很简单：XGBoost就是由很多CART树集成。但，什么是CART树？</p><p>数据挖掘或机器学习中使用的决策树有两种主要类型：</p><ul><li>分类树分析是指预测结果是数据所属的类（比如某个电影去看还是不看）</li><li>回归树分析是指预测结果可以被认为是实数（例如房屋的价格，或患者在医院中的逗留时间）</li></ul><p>而<strong>术语分类回归树（CART，Classification And Regression Tree）分析是用于指代上述两种树的总称</strong>，由Breiman等人首先提出。</p><h4 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h4><p>事实上，分类与回归是两个很接近的问题，分类的目标是根据已知样本的某些特征，判断一个新的样本属于哪种已知的样本类，它的结果是离散值。而回归的结果是连续的值。当然，本质是一样的，都是特征（feature）到结果/标签（label）之间的映射。</p><p>理清了什么是分类和回归之后，理解分类树和回归树就不难了。</p><p><strong>分类树的样本输出（即响应值）是类的形式</strong>，比如判断这个救命药是真的还是假的，周末去看电影《风语咒》还是不去。而<strong>回归树的样本输出是数值的形式</strong>，比如给某人发放房屋贷款的数额就是具体的数值，可以是0到300万元之间的任意值。</p><p>所以，对于回归树，<strong>你没法再用分类树那套信息增益、信息增益率、基尼系数来判定树的节点分裂了，你需要采取新的方式评估效果，包括预测误差（常用的有均方误差、对数误差等）。而且节点不再是类别，是数值（预测值）</strong>，那么怎么确定呢？有的是节点内样本均值，有的是最优化算出来的比如XGBoost。</p><p>CART回归树是假设树为二叉树，通过不断将特征进行分裂。比如当前树结点是基于第$j$个特征值进行分裂的，设该特征值小于$s$的样本划分为左子树，大于$s$的样本划分为右子树。</p><script type="math/tex;mode=display">R_{1}(j, s)=\left\{x | x^{(j)} \leq s\right\} \text { and } R_{2}(j, s)=\left\{x | x^{(j)}>s\right\}</script><p>而CART回归树实质上就是在该特征维度对样本空间进行划分，而这种空间划分的优化是一种NP难问题，因此，在决策树模型中是使用启发式方法解决。典型CART回归树产生的目标函数为：</p><script type="math/tex;mode=display">\sum_{x_{i} \in R_{m}}\left(y_{i}-f\left(x_{i}\right)\right)^{2}</script><p>因此，当我们为了求解最优的切分特征$j$和最优的切分点$s$，就转化为求解这么一个目标函数：</p><script type="math/tex;mode=display">\min _{j, s}\left[\min _{c_{1}} \sum_{x_{i} \in R_{1}(j, s)}\left(y_{i}-c_{1}\right)^{2}+\min _{c_{2}} \sum_{x_{i} \in R_{2}(j, s)}\left(y_{i}-c_{2}\right)^{2}\right]</script><p>所以我们只要<strong>遍历所有特征的的所有切分点，就能找到最优的切分特征和切分点。最终得到一棵回归树。</strong></p><blockquote><p>这里的特征可以理解为数据的属性，比如说，一个人身高体重等。</p></blockquote><h4 id="boosting集成学习"><a href="#boosting集成学习" class="headerlink" title="boosting集成学习"></a>boosting集成学习</h4><p>所谓集成学习，是指构建多个分类器（弱分类器）对数据集进行预测，然后用某种策略将多个分类器预测的结果集成起来，作为最终预测结果。通俗比喻就是“三个臭皮匠赛过诸葛亮”，或一个公司董事会上的各董事投票决策，它要求每个弱分类器具备一定的“准确性”，分类器之间具备“差异性”。</p><p>集成学习根据各个弱分类器之间有无依赖关系，分为Boosting和Bagging两大流派：</p><ul><li>Boosting流派，各分类器之间有依赖关系，必须串行，比如Adaboost、GBDT(Gradient Boosting Decision Tree)、XGBoost</li><li>Bagging流派，各分类器之间没有依赖关系，可各自并行，比如随机森林（Random Forest）</li></ul><p>著名的Adaboost作为boosting流派中最具代表性的一种方法，下面详细介绍它。</p><p>AdaBoost，是英文”Adaptive Boosting”（自适应增强）的缩写，由Yoav Freund和Robert Schapire在1995年提出。它的自适应在于：前一个基本分类器分错的样本会得到加强，加权后的全体样本再次被用来训练下一个基本分类器。同时，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数。</p><p>具体说来，整个Adaboost 迭代算法就3步：</p><ul><li>初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N。</li><li>训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</li><li>将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。</li></ul><p>而另一种boosting方法GBDT（Gradient Boost Decision Tree)，则与AdaBoost不同，GBDT每一次的计算是都为了减少上一次的残差，进而在残差减少（负梯度）的方向上建立一个新的模型。</p><p>boosting集成学习由多个<strong>相关联的决策树联合决策</strong>，什么叫相关联？举个例子</p><p>有一个样本<code>[数据-&gt;标签]</code>是：<code>[(2，4，5)-&gt; 4]</code>，第一棵决策树用这个样本训练的预测为<code>3.3</code>，那么第二棵决策树训练时的输入，这个样本就变成了：<code>[(2，4，5)-&gt; 0.7]</code>，也就是说，下一棵决策树输入样本会与前面决策树的训练和预测相关。</p><blockquote><p>之所以第二次输入标签变成了0.7，是因为要将所有弱分类器的结果相加，第一个弱分类器预测出的结果为3.3，第二个弱分类器则需要预测第一个分类器与真实值之间的差值，即为0.7。</p></blockquote><p>很快你会意识到，XGBoost为何也是一个boosting的集成学习了。</p><p>而一个回归树形成的关键点在于：</p><ul><li>分裂点依据什么来划分（如前面说的均方误差最小，loss）；</li><li>分裂后的节点预测值是多少（如前面说，有一种是将叶子节点下各样本实际值的均值作为叶子节点预测误差，或者计算所得）</li></ul><p>至于另一类集成学习方法，比如Random Forest（随机森林）算法，各个决策树是独立的、每个决策树在样本堆里随机选一批样本，随机选一批特征进行独立训练，各个决策树之间没有啥关系。本文暂不展开介绍。</p><h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><p>说到XGBoost，不得不先从GBDT(Gradient Boosting Decision Tree)说起。因为XGBoost本质上还是一个GBDT，但是力争把速度和效率发挥到极致，所以叫X (Extreme) GBoosted。包括前面说过，两者都是boosting方法。</p><p>GBDT的原理很简单，<strong>就是所有弱分类器的结果相加等于预测值，然后下一个弱分类器去拟合误差函数对预测值的梯度/残差(这个梯度/残差就是预测值与真实值之间的误差)</strong>。当然了，它里面的弱分类器的表现形式就是各棵树。如图所示：$Y = Y1 + Y2 + Y3$。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/3dd87f1c-f2bb-4976-b479-20023248a6d9.png" alt></p><p>举一个非常简单的例子，比如我今年30岁了，但计算机或者模型GBDT并不知道我今年多少岁，那GBDT咋办呢？</p><ul><li>它会在第一个弱分类器（或第一棵树中）随便用一个年龄比如20岁来拟合，然后发现误差有10岁；</li><li>接下来在第二棵树中，用6岁去拟合剩下的损失，发现差距还有4岁；</li><li>接着在第三棵树中用3岁拟合剩下的差距，发现差距只有1岁了；</li><li>最后在第四课树中用1岁拟合剩下的残差，完美。</li></ul><p>最终，四棵树的结论加起来，就是真实年龄30岁。<strong>实际工程中，GBDT是计算负梯度，用负梯度近似残差。</strong></p><p>注意，为何GBDT可以用用负梯度近似残差呢？</p><p>回归任务下，GBDT 在每一轮的迭代时对每个样本都会有一个预测值，此时的损失函数为均方差损失函数，</p><script type="math/tex;mode=display">l\left(y_{i}, y^{i}\right)=\frac{1}{2}\left(y_{i}-y^{i}\right)^{2}</script><script type="math/tex;mode=display">-\left[\frac{\partial l\left(y_{i}, y^{i}\right)}{\partial y^{i}}\right]=\left(y_{i}-y^{i}\right)</script><p>所以，<strong>当损失函数选用均方损失函数是时，每一次拟合的值就是（真实值-当前模型预测的值），即残差</strong>。此时的变量是$y^{i}$，即“当前预测模型的值”，也就是对它求负梯度。</p><p>另外，这里还得再啰嗦一下，上面预测年龄的第一个步骤中的“随便”二字看似随便，其实深入思考一下一点都不随便，你会发现大部分做预测的模型，基本都是这么个常规套路，先随便用一个值去预测，然后对比预测值与真实值的差距，最后不断调整 缩小差距。所以会出来一系列目标函数：确定目标，和损失函数：缩小误差。</p><p>再进一步思考，你会发现这完全符合人类做预测的普遍常识、普遍做法，当对一个事物不太了解时，一开始也是根据经验尝试、初探，直到逼近某种意义上的接近或者完全吻合。</p><p>还是年龄预测的例子。</p><p>简单起见，假定训练集只有4个人：A,B,C,D，他们的年龄分别是14,16,24,26。其中A、B分别是高一和高三学生；C,D分别是应届毕业生和工作两年的员工。</p><p>所以，现在的问题就是我们要预测这4个人的年龄，咋下手？很简单，先随便用一个年龄比如20岁去拟合他们，然后根据实际情况不断调整。</p><p>如果是用一棵传统的回归决策树来训练，会得到如下图所示结果：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/quesbase64153148112917172596.png" alt></p><p>现在我们使用GBDT来做这件事，由于数据太少，我们限定叶子节点做多有两个，即每棵树都只有一个分枝，并且限定只学两棵树。</p><p>我们会得到如下图所示结果：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/quesbase64153148115267426581.png" alt></p><p>在第一棵树分枝和图1一样，由于A,B年龄较为相近，C,D年龄较为相近，他们被分为左右两拨，每拨用平均年龄作为预测值。</p><p>此时计算<strong>残差（残差的意思就是：A的实际值 - A的预测值 = A的残差）</strong>，所以A的残差就是实际值14 - 预测值15 = 残差值-1。<br>注意，<strong>A的预测值是指前面所有树累加的和</strong>，这里前面只有一棵树所以直接是15，如果还有树则需要都累加起来作为A的预测值。<br>残差在数理统计中是指实际观察值与估计值（拟合值）之间的差。“残差”蕴含了有关模型基本假设的重要信息。如果回归模型正确的话， 我们可以将残差看作误差的观测值。</p><p>进而得到A,B,C,D的残差分别为-1,1，-1,1。</p><p>然后拿它们的残差-1、1、-1、1代替A B C D的原值，到第二棵树去学习，第二棵树只有两个值1和-1，直接分成两个节点，即A和C分在左边，B和D分在右边，经过计算（比如A，实际值-1 - 预测值-1 = 残差0，比如C，实际值-1 - 预测值-1 = 0），此时所有人的残差都是0。</p><p>残差值都为0，相当于第二棵树的预测值和它们的实际值相等，则只需把第二棵树的结论累加到第一棵树上就能得到真实年龄了，即每个人都得到了真实的预测值。</p><p>换句话说，现在A,B,C,D的预测值都和真实年龄一致了。Perfect！</p><ul><li>A: 14岁高一学生，购物较少，经常问学长问题，预测年龄A = 15 – 1 = 14</li><li>B: 16岁高三学生，购物较少，经常被学弟问问题，预测年龄B = 15 + 1 = 16</li><li>C: 24岁应届毕业生，购物较多，经常问师兄问题，预测年龄C = 25 – 1 = 24</li><li>D: 26岁工作两年员工，购物较多，经常被师弟问问题，预测年龄D = 25 + 1 = 26</li></ul><p>所以，GBDT需要将多棵树的得分累加得到最终的预测得分，且每一次迭代，都在现有树的基础上，增加一棵树去拟合前面树的预测结果与真实值之间的残差。</p><h3 id="XGBoost-1"><a href="#XGBoost-1" class="headerlink" title="XGBoost"></a>XGBoost</h3><h4 id="XGBoost树的定义"><a href="#XGBoost树的定义" class="headerlink" title="XGBoost树的定义"></a>XGBoost树的定义</h4><p>本节的示意图基本引用自XGBoost原作者陈天奇的讲义PPT中。</p><p>举个例子，我们要预测一家人对电子游戏的喜好程度，考虑到年轻和年老相比，年轻更可能喜欢电子游戏，以及男性和女性相比，男性更喜欢电子游戏，故先根据年龄大小区分小孩和大人，然后再通过性别区分开是男是女，逐一给各人在电子游戏喜好程度上打分，如下图所示。</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/20180804174128743.png" alt></p><p>就这样，训练出了2棵树tree1和tree2，类似之前GBDT的原理，两棵树的结论累加起来便是最终的结论，所以小孩的预测分数就是两棵树中小孩所落到的结点的分数相加：2 + 0.9 = 2.9。爷爷的预测分数同理：-1 + （-0.9）= -1.9。具体如下图所示</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/5-2.png" alt></p><p>恩，你可能要拍案而起了，惊呼，这不是跟上文介绍的GBDT乃异曲同工么？</p><p>事实上，如果不考虑工程实现、解决问题上的一些差异，XGBoost与GBDT比较大的不同就是目标函数的定义。XGBoost的目标函数如下图所示：</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/quesbase6415314827826172363.png" alt></p><ul><li>红色箭头所指向的L 即为损失函数，比如平方损失函数：$l\left(y_{i}, y^{i}\right)=\left(y_{i}-y^{i}\right)^{2}$，或logistic损失函数：$l\left(y_{i}, \hat{y}_{i}\right)=y_{i} \ln \left(1+e^{-\hat{y}_{i}}\right)+\left(1-y_{i}\right) \ln \left(1+e^{\hat{y}_{i}}\right)$</li><li>红色方框所框起来的是正则项（包括L1正则、L2正则）</li><li>红色圆圈所圈起来的为常数项</li><li>对于$f(x)$，XGBoost利用泰勒展开三项，做一个近似</li></ul><p>我们可以很清晰地看到，最终的目标函数只依赖于每个数据点在误差函数上的一阶导数和二阶导数。</p><p>额，峰回路转，突然丢这么大一个公式，不少人可能瞬间就懵了。没事，下面咱们来拆解下这个目标函数，并一一剖析每个公式、每个符号、每个下标的含义。</p><h4 id="XGBoost目标函数"><a href="#XGBoost目标函数" class="headerlink" title="XGBoost目标函数"></a>XGBoost目标函数</h4><p>XGBoost的核心算法思想不难，基本就是</p><p>1.不断地添加树，不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数，去拟合上次预测的残差。</p><script type="math/tex;mode=display">\hat{y}=\phi\left(x_{i}\right)=\sum_{k=1}^{K} f_{k}\left(x_{i}\right)</script><script type="math/tex;mode=display">F=\left\{f(x)=w_{q(x)}\right\}\left(q : R^{m} \rightarrow T, w \in R^{T}\right)</script><p>注：$w_q(x)$为叶子节点$q$的分数，$\mathcal{F}$对应了所有$K$棵回归树（regression tree）的集合，而$f(x)$为其中一棵回归树。</p><p>2.当我们训练完成得到$k$棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数。</p><p>3.最后只需要将每棵树对应的分数加起来就是该样本的预测值。</p><p>显然，我们的目标是要使得树群的预测值$\hat{y}_{i}$尽量接近真实值$y_{i}$，而且有尽量大的泛化能力。</p><p>所以，从数学角度看这是一个泛函最优化问题，故把目标函数简化如下：</p><script type="math/tex;mode=display">L(\phi)=\sum_{i} l\left(\hat{y}_{i}-y_{i}\right)+\sum_{k} \Omega\left(f_{k}\right)</script><p>如你所见，这个目标函数分为两部分：损失函数和正则化项。且损失函数揭示训练误差（即预测分数和真实分数的差距），正则化定义复杂度。</p><p>对于上式而言，$\hat{y}_{i}$是整个累加模型的输出，正则化项$\sum_{k} \Omega\left(f_{k}\right)$是则表示树的复杂度的函数，值越小复杂度越低，泛化能力越强，其表达式为</p><script type="math/tex;mode=display">\Omega(f)=\gamma T+\frac{1}{2} \lambda\|w\|^{2}</script><p>$T$表示叶子节点的个数，$w$表示叶子节点的分数。直观上看，目标要求预测误差尽量小，且叶子节点$T$尽量少（$γ$控制叶子结点的个数），节点数值$w$尽量不极端（$λ$控制叶子节点的分数不会过大），防止过拟合。</p><p>插一句，一般的目标函数都包含下面两项</p><p><img src="/DeepLearningApplications/实战/Kaggle比赛经验/20180805010136131.png" alt></p><p>其中，误差/损失函数鼓励我们的模型尽量去拟合训练数据，使得最后的模型会有比较少的 bias。而正则化项则鼓励更加简单的模型。因为当模型简单之后，有限数据拟合出来结果的随机性比较小，不容易过拟合，使得最后模型的预测更加稳定。</p><p>未完待续…</p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>文章中的visio图的附件在<a href="Kaggle比赛经验_Attachments/cross validation.vsdx">这里</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://dnc1994.com/2016/04/rank-10-percent-in-first-kaggle-competition/" target="_blank" rel="noopener">如何在 Kaggle 首战中进入前 10%</a><br><a href="https://cloud.tencent.com/developer/article/1064642" target="_blank" rel="noopener">分分钟带你杀入Kaggle Top 1%</a><br><a href="https://www.zhihu.com/question/61467937/answer/188191424" target="_blank" rel="noopener">为什么做stacking ensemble的时候需要固定k-fold？</a><br><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1564129036&amp;ver=1751&amp;signature=dzAG3d8Z*4fEyG-d0JNokHdC7Nt-1v8CdIClAcCVx-IcNS0AFXiMfKsb3YSetUk1gRoeijeh3r48*dgWU2XUjnRH0XGleMUweroua8yzbZMX3YEgAcZ*mct1RLiK7EHh&amp;new=1" target="_blank" rel="noopener">Kaggle数据挖掘比赛经验分享，陈成龙博士整理！</a><br><a href="https://blog.csdn.net/v_july_v/article/details/81410574" target="_blank" rel="noopener">通俗理解kaggle比赛大杀器xgboost</a><br><a href="https://oldpan.me/archives/how-to-use-loss-curves-debug-net" target="_blank" rel="noopener">如何根据训练/验证损失曲线诊断我们的CNN</a><br><a href="https://oldpan.me/archives/hyper-parameters-tune-guide" target="_blank" rel="noopener">浅谈深度学习中超参数调整策略</a><br><a href="https://oldpan.me/archives/how-to-use-tricks-to-train-network" target="_blank" rel="noopener">关于训练神经网路的诸多技巧Tricks(完全总结版)</a><br><a href="https://stackoverflow.com/questions/40910857/how-to-interpret-increase-in-both-loss-and-accuracy" target="_blank" rel="noopener">How to interpret increase in both loss and accuracy</a><br><a href="https://stats.stackexchange.com/questions/282160/how-is-it-possible-that-validation-loss-is-increasing-while-validation-accuracy" target="_blank" rel="noopener">How is it possible that validation loss is increasing while validation accuracy is increasing as well</a><br><a href="https://zhuanlan.zhihu.com/p/28084438" target="_blank" rel="noopener">Kaggle求生：亚马逊热带雨林篇</a><br><a href="https://blog.csdn.net/lanchunhui/article/details/50522424" target="_blank" rel="noopener">cross-validation：从 holdout validation 到 k-fold validation</a><br><a href="https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation/discussion/100736591271" target="_blank" rel="noopener">Gradient accumulation can solve this problem, no?</a><br><a href="https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation/discussion/100736585427" target="_blank" rel="noopener">pretrain weight dicusses</a><br><a href="https://sgugger.github.io/how-do-you-find-a-good-learning-rate.html" target="_blank" rel="noopener">How Do You Find A Good Learning Rate</a><br><a href="https://shenxiaohai.me/2019/02/27/lr_find/" target="_blank" rel="noopener">寻找最优学习率的方法以及周期性学习率更新策略(论文笔记)</a><br><a href="https://blog.csdn.net/qq_38410428/article/details/88061738" target="_blank" rel="noopener">神经网络学习速率设置指南（CLR Callback，LRFinder，SGDR等最新的学习率设置方案）附完整代码解析</a><br><a href="https://www.jeremyjordan.me/nn-learning-rate/" target="_blank" rel="noopener">Setting the learning rate of your neural network.</a><br><a href="https://srdas.github.io/DLBook/GradientDescentTechniques.html" target="_blank" rel="noopener">Chapter 7 Training Neural Networks Part 1</a><br><a href="https://srdas.github.io/DLBook/ImprovingModelGeneralization.html" target="_blank" rel="noopener">Chapter 8 Training Neural Networks Part 2</a><br><a href="https://zhuanlan.zhihu.com/p/34236769" target="_blank" rel="noopener">机器学习算法如何调参？这里有一份神经网络学习速率设置指南</a><br><a href="https://blog.csdn.net/accumulate_zhang/article/details/63251337" target="_blank" rel="noopener">模型的偏差与方差的理解</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/" title="Kaggle比赛经验">https://www.zdaiot.com/DeepLearningApplications/实战/Kaggle比赛经验/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Kaggle/" rel="tag"><i class="fa fa-tag"></i> Kaggle</a><a href="/tags/调参经验/" rel="tag"><i class="fa fa-tag"></i> 调参经验</a><a href="/tags/集成/" rel="tag"><i class="fa fa-tag"></i> 集成</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Tools/Computer/双电脑、双显示屏工作环境搭建/" rel="prev" title="双电脑、双显示屏工作环境搭建"><i class="fa fa-chevron-left"></i> 双电脑、双显示屏工作环境搭建</a></div><div class="post-nav-item"> <a href="/Linux/博客搭建/hexo部署到阿里云/" rel="next" title="hexo部署到阿里云">hexo部署到阿里云<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本知识"><span class="nav-number">1.</span> <span class="nav-text">基本知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据标准化"><span class="nav-number">2.</span> <span class="nav-text">数据标准化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据增强"><span class="nav-number">3.</span> <span class="nav-text">数据增强</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型"><span class="nav-number">4.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何挑选合适学习率"><span class="nav-number">5.</span> <span class="nav-text">如何挑选合适学习率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#学习率的影响"><span class="nav-number">5.1.</span> <span class="nav-text">学习率的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一维损失"><span class="nav-number">5.1.1.</span> <span class="nav-text">一维损失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多维损失"><span class="nav-number">5.1.2.</span> <span class="nav-text">多维损失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">5.1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理论"><span class="nav-number">5.2.</span> <span class="nav-text">理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实践"><span class="nav-number">5.3.</span> <span class="nav-text">实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学习率衰减策略"><span class="nav-number">6.</span> <span class="nav-text">学习率衰减策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Step-Decay"><span class="nav-number">6.1.</span> <span class="nav-text">Step Decay</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Warm-up"><span class="nav-number">6.2.</span> <span class="nav-text">Warm up</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cyclical-learning-rates"><span class="nav-number">6.3.</span> <span class="nav-text">Cyclical learning rates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SGD-with-Warm-Restarts-SGDR"><span class="nav-number">6.4.</span> <span class="nav-text">SGD with Warm Restarts (SGDR)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">6.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#训练-验证曲线"><span class="nav-number">7.</span> <span class="nav-text">训练/验证曲线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过拟合与欠拟合"><span class="nav-number">7.1.</span> <span class="nav-text">过拟合与欠拟合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#曲线分析"><span class="nav-number">7.2.</span> <span class="nav-text">曲线分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">7.3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例分析"><span class="nav-number">7.4.</span> <span class="nav-text">实例分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Learning-Rate与Batch-Size的关系"><span class="nav-number">8.</span> <span class="nav-text">Learning Rate与Batch Size的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多尺度训练"><span class="nav-number">9.</span> <span class="nav-text">多尺度训练</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#超参数搜索"><span class="nav-number">10.</span> <span class="nav-text">超参数搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网格搜索"><span class="nav-number">10.1.</span> <span class="nav-text">网格搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机搜索"><span class="nav-number">10.2.</span> <span class="nav-text">随机搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cross-Validation"><span class="nav-number">11.</span> <span class="nav-text">Cross Validation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TTA-Test-Time-Augmentation"><span class="nav-number">12.</span> <span class="nav-text">TTA(Test Time Augmentation)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ensemble-Generation"><span class="nav-number">13.</span> <span class="nav-text">Ensemble Generation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Stacking"><span class="nav-number">13.1.</span> <span class="nav-text">Stacking</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XGBoost"><span class="nav-number">14.</span> <span class="nav-text">XGBoost</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#决策树"><span class="nav-number">14.1.</span> <span class="nav-text">决策树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回归树与集成学习"><span class="nav-number">14.2.</span> <span class="nav-text">回归树与集成学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#回归树"><span class="nav-number">14.2.1.</span> <span class="nav-text">回归树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#boosting集成学习"><span class="nav-number">14.2.2.</span> <span class="nav-text">boosting集成学习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GBDT"><span class="nav-number">14.3.</span> <span class="nav-text">GBDT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XGBoost-1"><span class="nav-number">14.4.</span> <span class="nav-text">XGBoost</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#XGBoost树的定义"><span class="nav-number">14.4.1.</span> <span class="nav-text">XGBoost树的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XGBoost目标函数"><span class="nav-number">14.4.2.</span> <span class="nav-text">XGBoost目标函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附件"><span class="nav-number">15.</span> <span class="nav-text">附件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">16.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">311</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">53</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">367</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">30:36</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '3361aba3f0e958100923fd4e4590480e',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>