<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="这学期老师让我研究图神经网络（GNN），但是这玩意有点大。一方面可以研究GNN的理论，解决目前GNN存在的问题；另一方面可以研究GNN的应用。跟老师详细探讨之后，发现老师想让我研究GNN在Few-Shot Learning上的应用。 上周读了几篇论文，想要总结一下。看看会不会有什么新的想法。 问题定义其实，GNN可以用在四种学习任务中：Few-shot Learning、Zero-Shot Lea"><meta name="keywords" content="Few Shot Learning,GNN"><meta property="og:type" content="article"><meta property="og:title" content="Few-shot learning with graph neural networks"><meta property="og:url" content="https://www.zdaiot.com/DeepLearningApplications/Few-shot Learning/Few-shot learning with graph neural networks/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="这学期老师让我研究图神经网络（GNN），但是这玩意有点大。一方面可以研究GNN的理论，解决目前GNN存在的问题；另一方面可以研究GNN的应用。跟老师详细探讨之后，发现老师想让我研究GNN在Few-Shot Learning上的应用。 上周读了几篇论文，想要总结一下。看看会不会有什么新的想法。 问题定义其实，GNN可以用在四种学习任务中：Few-shot Learning、Zero-Shot Lea"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/DeepLearningApplications/Few-shot%20Learning/Few-shot%20learning%20with%20graph%20neural%20networks/1567511973226.png"><meta property="og:updated_time" content="2019-09-12T11:15:24.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Few-shot learning with graph neural networks"><meta name="twitter:description" content="这学期老师让我研究图神经网络（GNN），但是这玩意有点大。一方面可以研究GNN的理论，解决目前GNN存在的问题；另一方面可以研究GNN的应用。跟老师详细探讨之后，发现老师想让我研究GNN在Few-Shot Learning上的应用。 上周读了几篇论文，想要总结一下。看看会不会有什么新的想法。 问题定义其实，GNN可以用在四种学习任务中：Few-shot Learning、Zero-Shot Lea"><meta name="twitter:image" content="https://www.zdaiot.com/DeepLearningApplications/Few-shot%20Learning/Few-shot%20learning%20with%20graph%20neural%20networks/1567511973226.png"><link rel="canonical" href="https://www.zdaiot.com/DeepLearningApplications/Few-shot Learning/Few-shot learning with graph neural networks/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Few-shot learning with graph neural networks | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">木槿And达达</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/DeepLearningApplications/Few-shot Learning/Few-shot learning with graph neural networks/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="木槿And达达"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Few-shot learning with graph neural networks<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/DeepLearningApplications/Few-shot Learning/Few-shot learning with graph neural networks.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-19 10:19:50" itemprop="dateCreated datePublished" datetime="2019-07-19T10:19:50+08:00">2019-07-19</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-09-12 19:15:24" itemprop="dateModified" datetime="2019-09-12T19:15:24+08:00">2019-09-12</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DeepLearningApplications/" itemprop="url" rel="index"><span itemprop="name">DeepLearningApplications</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DeepLearningApplications/Few-shot-Learning/" itemprop="url" rel="index"><span itemprop="name">Few-shot Learning</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>9.2k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>这学期老师让我研究图神经网络（GNN），但是这玩意有点大。一方面可以研究GNN的理论，解决目前GNN存在的问题；另一方面可以研究GNN的应用。跟老师详细探讨之后，发现老师想让我研究GNN在Few-Shot Learning上的应用。</p><p>上周读了几篇论文，想要总结一下。看看会不会有什么新的想法。</p><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>其实，GNN可以用在四种<strong>学习任务</strong>中：Few-shot Learning、Zero-Shot Learning、Semi-supervised Learning和Avtive Learning。那么具体这几种任务有何区别呢？下面我们对这几种任务进行详细的说明及区分。</p><blockquote><p>这几个问题都可以应用在不同的问题中，例如小样本目标检测，小样本数据分类。这里我的主要研究方向主要为小样本数据分类。所以下面的主要阐述均是针对小样本数据分类而言的。</p></blockquote><p>不同于之前我们epoch、iteration的概念。在这些问题中，称<strong>一个task为episodic</strong>。那么什么叫做一个task呢？</p><p>对于任务$i$而言，从<strong>部分有标签且服从独立同分布$p$的图像样本集合</strong>中抽取任务$\left(\mathcal{T}_{i}, Y_{i}\right)_{i}$，其满足如下通项</p><script type="math/tex;mode=display">\begin{eqnarray} \mathcal{T}=\left\{\left\{\left(x_{1}, l_{1}\right), \ldots\left(x_{s}, l_{s}\right)\right\},\left\{\tilde{x}_{1}, \ldots, \tilde{x}_{r}\right\},\left\{\overline{x}_{1}, \ldots, \overline{x}_{t}\right\} ; l_{i} \in\{1, K\}, x_{i}, \tilde{x}_{j}, \overline{x}_{j} \sim \mathcal{P}_{l}\left(\mathbb{R}^{N}\right)\right\} \end{eqnarray}</script><script type="math/tex;mode=display">\begin{eqnarray} Y=\left(y_{1}, \ldots, y_{t}\right) \in\{1, K\}^{t}\end{eqnarray}</script><p>其中，$s$表示有类标样本的数目，称为support sets（支撑集）；$r$表示无类标样本的数目；$t$表示待分类样本的个数，即Query sets（查询集）；$K$为类别数目。$\mathcal{P}_{l}\left(\mathbb{R}^{N}\right)$表示特定类别在$\mathbb{R}^{N}$上的分布。</p><blockquote><p>为什么假设独立同分布呢？机器学习就是利用当前获取到的信息（或数据）进行训练学习，用以对未来的数据进行预测、模拟。所以都是建立在历史数据之上，采用模型去拟合未来的数据。因此需要我们使用的历史数据具有总体的代表性。为什么要有总体代表性？我们要从已有的数据（经验） 中总结出规律来对未知数据做决策，如果获取训练数据是不具有总体代表性的，就是特例的情况，那规律就会总结得不好或是错误，因为这些规律是由个例推算的，不具有推广的效果。而通过独立同分布的假设，就可以大大减小训练样本中个例的情形。</p></blockquote><p>给定大小为$L$的训练集合$\left\{\left(\mathcal{T}_{i}, Y_{i}\right)_{i}\right\}_{i \leq L}$(即有$L$个task)，标准的监督学习目标为：</p><script type="math/tex;mode=display">\begin{eqnarray} \min _{\Theta} \frac{1}{L} \sum_{i \leq L} \ell\left(\Phi\left(\mathcal{T}_{i} ; \Theta\right), Y_{i}\right)+\mathcal{R}(\Theta)\end{eqnarray}</script><p>其中$\Phi(\mathcal{T} ; \Theta)=p(Y | \mathcal{T})$为模型，从这个表达式中可以看出来，可以将模型看做是<strong>后验推理过程</strong>；$\mathcal{R}$为标准正则化。$\ell$为损失函数，例如交叉熵等。</p><h3 id="Few-shot-Learning"><a href="#Few-shot-Learning" class="headerlink" title="Few-shot Learning"></a>Few-shot Learning</h3><p>在式子$({1})$中，当$r=0, t\neq0,s=qK$的时候，即为Few-Shot Learning的定义。此时，一共有$K$个类别，每一个类别，都有$q$个已有标签的数据，称为<strong>q-shot, K-way</strong>学习。常见的的有<strong>5-way，1-shot和5-way，5-shot</strong>。</p><h3 id="Zero-Shot-Learning"><a href="#Zero-Shot-Learning" class="headerlink" title="Zero-Shot Learning"></a>Zero-Shot Learning</h3><p>与Few-Shot Learning相同，这里的$r=0, t=0$。不同点在于，假定所有的类别为$\mathcal{C}$，$\mathcal{C_{tr}}$表示训练集类别，$\mathcal{C_{tr}}$表示训练集类别，$\mathcal{C_{te}}$表示验证集类别，Zero-Shot Learning问题中要保证$\mathcal{C}_{t e} \cap \mathcal{C}_{t r}=\emptyset$，即测试集的类别不能出现在训练集类别中；除此之外，还有一点区别在于，在测试集中，Zero-Shot Learning所有数据均没有类标，而Few-Shot Learning可以有部分数据有类标。</p><blockquote><p>Few-Shot Learning中也可以测试集的类别不能出现在训练集类别中。</p></blockquote><h3 id="Semi-supervised-Learning"><a href="#Semi-supervised-Learning" class="headerlink" title="Semi-supervised Learning"></a>Semi-supervised Learning</h3><p>与Few-Shot Learning不同的是，在Semi-supervised Learning学习中，$r&gt;0,t\neq0$。也就是说在半监督学习中，可以使用未知标签的数据提高正确率。</p><h3 id="Avtive-Learning"><a href="#Avtive-Learning" class="headerlink" title="Avtive Learning"></a>Avtive Learning</h3><p>在主动学习中，$r&gt;0,t\neq0$。不同于半监督学习的是，这里可以请求从子集$\left\{\overline{x}_{1}, \ldots, \overline{x}_{t}\right\}$得到标签。</p><h2 id="GNN简介"><a href="#GNN简介" class="headerlink" title="GNN简介"></a>GNN简介</h2><p>之前虽然也记录过关于GNN的笔记，但是那个时候只是关注了GNN本身。最近在看了几篇GNN在Few-Shot Learning任务中的应用之后，对其有了更加深刻的理解。</p><p>从“图神经网络”名字中可以看出来，必须要有图，在图上定义神经网络即为“图神经网络”。之前的CNN之所以能够在图像中大放异彩，正是因为图像有着很规则的结构。而CNN具有平移不变性、局部性等特点，能够提取图像深层次的信息。CNN的<strong>数学本质为加权求和</strong>，且这个加权系数是通过反向传播学习训练出来的，所以才能提取图像深层次特征。其<strong>物理本质为提取图形不同频段的特征</strong>。而在拓扑结构中，CNN无法得到在哪滑窗、不具备平移不变形等。因此需要GNN，模仿者CNN数学本质为加权求和，GNN对一个中心点及其邻居节点<strong>求和</strong>（使用邻接矩阵或者拉普拉斯矩阵等），得到当前中心节点的更新值。但是，现在只是求和，并没有进行加权，所以引入了可训练参数，对中心节点及其邻居节点<strong>加权求和</strong>，得到当前中心节点的更新值。</p><p>如何利用中心节点以及其邻居节点得到中心节点的更新值，被称为<strong>Aggregator过程</strong>；而如何利用当前中心节点的更新值，更新当前中心节点的状态，称为<strong>Updater过程</strong>。整个过程称为<strong>Propagation过程</strong>。不同的Propagation过程对应着不同的GNN模型。</p><p>这里我们的关注点为如何使用GNN解决Few-shot Learning的问题，所以对于不同的GNN模型不进行探讨。只要我们通过上面的分析过程了解到GNN的本质为中心节点及其邻居节点的加权求和即可，也就是利用邻居节点的信息更新中心节点。</p><p>在Few-Shot Learning问题中，是已知少量数据标签的，如何将利用这些数据扩展到无标签数据呢？结合上面我们对GNN的简介，可以很自然的想到，能不能利用GNN，将已有标签的数据信息传播到无标签数据呢？这就是GNN在Few-Shot Learning应用的想法来源。</p><h2 id="Meta-Learning简介-待完善"><a href="#Meta-Learning简介-待完善" class="headerlink" title="Meta-Learning简介(待完善)"></a>Meta-Learning简介(待完善)</h2><p>元学习是<strong>一种方法，一种思想</strong>，可以用在<strong>小样本学习任务</strong>上。</p><h2 id="GNN与问题的结合"><a href="#GNN与问题的结合" class="headerlink" title="GNN与问题的结合"></a>GNN与问题的结合</h2><p>从<code>问题定义</code>小节可以看到，Few-shot Learning、Zero-Shot Learning、Semi-supervised Learning和Avtive Learning这几个问题有着统一的表达式。为了简便起见，我这里只介绍如何与Few-shot Learning的结合。</p><p>GNN与Few-shot Learning问题结合的方式大体上可以分为两种。</p><p><strong>第一种为：</strong>利用知识图谱，常用于Zero-Shot Learning。构建一个节点数目为总类别数目的知识图谱，使用WordNet对类别名称做词嵌入作为图节点的初始特征。学习目标为，图上的每一个节点均为二分类器的权重，其指导信息为预训练CNN模型的最后分类器权重。</p><p><strong>第二种为：</strong>构建相似图，常用于Few-shot Learning。利用样本之间的相似性，构建节点数目为task中样本总数的图，图上每个节点的特征为该样本的特征。学习目标为，图上的每一个节点（没有标签的样本和有标签的样本）为样本的特征，其指导信息为节点特征与分类器相连后损失最小。通用流程为，首先使用已训练好的CNN模型得到相似图中每一个图像的嵌入特征，相似性度量模块学习如何将集合中的嵌入特征组成一个图，GNN模块传播已知标签的节点特征到未知标签的节点，训练模型使得得到的节点特征与分类器相连后损失最小。</p><p>下面对几篇经典以及最新的论文进行分析与对比。</p><h2 id="Few-shot-Learning-With-Graph-Neural-Networks"><a href="#Few-shot-Learning-With-Graph-Neural-Networks" class="headerlink" title="Few-shot Learning With Graph Neural Networks"></a>Few-shot Learning With Graph Neural Networks</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul><li>标题：Few-shot learning with graph neural networks</li><li>年份：2018</li><li>期刊：ICLR</li><li>标签：相似图、图分类</li><li>数据：Omniglot、Mini-ImageNet（图结构未知）</li></ul><h3 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h3><ul><li>使用图神经网络端到端的训练</li><li>在参数较少的情况下，达到了state-of-art性能</li><li>扩展模型到半监督学习和主动学习。</li></ul><h3 id="创新点来源"><a href="#创新点来源" class="headerlink" title="创新点来源"></a>创新点来源</h3><p>Few-Shot Learning问题可以看做是有监督插值问题，节点上的值跟集合中的图片有关，而边通过可训练的相似核得到。结合图结构上的表征学习，提出了这种task-driven的模型。</p><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>该算法的整体流程如下图所示。网络整体分为CNN、GNN和损失函数三部分。具体而言，CNN模块使用了Resnet网络，GNN部分由三个<strong>度量学习-&gt;GCN模块</strong>组成，损失函数部分为多分类交叉熵函数。其中度量学习中的MLP部分由FC-&gt;BatchNorm-&gt;Relu-&gt;FC-&gt;BatchNorm-&gt;Relu-&gt;FC组成。</p><p><img src="/DeepLearningApplications/Few-shot Learning/Few-shot learning with graph neural networks/1567511973226.png" alt="1567511973226"></p><h4 id="图结构的定义"><a href="#图结构的定义" class="headerlink" title="图结构的定义"></a>图结构的定义</h4><p>小样本学习中一个task内含有$qK + t$个数据，为了度量这些数据之间的相似性，建立节点数为$qK + t$的图结构。定义节点$i$和节点$j$之间的相似度为：</p><script type="math/tex;mode=display">\begin{eqnarray} A_{i,j} = \varphi _{\tilde \theta }\left( x_i,x_j \right)= MLP_{\tilde \theta }\left( \mid \mid x_i - x_j \mid \mid_1 \right) \end{eqnarray}</script><p>其中，$x_i$和$x_j$分别表示顶点$i$和$j$上的数据特征。$\mid \mid \cdot \mid \mid_1$表示一范数，使用一范数表示两个向量的距离，可以保证非负性和对称性。另外，考虑到图结构对GNN中的信息传播有较大的影响，这里将两个向量的一范数结果输入到自定义的神经网络中。并通过最后的损失函数对该神经网络进行优化，从而让网络自己学习到对适合GNN的度量方式。</p><p>由此可以得到图中所有节点对之间的相似度，进而得到邻接矩阵$A$。为了防止反向传播过程中梯度爆炸，对$A$中的每一行经过softmax函数。</p><h4 id="GNN的定义"><a href="#GNN的定义" class="headerlink" title="GNN的定义"></a>GNN的定义</h4><p>定义图G，一般使用点的集合V和边的集合E来描述，即G=(V, E)。定义$A_{ij}$为节点$v_i$和节点$v_j$之间的权重。对于顶点$v_i$，其度定义为它相连的所有边的权重之和，即</p><script type="math/tex;mode=display">\begin{eqnarray} {d_i} = \sum\limits_{j = 1}^n {A_{ij}} \end{eqnarray}</script><p>利用每个节点度的定义，可以得到一个度矩阵$D$，只有对角线有值。根据$A_{ij}$，可以得到其邻接矩阵$A$。</p><p>图结构中，拉普拉斯矩阵的定义式如下：</p><script type="math/tex;mode=display">\begin{eqnarray} {L^{sys}} = {D^{ - 1/2}}L{D^{ - 1/2}} = I - {D^{ - 1/2}}A{D^{ - 1/2}} \end{eqnarray}</script><p>其中，$D$为对角矩阵，$I$为单位矩阵，$A$为邻接矩阵。</p><p>借鉴CNN中卷积操作的数学本质为<strong>加权求和</strong>，定义GNN中卷积操作如下：</p><script type="math/tex;mode=display">\begin{eqnarray} {X^{t + 1}} = {L^{sys}}{X^t}\theta \end{eqnarray}</script><p>其中，${X^t}$为$t$时刻图上各个顶点的特征矩阵。$\theta$为参数矩阵，${L^{sys}}{X^t}$可以得到各个顶点与其邻居节点的线性组合。而引入参数矩阵$\theta$可以得到各个顶点与其邻居节点的加权求和。</p><h4 id="初始特征构造"><a href="#初始特征构造" class="headerlink" title="初始特征构造"></a>初始特征构造</h4><p>对于初始节点$i$，其初始特征构造如下：</p><script type="math/tex;mode=display">\begin{eqnarray} {\bf{x}}_i^{(0)} = \left[ {\phi \left(  \right),h\left(  \right)} \right] \end{eqnarray}</script><p>其中，$\phi$为卷积神经网络，$x_i$为第$i$个图像，$\phi \left( \right)$为卷积神经网络提取出来的图像特征。$h(l) \in \mathbb{R}_{+}^{K}$为类标的one-hot编码。对于未知类标的样本，置$h(l)$为全零向量。考虑到类标中可能蕴含着对于GNN传播过程有利的信息，这里使用$[\cdot]$拼接操作将图像特征和类标的one-hot编码拼接到一起作为初始节点的特征。</p><h4 id="损失函数的构造"><a href="#损失函数的构造" class="headerlink" title="损失函数的构造"></a>损失函数的构造</h4><p>模型的目的为预测图像$\bar x \in {\cal T}$所对应的类标$Y$，因此网络的最后一层为Softmax层，将节点特征映射到$K$维向量，考虑交叉熵作为损失函数，表达式为</p><script type="math/tex;mode=display">\begin{eqnarray} \ell (\Phi (\cal T;\Theta ),Y) =  - \sum\limits_k {y_k} \log P\left( Y_* = y_k|\cal T \right) \end{eqnarray}</script><h4 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h4><p>下面结合代码部分，对上述过程进行详细说明。</p><p>当数据为omniglot，nway=5 (即$({1})式$中的$K$)，num_shots=1 (即$({1})式$中的$q$)，batch_size=300，num_test=1 (即$({1})式$中的$t$) 时，<strong>构建出的图节点数目为6</strong>。整个算法如下：</p><p><strong>（1）数据预处理：</strong>数据共有1600类，每类有20个样本。因为该数据集为手写体，不同的人手写的方向可能不同，所以对每个数据进行归一化并分别旋转0、90、180、270度扩充样本，最终每类有80个样本。选择其中1200类作为训练集，400类作为测试集。也就是测试集中的类别均未出现在训练集中。</p><p><strong>（2）数据准备：</strong>从1200类中随机选nway类，每类随机选num_shots个样本（带类标）。从这nway类中在随机选一类，再抽出一个不同的样本（不带类标）作为该task的测试集；将该样本类标单独放在一个变量中，作为该task的<strong>测试集类标</strong>。以上步骤即可取出一个task的数据，重复batch次，即可得到一个batch的数据。</p><p><strong>（3）输入：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">batch_x：[batch_size, input_channels, image_size[<span class="number">0</span>], image_size[<span class="number">1</span>]] 存放一个batch内所有未知标签的数据</span><br><span class="line">label_x：[batch_size, n_way]  存放一个batch内所有未知标签数据的类标，第二维度中<span class="number">1</span>的位置即为该数据所述的类别</span><br><span class="line">batch_xi；[batch_size, input_channels, image_size[<span class="number">0</span>], image_size[<span class="number">1</span>]]_&#123;n_way*num_shots&#125; 存放一个batch内已知标签的数据</span><br><span class="line">labels_yi：[batch_size, n_way]_&#123;n_way*num_shots&#125; 存放一个batch内已知标签数据的标签，第二维度中<span class="number">1</span>的位置即为该数据所述的类别</span><br></pre></td></tr></table></figure><p>其中，<code>[]</code>符号表示矩阵，其中的数字表示矩阵的大小；而<code>{}</code>符号表示列表，其中的数字表示列表的大小。<code>batch_size</code>为网络的batch大小参数，<code>input_channels</code>为输入图像的通道数，<code>image_size[0], image_size[1]</code>分别代表输入图像的高和宽。</p><p><strong>（4）训练过程：</strong><br>将task内的所有<code>batch_x</code>和<code>batch_xi</code>输入到CNN，分别得到未知标签图像的特征<code>[300, 64]</code>和已知标签图像的特征<code>[300, 64]_{5}</code>，将这两者拼接，得到该task内所有数据的特征<code>[300, 64]_{6}</code>。然后将<code>zero_pad</code>和<code>label_yi</code>拼接，得到<code>[300, 5]_{6}</code>。将<code>[300, 64]_{6}</code>和<code>[300, 5]_{6}</code>沿着<strong>第二维拼接</strong>并增加维度得到<code>[300, 1, 69]_{6}</code>，调整维度为<code>[300, 6, 69]</code>。将这个作为输入$X$。</p><p><strong>CNN模块 (学习图相似性矩阵)：</strong>将这个输入$X$经过CNN模型后，得到大小为<code>[300, 6, 6, 1]</code>的矩阵，矩阵的每一行经过softmax函数，即可得到task之内所有样本的相似性矩阵。将<strong>该矩阵与单位矩阵拼接</strong>得到大小为<code>[300, 12, 6]</code>的矩阵，该矩阵作为图相似性矩阵$W$。</p><p><strong>GNN模块 (信息传播)：</strong>将$W$和$X$做<strong>矩阵相乘</strong>得到新$X$，维度为<code>[300, 12, 69]</code>，调整维度为<code>[300x6, 69x2]</code> (<code>300x6</code>可以理解为batch内所有的样本，<code>batch_size x n_way x num_shots + 1</code>)，经过fc层 ( 作用为降维) 输出得到<code>[300x6, 48]</code>，resize可以得到<code>[300, 6, 48]</code>。<strong>旧$X$和新$X$拼接</strong>得到维度为<code>[300, 6, 69+48]</code>。作为下一次的输入$X$。</p><p>重复上述<strong>CNN模块</strong>和<strong>GNN模块</strong>三次，得到<code>[300, 6, 5]</code>的out，返回<code>out[:, 0, :]</code>。即维度<code>[300, 5]</code>。因为对于batch内的每个task，其第一项为待分类样本。这样就得到了一个batch之内所有task内待分类样本的标签。</p><p>输入<code>out[:, 0, :]</code>和<code>label_x</code>到Pytorch中的NLLLoss损失函数，得到损失值，并反向传播。</p><blockquote><p>这里有两个细节，在CNN模块中使用了学习到的相似矩阵和单位矩阵拼接作为最后的图相似性矩阵；在GNN模块将旧$X$和新$X$拼接得到得到最后的$X$。猜测这样做可以尽可能的在训练过程中保持有用信息并增加新的信息，防止过拟合的同时也可以防止欠拟合。</p></blockquote><p><strong>（5）测试过程：</strong><br>值得注意的是，测试过程数据准备过程与训练过程一样，唯一不同的是，测试过程从用于测试的400个类中抽取数据组成task，而训练数据从用于训练的1200类中抽取数据组成task。也就是说，<strong>在测试过程中，每个task均是知道<code>nways*num_shots</code>个数据的类标的，去预测某一个未知标签样本的标签（这个标签一定属于被选中的nways类中的一个）。</strong></p><blockquote><p>Semi-supervised Learning学习代码与Few-Shot Learning代码区别在于，对于输入数据<code>batch_yi</code>的处理方式不同。对于Semi-supervised Learning，<code>num_shots</code>个数据中前<code>unlabeled_extra</code>个数据，其对应在<code>batch_yi</code>的标签为全0向量 (即没有标签信息)。例如有3个<code>unlabeled_extra</code>数据，要想组成<code>5_shots</code>，每个task需要<code>5+3+1</code>个数据。</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>只考虑了$t=1$的情况</li><li>损失函数只考虑了待分类数据，而没有把有标签的数据考虑到损失函数中。这里将有标签数据的标签加入到了数据特征中，文章说标签可能蕴含了对于分类有用的信息。</li></ul><h3 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h3><ul><li>对于没有图结构的数据，要想使用GNN解决相关问题，必须手动构建图结构。而构建图神经网络过程中，一种方法是度量样本的相似性。<strong>注意这个度量要考虑对称性、非负性、自身与自身是否相似。</strong>另外，现有的论文都推荐使用神经网络度量样本间的相似性。比单独的使用范数等数学距离度量方式产生的图结构可能更适合这个任务。</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>思考1：</strong>Few-Shot Learning并不是说训练样本少，而是batch内的每一个task见到的样本少。</p><p><strong>思考2：</strong>如何理解元学习在Few-Shot Learning中的应用？<br>元学习定义：学习不同task之间的共同知识，扩展到未知类中。例如在本例中，通过元学习方法学习如何将未知标签的数据分为nways类中。然后扩展到测试集中（测试集中的类别在训练集中均没有见过）。这和元学习的目标一致。但是元学习有一个大前提：假设训练过程中的task和测试过程中的task满足同一个分布。</p><p><strong>思考3：</strong>如何理解GNN在Few-Shot Learning（Semi-supervised Learning）中的应用？<br>在Few-Shot Learning（Semi-supervised Learning）中，问题均为已知部分数据的标签，未知部分数据的标签。无标签节点部分被动的接受者来自相邻节点的特征，改变自己的特征，从而影响着自己的label。而特征矩阵左乘图神经网络中的拉普拉斯矩阵，正是对各个节点的特征进行<strong>线性组合</strong>，而右乘以参数矩阵，可以得到各个节点的特征的<strong>加权线性组合</strong>，从而获得更加高阶更加复杂的特征。使用GNN最终学到的特征传播过程可以得到未知标签样本的特征，进一步可以得到预测标签。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/67745489" target="_blank" rel="noopener">Meta-Learning 论文笔记：GNN</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/DeepLearningApplications/Few-shot Learning/Few-shot learning with graph neural networks/" title="Few-shot learning with graph neural networks">https://www.zdaiot.com/DeepLearningApplications/Few-shot Learning/Few-shot learning with graph neural networks/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Few-Shot-Learning/" rel="tag"><i class="fa fa-tag"></i> Few Shot Learning</a><a href="/tags/GNN/" rel="tag"><i class="fa fa-tag"></i> GNN</a></div><div class="post-nav"><div class="post-nav-item"><a href="/MLFrameworks/Pytorch/Pytorch学习率控制/" rel="prev" title="Pytorch学习率控制"><i class="fa fa-chevron-left"></i> Pytorch学习率控制</a></div><div class="post-nav-item"> <a href="/Tools/Computer/双电脑、双显示屏工作环境搭建/" rel="next" title="双电脑、双显示屏工作环境搭建">双电脑、双显示屏工作环境搭建<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题定义"><span class="nav-number">1.</span> <span class="nav-text">问题定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Few-shot-Learning"><span class="nav-number">1.1.</span> <span class="nav-text">Few-shot Learning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zero-Shot-Learning"><span class="nav-number">1.2.</span> <span class="nav-text">Zero-Shot Learning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semi-supervised-Learning"><span class="nav-number">1.3.</span> <span class="nav-text">Semi-supervised Learning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Avtive-Learning"><span class="nav-number">1.4.</span> <span class="nav-text">Avtive Learning</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GNN简介"><span class="nav-number">2.</span> <span class="nav-text">GNN简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Meta-Learning简介-待完善"><span class="nav-number">3.</span> <span class="nav-text">Meta-Learning简介(待完善)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GNN与问题的结合"><span class="nav-number">4.</span> <span class="nav-text">GNN与问题的结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Few-shot-Learning-With-Graph-Neural-Networks"><span class="nav-number">5.</span> <span class="nav-text">Few-shot Learning With Graph Neural Networks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本信息"><span class="nav-number">5.1.</span> <span class="nav-text">基本信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创新点"><span class="nav-number">5.2.</span> <span class="nav-text">创新点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创新点来源"><span class="nav-number">5.3.</span> <span class="nav-text">创新点来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主要内容"><span class="nav-number">5.4.</span> <span class="nav-text">主要内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#图结构的定义"><span class="nav-number">5.4.1.</span> <span class="nav-text">图结构的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GNN的定义"><span class="nav-number">5.4.2.</span> <span class="nav-text">GNN的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始特征构造"><span class="nav-number">5.4.3.</span> <span class="nav-text">初始特征构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#损失函数的构造"><span class="nav-number">5.4.4.</span> <span class="nav-text">损失函数的构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#详细步骤"><span class="nav-number">5.4.5.</span> <span class="nav-text">详细步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-number">5.5.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启发"><span class="nav-number">5.6.</span> <span class="nav-text">启发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思考"><span class="nav-number">5.7.</span> <span class="nav-text">思考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">木槿And达达</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">305</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">364</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">30:09</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '6018b90c53876c1cedc535f23357aa1b',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>