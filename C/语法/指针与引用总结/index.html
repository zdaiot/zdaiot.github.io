<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.zdaiot.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="指针若现在指针不知道指向，可以使用NULL，例如int *b = NULL; char *a = NULL;，但是使用的时候若指针指向的是数组、字符串和结构体等，需要提前声明大小。若是int *，则不需要，直接将一个int类型的指针赋值给它即可。 c++中的*与&amp;amp;对于初学者来说，确实有点让人搞懵。因为在变量的定义和调用时，*和&amp;amp;都会表现出不一样的含义。 * 总结 定义一个指针的三种"><meta name="keywords" content="const,引用,指针"><meta property="og:type" content="article"><meta property="og:title" content="指针与引用总结"><meta property="og:url" content="https://www.zdaiot.com/C/语法/指针与引用总结/index.html"><meta property="og:site_name" content="zdaiot"><meta property="og:description" content="指针若现在指针不知道指向，可以使用NULL，例如int *b = NULL; char *a = NULL;，但是使用的时候若指针指向的是数组、字符串和结构体等，需要提前声明大小。若是int *，则不需要，直接将一个int类型的指针赋值给它即可。 c++中的*与&amp;amp;对于初学者来说，确实有点让人搞懵。因为在变量的定义和调用时，*和&amp;amp;都会表现出不一样的含义。 * 总结 定义一个指针的三种"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/fb012113-1392-4fe5-b72e-861161607e3d.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/f9e52452-631c-48a8-8efe-40bea5d079ed.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/900715-20170824023128902-1976389147.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/8ac3079c-aacb-4273-95c9-b294941cad91.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/900715-20170824033346011-489080809.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/900715-20170824043020527-902496772.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/900715-20170824043535808-172238642.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/900715-20170824213332277-1403805406.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/900715-20170824213909761-1693110470.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/900715-20170824225424339-901573647.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/900715-20170824231047714-55281615.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/900715-20170824233843558-1731339574.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/99082f20-c97d-4e56-9d28-d36feb5fa7d7.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/1f3ed4b1-4586-4f71-bdb3-b8d105c5afd2.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/b5f041e6-c7eb-4cd4-955d-4e6c76032df8.jpg"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/34e735a5-b317-4de2-aa30-0d5ee6fe88bd.jpg"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/56d6fcbb-2063-4df4-be41-cf96e3189c18.jpg"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/b49bfca4-909f-47a6-991d-ee10cd568012.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/921504d4-2af1-4fd4-bf9c-a0ca20cc410b.png"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/1cfe0b02-2b8a-40d1-b10f-5194db57254c.jpg"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/8867b874-0b96-45e1-b704-6e4e9eb89b31.jpg"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/87160959-3c81-47db-aca0-1df70139bf78.jpg"><meta property="og:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/45e418df-2737-4ad9-b22d-d3a1bce878dc.png"><meta property="og:updated_time" content="2019-09-15T04:10:35.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="指针与引用总结"><meta name="twitter:description" content="指针若现在指针不知道指向，可以使用NULL，例如int *b = NULL; char *a = NULL;，但是使用的时候若指针指向的是数组、字符串和结构体等，需要提前声明大小。若是int *，则不需要，直接将一个int类型的指针赋值给它即可。 c++中的*与&amp;amp;对于初学者来说，确实有点让人搞懵。因为在变量的定义和调用时，*和&amp;amp;都会表现出不一样的含义。 * 总结 定义一个指针的三种"><meta name="twitter:image" content="https://www.zdaiot.com/C/语法/指针与引用总结/fb012113-1392-4fe5-b72e-861161607e3d.png"><link rel="canonical" href="https://www.zdaiot.com/C/语法/指针与引用总结/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>指针与引用总结 | zdaiot</title><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0b0b58037319da4959d5a3c014160ccd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">zdaiot</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">404NotFound</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zdaiot.com/C/语法/指针与引用总结/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="zdaiot"><meta itemprop="description" content="404NotFound"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zdaiot"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 指针与引用总结<a href="https://github.com/zdaiot/zdaiot.github.io/tree/hexo/source/_posts/C/语法/指针与引用总结.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-09-27 08:46:17" itemprop="dateCreated datePublished" datetime="2018-09-27T08:46:17+08:00">2018-09-27</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-09-15 12:10:35" itemprop="dateModified" datetime="2019-09-15T12:10:35+08:00">2019-09-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/语法/" itemprop="url" rel="index"><span itemprop="name">语法</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>24k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>22 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>若现在指针不知道指向，可以使用<code>NULL</code>，例如<code>int *b = NULL; char *a = NULL;</code>，但是使用的时候若指针指向的是数组、字符串和结构体等，需要提前声明大小。若是<code>int *</code>，则不需要，直接将一个<code>int</code>类型的指针赋值给它即可。</p><p>c++中的<code>*</code>与<code>&amp;</code>对于初学者来说，确实有点让人搞懵。因为在变量的定义和调用时，<code>*</code>和<code>&amp;</code>都会表现出不一样的含义。</p><h3 id="总结"><a href="#总结" class="headerlink" title="* 总结"></a>* 总结</h3><blockquote><p><strong>定义一个指针的三种写法都对：<code>1. int * p; 2. int* p; 3. int *p;</code> 习惯不同而已<br>定义一个函数指针的三种写法都对：<code>1. int *p(); 2. int * p(); 3. int* p();</code></strong></p></blockquote><h4 id="用于定义"><a href="#用于定义" class="headerlink" title="用于定义"></a>用于定义</h4><p><code>*</code>在定义时是声明该变量是一个指针，例如<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p; //那p就是一个int型的指针。</span><br></pre></td></tr></table></figure><p></p><p>例1:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 0; </span><br><span class="line">int *p = a; //那p的值就是a的地址。</span><br></pre></td></tr></table></figure><p></p><blockquote><p>上面的<code>int a = 0; int *p = a;</code>实际上是<code>int a = 0; int *p = &amp;a;</code>这两者是等价的！！！</p></blockquote><p>原因是<code>int *p = &amp;a;</code>时，c语言本身提供了可以略去<code>&amp;</code>的简写，但是本人不是很喜欢这样的写法，因为这样会误导初学者！</p><p>所以大家还是写全比较规范一点，写完<code>int *p = &amp;a</code>，这样比较好。</p><p>c++就没有这样的简写机制，大家可以测试一下。</p><h4 id="用于调用时"><a href="#用于调用时" class="headerlink" title="用于调用时"></a>用于调用时</h4><p><code>*</code>在调用时是指针指向的那个变量，是取值运算符。</p><p>例如:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">printf(&quot;*p = %d\n&quot;, *p);</span><br></pre></td></tr></table></figure><p></p><h3 id="amp-总结"><a href="#amp-总结" class="headerlink" title="&amp;总结"></a>&amp;总结</h3><h4 id="用于定义时"><a href="#用于定义时" class="headerlink" title="用于定义时"></a>用于定义时</h4><p><code>&amp;</code>在定义时是定义一个引用</p><p>例2：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">int &amp;b = a;</span><br></pre></td></tr></table></figure><p></p><p>那么<code>b</code>就是<code>a</code>的引用，即<code>b=a</code>;如果再给<code>a</code>赋值<code>a=10</code>,则<code>b</code>也会变为<code>10</code>;如果给<code>b</code>赋值<code>b=20</code>,则<code>a</code>也会变为<code>20</code>;</p><blockquote><p>关于具体引用的介绍我们将会在下面详细的进行介绍</p></blockquote><h4 id="用于调用时-1"><a href="#用于调用时-1" class="headerlink" title="用于调用时"></a>用于调用时</h4><p><code>&amp;</code>在调用时是一个取地址运算符。<br>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">printf(&quot;&amp;a = %p\n&quot;, &amp;a);</span><br></pre></td></tr></table></figure><p></p><p>会打印出<code>a</code>的地址，这个地址因为变量<code>a</code>在各个计算机的地址的不一样，所以打印的也不一样。</p><blockquote><p><code>&amp;</code>在调用时还有一种与运算，如：<code>int a = 0; a&amp; = 0;</code> //按位与操作，这个就不细说了</p></blockquote><h3 id="关于int-a-int-amp-a-int-amp-a-int-amp-a-int-amp-a"><a href="#关于int-a-int-amp-a-int-amp-a-int-amp-a-int-amp-a" class="headerlink" title="关于int *a; int &amp;a; int &amp; *a; int * &amp;a; (int*) &amp;a"></a>关于<code>int *a; int &amp;a; int &amp; *a; int * &amp;a; (int*) &amp;a</code></h3><p>上述的四条语句，前面两个很好理解，而后面两个，大部分C＋＋初学者都会比较困惑，今天我也是查阅了一些资料以后才恍然大悟。下面具体来说明一下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line"></span><br><span class="line">int *a = &amp;i;//这里a是一个指针，它指向变量i</span><br><span class="line"></span><br><span class="line">int &amp;b = i;//这里b是一个引用，它是变量i的引用，引用是什么？它的本质是什么？下面会具体讲述</span><br><span class="line"></span><br><span class="line">int * &amp;c = a;//这里c是一个引用，它是指针a的引用</span><br><span class="line"></span><br><span class="line">int &amp; *d;//这里d是一个指针，它指向引用，但引用不是实体，所以这是错误的</span><br></pre></td></tr></table></figure><p></p><blockquote><p><strong>注意：</strong><code>(int*) &amp;a</code>为取a的地址，然后进行强制类型转换，转为int类型的指针。</p></blockquote><h4 id="int-amp-a和int-amp-a"><a href="#int-amp-a和int-amp-a" class="headerlink" title="int * &amp;a和int &amp; *a"></a><code>int * &amp;a</code>和<code>int &amp; *a</code></h4><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p>我在写这两句语句时，在<code>int</code> 和<code>*(&amp;)</code>间空了一格，而后面的<code>&amp;(*)</code>紧跟<code>a</code>。原因是：分析此类语句时，最简单的办法就是从<strong>右往左读，离</strong>注意：<strong>变量名最近的符号对其类型有最直接的影</strong>响，即先看<code>a</code>前紧跟的是什么，它决定了<code>a</code>的类型。例如，对于<code>int &amp; *a</code>，此处是<code>*</code>，表示其首先是个指针，指针的类型是一个int型引用。而<code>int</code>后的一个空格是为了解释<code>int *a, b;//a是指针，而b不是</code>。</p><blockquote><p>正确的多个指针声明应该为：例：<code>int *a，*b，*c，*d；</code></p></blockquote><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在使用过程中，假设有一个 int 类型的变量 <code>a</code>，<code>pa</code>是指向它的指针，那么<code>*&amp;a</code>和<code>&amp;*pa</code>分别是什么意思呢？</p><p><code>*&amp;a</code>可以理解为<code>*(&amp;a)</code>，<code>&amp;a</code>表示取变量 <code>a</code> 的地址（等价于 <code>pa</code>），<code>*(&amp;a)</code>表示取这个地址上的数据（等价于 <code>*pa</code>），绕来绕去，又回到了原点，<code>*&amp;a</code>仍然等价于 a。</p><p><code>&amp;*pa</code>可以理解为<code>&amp;(*pa)</code>，<code>*pa</code>表示取得 <code>pa</code> 指向的数据（等价于 <code>a</code>），<code>&amp;(*pa)</code>表示数据的地址（等价于 <code>&amp;a</code>），所以<code>&amp;*pa</code>等价于 <code>pa</code>。</p><h4 id="int-a"><a href="#int-a" class="headerlink" title="int **a;"></a><code>int **a;</code></h4><p><img src="/C/语法/指针与引用总结/fb012113-1392-4fe5-b72e-861161607e3d.png" alt></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>上面初步介绍了引用，下面相信介绍引用的概念、注意事项以及作用</p><h3 id="什么是引用"><a href="#什么是引用" class="headerlink" title="什么是引用"></a>什么是引用</h3><p>引用，顾名思义是某一个变量或对象的<strong>别名</strong>，对引用的操作与对其所绑定的变量或对象的操作完全等价</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：类型 &amp;引用名=目标变量名；</span><br></pre></td></tr></table></figure><blockquote><p><strong>当<code>&amp;</code>出现在等式左边的定义时。或者当<code>&amp;</code>出现在函数的参数值中的时候是引用。或者在函数定义时，如<code>float &amp;fn2(float r)</code></strong></p></blockquote><p><strong>特别注意：</strong></p><ul><li><p><code>&amp;</code>不是求地址运算符，而是起标志作用</p></li><li><p>引用的类型必须和其所绑定的变量的类型相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    double a=10.3;</span><br><span class="line">    int &amp;b=a; //错误，引用的类型必须和其所绑定的变量的类型相同</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>报错<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: invalid initialization of non-const reference of type &apos;int&amp;&apos; from an rvalue of type &apos;int&apos;|</span><br></pre></td></tr></table></figure><p></p><ul><li><p>声明引用的同时必须对其初始化，否则系统会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int &amp;a; //错误！声明引用的同时必须对其初始化</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用相当于变量或对象的别名，因此<strong>不能再将已有的引用名作为其他变量或对象的名字或别名</strong></p></li><li><p>引用不是定义一个新的变量或对象，因此<strong>内存不会为引用开辟新的空间存储这个引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int value=10;</span><br><span class="line">    int &amp;new_value=value;</span><br><span class="line">    cout&lt;&lt;&quot;value的值为：&quot;&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;new_value的值为：&quot;&lt;&lt;new_value&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;value在内存中的地址为：&quot;&lt;&lt;&amp;value&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;new_value在内存中的地址为：&quot;&lt;&lt;&amp;new_value&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/C/语法/指针与引用总结/f9e52452-631c-48a8-8efe-40bea5d079ed.png" alt></p><blockquote><p>即可简单的理解为上例中的<code>new_value</code>为<code>value</code>。</p></blockquote><h4 id="对数组的引用"><a href="#对数组的引用" class="headerlink" title="对数组的引用"></a>对数组的引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：类型 (&amp;引用名)[数组中元素数量]=数组名；</span><br></pre></td></tr></table></figure><p>例如<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[3]=&#123;1,2,3&#125;;</span><br><span class="line">    int (&amp;b)[3]=a;//对数组的引用</span><br><span class="line">    cout&lt;&lt;&amp;a[0]&lt;&lt;&quot; &quot;&lt;&lt;&amp;b[0]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&amp;a[1]&lt;&lt;&quot; &quot;&lt;&lt;&amp;b[1]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&amp;a[2]&lt;&lt;&quot; &quot;&lt;&lt;&amp;b[2]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="/C/语法/指针与引用总结/900715-20170824023128902-1976389147.png" alt></p><h4 id="对指针的引用"><a href="#对指针的引用" class="headerlink" title="对指针的引用"></a>对指针的引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：类型 *&amp;引用名=指针名;//可以理解为：（类型*） &amp;引用名=指针名，即将指针的类型当成类型*</span><br></pre></td></tr></table></figure><p>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    int *ptr=&amp;a;</span><br><span class="line">    int *&amp;new_ptr=ptr;</span><br><span class="line">    //int *&amp;new_ptr1 = &amp;a; //error: invalid initialization of non-const reference of type &apos;int*&amp;&apos; from an rvalue of type &apos;int*&apos;|</span><br><span class="line">    cout&lt;&lt;ptr&lt;&lt;&quot; &quot;&lt;&lt;new_ptr&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&amp;ptr&lt;&lt;&quot; &quot;&lt;&lt;&amp;new_ptr&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="/C/语法/指针与引用总结/8ac3079c-aacb-4273-95c9-b294941cad91.png" alt></p><p><strong>上例可理解为<code>new_ptr</code>为变量<code>ptr</code>的引用，</strong>因此两者的地址均相同。</p><p>上例中的<code>int *&amp;new_ptr1 = &amp;a;</code>会报错，可以理解为引用的类型只能与绑定的类型一致，因此只能给<code>new_ptr1</code>赋值指针变量。</p><h3 id="引用的应用"><a href="#引用的应用" class="headerlink" title="引用的应用"></a>引用的应用</h3><h4 id="引用作为函数的参数"><a href="#引用作为函数的参数" class="headerlink" title="引用作为函数的参数"></a>引用作为函数的参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void swap(int &amp;a,int &amp;b)&#123;//引用作为函数的参数</span><br><span class="line">    int temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp; </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int value1=10,value2=20;</span><br><span class="line">    cout&lt;&lt;&quot;-&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;value1的值为：&quot;&lt;&lt;value1&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;&quot;value2的值为：&quot;&lt;&lt;value2&lt;&lt;endl;</span><br><span class="line">    swap(value1,value2); </span><br><span class="line">    cout&lt;&lt;&quot;-&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;value1的值为：&quot;&lt;&lt;value1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;value2的值为：&quot;&lt;&lt;value2&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><img src="/C/语法/指针与引用总结/900715-20170824033346011-489080809.png" alt></p><p>上述例子可以简单的理解为但<code>value1</code>传入到<code>swap</code>函数中的时候，为<code>int &amp;a = value1</code>，对应上面介绍的引用定义。</p><p><strong>特别注意：</strong></p><ul><li><p>当用引用作为函数的参数时，其效果<strong>和用指针作为函数参数的效果相当</strong>。当调用函数时，函数中的形参就会被当成实参变量或对象的一个别名来使用，也就是说<strong>此时函数中对形参的各种操作实际上是对实参本身进行操作，而非简单的将实参变量或对象的值拷贝给形参</strong>。</p></li><li><p>通常函数调用时，系统采用值传递的方式将实参变量的值传递给函数的形参变量。此时，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，也就是说形参变量只是实参变量的副本而已；并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象。而<strong>使用引用作为函数的形参时，由于此时形参只是要传递给函数的实参变量或对象的别名而非副本，故系统不会耗费时间来在内存中开辟空间来存储形参</strong>。因此<strong>如果参数传递的数据较大时，建议使用引用作为函数的形参，这样会提高函数的时间效率，并节省内存空间</strong>。</p></li><li><p>使用指针作为函数的形参虽然达到的效果和使用引用一样，但<strong>当调用函数时仍需要为形参指针变量在内存中分配空间</strong>，而引用则不需要这样，故<strong>在C++中推荐使用引用而非指针作为函数的参数</strong></p></li><li><p><strong>如果在编程过程中既希望通过让引用作为函数的参数来提高函数的编程效率，又希望保护传递的参数使其在函数中不被改变，则此时应当使用对常量的引用作为函数的参数。</strong></p></li><li><p>数组的引用作为函数的参数：C++的数组类型是带有长度信息的，<strong>引用传递时如果指明的是数组则必须指定数组的长度</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int(&amp;a)[5])</span><br><span class="line">&#123;</span><br><span class="line">    //数组引用作为函数的参数，必须指明数组的长度 </span><br><span class="line">    //函数体 </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int number[5]=&#123;0,1,2,3,4&#125;;</span><br><span class="line">    func(number); </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：const 类型 &amp;引用名=目标变量名；</span><br></pre></td></tr></table></figure><p><strong>常引用不允许通过该引用对其所绑定的变量或对象进行修改</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    const int &amp;new_a=a;</span><br><span class="line">    new_a=11;//错误！不允许通过常引用对其所绑定的变量或对象进行修改 </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>特别注意</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">string func1()&#123;</span><br><span class="line">    string temp=&quot;This is func1&quot;;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">void func2(string &amp;str)&#123;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    func2(func1());</span><br><span class="line">    func2(&quot;Tomwenxing&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行上面的程序编译器会报错</p><p><img src="/C/语法/指针与引用总结/900715-20170824043020527-902496772.png" alt></p><p>这是由于func1()和“Tomwenxing”都会在系统中产生一个临时对象（string对象）来存储它们，而<strong>在C++中所有的临时对象都是const类型的，而上述<code>func1</code>返回值与<code>&quot;Tomwenxing&quot;</code>均没有与之对应的变量名</strong>，而上面的程序试图将const对象赋值给非const对象，这必然会使程序报错。如果在函数func2的参数前添加const，则程序便可正常运行了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string func1()&#123;</span><br><span class="line">    string temp=&quot;This is func1&quot;;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">void func2(const string &amp;str)&#123;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    //str = &quot;hello&quot;;  // 报错，因为const不可更改</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    func2(func1());</span><br><span class="line">    func2(&quot;Tomwenxing&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="/C/语法/指针与引用总结/900715-20170824043535808-172238642.png" alt></p><p>或者可以改为下面形式，将上面的常量给赋值成为变量：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string func1()&#123;</span><br><span class="line">    string temp=&quot;This is func1&quot;;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">void func2(string &amp;str)&#123;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string one = func1();</span><br><span class="line">    func2(one);</span><br><span class="line">    string two = &quot;Tomwenxing&quot;;</span><br><span class="line">    func2(two);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="引用作为函数的返回值"><a href="#引用作为函数的返回值" class="headerlink" title="引用作为函数的返回值"></a>引用作为函数的返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：类型 &amp;函数名（形参列表）&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><h5 id="注意事项1"><a href="#注意事项1" class="headerlink" title="注意事项1"></a>注意事项1</h5><ul><li>引用作为函数的返回值时，<strong><code>&amp;</code>必须在定义函数时在函数名前</strong></li></ul><h5 id="注意事项2"><a href="#注意事项2" class="headerlink" title="注意事项2"></a>注意事项2</h5><ul><li>用引用作函数的返回值的<strong>最大的好处是在内存中不产生返回值的副本</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//代码来源：RUNOOB</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">float temp;</span><br><span class="line">float fn1(float r)&#123;</span><br><span class="line">    temp=r*r*3.14;</span><br><span class="line">    return temp;</span><br><span class="line">&#125; </span><br><span class="line">float &amp;fn2(float r)&#123; //&amp;说明返回的是temp的引用，换句话说就是返回temp本身</span><br><span class="line">    temp=r*r*3.14;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    float a=fn1(5.0); //case 1：返回值</span><br><span class="line">    //float &amp;b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type &apos;float&amp;&apos; from an rvalue of type &apos;float&apos;</span><br><span class="line">                           //（有些编译器可以成功编译该语句，但会给出一个warning） </span><br><span class="line">    float c=fn2(5.0);//case 3：返回引用</span><br><span class="line">    float &amp;d=fn2(5.0);//case 4：用函数返回的引用作为新引用的初始化值</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;//78.5</span><br><span class="line">    //cout&lt;&lt;b&lt;&lt;endl;//78.5</span><br><span class="line">    cout&lt;&lt;c&lt;&lt;endl;//78.5</span><br><span class="line">    cout&lt;&lt;d&lt;&lt;endl;//78.5</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上例中4个case的说明解释：</strong></p><h6 id="case-1"><a href="#case-1" class="headerlink" title="case 1"></a>case 1</h6><p>用返回值方式调用函数（如下图，图片来源：伯乐在线）：<br><img src="/C/语法/指针与引用总结/900715-20170824213332277-1403805406.png" alt></p><p><strong>返回全局变量temp的值时，C++会在内存中创建临时变量并将temp的值拷贝给该临时变量。当返回到主函数main后，赋值语句a=fn1(5.0)会把临时变量的值再拷贝给变量a</strong></p><h6 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h6><p>用函数的返回值初始化引用的方式调用函数（如下图，图片来源：伯乐在线）</p><p><img src="/C/语法/指针与引用总结/900715-20170824213909761-1693110470.png" alt></p><p><strong>这种情况下，函数fn1()是以值方式返回到，返回时，首先拷贝temp的值给临时变量。返回到主函数后，用临时变量来初始化引用变量b，使得b成为该临时变量到的别名。由于临时变量的作用域短暂（在C++标准中，临时变量或对象的生命周期在一个完整的语句表达式结束后便宣告结束，也就是在语句float &amp;b=fn1(5.0);之后） ，所以b面临无效的危险，很有可能以后的值是个无法确定的值。</strong></p><blockquote><p>如果真的希望用函数的返回值来初始化一个引用，应当先创建一个变量，将函数的返回值赋给这个变量，然后再用该变量来初始化引用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x=fn1(5.0);</span><br><span class="line">int &amp;b=x;</span><br></pre></td></tr></table></figure><p></p></blockquote><h6 id="case-3"><a href="#case-3" class="headerlink" title="case 3"></a>case 3</h6><p>用返回引用的方式调用函数（如下图，图片来源：伯乐在线）</p><p><img src="/C/语法/指针与引用总结/900715-20170824225424339-901573647.png" alt></p><p><strong>这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数，即主函数的赋值语句中的左值是直接从变量temp中拷贝而来（也就是说c只是变量temp的一个拷贝而非别名） ，这样就避免了临时变量的产生。尤其当变量temp是一个用户自定义的类的对象时，这样还避免了调用类中的拷贝构造函数在内存中创建临时对象的过程，提高了程序的时间和空间的使用效率。</strong></p><h6 id="case-4"><a href="#case-4" class="headerlink" title="case 4"></a>case 4</h6><p>用函数返回的引用作为新引用的初始化值的方式来调用函数（如下图，图片来源：伯乐在线）<br><img src="/C/语法/指针与引用总结/900715-20170824231047714-55281615.png" alt></p><p><strong>这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数。在主函数中，一个引用声明d用该返回值初始化，也就是说此时d成为变量temp的别名。由于temp是全局变量，所以在d的有效期内temp始终保持有效，故这种做法是安全的。</strong></p><h5 id="注意事项3"><a href="#注意事项3" class="headerlink" title="注意事项3"></a>注意事项3</h5><p><strong>不能返回局部变量的引用。</strong>如上面的例子，如果temp是局部变量，那么它会在函数返回后被销毁，此时对temp的引用就会成为“无所指”的引用，程序会进入未知状态。</p><h5 id="注意事项4"><a href="#注意事项4" class="headerlink" title="注意事项4"></a>注意事项4</h5><p><strong>不能返回函数内部通过new分配的内存的引用</strong>。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，那么就可能造成这个引用所指向的空间（有new分配）无法释放的情况（由于没有具体的变量名，故无法用delete手动释放该内存），从而造成内存泄漏。因此应当避免这种情况的发生</p><h5 id="注意事项5"><a href="#注意事项5" class="headerlink" title="注意事项5"></a>注意事项5</h5><p><strong>当返回类成员的引用时，最好是const引用</strong>。这样可以避免在无意的情况下破坏该类的成员。</p><h5 id="注意事项6"><a href="#注意事项6" class="headerlink" title="注意事项6"></a>注意事项6</h5><p>可以用函数返回的引用作为赋值表达式中的左值<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int value[10];</span><br><span class="line">int error=-1;</span><br><span class="line">int &amp;func(int n)&#123;</span><br><span class="line">    if(n&gt;=0&amp;&amp;n&lt;=9)</span><br><span class="line">        return value[n];//返回的引用所绑定的变量一定是全局变量，不能是函数中定义的局部变量 </span><br><span class="line">    else</span><br><span class="line">        return error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    func(0)=10;</span><br><span class="line">    func(4)=12;</span><br><span class="line">    cout&lt;&lt;value[0]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;value[4]&lt;&lt;endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="/C/语法/指针与引用总结/900715-20170824233843558-1731339574.png" alt></p><h4 id="用引用实现多态"><a href="#用引用实现多态" class="headerlink" title="用引用实现多态"></a>用引用实现多态</h4><p>在C++中，<strong>引用是除了指针外另一个可以产生多态效果的手段</strong>。也就是说一个基类的引用可以用来绑定其派生类的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Father;//基类（父类）</span><br><span class="line">class Son：public Father&#123;.....&#125;//Son是Father的派生类</span><br><span class="line">Son son;//son是类Son的一个实例</span><br><span class="line">Father &amp;ptr=son;//用派生类的对象初始化基类对象的使用</span><br></pre></td></tr></table></figure><p><strong>特别注意：</strong><br><strong>ptr只能用来访问派生类对象中从基类继承下来的成员</strong>。<strong>如果基类（类Father）中定义的有虚函数，那么就可以通过在派生类（类Son）中重写这个虚函数来实现类的多态。</strong></p><h3 id="引用总结"><a href="#引用总结" class="headerlink" title="引用总结"></a>引用总结</h3><ul><li><p>在引用的使用中，单纯给某个变量去别名是毫无意义的，<strong>引用的目的主要用于在函数参数的传递中，解决大块数据或对象的传递效率和空间不如意的问题</strong></p></li><li><p>用引用传递函数的参数，能<strong>保证参数在传递的过程中不产生副本</strong>，从而提高传递效率，同时<strong>通过const的使用，还可以保证参数在传递过程中的安全性</strong></p></li><li><p>引用本身是目标变量或对象的别名，对引用的操作本质上就是对目标变量或对象的操作。因此<strong>能使用引用时尽量使用引用而非指针</strong></p></li></ul><h2 id="指针和引用的对比"><a href="#指针和引用的对比" class="headerlink" title="指针和引用的对比"></a>指针和引用的对比</h2><h3 id="指针-1"><a href="#指针-1" class="headerlink" title="指针"></a>指针</h3><p>对于一个类型<code>T</code>，<code>T*</code>就是指向<code>T</code>的指针类型，也即一个<code>T*</code>类型的变量能够保存一个<code>T</code>对象的地址，而类型<code>T</code>是可以加一些限定词的，如<code>const、volatile</code>等等。见下图，所示指针的含义：</p><p><img src="/C/语法/指针与引用总结/99082f20-c97d-4e56-9d28-d36feb5fa7d7.png" alt></p><h3 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h3><p>引用是一个对象的别名，主要用于函数参数和返回值类型，符号<code>X&amp;</code>表示<code>X</code>类型的引用。见下图，所示引用的含义：</p><p><img src="/C/语法/指针与引用总结/1f3ed4b1-4586-4f71-bdb3-b8d105c5afd2.png" alt></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>首先，引用不可以为空，但指针可以为空。前面也说过了引用是对象的别名，引用为空——对象都不存在，怎么可能有别名！故定义一个引用的时候，必须初始化。因此如果你有一个变量是用于指向另一个对象，但是它可能为空，这时你应该使用指针；如果变量总是指向一个对象，i.e.，你的设计不允许变量为空，这时你应该使用引用。如下图中，如果定义一个引用变量，不初始化的话连编译都通不过（编译时错误）：</p><p><img src="/C/语法/指针与引用总结/b5f041e6-c7eb-4cd4-955d-4e6c76032df8.jpg" alt></p><p>而声明指针是可以不指向任何对象，也正是因为这个原因，<strong>使用指针之前必须做判空操作，而引用就不必</strong>。</p><p>其次，引用不可以改变指向，对一个对象”至死不渝”；但是指针可以改变指向，而指向其它对象。说明：虽然引用不可以改变指向，但是可以改变初始化对象的内容。例如就++操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。见下面的代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main(int argc,char** argv)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    int i=10;</span><br><span class="line">    int&amp; ref=i;</span><br><span class="line">    ref++;</span><br><span class="line">    cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;ref=&quot;&lt;&lt;ref&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    int j=20;</span><br><span class="line">    ref=j;</span><br><span class="line">    ref++;</span><br><span class="line">    cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;ref=&quot;&lt;&lt;ref&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;j=&quot;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对<code>ref</code>的<code>++</code>操作是直接反应到所指变量之上，对引用变量<code>ref</code>重新赋值<code>&quot;ref=j&quot;</code>（此处要注意<code>ref</code>是可以重新在赋值的，但指向并不会发生变化），并不会改变<code>ref</code>的指向，它仍然指向的是<code>i</code>，而不是<code>j</code>。理所当然，这时对<code>ref</code>进行<code>++</code>操作不会影响到j。而这些换做是指针的话，情况大不相同，请自行实验。输出结果如下：</p><p><img src="/C/语法/指针与引用总结/34e735a5-b317-4de2-aa30-0d5ee6fe88bd.jpg" alt></p><p>再次，引用的大小是所指向的变量的大小，因为引用只是一个别名而已；指针是指针本身的大小，4个字节。见下图所示：</p><p><img src="/C/语法/指针与引用总结/56d6fcbb-2063-4df4-be41-cf96e3189c18.jpg" alt></p><p>从上面也可以看出：<strong>引用比指针使用起来形式上更漂亮，使用引用指向的内容时可以之间用引用变量名，而不像指针一样要使用*；定义引用的时候也不用像指针一样使用&amp;取址。</strong></p><p>最后，引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。const 指针虽然不能改变指向，但仍然存在空指针，并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针）。</p><p>总而言之，言而总之——它们的这些差别都可以归结为”<strong>指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，引用不改变指向。</strong>“</p><h2 id="指针传递和引用传递比较"><a href="#指针传递和引用传递比较" class="headerlink" title="指针传递和引用传递比较"></a>指针传递和引用传递比较</h2><p>在C语言中，如果要实现在函数内部改变外部变量的值的话，就应该传递这个变量的指针。如果要通过指针访问变量，必须使用指针运算符<code>*</code>。这样在源代码中就会显得比较别扭：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void function(int *pval)</span><br><span class="line">&#123;</span><br><span class="line">    *pval=100;</span><br><span class="line">    //pval=100;先不考虑此处类型转换的错误，该代码只能改变堆栈中临时指针变量的地址，而不能改变指针指向对象的值</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int x=200;</span><br><span class="line">   function(&amp;x);</span><br><span class="line">   //或者如下调用</span><br><span class="line">   int *refx=&amp;x;</span><br><span class="line">   function(refx);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>为了能透明地使用指针来访问变量，C++中引入了“引用”的概念<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void function(int &amp;refval)</span><br><span class="line">&#123;</span><br><span class="line"> refval=100;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int x=200; </span><br><span class="line"> function(x);</span><br><span class="line"> //当然，如下调用也可以。但这样做就失去引入&quot;引用&quot;的原本意义了</span><br><span class="line"> int &amp;refx=x;</span><br><span class="line"> function(refx);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样一来，<strong>只要改一下函数声明</strong>，就可以在源代码的级别上实现指针访问和一般访问的一致性。<strong>可以把“引用”想象成一个不需要<code>&quot;*&quot;</code>操作符就可以访问变量的指针</strong>。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。</p><p>而引用是一个别名，它在<strong>逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的</strong>（自始至终只能依附于同一个变量）。</p><p>在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：</p><p>指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。</p><p>而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（<strong>指针传递参数时，指针中存放的也是实参的地址，但是在被调函数内部指针存放的内容可以被改变，即可能改变指向的实参，所以并不安全，而引用则不同，它引用的对象的地址一旦赋予，则不能改变</strong>）。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p><p>引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。<strong>即指针传递只是传了一个地址copy, 在函数内部改变形参所指向的地址，不能改变原实参指向的地址，仅可以通过修改形参地址的内容，来达到修改实参内容的目的（原C语言中的通过指针来互换值小函数例子），所以如果想通过被调函数来修改原实参的地址或给重新分配一个对象都是不能完成的，只能使用双指针或指针引用（下面会进行详解）</strong></p><p><strong>如以下指针传递的例子：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void function(int *pval)</span><br><span class="line">&#123;</span><br><span class="line">    int a = 200;</span><br><span class="line">    pval = &amp;a;</span><br><span class="line">    *pval = 300;</span><br><span class="line">    cout&lt;&lt;&quot;内部函数值：&quot;&lt;&lt;*pval&lt;&lt;endl;</span><br><span class="line">    //pval=100;先不考虑此处类型转换的错误，该代码只能改变堆栈中临时指针变量的地址，而不能改变指针指向对象的值</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int x = 100;</span><br><span class="line">   function(&amp;x);</span><br><span class="line">   cout&lt;&lt;&quot;外部函数值：&quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：</p><p><strong>如以下引用传递的例子：</strong><br><img src="/C/语法/指针与引用总结/b49bfca4-909f-47a6-991d-ee10cd568012.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void function(int &amp;pval)</span><br><span class="line">&#123;</span><br><span class="line">    int a = 200;</span><br><span class="line">    pval = a;</span><br><span class="line">    cout&lt;&lt;&quot;内部函数值：&quot;&lt;&lt;pval&lt;&lt;endl;</span><br><span class="line">    //pval=100;先不考虑此处类型转换的错误，该代码只能改变堆栈中临时指针变量的地址，而不能改变指针指向对象的值</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int x = 100;</span><br><span class="line">   function(x);</span><br><span class="line">   cout&lt;&lt;&quot;外部函数值：&quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/C/语法/指针与引用总结/921504d4-2af1-4fd4-bf9c-a0ca20cc410b.png" alt></p><p>为了进一步加深大家对指针和引用的区别，下面我从编译的角度来阐述它们之间的区别：</p><p>程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。<strong>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值</strong>。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p><p><strong>最后，总结一下指针和引用的相同点和不同点：</strong></p><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><ul><li>都是地址的概念；<br>指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。</li></ul><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><ul><li>指针是一个实体，而引用仅是个别名；</li><li>引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；</li><li>引用没有<code>const</code>，指针有<code>const</code>，<code>const</code>的指针不可变；（具体指没有<code>int&amp; const a</code>这种形式，而<code>const int&amp; a</code>是有的，前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）</li><li>引用不能为空，指针可以为空；</li><li><code>sizeof 引用</code>得到的是所指向的变量(对象)的大小，而<code>sizeof 指针</code>得到的是指针本身的大小；</li><li>指针和引用的自增(++)运算意义不一样；</li><li>引用是类型安全的，而指针不是 (引用比指针多了类型检查）</li></ul><h2 id="指针的指针和指针的引用对比"><a href="#指针的指针和指针的引用对比" class="headerlink" title="指针的指针和指针的引用对比"></a>指针的指针和指针的引用对比</h2><h3 id="指针的指针例子详解"><a href="#指针的指针例子详解" class="headerlink" title="指针的指针例子详解"></a>指针的指针例子详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 指针的指针作为形参，data1是主函数中实参 data1 的地址，*data1 表示实参 data1 的值</span><br><span class="line">void test1(float **data1)</span><br><span class="line">&#123;</span><br><span class="line">    // 调用方式一</span><br><span class="line">    printf(&quot;inside1_data1:%p\n&quot;, *data1);</span><br><span class="line">    *data1 = (float*)calloc(10, sizeof(float));</span><br><span class="line">    printf(&quot;inside2_data1:%p\n&quot;, *data1);</span><br><span class="line">    for(int i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // printf(&quot;%p\n&quot;,*data1+i);</span><br><span class="line">        *(*data1 + i) = i; // *data1 + 1 表示地址偏移</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test2(float *data2)</span><br><span class="line">&#123;</span><br><span class="line">    // 调用方式二</span><br><span class="line">    printf(&quot;inside1_data2:%p\n&quot;, data2);</span><br><span class="line">    data2 = (float*)calloc(10, sizeof(float));</span><br><span class="line">    printf(&quot;inside2_data2:%p\n&quot;, data2);</span><br><span class="line">    for(int i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(data2 + i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test3(float **data3)</span><br><span class="line">&#123;</span><br><span class="line">    // 调用方式三</span><br><span class="line">    printf(&quot;inside1_data3:%p\n&quot;, data3);</span><br><span class="line"></span><br><span class="line">    data3 = (float **)calloc(10, sizeof(float*));</span><br><span class="line">    for(int i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(data3+i) = (float *)calloc(10, sizeof(float));</span><br><span class="line">    &#125;</span><br><span class="line">    // *data3 = calloc(10, sizeof(float));</span><br><span class="line">    printf(&quot;inside2_data3:%p\n&quot;, *data3);</span><br><span class="line">    for(int i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // printf(&quot;%p\n&quot;,*data1+i);</span><br><span class="line">        for(int j=0;j&lt;10;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(*(data3 + i)+j) = 5; // *data1 + 1 表示地址偏移</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // printf(&quot;%p\n&quot;,*data1+i);</span><br><span class="line">        for(int j=0;j&lt;10;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            //printf(&quot;%f\n&quot;, *(*(data3 + i)+j)); // *data1 + 1 表示地址偏移</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        free(*(data3+i));</span><br><span class="line">    &#125;</span><br><span class="line">    free(data3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test4(char *str1)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;inside1_str1:%p\n&quot;, str1);</span><br><span class="line">    str1 = (char*)calloc(10, sizeof(char));</span><br><span class="line">    printf(&quot;inside2_str1:%p\n&quot;, str1);</span><br><span class="line">    for(int i=0;i&lt;10;i++)</span><br><span class="line">        str1[i] = &apos;a&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test5(char *str2)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;inside1_str2:%p\n&quot;, str2);</span><br><span class="line">    for(int i=0;i&lt;10;i++)</span><br><span class="line">        str2[i] = &apos;a&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test6(char *str3)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;inside1_str3:%p\n&quot;, str3);</span><br><span class="line">    char *str4 = (char*)calloc(10, sizeof(char));</span><br><span class="line">    for(int i=0;i&lt;10;i++)</span><br><span class="line">        str4[i] = &apos;a&apos;;</span><br><span class="line">    str3 = str4;</span><br><span class="line">    printf(&quot;inside2_str3:%p\n&quot;, str3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // 调用方式一，传入指针的地址作为实参，可以更改指针的值</span><br><span class="line">    float *data1 = NULL;</span><br><span class="line">    printf(&quot;outside1_data1:%p\n&quot;, data1); // 打印 data1 的值，而非data1的地址</span><br><span class="line">    test1(&amp;data1);</span><br><span class="line">    free(data1);</span><br><span class="line">    printf(&quot;outside2_data1:%p\n&quot;, data1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 调用方式二，传入指针的值作为实参，不可改变指针的值</span><br><span class="line">    float *data2 = NULL;</span><br><span class="line">    printf(&quot;outside1_data2:%p\n&quot;, data2);</span><br><span class="line">    test2(data2);</span><br><span class="line">    free(data2);</span><br><span class="line">    printf(&quot;outside2_data2:%p\n&quot;, data2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 调用方式三，和调用方式是一的区别，&amp;data1是一维数组，**data3是二维数组</span><br><span class="line">    // 在对二维动态数组进行动态内存分配时，要使用逐层内存申请的方式，第一层是指向指针的指针，每个元素是指针的形式，</span><br><span class="line">    // 第二层使用for循环进行内存申请，每个元素是基本数据类型（int,float）。</span><br><span class="line">    float **data3 = NULL;</span><br><span class="line">    // *data3 = NULL;</span><br><span class="line">    printf(&quot;outside1_data3:%p\n&quot;, data3); // 打印 data3 的值，而非data3的地址</span><br><span class="line">    test3(data3);</span><br><span class="line">    free(data3);</span><br><span class="line">    printf(&quot;outside2_data3:%p\n&quot;, data3);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 调用方式四，同调用方式二</span><br><span class="line">    char *str1 = NULL;</span><br><span class="line">    printf(&quot;outside1_str1:%p\n&quot;, str1);</span><br><span class="line">    test4(str1);</span><br><span class="line">    free(str1);</span><br><span class="line">    printf(&quot;outside2_str1:%p\n&quot;, str1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 调用方式五，在函数外部声明大小，指针作为函数的实参</span><br><span class="line">    char *str2 = NULL;</span><br><span class="line">    printf(&quot;outside1_str2:%p\n&quot;, str2);</span><br><span class="line">    str2 = (char*)calloc(10, sizeof(char));</span><br><span class="line">    printf(&quot;outside2_str2:%p\n&quot;, str2);</span><br><span class="line">    test5(str2);</span><br><span class="line">    free(str2);</span><br><span class="line">    printf(&quot;outside3_str2:%p\n&quot;, str2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 调用方式六</span><br><span class="line">    char *str3 = NULL;</span><br><span class="line">    printf(&quot;outside1_str3:%p\n&quot;, str3);</span><br><span class="line">    str3 = (char*)calloc(10, sizeof(char));</span><br><span class="line">    printf(&quot;outside2_str3:%p\n&quot;, str3);</span><br><span class="line">    test6(str3);</span><br><span class="line">    free(str3);</span><br><span class="line">    printf(&quot;outside3_str3:%p\n&quot;, str3);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 以下用法错误</span><br><span class="line">    // char **data1 = NULL;</span><br><span class="line">    // printf(&quot;%p&quot;, *data1);</span><br><span class="line">    // *data1 = (char*)calloc(10, sizeof(char));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">outside1_data1:00000000</span><br><span class="line">inside1_data1:00000000</span><br><span class="line">inside2_data1:00370F00</span><br><span class="line">outside2_data1:00370F00</span><br><span class="line"></span><br><span class="line">outside1_data2:00000000</span><br><span class="line">inside1_data2:00000000</span><br><span class="line">inside2_data2:00370F00</span><br><span class="line">outside2_data2:00000000</span><br><span class="line"></span><br><span class="line">outside1_data3:00000000</span><br><span class="line">inside1_data3:00000000</span><br><span class="line">inside2_data3:00370F60</span><br><span class="line">outside2_data3:00000000</span><br><span class="line"></span><br><span class="line">outside1_str1:00000000</span><br><span class="line">inside1_str1:00000000</span><br><span class="line">inside2_str1:00370F30</span><br><span class="line">outside2_str1:00000000</span><br><span class="line"></span><br><span class="line">outside1_str2:00000000</span><br><span class="line">outside2_str2:00370F48</span><br><span class="line">inside1_str2:00370F48</span><br><span class="line">outside3_str2:00370F48</span><br><span class="line"></span><br><span class="line">outside1_str3:00000000</span><br><span class="line">outside2_str3:00370F48</span><br><span class="line">inside1_str3:00370F48</span><br><span class="line">inside2_str3:00370F60</span><br><span class="line">outside3_str3:00370F48</span><br></pre></td></tr></table></figure><p></p><ul><li><p>对比调用方式二和调用方式四，可以得出<code>float *</code>和<code>char *</code>相同，都可以理解为特殊形式的数组。前者是<code>float</code>数组，后者是<code>char</code>数组。</p></li><li><p>对比调用方式一和调用方式二，当指针的地址作为实参时候，可以更改指针的值；当指针的值作为实参的时候，不可以更改指针的值。</p></li><li><p>对比调用方式一和调用方式三，调用方式一中<code>&amp;data1</code>是一维数组，调用方式三中<code>**data3</code>是二维数组。</p></li><li><p>对比调用方式四、调用方式五和调用方式六，在函数外部声明大小，指针的值作为实参，可以更改指针值所指向空间的值，而不可以更改指针的指向(值)。</p></li><li><p>对比第153行和第10行，第10行<code>*data1</code>是0，而第153的<code>*data1</code>没有值，因此会报错。</p></li></ul><p><strong>总结</strong><br>由此可见，可以把指针<code>float *data1</code>、<code>char *str1</code>看成是一个<strong>变量</strong>（指针变量），若想在子函数中改变变量的值，需要将变量取地址作为实参传给子函数，而非调用方式二的用法。而因为<strong>指针是指针变量，指针的值作为实参的时候，可以更改指针指向地址的内容，而不能更改指针的指向。</strong></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>在下列函数声明中，为什么要同时使用<code>*</code>和<code>&amp;</code>符号？以及什么场合使用这种声明方式?<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func1( MYCLASS *&amp;pBuildingElement );</span><br></pre></td></tr></table></figure><p></p><p>先来看<code>int **pp</code>和<code>int *&amp;rp</code>区别。前者是一个指向指针的指针；<strong>后者是一个指针的引用</strong>。如果这样看不明白的话，变换一下就清楚了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef int * LPINT;</span><br><span class="line"> LPINT *pp;</span><br><span class="line"> LPINT &amp;rp;</span><br></pre></td></tr></table></figure><p></p><p>而指针的指针和指针的引用作为传递参数时，如下面的两个函数在被调用时，编译器编译的二进制代码都将传递一个双重指针，只不过两者的调用方法不同：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void function1(int **p)</span><br><span class="line">&#123;</span><br><span class="line"> **p=100;</span><br><span class="line"> *p=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void function2(int *&amp;ref)</span><br><span class="line">&#123;</span><br><span class="line"> *ref=100;</span><br><span class="line"> ref=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可见，“引用”仅仅是为了给重载操作符提供了方便之门，其本质和指针是没有区别的。所以只要你碰到<code>*&amp;</code>，就应该想到<code>**</code>。也就是说这个函数修改或可能修改调用者的指针，而调用者象普通变量一样传递这个指针，不使用地址操作符<code>&amp;</code>。</p><p>下面用三个函数<code>onePointerFunc，poiPointerFunc, refPointerFunc</code>举例详解，三个函数均想要在函数调用完毕后可以指向新的对象。</p><p><strong>传单指针：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">voidonePointerFunc(MYCLASS *pMyClass) </span><br><span class="line">&#123; </span><br><span class="line">DoSomething(pMyClass); </span><br><span class="line">pMyClass = // 其它对象的指针 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>调用：<code>MYCLASS* p = new MYCLASS; onePointerFunc(p);</code> 调用<code>onePointerFunc</code>后<code>p</code>没有指向新的对象：</p><p>第二条语句在函数过程中只修改了<code>pMyClass</code>的值。并没有修改调用者的变量<code>p</code>的值。如果<code>p</code>指向某个位于地址<code>0x008a00</code>的对象，当<code>func1</code>返回时，它仍然指向这个特定的对象。</p><p><strong>传双指针：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">voidpoiPointerFunc(MYCLASS** pMyClass); </span><br><span class="line">&#123; </span><br><span class="line">*pMyClass = new MYCLASS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>调用：<code>MYCLASS* p =new MYCLASS;poiPointerFunc(&amp;p);</code>调用<code>poiPointerFunc</code>之后，<code>p</code>指向新的对象。</p><p>BTW，在COM编程中，到处都会碰到这样的用法—例如在查询对象接口的<code>QueryInterface</code>函数中：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface ISomeInterface &#123; </span><br><span class="line">　　 HRESULT QueryInterface(IID &amp;iid, void** ppvObj); </span><br><span class="line">　　 …… </span><br><span class="line">　　 &#125;; </span><br><span class="line">　　 LPSOMEINTERFACE p=NULL; </span><br><span class="line">　　 pOb-&gt;QueryInterface(IID_SOMEINTERFACE, &amp;p);</span><br></pre></td></tr></table></figure><p></p><p>此处，<code>p</code>是<code>SOMEINTERFACE</code>类型的指针，所以<code>&amp;p</code>便是指针的指针，在<code>QueryInterface</code>返回的时候，如果调用成功，则变量<code>p</code>包含一个指向新的接口的指针。 　　</p><p><strong>传指针的引用：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">voidrefPointerFunc(MYCLASS *&amp;pMyClass); </span><br><span class="line"> 　　 &#123; </span><br><span class="line"> 　　 pMyClass = new MYCLASS; </span><br><span class="line"> 　　 …… </span><br><span class="line"> 　　 &#125;</span><br></pre></td></tr></table></figure><p></p><p>其实，它和前面所讲得指针的指针例子是一码事，只是语法有所不同。传递的时候不用传<code>p</code>的地址<code>&amp;p</code>，而是直接传<code>p</code>本身：　　<br>调用：<code>MYCLASS* p = new MYCLASS; refPointerFunc(p);</code>调用<code>refPointerFunc</code>之后，<code>p</code>指向新的对象。</p><p>MFC在其集合类中用到的<code>*&amp;</code>作为返回修饰符的例子—<code>CObList</code>，它是一个<code>CObjects</code>指针列表。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CObList : public CObject &#123; </span><br><span class="line"> 　　 …… </span><br><span class="line"> 　　 // 获取/修改指定位置的元素 </span><br><span class="line"> 　　 CObject*&amp; GetAt(POSITION position); </span><br><span class="line"> 　　 CObject* GetAt(POSITION position) const; </span><br><span class="line"> 　　 &#125;;</span><br></pre></td></tr></table></figure><p></p><p>这里有两个<code>GetAt</code>函数，功能都是获取给定位置的元素。区别何在呢？ 区别在于一个让你修改列表中的对象，另一个则不行。所以如果你写成下面这样：<code>CObject* pObj = mylist.GetAt(pos);</code> 则<code>pObj</code>是列表中某个对象的指针，</p><p>如果接着改变<code>pObj</code>的值： <code>pObj = pSomeOtherObj;</code> 这并改变不了在位置<code>pos</code>处的对象地址，而仅仅是改变了变量<code>pObj</code>.</p><p>但是，如果写成下面这样： <code>CObject*&amp; rpObj = mylist.GetAt(pos);</code>。现在，<code>rpObj</code>是引用一个列表中的对象的指针，所以当改变<code>rpObj</code>时，也会改变列表中位置<code>pos</code>处的对象地址—换句话说，替代了这个对象。这就是为什么<code>CObList</code>会有两个<code>GetAt</code>函数的缘故。一个可以修改指针的值，另一个则不能。注意我在此说的是指针，不是对象本身。这两个函数都可以修改对象，但只有<code>*&amp;</code>版本可以替代对象</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>在这里我为什么要提到<code>const</code>关键字呢？因为<code>const</code>对指针和引用的限定是有差别的，下面听我一一到来。</p><h3 id="常量指针VS常量引用"><a href="#常量指针VS常量引用" class="headerlink" title="常量指针VS常量引用"></a>常量指针VS常量引用</h3><h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><p>指向常量的指针，在指针定义语句的类型前加<code>const</code>，表示指向的对象是常量。</p><p>定义指向常量的指针只限制指针的间接访问操作，而不能规定指针指向的值本身的操作规定性。</p><p><img src="/C/语法/指针与引用总结/1cfe0b02-2b8a-40d1-b10f-5194db57254c.jpg" alt></p><p>常量指针定义<code>&quot;const int* pointer=&amp;a&quot;</code>告诉编译器，<code>*pointer</code>是常量，不能将<code>*pointer</code>作为左值进行操作。</p><h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><p>指向常量的引用，在引用定义语句的类型前加const，表示指向的对象是常量。也跟指针一样不能利用引用对指向的变量进行重新赋值操作。</p><p><img src="/C/语法/指针与引用总结/8867b874-0b96-45e1-b704-6e4e9eb89b31.jpg" alt></p><h3 id="指针常量VS引用常量"><a href="#指针常量VS引用常量" class="headerlink" title="指针常量VS引用常量"></a>指针常量VS引用常量</h3><p>在指针定义语句的指针名前加<code>const</code>，表示指针本身是常量。在定义指针常量时必须初始化！而这是引用天生具来的属性，不用再引用指针定义语句的引用名前加<code>const</code>。</p><p>指针常量定义<code>&quot;int* const pointer=&amp;b&quot;</code>告诉编译器，<code>pointer</code>是常量，不能作为左值进行操作，但是允许修改间接访问值，即<code>*pointer</code>可以修改</p><p><img src="/C/语法/指针与引用总结/87160959-3c81-47db-aca0-1df70139bf78.jpg" alt></p><h3 id="常量指针常量VS常量引用常量"><a href="#常量指针常量VS常量引用常量" class="headerlink" title="常量指针常量VS常量引用常量"></a>常量指针常量VS常量引用常量</h3><h4 id="常量指针常量"><a href="#常量指针常量" class="headerlink" title="常量指针常量"></a>常量指针常量</h4><p>指向常量的指针常量，可以定义一个指向常量的指针常量，它必须在定义时初始化。常量指针常量定义<code>&quot;const int* const pointer=&amp;c&quot;</code>告诉编译器，<code>pointer</code>和<code>*pointer</code>都是常量，他们都不能作为左值进行操作。</p><p>而就不存在所谓的”常量引用常量”，因为跟上面讲的一样引用变量就是引用常量。C++不区分变量的<code>const</code>引用和<code>const</code>变量的引用。程序决不能给引用本身重新赋值，使他指向另一个变量，因此引用总是<code>const</code>的。如果对引用应用关键字<code>const</code>，起作用就是使其目标称为<code>const</code>变量。即没有：<code>Const double const&amp; a=1；只有const double&amp; a=1</code>；</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>有一个规则可以很好的区分<code>const</code>是修饰指针，还是修饰指针指向的数据——画一条垂直穿过指针声明的星号<code>（*）</code>，如果<code>const</code>出现在线的左边，指针指向的数据为常量；如果<code>const</code>出现在右边，指针本身为常量。而引用本身与天俱来就是常量，即不可以改变指向。</p><blockquote><p>或者看离<code>const</code>最近的是什么，例如<code>char * const [指向字符的静态指针]</code>，离<code>const</code>最近的是<code>*</code>，则是<strong>指针常量，不能更改指针</strong>；而<code>const char * [指向静态字符的指针]</code>,，离<code>const</code>最近的是<code>char</code>，则是<strong>代表字符不能改变，但是指针可以变，也就是说该指针可以指针其他的const char。</strong></p></blockquote><p>如下例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char a[] = &quot;hello&quot;;</span><br><span class="line">    char aa[] = &quot;haha&quot;;</span><br><span class="line"></span><br><span class="line">    //const 修饰的是 *，则指针指向不可改变，但是其指向的内容可以更改</span><br><span class="line">    char * const c = a;</span><br><span class="line">    //c = aa; //error: assignment of read-only variable &apos;c&apos;</span><br><span class="line">    a[1] = &apos;a&apos;;</span><br><span class="line"></span><br><span class="line">    // const 修饰的是char。表示指针指向可更改，但是指向的内容不能改变</span><br><span class="line">    const char * d = a;</span><br><span class="line">    d = aa;</span><br><span class="line">    //d[1] = &apos;a&apos;; //error: assignment of read-only variable &apos;c&apos;</span><br><span class="line">    cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="/C/语法/指针与引用总结/45e418df-2737-4ad9-b22d-d3a1bce878dc.png" alt></p><blockquote><p>变量可以转为常量。但是常量不能变为非常量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int i = 10;</span><br><span class="line">int &amp;a = i; //错误</span><br><span class="line">const int &amp;b = i; //正确</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>文章中的visio图的附件在<a href="指针与引用总结_Attachments/指针.vsdx">这里</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/duwenxing/p/7421100.html" target="_blank" rel="noopener">C++：引用的简单理解</a><br><a href="https://blog.csdn.net/luoshenfu001/article/details/8601494#commentBox" target="_blank" rel="noopener">C++中引用，指针，指针的引用，指针的指针</a><br><a href="https://blog.csdn.net/u013654125/article/details/77314483" target="_blank" rel="noopener">c++的*与&amp;简单总结</a></p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束------</div></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/uploads/wechat.png" alt="zdaiot 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/uploads/aipay.jpg" alt="zdaiot 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zdaiot</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zdaiot.com/C/语法/指针与引用总结/" title="指针与引用总结">https://www.zdaiot.com/C/语法/指针与引用总结/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/const/" rel="tag"><i class="fa fa-tag"></i> const</a><a href="/tags/引用/" rel="tag"><i class="fa fa-tag"></i> 引用</a><a href="/tags/指针/" rel="tag"><i class="fa fa-tag"></i> 指针</a></div><div class="post-nav"><div class="post-nav-item"><a href="/C/语法/C++常见符号含义与区别/" rel="prev" title="C++常见符号含义与区别"><i class="fa fa-chevron-left"></i> C++常见符号含义与区别</a></div><div class="post-nav-item"> <a href="/C/语法/二维数组传参与动态声明详解/" rel="next" title="二维数组传参与动态声明详解">二维数组传参与动态声明详解<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#指针"><span class="nav-number">1.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.1.</span> <span class="nav-text">* 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用于定义"><span class="nav-number">1.1.1.</span> <span class="nav-text">用于定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用于调用时"><span class="nav-number">1.1.2.</span> <span class="nav-text">用于调用时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#amp-总结"><span class="nav-number">1.2.</span> <span class="nav-text">&amp;总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用于定义时"><span class="nav-number">1.2.1.</span> <span class="nav-text">用于定义时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用于调用时-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">用于调用时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于int-a-int-amp-a-int-amp-a-int-amp-a-int-amp-a"><span class="nav-number">1.3.</span> <span class="nav-text">关于int *a; int &amp;a; int &amp; *a; int * &amp;a; (int*) &amp;a</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#int-amp-a和int-amp-a"><span class="nav-number">1.3.1.</span> <span class="nav-text">int * &amp;a和int &amp; *a</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#声明"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-a"><span class="nav-number">1.3.2.</span> <span class="nav-text">int **a;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number">2.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是引用"><span class="nav-number">2.1.</span> <span class="nav-text">什么是引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对数组的引用"><span class="nav-number">2.1.1.</span> <span class="nav-text">对数组的引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对指针的引用"><span class="nav-number">2.1.2.</span> <span class="nav-text">对指针的引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用的应用"><span class="nav-number">2.2.</span> <span class="nav-text">引用的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用作为函数的参数"><span class="nav-number">2.2.1.</span> <span class="nav-text">引用作为函数的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常引用"><span class="nav-number">2.2.2.</span> <span class="nav-text">常引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用作为函数的返回值"><span class="nav-number">2.2.3.</span> <span class="nav-text">引用作为函数的返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#注意事项1"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">注意事项1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意事项2"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">注意事项2</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#case-1"><span class="nav-number">2.2.3.2.1.</span> <span class="nav-text">case 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#case-2"><span class="nav-number">2.2.3.2.2.</span> <span class="nav-text">case 2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#case-3"><span class="nav-number">2.2.3.2.3.</span> <span class="nav-text">case 3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#case-4"><span class="nav-number">2.2.3.2.4.</span> <span class="nav-text">case 4</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意事项3"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">注意事项3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意事项4"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">注意事项4</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意事项5"><span class="nav-number">2.2.3.5.</span> <span class="nav-text">注意事项5</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意事项6"><span class="nav-number">2.2.3.6.</span> <span class="nav-text">注意事项6</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用引用实现多态"><span class="nav-number">2.2.4.</span> <span class="nav-text">用引用实现多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用总结"><span class="nav-number">2.3.</span> <span class="nav-text">引用总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针和引用的对比"><span class="nav-number">3.</span> <span class="nav-text">指针和引用的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针-1"><span class="nav-number">3.1.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用-1"><span class="nav-number">3.2.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区别"><span class="nav-number">3.3.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针传递和引用传递比较"><span class="nav-number">4.</span> <span class="nav-text">指针传递和引用传递比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">4.1.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相同点："><span class="nav-number">4.1.1.</span> <span class="nav-text">相同点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同点："><span class="nav-number">4.1.2.</span> <span class="nav-text">不同点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针的指针和指针的引用对比"><span class="nav-number">5.</span> <span class="nav-text">指针的指针和指针的引用对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针的指针例子详解"><span class="nav-number">5.1.</span> <span class="nav-text">指针的指针例子详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对比"><span class="nav-number">5.2.</span> <span class="nav-text">对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-number">6.</span> <span class="nav-text">const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常量指针VS常量引用"><span class="nav-number">6.1.</span> <span class="nav-text">常量指针VS常量引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常量指针"><span class="nav-number">6.1.1.</span> <span class="nav-text">常量指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常量引用"><span class="nav-number">6.1.2.</span> <span class="nav-text">常量引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针常量VS引用常量"><span class="nav-number">6.2.</span> <span class="nav-text">指针常量VS引用常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量指针常量VS常量引用常量"><span class="nav-number">6.3.</span> <span class="nav-text">常量指针常量VS常量引用常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常量指针常量"><span class="nav-number">6.3.1.</span> <span class="nav-text">常量指针常量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">6.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附件"><span class="nav-number">7.</span> <span class="nav-text">附件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zdaiot" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">zdaiot</p><div class="site-description" itemprop="description">404NotFound</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">311</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">53</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">367</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zdaiot" title="GitHub → https://github.com/zdaiot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zdaiot@163.com" title="E-Mail → mailto:zdaiot@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/" title="知乎 → https://www.zhihu.com/people/" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/zdaiot" title="CSDN → https://blog.csdn.net/zdaiot" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://kalacloud.com" title="https://kalacloud.com" rel="noopener" target="_blank">卡拉云低代码工具</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021031914号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zdaiot</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">2m</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">30:36</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b5e7e498f94b7ad" async="async"></script></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/01/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4800250e682fe873198b',
      clientSecret: '80f7f33f5f8ddfd3944f455cabadda4ff3299147',
      repo        : 'zdaiot.github.io',
      owner       : 'zdaiot',
      admin       : ['zdaiot'],
      id          : '0f5ee346cbd273d3b3962accde755c1b',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0}})</script></body></html>